<html>
<head>
<title>Spring Cloud Gateway — Encryption/Decryption of Request/Response</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring云网关—请求/响应的加密/解密</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/spring-cloud-gateway-encryption-decryption-of-request-response-4e76f5b15718?source=collection_archive---------4-----------------------#2020-06-22">https://levelup.gitconnected.com/spring-cloud-gateway-encryption-decryption-of-request-response-4e76f5b15718?source=collection_archive---------4-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3f86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文提供了一个使用Spring Cloud Gateway来解密来自客户端的请求、将解密的内容发送到目标服务、接收响应并在将响应发送到客户端之前对其进行加密的工作示例。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/cacd74b72bb7afe33674bb32a94745b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUraok0gNLKfvSfSC7KZWw.jpeg"/></div></div></figure><p id="85a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要获得本文中提到的代码，请访问知识库@<a class="ae la" href="https://github.com/sumantrana/SpringGatewayCustomFilter.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sumantrana/SpringGatewayCustomFilter.git</a></p><h1 id="3fe0" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">介绍</h1><p id="1a97" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">使用网关的优势之一是它可以用于处理影响通过它的多条路由的常见功能，例如认证、度量、加密/解密。</p><p id="3808" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以在网关处将这些常见的问题整合在一起，而不是分散在多个微服务中。这提供了以下一组优势:</p><ul class=""><li id="0162" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">减少开发/更改它们所需的工作量(根据需要)。由于代码位于中心位置，因此只需在一个地方进行更改，测试和部署所需的时间会更少。</li><li id="dca4" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">代码更清晰，更容易理解(原因同上)</li><li id="2582" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">关注点分离。开发微服务的团队不需要知道传入请求如何被认证、加密等细节。他们只能专注于业务逻辑。</li></ul><p id="6de9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将深入研究加密/解密方面。有几种方法可以实现这一功能:</p><ul class=""><li id="f4d4" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">创建一个外部服务，并将加密和解密的责任委托给该服务。对于每个传入的请求和每个传出的响应，从网关调用该服务。</li><li id="629a" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">在网关中创建一个自定义过滤器，它将拦截每个请求，解密它，并相应地拦截每个响应，并在发送之前加密它。</li></ul><p id="bb22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下部分详细解释了后一种方法。</p><h1 id="ef67" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">加密解密助手</h1><p id="8d35" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">该类充当助手类，并提供静态方法来加密和解密传入的字符串数据。这只是一个示例助手，用来说明功能，可以根据组织的需要用复杂的机制来替换。其思想是将加密/解密问题与过滤器分开，以便在需要时可以更改。也可以将其配置为bean。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ms"><img src="../Images/1d7407724db2be20470dfc85cd0a5666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7KXRbyuEleR1xWJFWVTcPQ.png"/></div></div></figure><p id="0064" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整代码请参考github资源库。</p><h1 id="d005" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">加密解密过滤器</h1><p id="a661" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">要在Spring Cloud Gateway中创建网关过滤器，我们可以实现<code class="fe mt mu mv mw b">AbstractGatewayFilterFactory</code>或者扩展现有的<code class="fe mt mu mv mw b">GatewayFilter</code>的功能。这里我们将通过实现<code class="fe mt mu mv mw b">AbstractGatewayFilterFactory.</code>来实现一个新的过滤器</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/9ac1fabb74d2762843deea3d692a46a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWHqTPpu1wRxyjSWCKiuEg.png"/></div></div></figure><p id="4c98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Config类提供了一种向自定义过滤器传递所需参数的机制。在我们的例子中，它是一个空类，但是它可以用于定制过滤器的某些方面，比如用于加密/解密的helper类。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/de3aa016cd9cdae15686c25fe9c1a1ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDBpvTqh_GvQjtjM2-jHWQ.png"/></div></div></figure><p id="7ba0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的网关过滤器的构造器接受两个参数——一组<code class="fe mt mu mv mw b">MessageBodyDecoder</code>和一组<code class="fe mt mu mv mw b">MessageBodyEncoder</code>。这些解码器和编码器在解析传入请求或创建传出响应时使用。</p><h2 id="0f98" class="mz lc it bd ld na nb dn lh nc nd dp ll kb ne nf lp kf ng nh lt kj ni nj lx nk bi translated">注入编码器和解码器</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/6d85db964771e8b90da5287b0f7d65a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmHILfTF8y_CPVwAyk-Eog.png"/></div></div></figure><blockquote class="nm nn no"><p id="bc09" class="jq jr np js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">默认情况下，Spring Boot提供了一个Gzip消息体编码器和解码器。这个Gzip编码器解码器被注入到过滤器中，并且将在发送请求的客户端发送以下报头<code class="fe mt mu mv mw b">Accept-Encoding: gzip, deflate</code>时使用。该报头表示客户端期望响应是压缩格式的，并且过滤器需要接受它。</p><p id="237b" class="jq jr np js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">下面是一个示例输出，显示了客户端在请求中发送<code class="fe mt mu mv mw b">Accept-Encoding</code>报头:</p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/91b8d2c42280291a73f3ed8aa761ef40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQRO7Tz3jrdnsl-3fT_ODg.png"/></div></div></figure><blockquote class="nm nn no"><p id="2e35" class="jq jr np js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">对客户端的相应响应显示了服务器如何响应:</p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nu"><img src="../Images/f2ff835934601605e181c32a3ec3c4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LieNHG-dh6HV_LJHZw8YEg.png"/></div></div></figure><h2 id="c1bf" class="mz lc it bd ld na nb dn lh nc nd dp ll kb ne nf lp kf ng nh lt kj ni nj lx nk bi translated">订购过滤器</h2><p id="21d7" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">对过滤器进行排序起着重要的作用，尤其是当我们希望我们的过滤器同时应用于传入请求和传出响应时。为了将过滤器应用于响应，我们希望它应用于网关顺序为<code class="fe mt mu mv mw b">-1</code>的<code class="fe mt mu mv mw b">NettyRewriteResponseFilter</code>之后。这意味着我们可以选择任何小于<code class="fe mt mu mv mw b">-1</code>的数字，我们的滤波器将能够成功地修改响应。</p><p id="4e3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们忽略了排序，gateway将为我们的过滤器分配一个默认的顺序<code class="fe mt mu mv mw b">0</code>，它将不能按要求运行。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/05130dbced57a8265053d2bdf4f977f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRPwDaouNDwV6ort6N0tUQ.png"/></div></div></figure><blockquote class="nm nn no"><p id="8609" class="jq jr np js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">理想情况下，应该使用更大的负数，因为它可以确保在EncryptDecrypt过滤器之前有足够的空间来应用任何过滤器。</p></blockquote><h2 id="1602" class="mz lc it bd ld na nb dn lh nc nd dp ll kb ne nf lp kf ng nh lt kj ni nj lx nk bi translated">解密请求</h2><p id="7c5f" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">为了解密传入的请求，我们需要首先从传入的<code class="fe mt mu mv mw b">Flux&lt;DataBuffer&gt;</code>中提取请求体。</p><p id="5e29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先从输入缓冲区创建一个缓存流量</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/025db29b0e9bca6489a2f849815401f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AaLxqRjahm4t4AMpf_zIKQ.png"/></div></div></figure><p id="f689" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后用它来解析请求体</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/43eb372215fc998c4688b2e03b8c207f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NU5P6vQOOpCMqmFEbxphWA.png"/></div></div></figure><p id="f66d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦提取了主体，我们就可以使用我们的<code class="fe mt mu mv mw b">EncryptDecryptHelper</code>解密主体，并创建一个<code class="fe mt mu mv mw b">ServerHttpRequestDecorator</code>对象，从修改后的主体创建一个新的请求。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/21e470e536098695dabad04a9ccfa53a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Df30D1YZ7GszoS5A_C3YmQ.png"/></div></div></figure><blockquote class="nm nn no"><p id="375e" class="jq jr np js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">这里需要记住的重要一点是，请求的<code class="fe mt mu mv mw b">Content-Length</code>需要更新，因为解密会改变请求体。如果类型发生变化，也可能需要更新<code class="fe mt mu mv mw b">Content-Type</code>报头，例如在本例中，由于传入的加密请求主体是<code class="fe mt mu mv mw b">plain text</code>，因此<code class="fe mt mu mv mw b">text/plain</code>内容类型被更改为<code class="fe mt mu mv mw b">application/json</code>，但是当我们解密它时，它会更改为<code class="fe mt mu mv mw b">json.</code></p></blockquote><p id="cd4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，这个装饰器可以用来更新交换，并通过链传递，以便应用进一步的过滤器:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/ab2792a81d373a9f8e4b5000588f7aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FP9eIstL48b90ds5jihtmA.png"/></div></div></figure><h2 id="853f" class="mz lc it bd ld na nb dn lh nc nd dp ll kb ne nf lp kf ng nh lt kj ni nj lx nk bi translated">加密响应</h2><p id="ef3d" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">加密响应的代码灵感来自Spring提供的<code class="fe mt mu mv mw b">ModifyResponseGatewayFilter</code>。与请求类似，我们需要首先提取响应，以便能够对其进行加密。</p><p id="c4f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一步是创建一个<code class="fe mt mu mv mw b">ServerHttpResponseDecorator</code>对象并覆盖<code class="fe mt mu mv mw b">writeWith</code>方法。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/e7e14e651f73e6ea9bed683d90de6bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53XlOc5aBf2-VBrbFuUiIQ.png"/></div></div></figure><p id="219f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个包含正文和标题的<code class="fe mt mu mv mw b">ClientResponse</code>对象:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/0901011a1d8cb4560e027d50e512a76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKTUVyNwAPDr5EzqUuFhwQ.png"/></div></div></figure><p id="c45a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后提取主体并用<code class="fe mt mu mv mw b">EncryptDecryptHelper</code>类加密。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/0d8847812937c39b2d6a19e90178829e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2exYzpJlYlDn4iTm88EIA.png"/></div></div></figure><p id="4657" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提取正文方法考虑了创建过滤器时注入的消息正文解码器。如果找到任何解码器，它使用它们来解码主体缓冲区。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi od"><img src="../Images/dfe20b2c0db1d74c4a2526bd3b3f5027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GfyCpjzD5tiGA6_QHzgyw.png"/></div></div></figure><p id="6152" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦主体可用，就使用一个<code class="fe mt mu mv mw b">BodyInserter</code>类的对象来创建更新的响应</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/968a09c70dc373fbaaccaeb2939388a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyWyPgHuf2q29n9aJrtAng.png"/></div></div></figure><blockquote class="nm nn no"><p id="ea7a" class="jq jr np js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">同样，对于请求，响应<code class="fe mt mu mv mw b">Content-Length</code>和<code class="fe mt mu mv mw b">Content-Type</code>可能会改变。这是根据需求更新这些头的正确位置。对于这篇文章，客户端期望一个文本输出，所以<code class="fe mt mu mv mw b">Content-Type</code>被重置为<code class="fe mt mu mv mw b">text/plain</code>。</p></blockquote><p id="efb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mt mu mv mw b">updateBody</code>方法还考虑了消息体编码器，并使用它们对输出响应进行适当的编码。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/b8daf7a18c33b7ad391a18796294efaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Um_d0amtELcS51-DHknMlg.png"/></div></div></figure><p id="5269" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，创建的<code class="fe mt mu mv mw b">ServerHttpResponseDecorator</code>用于更新交换，并通过链进行进一步过滤:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/4c11383e330762946954c93a1cba4263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYA8NuCwYK6U1aoFzNoo6Q.png"/></div></div></figure><p id="aebd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就完成了过滤器，因为请求和响应都发生了变异。</p><h1 id="7a68" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">配置</h1><p id="525a" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">自定义过滤器需要使用application.properties(或application.yml)进行配置。下面的代码片段显示了所需的配置</p><pre class="kp kq kr ks gt oh mw oi oj aw ok bi"><span id="2507" class="mz lc it mw b gy ol om l on oo">spring:<br/>  cloud:<br/>    gateway:<br/>      routes:<br/>        - id: book_encrypt_decrypt_route<br/>          uri: http://localhost:8080/<br/>          predicates:<br/>            - Path=/createBook<br/>          filters:<br/>            - EncryptDecryptFilter<br/>            - RewritePath=/createBook, /api/book</span></pre><p id="460c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的配置创建了到托管目标服务的目标uri <code class="fe mt mu mv mw b"><a class="ae la" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></code>的新路由<code class="fe mt mu mv mw b">book_encrypt_decrypt_route</code>。</p><p id="90be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个请求会被<code class="fe mt mu mv mw b">EncryptDecryptFilter</code>拦截。它的身体将被提取和解密。然后，这个请求将被移交给<code class="fe mt mu mv mw b">RewritePath</code>过滤器，过滤器将uri从<code class="fe mt mu mv mw b">/createBook</code>更改为<code class="fe mt mu mv mw b">/api/book</code>并转发请求。</p><p id="0c1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当目标服务响应时，响应将再次被<code class="fe mt mu mv mw b">EncryptDecryptFilter</code>拦截。然后，在将最终响应发送给客户端之前，将对响应正文进行加密。</p><h1 id="74ef" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试</h1><p id="b01a" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">可以通过使用<code class="fe mt mu mv mw b">wiremock</code>或等效的库模拟REST端点来测试过滤器，以启动模拟端点。</p><p id="944b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的代码片段显示了一个工作测试用例:</p><pre class="kp kq kr ks gt oh mw oi oj aw ok bi"><span id="000d" class="mz lc it mw b gy ol om l on oo">@ExtendWith({SpringExtension.class})<br/>@SpringBootTest( webEnvironment = SpringBootTest.WebEnvironment.<em class="np">RANDOM_PORT</em>)<br/>@TestInstance(TestInstance.Lifecycle.<em class="np">PER_CLASS</em>)<br/>public class GatewayEncryptDecryptTests {<br/><br/>   @Autowired<br/>   private TestRestTemplate testRestTemplate;<br/><br/>   @LocalServerPort<br/>   private int port;<br/><br/>   private WireMockServer wireMockServer;<br/><br/><br/>   @BeforeAll<br/>   public void init(){<br/>      wireMockServer = new WireMockServer(<em class="np">options</em>().port(8080));<br/>      wireMockServer.start();<br/><br/>   }<br/><br/>   @AfterAll<br/>   public void destroy(){<br/>      wireMockServer.stop();<br/>   }<br/><br/><br/>   @Test<br/>   public void encryptDecryptFilter_decryptsDefaultBook_and_EncryptsDefaultResponse(){<br/><br/>      <em class="np">//language=JSON<br/>      </em>String data = "{<strong class="mw iu">\n</strong>"<br/>            + "  <strong class="mw iu">\"</strong>title<strong class="mw iu">\"</strong>: <strong class="mw iu">\"</strong>TestTitle1<strong class="mw iu">\"</strong>,<strong class="mw iu">\n</strong>"<br/>            + "  <strong class="mw iu">\"</strong>author<strong class="mw iu">\"</strong>: <strong class="mw iu">\"</strong>TestAuthor1<strong class="mw iu">\"\n</strong>"<br/>            + "}";<br/><br/>      MultiValueMap&lt;String, String&gt; headers = new LinkedMultiValueMap&lt;&gt;();<br/>      headers.add(HttpHeaders.<em class="np">CONTENT_TYPE</em>, MediaType.<em class="np">TEXT_PLAIN_VALUE</em>);<br/><br/>      wireMockServer.stubFor( <em class="np">post</em>("/api/book").withRequestBody(<em class="np">equalToJson</em>(data))<br/>            .willReturn( <em class="np">status</em>(201).withBody("Created")));<br/><br/><br/>      String gatewayUrl = "http://localhost:" + port + "/createBook";<br/><br/>      String encryptedRequest = EncryptDecryptHelper.<em class="np">encrypt</em>(data);<br/>      String expectedDecryptedResponse = "Created";<br/><br/><br/>      ResponseEntity&lt;String&gt; outputEntity = testRestTemplate.exchange(gatewayUrl, HttpMethod.<em class="np">POST</em>,new HttpEntity&lt;String&gt;(encryptedRequest, headers),String.class);<br/><br/><br/>      <em class="np">assertThat</em>( outputEntity.getStatusCode() ).isEqualTo( HttpStatus.<em class="np">CREATED </em>);<br/>      <em class="np">assertThat</em>( EncryptDecryptHelper.<em class="np">decrypt</em>( outputEntity.getBody() ) ).isEqualTo(expectedDecryptedResponse);<br/><br/>   }<br/><br/><br/><br/>}</span></pre><p id="6d62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据测试代码，网络模拟的目标服务期望在主体中有一个json，并在响应中返回一个文本，但是我们使用加密的json而不是真实的JSON调用网关URL，网关过滤器在将它发送到目标之前对其进行解密。</p><blockquote class="nm nn no"><p id="8cb2" class="jq jr np js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">要获得本文中提到的代码，请访问知识库@<a class="ae la" href="https://github.com/sumantrana/SpringGatewayCustomFilter.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sumantrana/SpringGatewayCustomFilter.git</a></p></blockquote></div></div>    
</body>
</html>