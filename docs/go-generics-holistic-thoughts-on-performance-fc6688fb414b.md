# Go Generics:关于性能的整体思考

> 原文：<https://levelup.gitconnected.com/go-generics-holistic-thoughts-on-performance-fc6688fb414b>

![](img/39216bc30ae0c2897d3c9abfc3816524.png)

已经有很多关于 Go 中泛型的性能影响的讨论，围绕着具体的场景和抽象地，让我们试着更全面地思考一下。

## 什么是性能？

为了明确这一点，让我们快速澄清一下我们所说的性能是什么意思。

*   **Raw** :对照基准研磨代码，是快了还是慢了？它能很好地处理内存和垃圾收集器吗？
*   **开发**:使用的难易程度，即对开发者性能的影响。
*   **寿命**:可靠性？可以理解？灵活？可增强？

如果你认为只有原始性能才是最重要的，我会说为什么不是所有代码都用汇编语言编写？

## 给一个简单的例子评分

让我们举一个简单的例子，用 Go 的泛型给性能打分。我将使用一个简单的 *min* 函数，它接受两个参数并返回这两个参数中的最小值:

```
*// Min returns minimum value of two constraints.Ordered values,
func* Min[T constraints.Ordered](a, b T) T {
   *if* a < b {
      *return* a
   }
   *return* b
}
```

我们将自下而上地工作。

## 寿命:A+

这是一个单一的[干](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)功能，易于阅读，适用于许多类型。

## **开发:A+**

出于与它的终身性能相同的原因，它更适合开发。您不需要在众多特定类型的 min 函数中寻找一个，或者更糟的是，发现您想要的类型不受支持，需要重新编写。

## Raw:一个-

因此，原始性能是更值得讨论的地方。通用函数**不会比任何相应的特定类型函数**更快。如果特定类型的丢失迫使你降低算法的速度，那么它可能会更慢。然而，考虑一下，如果你以前需要一个更加类型不可知的 min，并且你写了一个接受类型 *interface{}，*的参数，即使实现很出色， *interface{}* 也要花费你装箱、拆箱和反射的时间。通用函数**将**明显更快。所以在原始性能方面， ***如果你需要泛型，使用 Go 的泛型会更快。***

现在，如果你只需要一种类型，泛型版本不会天生就慢，除非它导致一个不太优雅的算法。这将产生一个稍大的二进制文件。

## 摘要

Go 的泛型几乎肯定会提高您的开发和生命周期性能，在原始性能方面，如果在您真正需要时使用泛型，它们也应该是性能提升。