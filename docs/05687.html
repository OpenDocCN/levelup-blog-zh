<html>
<head>
<title>Secures APIs with a JWT Token</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JWT令牌保护API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/secures-apis-with-jwt-token-c471d1622cbc?source=collection_archive---------1-----------------------#2020-09-22">https://levelup.gitconnected.com/secures-apis-with-jwt-token-c471d1622cbc?source=collection_archive---------1-----------------------#2020-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ae8c55367c914d06af74aeab6d482461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aAVE2H3tOgrilaND"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@franckinjapan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗兰克</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="bacd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://medium.com/@hantsy/connecting-to-mongodb-c8166e0a6cb7" rel="noopener">上一篇文章中，</a>我们连接到一个MongoDB服务器，并使用一个真实的数据库来替换虚拟数据存储。在本帖中，我们将探讨如何在向客户端应用程序公开API时保护您的API。</p><p id="db30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们谈到web应用程序的安全性时，从技术上讲，它包括:</p><ul class=""><li id="791f" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">认证</strong> —应用程序会要求您提供您的委托人，然后识别您的身份。</li><li id="1d85" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">授权</strong> —根据您的声明，检查您是否有权限执行某些操作。</li></ul><p id="89ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="http://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank"> Passportjs </a>是<a class="ae kc" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Expressjs </a>平台上最流行的认证框架之一。Nestjs通过其<code class="fe lp lq lr ls b">@nestjs/passportjs</code>模块与passportjs进行了很好的集成。我们将遵循官方指南的<a class="ae kc" href="https://docs.nestjs.com/techniques/authentication" rel="noopener ugc nofollow" target="_blank">认证</a>章节，将<em class="lt">本地</em>和<em class="lt"> jwt </em>策略添加到我们之前帖子所做的应用中。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="da1b" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">先决条件</h1><p id="476b" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">安装与passportjs相关的依赖项。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="267d" class="nm mc iq ls b gy nn no l np nq">$ npm install --save @nestjs/passport passport passport-local @nestjs/jwt passport-jwt<br/>$ npm install --save-dev @types/passport-local @types/passport-jwt</span></pre><p id="ddf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在开始认证工作之前，我们先生成一些骨架代码。</p><p id="9c49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先生成一个<code class="fe lp lq lr ls b">AuthModule</code>和<code class="fe lp lq lr ls b">AuthService</code>。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="f7b4" class="nm mc iq ls b gy nn no l np nq">nest g mo auth<br/>nest g s auth</span></pre><p id="5eff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">身份验证应该与应用程序中的用户一起工作。</p><p id="aa14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似地，创建一个独立的<code class="fe lp lq lr ls b">UserModule</code>来处理用户查询。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="67fe" class="nm mc iq ls b gy nn no l np nq">nest g mo user<br/>nest g s user</span></pre><p id="bbac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，让我们开始充实<code class="fe lp lq lr ls b">AuthModule</code>。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="74c3" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">实施身份验证</h1><p id="257f" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">首先，我们为用户模型创建一些资源，一个<code class="fe lp lq lr ls b">Document</code>和<code class="fe lp lq lr ls b">Schema</code>文件。</p><p id="33bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="lt">/用户</em>文件夹下创建新文件。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="1032" class="nm mc iq ls b gy nn no l np nq">import { SchemaFactory, Schema, Prop } from '@nestjs/mongoose';<br/>import { Document } from 'mongoose';</span><span id="e34f" class="nm mc iq ls b gy nr no l np nq">@Schema()<br/>export class User extends Document {<br/>  @Prop({ require: true })<br/>  readonly username: string;</span><span id="db08" class="nm mc iq ls b gy nr no l np nq">  @Prop({ require: true })<br/>  readonly email: string;</span><span id="408b" class="nm mc iq ls b gy nr no l np nq">  @Prop({ require: true })<br/>  readonly password: string;<br/>}</span><span id="de50" class="nm mc iq ls b gy nr no l np nq">export const UserSchema = SchemaFactory.createForClass(User);</span></pre><p id="ec05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lp lq lr ls b">User</code>类是用Mongoose包装一个文档，<code class="fe lp lq lr ls b">UserSchema</code>是描述<code class="fe lp lq lr ls b">User</code>文档。</p><p id="a761" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lp lq lr ls b">UserModule</code>中注册<code class="fe lp lq lr ls b">UserSchema</code>，然后可以使用<code class="fe lp lq lr ls b">Model&lt;User&gt;</code>对<code class="fe lp lq lr ls b">User</code>文档进行一些操作。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="4928" class="nm mc iq ls b gy nn no l np nq">@Module({<br/>  imports: [MongooseModule.forFeature([{ name: 'users', schema: UserSchema }])],<br/>  providers: [//...<br/>  ],<br/>  exports: [//...<br/>  ],<br/>})<br/>export class UserModule {}</span></pre><p id="7b8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的<em class="lt">用户</em>作为<em class="lt">令牌</em>在注入一个<code class="fe lp lq lr ls b">Model</code>时用来标识不同的<code class="fe lp lq lr ls b">Model</code>。在mongoose中注册一个<code class="fe lp lq lr ls b">UserSchema</code>时，上面<code class="fe lp lq lr ls b">MongooseModule.forFeature</code>中的name属性也是<code class="fe lp lq lr ls b">User</code>文档的收藏名称。</p><p id="eb0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lp lq lr ls b">UserService</code>中增加一个<code class="fe lp lq lr ls b">findByUsername</code>方法。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="202f" class="nm mc iq ls b gy nn no l np nq">@Injectable()<br/>export class UserService {<br/>  constructor(@InjectModel('users') private userModel: Model&lt;User&gt;) {}</span><span id="a110" class="nm mc iq ls b gy nr no l np nq">  findByUsername(username: string): Observable&lt;User | undefined&gt; {<br/>    return from(this.userModel.findOne({ username }).exec());<br/>  }<br/>}</span></pre><p id="7e61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lp lq lr ls b">UserModule</code>的<code class="fe lp lq lr ls b">@Module</code>声明中，将<code class="fe lp lq lr ls b">UserService</code>注册到<code class="fe lp lq lr ls b">providers</code>中，不要忘记将其添加到<code class="fe lp lq lr ls b">exports</code>中，这样其他模块在导入<code class="fe lp lq lr ls b">UserModule</code>时可以使用该服务。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="30f6" class="nm mc iq ls b gy nn no l np nq">//...other imports<br/>import { UserService } from './user.service';</span><span id="dab9" class="nm mc iq ls b gy nr no l np nq">@Module({<br/>  providers: [UserService],<br/>  exports:[UserService]//exposing users to other modules...<br/>})<br/>export class UserModule {}</span></pre><p id="e90a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个测试用例来测试<code class="fe lp lq lr ls b">findByUsername</code>方法。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="9c26" class="nm mc iq ls b gy nn no l np nq">describe('UserService', () =&gt; {<br/>  let service: UserService;<br/>  let model: Model&lt;User&gt;;</span><span id="cb29" class="nm mc iq ls b gy nr no l np nq">  beforeEach(async () =&gt; {<br/>    const module: TestingModule = await Test.createTestingModule({<br/>      providers: [<br/>        UserService,<br/>        {<br/>          provide: getModelToken('users'),<br/>          useValue: {<br/>            findOne: jest.fn(),<br/>          },<br/>        },<br/>      ],<br/>    }).compile();</span><span id="62d5" class="nm mc iq ls b gy nr no l np nq">    service = module.get&lt;UserService&gt;(UserService);<br/>    model = module.get&lt;Model&lt;User&gt;&gt;(getModelToken('users'));<br/>  });</span><span id="112f" class="nm mc iq ls b gy nr no l np nq">  it('should be defined', () =&gt; {<br/>    expect(service).toBeDefined();<br/>  });</span><span id="32be" class="nm mc iq ls b gy nr no l np nq">  it('findByUsername should return user', async () =&gt; {<br/>    jest<br/>      .spyOn(model, 'findOne')<br/>      .mockImplementation((conditions: any, projection: any, options: any) =&gt; {<br/>        return {<br/>          exec: jest.fn().mockResolvedValue({<br/>            username: 'hantsy',<br/>            email: 'hantsy@example.com',<br/>          } as User),<br/>        } as any;<br/>      });</span><span id="cd16" class="nm mc iq ls b gy nr no l np nq">    const foundUser = await service.findByUsername('hantsy').toPromise();<br/>    expect(foundUser).toEqual({<br/>      username: 'hantsy',<br/>      email: 'hantsy@example.com',<br/>    });<br/>    expect(model.findOne).lastCalledWith({username: 'hantsy'});<br/>    expect(model.findOne).toBeCalledTimes(1);<br/>  });<br/>});</span></pre><p id="a521" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lp lq lr ls b">UserService</code>依赖于一个<code class="fe lp lq lr ls b">Model&lt;User&gt;</code>，使用一个provider通过jest嘲弄特性来嘲弄它。使用<code class="fe lp lq lr ls b">jest.spyOn</code>方法，你可以存根一个方法的细节，并观察这个方法的调用。</p><p id="53c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们转到<code class="fe lp lq lr ls b">AuthModule</code>。</p><p id="c6df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lp lq lr ls b">@nestjs/passpart</code>，通过扩展<code class="fe lp lq lr ls b">PassportStrategy</code>设置您的passport策略很简单，我们将在这里创建两个passport策略。</p><ul class=""><li id="0cea" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe lp lq lr ls b">LocalStrategy</code>根据请求中的用户名和密码字段处理验证。</li><li id="70de" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe lp lq lr ls b">JwtStrategy</code>通过给定的JWT令牌头来处理认证。</li></ul><p id="2dbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简化，通过嵌套命令行生成两个文件。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="2f6d" class="nm mc iq ls b gy nn no l np nq">nest g class auth/local.strategy.ts --flat<br/>nest g class auth/jwt.strategy.ts --flat</span></pre><p id="1a3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们实现<code class="fe lp lq lr ls b">LocalStrategy</code>。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="60bf" class="nm mc iq ls b gy nn no l np nq">@Injectable()<br/>export class LocalStrategy extends PassportStrategy(Strategy) {<br/>  constructor(private authService: AuthService) {<br/>    super({<br/>      usernameField: 'username',<br/>      passwordField: 'password',<br/>    });<br/>  }</span><span id="634b" class="nm mc iq ls b gy nr no l np nq">  validate(username: string, password: string): Observable&lt;any&gt; {<br/>    return this.authService<br/>      .validateUser(username, password)<br/>      .pipe(throwIfEmpty(() =&gt; new UnauthorizedException()));<br/>  }<br/>}</span></pre><p id="f589" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在构造器中，使用<code class="fe lp lq lr ls b">super</code>提供您正在使用的策略的基本选项。对于本地策略，它需要用户名和密码字段。</p><p id="e816" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">validate方法用于根据给定的信息验证认证信息，这里是从请求中提供的<em class="lt">用户名</em>和<em class="lt">密码</em>。</p><blockquote class="ns nt nu"><p id="d928" class="kd ke lt kf b kg kh ki kj kk kl km kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated"><em class="iq">关于本地策略的配置选项和验证的更多细节，查看</em><a class="ae kc" href="http://www.passportjs.org/packages/passport-local/" rel="noopener ugc nofollow" target="_blank"><em class="iq">passport-local</em></a><em class="iq">项目。</em></p></blockquote><p id="3b96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lp lq lr ls b">AuthService</code>中，增加一个方法<code class="fe lp lq lr ls b">validateUser</code>。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="7c52" class="nm mc iq ls b gy nn no l np nq">@Injectable()<br/>export class AuthService {<br/>  constructor(<br/>    private userService: UserService,<br/>    private jwtService: JwtService,<br/>  ) {}</span><span id="7304" class="nm mc iq ls b gy nr no l np nq">  validateUser(username: string, pass: string): Observable&lt;any&gt; {<br/>    return this.userService.findByUsername(username).pipe(<br/>      map(user =&gt; {<br/>        if (user &amp;&amp; user.password === pass) {<br/>          const { password, ...result } = user;<br/>          return result;<br/>        }<br/>        return null;<br/>      }),<br/>    );<br/>  }<br/>}</span></pre><blockquote class="ns nt nu"><p id="72fe" class="kd ke lt kf b kg kh ki kj kk kl km kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated"><em class="iq">在实际应用中，我们可以使用一个加密工具来散列和比较输入的密码。我们将在以后的文章中讨论它。</em></p></blockquote><p id="9c14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它从<code class="fe lp lq lr ls b">UserModule</code>调用<code class="fe lp lq lr ls b">UserService</code>中的<code class="fe lp lq lr ls b">findByUsername</code>。<code class="fe lp lq lr ls b">AuthModule</code>报关单中的<code class="fe lp lq lr ls b">UserModule</code>。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="70a3" class="nm mc iq ls b gy nn no l np nq">@Module({<br/>  imports: [<br/>    UserModule,<br/> 	...]<br/>    ...   <br/>})<br/>export class AuthModule {}</span></pre><p id="810b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在<code class="fe lp lq lr ls b">AppController</code>中创建一个方法，通过给定的用户名和密码字段实现认证。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="652b" class="nm mc iq ls b gy nn no l np nq">@Controller()<br/>export class AppController {<br/>  constructor(private authService: AuthService) {}</span><span id="d960" class="nm mc iq ls b gy nr no l np nq">  @UseGuards(LocalAuthGuard)<br/>  @Post('auth/login')<br/>  login(@Req() req: Request): Observable&lt;any&gt; {<br/>    return this.authService.login(req.user);<br/>  }<br/>}</span></pre><p id="5281" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只是在<code class="fe lp lq lr ls b">AuthService</code>中调用另一个方法<code class="fe lp lq lr ls b">login</code>。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="da52" class="nm mc iq ls b gy nn no l np nq">@Injectable()<br/>export class AuthService {<br/>  constructor(<br/>    private userService: UserService,<br/>    private jwtService: JwtService,<br/>  ) {}<br/>  //...<br/>  login(user: Partial&lt;User&gt;): Observable&lt;any&gt; {<br/>    const payload = {<br/>      sub: user.username,<br/>      email: user.email,<br/>      roles: user.roles,<br/>    };<br/>    return from(this.jwtService.signAsync(payload)).pipe(<br/>      map(access_token =&gt; {<br/>        access_token;<br/>      }),<br/>    );<br/>  }<br/>}</span></pre><p id="07f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lp lq lr ls b">login</code>方法负责根据经过认证的主体生成基于JWT的访问令牌。</p><p id="5d77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">URI路径<code class="fe lp lq lr ls b">auth/login</code>使用一个<code class="fe lp lq lr ls b">LocalAuthGuard</code>来保护它。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="ff6e" class="nm mc iq ls b gy nn no l np nq">@Injectable()<br/>export class LocalAuthGuard extends AuthGuard('local') {}</span></pre><p id="ba71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们总结一下本地策略是如何工作的。</p><ol class=""><li id="0053" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la ny lh li lj bi translated">当用户用<code class="fe lp lq lr ls b">username</code>和<code class="fe lp lq lr ls b">password</code>点击<em class="lt">认证/登录</em>时，将应用<code class="fe lp lq lr ls b">LocalAuthGuard</code>。</li><li id="913d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ny lh li lj bi translated"><code class="fe lp lq lr ls b">LocalAuthGuard</code>将触发<code class="fe lp lq lr ls b">LocalStrategy</code>，并调用其<code class="fe lp lq lr ls b">validate</code>方法，并将结果存储回<code class="fe lp lq lr ls b">request.user</code>。</li><li id="099b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ny lh li lj bi translated">返回控制器，从<code class="fe lp lq lr ls b">request</code>读取用户主体，生成JWT令牌并将其发送回客户端。</li></ol><p id="acd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">登录后，可以提取<code class="fe lp lq lr ls b">access token</code>并将其放入新请求的HTTP头中，以访问受保护的资源。</p><p id="034c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看JWT策略是如何运作的。</p><p id="10e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先执行<code class="fe lp lq lr ls b">JwtStrategy</code>。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="9248" class="nm mc iq ls b gy nn no l np nq">@Injectable()<br/>export class JwtStrategy extends PassportStrategy(Strategy) {<br/>  constructor() {<br/>    super({<br/>      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),<br/>      ignoreExpiration: false,<br/>      secretOrKey: jwtConstants.secret,<br/>    });<br/>  }</span><span id="5fc8" class="nm mc iq ls b gy nr no l np nq">  validate(payload: any) :any{<br/>    return { email: payload.email, sub: payload.username };<br/>  }<br/>}</span></pre><p id="d721" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在构造函数中，配置了几个选项。</p><p id="1264" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lp lq lr ls b">jwtFromRequest</code>指定了提取令牌的方法，它可以来自HTTP cookie或者请求头<code class="fe lp lq lr ls b">Authorization</code>。</p><p id="81e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe lp lq lr ls b">ignoreExpiration</code>为假，当解码JWT令牌时，它将检查有效期。</p><p id="9a7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lp lq lr ls b">secretOrKey</code>用于签署JWT令牌或解码令牌。</p><p id="444b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lp lq lr ls b">validate</code>方法中，有效载荷是<strong class="kf ir">解码的内容</strong> JWT声明。您可以根据声明添加自定义验证。</p><blockquote class="ns nt nu"><p id="f2c8" class="kd ke lt kf b kg kh ki kj kk kl km kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated"><em class="iq">更多关于配置选项和验证方法，查看</em><a class="ae kc" href="http://www.passportjs.org/packages/passport-jwt/" rel="noopener ugc nofollow" target="_blank"><em class="iq">passport-jwt</em></a><em class="iq">项目。</em></p></blockquote><p id="402d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lp lq lr ls b">AuthModule</code>的声明中，imports <code class="fe lp lq lr ls b">JwtModule</code>接受一个register方法，为JWT令牌签名添加初始选项。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="3fec" class="nm mc iq ls b gy nn no l np nq">@Module({<br/>  imports: [<br/>     // ...<br/>    JwtModule.register({<br/>      secret: jwtConstants.secret,<br/>      signOptions: { expiresIn: '60s' },<br/>    }),<br/>  ],<br/>  providers: [//..., <br/>      LocalStrategy, JwtStrategy],<br/>  exports: [AuthService],<br/>})<br/>export class AuthModule {}</span></pre><p id="a245" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样创建一个<code class="fe lp lq lr ls b">JwtAuthGuard</code>，并在<code class="fe lp lq lr ls b">AuthModule</code>中的<em class="lt">提供者</em>中注册它。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="b76e" class="nm mc iq ls b gy nn no l np nq">@Injectable()<br/>export class JwtAuthGuard extends AuthGuard('jwt'){}</span></pre><p id="cc5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个方法来读取当前用户的配置文件。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="001a" class="nm mc iq ls b gy nn no l np nq">@Controller()<br/>export class AppController {<br/>  constructor(private authService: AuthService) {}<br/>  <br/>  //...  <br/>  @UseGuards(JwtAuthGuard)<br/>  @Get('profile')<br/>  getProfile(@Req() req: Request): any {<br/>    return req.user;<br/>  }<br/>}</span></pre><p id="2356" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们回顾一下JWT战略的工作流程。</p><ol class=""><li id="5c02" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la ny lh li lj bi translated">给定一个JWT令牌<code class="fe lp lq lr ls b">XXX</code>，访问<em class="lt">/带有头文件<code class="fe lp lq lr ls b">Authorization:Bearer XXX</code>的简介</em>。</li><li id="fa21" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ny lh li lj bi translated"><code class="fe lp lq lr ls b">JwtAuthGuard</code>会触发<code class="fe lp lq lr ls b">JwtStrategy</code>，调用<code class="fe lp lq lr ls b">validate</code>方法，并将结果存储回<code class="fe lp lq lr ls b">request.user</code>。</li><li id="7f19" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la ny lh li lj bi translated">在<code class="fe lp lq lr ls b">getProfile</code>方法中，将<code class="fe lp lq lr ls b">request.user</code>发送给客户端。</li></ol><p id="6721" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想设置一个默认策略，将<code class="fe lp lq lr ls b">AuthModule</code>声明中的<code class="fe lp lq lr ls b">PassportModule</code>改为如下。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="7bff" class="nm mc iq ls b gy nn no l np nq">@Module({<br/>  imports: [<br/>    PassportModule.register({ defaultStrategy: 'jwt' }),<br/>    //...<br/>})<br/>export class AuthModule {}</span></pre><p id="efcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Nestjs在运行时提供了几个应用程序生命周期挂钩。在您的代码中，您可以观察这些生命周期事件，并为您的应用程序执行一些特定的任务。</p><p id="e325" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，为<code class="fe lp lq lr ls b">Post</code>创建一个数据初始化器来插入样本数据。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="ba32" class="nm mc iq ls b gy nn no l np nq">@Injectable()<br/>export class UserDataInitializerService<br/>  implements OnModuleInit, OnModuleDestroy {<br/>  constructor(@InjectModel('users') private userModel: Model&lt;User&gt;) {}<br/>  onModuleInit(): void {<br/>    console.log('(UserModule) is initialized...');<br/>    this.userModel<br/>      .create({<br/>        username: 'hantsy',<br/>        password: 'password',<br/>        email: 'hantsy@example.com',<br/>      })<br/>      .then(data =&gt; console.log(data));<br/>  }<br/>  onModuleDestroy(): void {<br/>    console.log('(UserModule) is being destroyed...');<br/>    this.userModel<br/>      .deleteMany({})<br/>      .then(del =&gt; console.log(`deleted ${del.deletedCount} rows`));<br/>  }<br/>}</span></pre><blockquote class="ns nt nu"><p id="a1ec" class="kd ke lt kf b kg kh ki kj kk kl km kn nv kp kq kr nw kt ku kv nx kx ky kz la ij bi translated"><em class="iq">更多关于生命周期钩子的信息，查看官方文档的</em> <a class="ae kc" href="https://docs.nestjs.com/fundamentals/lifecycle-events" rel="noopener ugc nofollow" target="_blank"> <em class="iq">生命周期事件</em> </a> <em class="iq">章节。</em></p></blockquote></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="e6d1" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">运行应用程序</h1><p id="cb7a" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">打开您的终端，通过执行以下命令运行应用程序。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="5d8c" class="nm mc iq ls b gy nn no l np nq">npm run start</span></pre><p id="e0b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<em class="lt">用户名/密码</em>对登录。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="fdd2" class="nm mc iq ls b gy nn no l np nq">&gt;curl <a class="ae kc" href="http://localhost:3000/auth/login" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/auth/login</a> -d "{\"username\":\"hantsy\", \"password\":\"password\"}" -H "Content-Type:application/json"<br/>&gt;{"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cG4iOiJoYW50c3kiLCJzdWIiOiI1ZjJkMGU0ODZhOTZiZTEyMDBmZWZjZWMiLCJlbWFpbCI6ImhhbnRzeUBleGFtcGxlLmNvbSIsInJvbGVzIjpbIlVTRVIiXSwiaWF0IjoxNTk2Nzg4NDg5LCJleHAiOjE1OTY3OTIwODl9.4oYpKTikoTfeeaUBoEFr9d1LPcN1pYqHjWXRuZXOfek"}</span></pre><p id="6ea2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尝试使用此<em class="lt">访问令牌</em>访问<em class="lt"> /profile </em>端点。</p><pre class="ne nf ng nh gt ni ls nj nk aw nl bi"><span id="5204" class="nm mc iq ls b gy nn no l np nq">&gt;curl <a class="ae kc" href="http://localhost:3000/profile" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/profile</a> -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cG4iOiJoYW50c3kiLCJzdWIiOiI1ZjJkMGU0ODZhOTZiZTEyMDBmZWZjZWMiLCJlbWFpbCI6ImhhbnRzeUBleGFtcGxlLmNvbSIsInJvbGVzIjpbIlVTRVIiXSwiaWF0IjoxNTk2Nzg4NDg5LCJleHAiOjE1OTY3OTIwODl9.4oYpKTikoTfeeaUBoEFr9d1LPcN1pYqHjWXRuZXOfek"<br/>{"username":"hantsy","email":"hantsy@example.com","id":"5f2d0e486a96be1200fefcec","roles":["USER"]}</span></pre><p id="9d71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从我的github 中抓取<a class="ae kc" href="https://github.com/hantsy/nestjs-sample" rel="noopener ugc nofollow" target="_blank">源代码，切换到分支</a><a class="ae kc" href="https://github.com/hantsy/nestjs-sample/blob/feat/auth" rel="noopener ugc nofollow" target="_blank"> feat/auth </a>。</p></div></div>    
</body>
</html>