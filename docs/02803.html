<html>
<head>
<title>Add view outside Activity through WindowManager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过WindowManager添加查看外部活动</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/add-view-outside-activity-through-windowmanager-1a70590bad40?source=collection_archive---------8-----------------------#2020-04-05">https://levelup.gitconnected.com/add-view-outside-activity-through-windowmanager-1a70590bad40?source=collection_archive---------8-----------------------#2020-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/06605effc1c9a8f5b62782c270a72af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iWgp8GBSCmZ4RuI-"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由<a class="ae kf" href="https://unsplash.com/@mooo3721" rel="noopener ugc nofollow" target="_blank"> R莫</a>在<a class="ae kf" href="https://unsplash.com/photos/w-_iZqdviAo" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="6824" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">对于传统的Android开发学习来说，WindowManager并不是一门典型的课程。然而，它是一个有用的系统服务。</p><p id="fba1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如在这个<a class="ae kf" href="https://stackoverflow.com/questions/19846541/what-is-windowmanager-in-android" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>中很好地解释的，</p><blockquote class="ln lo lp"><p id="4699" class="kg kh lq ki b kj kk kl km kn ko kp kq lr ks kt ku ls kw kx ky lt la lb lc ld im bi translated">Android WindowManager是一个系统服务，负责管理窗口的z排序列表，哪些窗口是可见的，以及它们在屏幕上的布局。除此之外，当打开或关闭应用程序或旋转屏幕时，它会自动执行窗口转换和动画。</p></blockquote><p id="92ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使人们能够在活动的顶部显示一个视图！</p><p id="d44d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的一些用法示例如下:</p><ul class=""><li id="4481" class="lu lv it ki b kj kk kn ko kr lw kv lx kz ly ld lz ma mb mc bi translated"><a class="ae kf" href="https://img.gadgethacks.com/img/67/17/63693961141749/0/enable-disable-chat-heads-facebook-messenger-android-for-quick-access-conversations.w1456.jpg" rel="noopener ugc nofollow" target="_blank"> Facebook Messenger聊天头像</a></li><li id="7a98" class="lu lv it ki b kj md kn me kr mf kv mg kz mh ld lz ma mb mc bi translated"><a class="ae kf" href="https://raw.githubusercontent.com/sephiroth74/android-target-tooltip/master/screenshots/video2.gif" rel="noopener ugc nofollow" target="_blank">自定义浮动工具提示</a></li><li id="f75a" class="lu lv it ki b kj md kn me kr mf kv mg kz mh ld lz ma mb mc bi translated"><a class="ae kf" href="https://i.stack.imgur.com/Y2JS4.png" rel="noopener ugc nofollow" target="_blank">安卓吐司</a></li></ul><h1 id="e534" class="mi mj it bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">让我们在WindowManger上试验一些视图</h1><p id="0c5b" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">WindowManager的乐趣在于能够在活动之上显示一个视图。有了它，我们可以编写一些超越传统Android应用程序界面的代码。</p><p id="7142" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我制作的示例代码(下面可用),用来演示我们如何在活动之外拥有一个视图。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/1ce0611f8ba176a2b5535e9289276be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*jKdpYApaunkNLtwYiqegPg.gif"/></div></figure><p id="f997" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是编码它所需的内容。</p><h2 id="17e6" class="nq mj it bd mk nr ns dn mo nt nu dp ms kr nv nw mw kv nx ny na kz nz oa ne ob bi translated">访问窗口管理器</h2><p id="49db" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">默认情况下，您可以在活动中获得<code class="fe oc od oe of b">WindowManager</code>对象。然而，如果您在活动之外工作(在另一个类或服务中)，您可以使用上下文访问<code class="fe oc od oe of b">WindowManager</code>。</p><pre class="nm nn no np gt og of oh oi aw oj bi"><span id="b904" class="nq mj it of b gy ok ol l om on">private val windowManager by <em class="lq">lazy </em><strong class="of iu">{<br/>    </strong>context.getSystemService(Context.<em class="lq">WINDOW_SERVICE</em>) <br/>        as WindowManager<br/><strong class="of iu">}</strong></span></pre><h2 id="deac" class="nq mj it bd mk nr ns dn mo nt nu dp ms kr nv nw mw kv nx ny na kz nz oa ne ob bi translated">放大您希望通过窗口管理器显示的视图</h2><p id="fb71" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">无论您是在活动中还是在服务中，您都可以创建一个充气机:</p><pre class="nm nn no np gt og of oh oi aw oj bi"><span id="64a7" class="nq mj it of b gy ok ol l om on">val floatView = (getSystemService(Context.<em class="lq">LAYOUT_INFLATER_SERVICE</em>) as LayoutInflater).inflate(R.layout.<em class="lq">view_service_float</em>, null)</span></pre><h2 id="09da" class="nq mj it bd mk nr ns dn mo nt nu dp ms kr nv nw mw kv nx ny na kz nz oa ne ob bi translated">设置视图所需的参数</h2><p id="1fc4" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">为我们的视图创建窗口管理器所需的所有参数</p><p id="2db1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参数</p><pre class="nm nn no np gt og of oh oi aw oj bi"><span id="5f95" class="nq mj it of b gy ok ol l om on">public LayoutParams(<br/>    int w, int h, int _type, int _flags, int _format)</span></pre><p id="1263" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如何启动它们的示例如下</p><pre class="nm nn no np gt og of oh oi aw oj bi"><span id="e4a1" class="nq mj it of b gy ok ol l om on">val paramFloat = WindowManager.LayoutParams(<br/>    WindowManager.LayoutParams.<em class="lq">WRAP_CONTENT</em>,<br/>    WindowManager.LayoutParams.<em class="lq">WRAP_CONTENT</em>,<br/>    type,<br/>    WindowManager.LayoutParams.<em class="lq">FLAG_NOT_FOCUSABLE</em>,<br/>    PixelFormat.<em class="lq">TRANSLUCENT</em>)<br/>paramFloat.gravity = Gravity.<em class="lq">TOP </em>or Gravity.<em class="lq">CENTER_HORIZONTAL</em></span></pre><p id="40e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里我将更多地关注<code class="fe oc od oe of b">type</code>的不同。</p><p id="ec7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有不同的类型，我将在下面探讨两种类型。</p><p id="a025" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1.<code class="fe oc od oe of b">TYPE_APPLICATION_PANEL</code></p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7340abeffa2ae5af09b735e14f0442fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*E6B17PeoBZ3FrWZ5P-ndLA.gif"/></div></figure><p id="65c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这只能在Activity之上使用，并且存在于Activity之内。因此在这种情况下，它是通过活动发起的。</p><p id="19d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于定制工具提示或Coachmark非常有用。</p><p id="5d24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过服务触发此视图会使应用程序崩溃。</p><p id="d694" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.<code class="fe oc od oe of b">TYPE_APPLICATION_OVERLAY</code>(适用于Android O及更高版本，而<code class="fe oc od oe of b">TYPE_SYSTEM_ALERT</code>适用于早期SDK)</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/0885ca6232c94494303efad83e868752.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*LnfZUn1Fd3-puZ__UQFZNQ.gif"/></div></figure><p id="9dde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个布局，它不仅位于活动之上，还可以位于活动之外。</p><p id="01f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，这将通过服务启动，虽然通过活动启动是允许的，但在不同的SDK中有不同的行为。</p><p id="4e48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所显示的视图可以在Activity live之后继续存在(即，即使Activity被终止，它仍然存在)</p><p id="e8d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于Facebook Messenger聊天头，甚至Android Toast之类的东西都很有用。</p><h2 id="ae7d" class="nq mj it bd mk nr ns dn mo nt nu dp ms kr nv nw mw kv nx ny na kz nz oa ne ob bi translated"><code class="fe oc od oe of b">TYPE_APPLICATION_OVERLAY</code>需要一些许可</h2><p id="55df" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">因为<code class="fe oc od oe of b">TYPE_APPLICATION_OVERLAY</code>将使视图能够超越活动而存在，Android需要一些许可，应用程序才能通过WindowManager添加这样的视图。</p><p id="5e17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要AndroidManifest.xml文件中的SYSTEM_ALERT_WINDOW权限。</p><pre class="nm nn no np gt og of oh oi aw oj bi"><span id="b679" class="nq mj it of b gy ok ol l om on">&lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt;</span></pre><p id="2c60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了Android SDK 23之外，还需要即时申请许可:</p><pre class="nm nn no np gt og of oh oi aw oj bi"><span id="5f87" class="nq mj it of b gy ok ol l om on">private fun requestPermission(requestCode: Int): Boolean {<br/>    if (Build.VERSION.<em class="lq">SDK_INT </em>&gt;= Build.VERSION_CODES.<em class="lq">M</em>) {<br/>        if (!Settings.canDrawOverlays(this)) {<br/>            val intent = Intent(<br/>                Settings.<em class="lq">ACTION_MANAGE_OVERLAY_PERMISSION</em>,<br/>                Uri.parse("package:$<em class="lq">packageName</em>")<br/>            )<br/>            startActivityForResult(intent, requestCode)<br/>            return true<br/>        }<br/>    }<br/>    return false<br/>}</span></pre><p id="db92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回来后，我们可以跑。<em class="lq">注意:延迟是基于实验的，仅在一小会儿后授予许可。因此，这里有0.5秒的延迟。</em></p><pre class="nm nn no np gt og of oh oi aw oj bi"><span id="69ba" class="nq mj it of b gy ok ol l om on">@TargetApi(Build.VERSION_CODES.<em class="lq">M</em>)<br/>override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {<br/>    super.onActivityResult(requestCode, resultCode, data)<br/>    if (requestCode == <em class="lq">MANAGE_OVERLAY_PERMISSION_REQUEST_CODE</em>) {<br/>        Handler().postDelayed(<strong class="of iu">{<br/>            </strong>if (Settings.canDrawOverlays(this)) {<br/>                when (requestCode) {<br/>                    launchViewThroughWindowManager()<br/>                }<br/>            }<br/>        <strong class="of iu">}</strong>, 500)<br/>    }<br/>}</span></pre><h2 id="9ca1" class="nq mj it bd mk nr ns dn mo nt nu dp ms kr nv nw mw kv nx ny na kz nz oa ne ob bi translated">将视图添加到WindowManager</h2><p id="d57f" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">完成上述操作后，只需将视图添加到<code class="fe oc od oe of b">WindowManager</code>中</p><pre class="nm nn no np gt og of oh oi aw oj bi"><span id="d1df" class="nq mj it of b gy ok ol l om on">windowManager.addView(floatView, paramFloat)</span></pre><p id="92d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以从</p><div class="oo op gp gr oq or"><a href="https://github.com/elye/demo_android_windowmanager" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">elye/demo _ Android _ window manager</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">演示通过WindowManager添加视图，来自活动和服务—elye/demo _ Android _ window manager</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf jz or"/></div></div></a></div><h1 id="70a8" class="mi mj it bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">SDK中的不同行为</h1><p id="ff50" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">根据我对通过WindowManager添加的视图的体验，我在不同的SDK中得到不同的行为。我不是100%确定这是不是模拟器设置。但值得注意的是，我的以下发现作为参考，以确保跨设备的支持得到彻底测试。</p><p id="3f3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在SDK 16(果冻豆)、24(牛轧糖)和26(奥利奥)上进行了测试</p><h2 id="2372" class="nq mj it bd mk nr ns dn mo nt nu dp ms kr nv nw mw kv nx ny na kz nz oa ne ob bi translated"><code class="fe oc od oe of b">TYPE_APPLICATION_OVERLAY/TYPE_SYSTEM_ALERT view life</code></h2><p id="0c55" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">对于SDK 14和24，当应用程序被终止(手动)时，视图也被终止。</p><p id="c0b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于SDK 26，即使应用程序被终止(手动)，视图仍然存在，无论视图是通过服务还是活动启动的。</p><h2 id="0d28" class="nq mj it bd mk nr ns dn mo nt nu dp ms kr nv nw mw kv nx ny na kz nz oa ne ob bi translated"><code class="fe oc od oe of b">TYPE_APPLICATION_OVERLAY/TYPE_SYSTEM_ALERT launched through Activity behavior</code></h2><p id="56f0" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">对于SDK 14,<code class="fe oc od oe of b">TYPE_SYSTEM_ALERT</code>视图位于活动视图边界内。如果活动在背景上，视图也是隐藏的。</p><p id="316d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于SDK 24和26，<code class="fe oc od oe of b">TYPE_APPLICATION_OVERLAY</code>视图位于活动视图边界之外。如果活动在背景上，视图仍然显示。</p><p id="d374" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许这是由于<code class="fe oc od oe of b">TYPE_SYSTEM_ALERT</code>和<code class="fe oc od oe of b">TYPE_APPLICATION_OVERLAY</code>不同的行为。</p><h2 id="f21e" class="nq mj it bd mk nr ns dn mo nt nu dp ms kr nv nw mw kv nx ny na kz nz oa ne ob bi translated"><code class="fe oc od oe of b">TYPE_APPLICATION_OVERLAY/TYPE_SYSTEM_ALERT launched through Activity effect on TYPE_APPLICATION_OVERLAY/TYPE_SYSTEM_ALERT launch through Service</code></h2><p id="fce1" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">正如我们所知，对于SDK 14、24和26，通过<strong class="ki iu">服务</strong>启动的<code class="fe oc od oe of b">TYPE_SYSTEM_ALERT/TYPE_APPLICATION_OVERLAY</code>视图位于活动视图边界之外。如果活动在背景上，视图仍然显示。</p><p id="06cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而对于SDK 14，如果我们通过<strong class="ki iu">活动</strong>再次启动另一个<code class="fe oc od oe of b">TYPE_SYSTEM_ALERT/TYPE_APPLICATION_OVERLAY</code>视图；先前从<strong class="ki iu">服务</strong>中启动的<code class="fe oc od oe of b">TYPE_SYSTEM_ALERT/TYPE_APPLICATION_OVERLAY</code>视图的行为更改如下。</p><ul class=""><li id="fefb" class="lu lv it ki b kj kk kn ko kr lw kv lx kz ly ld lz ma mb mc bi translated">对于SDK 14，通过服务启动的<code class="fe oc od oe of b">TYPE_SYSTEM_ALERT/TYPE_APPLICATION_OVERLAY</code>视图现在也将在活动视图边界内<strong class="ki iu">活动。</strong></li></ul><p id="5859" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如下图所示。<em class="lq">我怀疑这是SDK 14中的一个错误，正如你在后台注意到的，整个屏幕启动器是空白的。</em></p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/86bb95f055a683db29751475a5327a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*zzyyLcMmxN6BPeAbvGpcOg.gif"/></div></figure><p id="6bf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于SDK 24和26，行为没有改变，因为无论从活动还是服务启动，<code class="fe oc od oe of b">TYPE_APPLICATION_OVERLAY</code>视图都在活动视图之外。</p></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><p id="df4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理想情况下，良好做法是:</p><ol class=""><li id="064e" class="lu lv it ki b kj kk kn ko kr lw kv lx kz ly ld pn ma mb mc bi translated">通过活动/片段启动<code class="fe oc od oe of b">TYPE_APPLICATION_PANEL</code>视图。(通过服务启动会导致应用崩溃)</li><li id="e483" class="lu lv it ki b kj md kn me kr mf kv mg kz mh ld pn ma mb mc bi translated">通过服务仅启动<code class="fe oc od oe of b">TYPE_SYSTEM_ALERT/TYPE_APPLICATION_OVERLAY</code>视图(以确保新旧SDK的一致行为)</li><li id="3f48" class="lu lv it ki b kj md kn me kr mf kv mg kz mh ld pn ma mb mc bi translated">通过服务启动<code class="fe oc od oe of b">TYPE_SYSTEM_ALERT/TYPE_APPLICATION_OVERLAY</code>视图还有助于确保只启动一个视图。在活动中，人们可能会意外地启动多个这样视图，且需要代码来控制只启动一个视图。</li></ol></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h2 id="85ff" class="nq mj it bd mk nr ns dn mo nt nu dp ms kr nv nw mw kv nx ny na kz nz oa ne ob bi translated">参考</h2><div class="oo op gp gr oq or"><a href="https://github.com/henrychuangtw/Android-ChatHead" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">henrychuangtw/Android-ChatHead</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">Android应用程序的聊天头，如FB messenger。开始聊天:显示消息(见下图“消息”):` ` Java意图…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="po l pc pd pe pa pf jz or"/></div></div></a></div><div class="oo op gp gr oq or"><a href="https://github.com/sephiroth74/android-target-tooltip" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">sephiroth 74/Android-目标-工具提示</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">创建类似工具提示的提示，可以指定物理目标，甚至是屏幕上的点。许多附加功能和…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pp l pc pd pe pa pf jz or"/></div></div></a></div></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><p id="8330" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读。你可以在这里查看我的其他话题<a class="ae kf" href="https://medium.com/@elye.project/" rel="noopener"/>。</p><p id="4de3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关注我的<a class="ae kf" href="https://medium.com/@elye.project" rel="noopener"><em class="lq"/></a><em class="lq"/><a class="ae kf" href="https://twitter.com/elye_project" rel="noopener ugc nofollow" target="_blank"><em class="lq">Twitter</em></a><em class="lq"/><a class="ae kf" href="https://www.facebook.com/elyeproj/" rel="noopener ugc nofollow" target="_blank"><em class="lq">脸书</em> </a>或<a class="ae kf" href="https://www.reddit.com/user/elyeproj/" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> Reddit </em> </a>获取移动开发等相关话题的小技巧和学习。~Elye~</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="pq pr l"/></div></figure></div></div>    
</body>
</html>