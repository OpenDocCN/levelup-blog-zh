<html>
<head>
<title>Scala Beginner Series (1) : Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala初学者系列(1):基础知识</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-beginner-series-1-basics-d1dae1f3458d?source=collection_archive---------5-----------------------#2020-08-29">https://levelup.gitconnected.com/scala-beginner-series-1-basics-d1dae1f3458d?source=collection_archive---------5-----------------------#2020-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c291ba4b50121fc0a3fd596a01147f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e7E19wDlZVrVrzpT.png"/></div></div></figure><blockquote class="jy"><p id="864c" class="jz ka iq bd kb kc kd ke kf kg kh ki dk translated">这个系列讲的都是Scala的味道。最适合所有Scala新手。所以我们开始吧…</p></blockquote><p id="d044" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ki ij bi translated">本文将涵盖Scala语言的基础知识。</p><h1 id="0d72" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">价值观念</h1><p id="ffdb" class="pw-post-body-paragraph kj kk iq kl b km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf ki ij bi translated">在Scala中，我们处理值:</p><p id="54b2" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">值用于定义常数。修饰符的意思是常量或不可变的，这意味着一旦它被创建，我们就不能改变它的值。因此禁止重新分配到<code class="fe mo mp mq mr b">val </code>。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/84f56b67f4109f59779d443cea2b358b.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/0*4gtfhCcWjfMAAhvJ.png"/></div></figure><p id="84a7" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">仅在定义时对其进行评估。一旦求值，它对它的所有引用重用相同的值。</p><h1 id="c1d7" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">变量</h1><p id="5350" class="pw-post-body-paragraph kj kk iq kl b km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf ki ij bi translated">Scala还允许我们定义可变值。变量用于定义对值的可变引用。<code class="fe mo mp mq mr b">var </code>修饰符的意思是可变的，也就是说我们可以在程序的整个生命周期中改变它的值。因此允许重新分配到<code class="fe mo mp mq mr b">var </code>。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/9ea84d7e4440a2a8fb0528635526d758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*eKicePVkqjRujR-n.png"/></div></figure><p id="8f90" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">我们在Scala中确实有变量的概念，但是我们不鼓励这样做。一般来说，我们使用不可变的数据结构:对现有实例的任何修改都应该返回一个新的(修改后的)实例。</p><h1 id="e40d" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">类型</h1><p id="1b61" class="pw-post-body-paragraph kj kk iq kl b km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf ki ij bi translated">在Scala中，我们并不总是需要指定我们的值的数据类型，因为编译器足够聪明来为我们推断。我们也可以写:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/6743a15cf7623d456a56c49bb973e428.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/0*utPL_eCqOp_X0bN3.png"/></div></figure><p id="6afe" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">我们可以看到，编译器自动推断出值的数据类型。</p><h1 id="adfc" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">用线串</h1><p id="352c" class="pw-post-body-paragraph kj kk iq kl b km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf ki ij bi translated">Scala中的字符串类似于我们在其他语言中看到的，但是有一些特殊的功能:</p><p id="5e3b" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">字符串被定义为:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/36e245d5d271baae14e5045d964edc3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/0*3P8XwoqK0q0wX2WW.png"/></div></figure><p id="cffd" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">每当编译器在代码中遇到一个字符串文字，它就用它的值创建一个<code class="fe mo mp mq mr b">java.lang.String</code>类的字符串对象。</p><p id="8a08" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">用于获取对象信息的方法称为访问器方法。</p><p id="1ae9" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">一个可用于字符串的访问器方法是<code class="fe mo mp mq mr b">length()</code>方法，它返回string对象中包含的字符数。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6f65246058bff7dab9f5bc4c272e7f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/0*4KqJXvDeYeEaYA6M.png"/></div></figure><p id="60ca" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">String类包含一个连接两个字符串的方法<code class="fe mo mp mq mr b">concat()</code>。但是字符串通常用<code class="fe mo mp mq mr b">+</code>操作符连接起来。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a0bd466e322e8b812fcce8962365bbfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/0*-YcWXMHS-aVruMbH.png"/></div></figure><p id="8a4d" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">也可以使用<code class="fe mo mp mq mr b">s </code>字符串插值器进行字符串插值。通过注入一个带有<code class="fe mo mp mq mr b">$</code>符号的值，它允许在处理字符串时直接使用变量。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/158518c9614aeee3d012c5fa18ec03bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*6MyztxA9Yu0h5obK.png"/></div></figure><h1 id="1be7" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">公式</h1><p id="8beb" class="pw-post-body-paragraph kj kk iq kl b km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf ki ij bi translated">在Scala中，我们处理值，并组合它们以获得其他值。组成结构是表达式<strong class="kl ir">、</strong>，它们正是我们所期望的。</p><p id="4e49" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">之前我们已经定义了分配给文字的值。但是，更准确的说法是，它们被赋给了表达式的返回值。</p><p id="ea8f" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">因此，表达式是一个单一的代码单位，可以简化为一个值。它可以是文字、计算或函数调用。表达式有自己的范围，可能包含表达式块的局部值。</p><p id="0f3a" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">我们可以将基于表达式的值定义为:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/91bf12633fe9f6d6d930ead33e0b2175.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/0*F4zTst9s540DvmC8.png"/></div></figure><p id="00af" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">在Scala中，我们也可以定义表达式块。可以使用花括号将多个表达式组合起来，创建一个表达式块。块中的最后一个表达式是整个块的返回值。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/1e1a5b8dfd7dc81cc16bcddd7034e549.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/0*jLM_xvxwUNbowGXN.png"/></div></figure><p id="3201" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">If结构也是表达式。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/1a1f3bee5857b98eb143ac0cf80242cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/0*exJN8X2bWGChw_zW.png"/></div></figure><p id="108d" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">在类C语言中，我们有等价的三元运算符，但是在Scala中，可读性更好，因为我们可以在无限的if/else结构中链接if表达式，而没有误解任何逻辑的风险。</p><p id="2e0f" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">我们还有其他类型表达式，比如for表达式、match表达式等等。我们稍后会谈到它们。</p><h1 id="b4a9" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">功能</h1><p id="ab4a" class="pw-post-body-paragraph kj kk iq kl b km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf ki ij bi translated">Scala既有函数又有方法，我们可以互换使用方法和函数这两个术语，只是有一点点不同。Scala方法是一个类的一部分，它有一个名字和一个签名，而Scala中的函数是一个完整的对象，它可以被赋给一个变量。</p><p id="950a" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">函数的声明和定义如下:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/3fc558f6d48683c709d66e4a5f1eaf90.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/0*8d8aWxW646Hlu62W.png"/></div></figure><p id="6f9a" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">所以我们有:</p><ul class=""><li id="9d83" class="nf ng iq kl b km mj kq mk ku nh ky ni lc nj ki nk nl nm nn bi translated"><code class="fe mo mp mq mr b">def</code></li><li id="6811" class="nf ng iq kl b km no kq np ku nq ky nr lc ns ki nk nl nm nn bi translated">函数名</li><li id="d41e" class="nf ng iq kl b km no kq np ku nq ky nr lc ns ki nk nl nm nn bi translated"><code class="fe mo mp mq mr b">arg : Type</code>形式的论据</li><li id="f5f3" class="nf ng iq kl b km no kq np ku nq ky nr lc ns ki nk nl nm nn bi translated"><code class="fe mo mp mq mr b">: ReturnType</code></li><li id="cb2e" class="nf ng iq kl b km no kq np ku nq ky nr lc ns ki nk nl nm nn bi translated"><code class="fe mo mp mq mr b">=</code></li><li id="7cda" class="nf ng iq kl b km no kq np ku nq ky nr lc ns ki nk nl nm nn bi translated">那么函数将返回一个表达式。</li></ul><p id="7212" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">递归在纯函数式编程中扮演着重要角色，Scala非常支持递归函数。在Scala中，我们不考虑循环。我们从递归的角度来思考。</p><p id="5820" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">递归意味着函数可以重复调用自己。</p><p id="e311" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">递归的一个简单示例如下所示:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/a6da320624efbe5e5b72213bcadf0984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*syZ6zqab4xqk8mIg.png"/></div></div></figure><p id="5530" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">必须提到递归函数的返回类型。</p><h1 id="2471" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">单位类型</h1><p id="7276" class="pw-post-body-paragraph kj kk iq kl b km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf ki ij bi translated">最后，我将用不返回任何有意义的值的表达式类型来结束本文，即<code class="fe mo mp mq mr b">Unit</code>。它相当于其他语言中的<code class="fe mo mp mq mr b">void </code>函数。当函数不需要返回任何内容时使用它。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/6965ce8069d0c44562d82945d38fea29.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/0*2qO5XrXQR8QDMVuR.png"/></div></figure><p id="fafa" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">一个例子是返回<code class="fe mo mp mq mr b">Unit</code>的<code class="fe mo mp mq mr b">println()</code>函数。它是一个包含一个表示为<code class="fe mo mp mq mr b">()</code>的值的类型。</p><p id="66e6" class="pw-post-body-paragraph kj kk iq kl b km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf ki ij bi translated">返回<code class="fe mo mp mq mr b">Unit </code>的表达式被称为副作用，因为它们与计算有意义的值无关。在纯函数式编程中，我们倾向于将副作用降到最低。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="ab61" class="lg lh iq bd li lj ob ll lm ln oc lp lq lr od lt lu lv oe lx ly lz of mb mc md bi translated">类似文章-</h1><p id="08bd" class="pw-post-body-paragraph kj kk iq kl b km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf ki ij bi translated">你也可以查看我在<em class="og"> Scala初学者系列</em>上的其他文章</p><ul class=""><li id="39f6" class="nf ng iq kl b km mj kq mk ku nh ky ni lc nj ki nk nl nm nn bi translated"><a class="ae oh" rel="noopener ugc nofollow" target="_blank" href="/scala-beginner-series-2-object-oriented-scala-4e2496ec2e9f"> Scala初学者系列(2):面向对象的Scala </a></li><li id="8a82" class="nf ng iq kl b km no kq np ku nq ky nr lc ns ki nk nl nm nn bi translated"><a class="ae oh" rel="noopener ugc nofollow" target="_blank" href="/scala-beginner-series-3-functional-scala-eedd9090a3ac"> Scala初学者系列(三) :函数式Scala </a></li></ul></div></div>    
</body>
</html>