<html>
<head>
<title>Javascript Service Wrapper for Browsers and NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览器和节点的Javascript服务包装器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/collective-service-wrapper-for-browsers-and-nodejs-aac68251c583?source=collection_archive---------21-----------------------#2020-06-02">https://levelup.gitconnected.com/collective-service-wrapper-for-browsers-and-nodejs-aac68251c583?source=collection_archive---------21-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ac560cb8d328038af0f1cd7c5bfda596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sqVEFjVE6LV9HgaZ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@twinsfisch?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊莎贝拉和Zsa Fischer </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0a47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时，您需要从共享管道传递您的服务函数，并对所有这些函数调用一些操作。或者，您可能希望将所有服务添加到支持并行和挂起任务的队列中。</p><p id="783c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我上面提到的需求是常见的，尤其是当你使用一个http-请求客户端，比如<a class="ae kf" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>、<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> fetch </a>或<a class="ae kf" href="https://github.com/visionmedia/superagent" rel="noopener ugc nofollow" target="_blank"> superagent </a>。大量的抓取操作可能会同时发生，如果您想检查所有这些操作的共同情况，这可能会非常令人沮丧。</p><p id="a297" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这些情况下，可以使用<a class="ae kf" href="https://github.com/behnamazimi/js-service-wrapper" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> JS服务包装器</strong> </a>。一个基于承诺的服务包装器，支持队列，在浏览器和节点环境下工作。</p><h1 id="be1b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JS服务包装器的完整示例</h1><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9c87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将是上面示例的控制台结果:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="4752" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有三个包装的服务。它们中的每一个在队列中都有其唯一的id，但是ID是从队列中的实际位置索引开始的。正如您在上面看到的，所有的服务都依次添加到队列中。当添加第一个服务时，它会触发，因为它也是队列中的第一个。</p><p id="0144" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个服务将在第一个服务之后添加到队列中，但是它不是并行的，所以它必须等到轮到它。在第二个、第三个之后，唯一的并行服务应该添加到队列中。因为它是并行的，所以当它被添加到队列中时会立即触发。添加完所有服务后，第一个服务将被解析并从队列中删除，第二个挂起的服务将被触发。完成后，每个服务都将从队列中删除。</p><h1 id="236a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">入门指南</h1><p id="3dce" class="pw-post-body-paragraph kg kh it ki b kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">首先，您需要在项目中导入<code class="fe mn mo mp mq b">js-service-wrapper</code>。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5031" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mn mo mp mq b">ServiceWrapper</code>是我们效用的主要对象。你需要初始化它，在你的项目中初始化一次就足够了。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="b158" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您在<code class="fe mn mo mp mq b">ServiceWrapper</code>上设置的客户端是初始化中最重要的部分。在<code class="fe mn mo mp mq b">ClientHandler</code>里面会调用它，它会返回一个承诺。这里有一个包装的例子。这段代码将调用<code class="fe mn mo mp mq b">axios</code>作为客户端，因为我们在<code class="fe mn mo mp mq b">init</code>上发送它作为客户端值。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="84b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有机会在不同阶段中断上述正常流程。我们用钩子来做这个。让我们给服务包装器设置一些钩子。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="900e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个钩子将调用所有的包装器。第一个将得到结果并返回其<code class="fe mn mo mp mq b">data</code>属性，第二个只是在客户端承诺成功并记录后接收结果。</p><p id="c5c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有六个预定义的挂钩，您可以将它们设置到<code class="fe mn mo mp mq b">ServiceWrapper</code>或每个<code class="fe mn mo mp mq b">ClientHandler</code>上，以影响服务。</p><ol class=""><li id="41bd" class="mr ms it ki b kj kk kn ko kr mt kv mu kz mv ld mw mx my mz bi translated"><code class="fe mn mo mp mq b">HOOKS.BEFORE_FIRE</code>在客户端服务调用之前调用，但是这个钩子不是异步的，fire不会等待这个。</li><li id="e6de" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated"><code class="fe mn mo mp mq b">HOOKS.BEFORE_RESOLVE</code>当服务客户端承诺正在解析时调用，它返回的值将作为解析参数发送。</li><li id="0f21" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated"><code class="fe mn mo mp mq b">HOOKS.BEFORE_REJECT</code>当服务客户端promise拒绝时调用，其返回值将作为拒绝参数发送。</li><li id="cc1d" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated"><code class="fe mn mo mp mq b">HOOKS.AFTER_SUCCESS</code>正好在解析之前调用，这也不是异步的。</li><li id="3570" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated"><code class="fe mn mo mp mq b">HOOKS.AFTER_FAIL</code>正好在拒绝之前调用，这也不是异步的。</li><li id="83c4" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld mw mx my mz bi translated"><code class="fe mn mo mp mq b">HOOKS.UPDATE_REQUEST_CONFIG</code>使用这个钩子，你可以在触发之前更新请求配置。</li></ol><p id="548c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，您可以为每个<code class="fe mn mo mp mq b">ClientHandler</code>设置特殊的<code class="fe mn mo mp mq b">client</code>和<code class="fe mn mo mp mq b">hooks</code>:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="fb61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您在初始化时激活队列，那么您可以指定队列中每个服务的行为，并确定您的服务应该与其他服务并行还是挂起。为此，您应该将选项传递给<code class="fe mn mo mp mq b">fire</code>方法的<br/>，并将<code class="fe mn mo mp mq b">parallel</code>属性的值设置为<code class="fe mn mo mp mq b">true</code>或<code class="fe mn mo mp mq b">false</code>。下面是一个并行和待定服务定义的示例。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><h1 id="1cc0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">技巧</h1><ul class=""><li id="b104" class="mr ms it ki b kj mi kn mj kr nf kv ng kz nh ld ni mx my mz bi translated">要使用<code class="fe mn mo mp mq b">fetch</code>作为您的客户端函数，您需要像<code class="fe mn mo mp mq b">fetch.bind(window)</code>一样发送它的绑定版本。</li><li id="4713" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld ni mx my mz bi translated">您传递给<code class="fe mn mo mp mq b">fire</code>方法的<code class="fe mn mo mp mq b">fireOptions</code>可以作为第二个参数在钩子方法中访问。</li><li id="c857" class="mr ms it ki b kj na kn nb kr nc kv nd kz ne ld ni mx my mz bi translated">包装器本身是promise base，但是<code class="fe mn mo mp mq b">client</code>函数不一定是promise。</li></ul><h1 id="9103" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="889b" class="pw-post-body-paragraph kg kh it ki b kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">当您希望以一种通用的方式同时控制许多服务时，这个包装器会非常有用。我在之前的两个项目中使用了这种代码结构，并尽可能地让它动态化。您可以将它与许多著名的HTTP请求处理程序一起使用，也可以定义您的客户端。您可以根据需要启用或禁用队列。</p><p id="8b02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图书馆是新的，它可能没有涵盖所有的东西，或者可能有一些问题。评论你的想法并<a class="ae kf" href="https://github.com/behnamazimi/js-service-wrapper" rel="noopener ugc nofollow" target="_blank">为项目</a>做出贡献。我会很高兴的。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><div class="mc md me mf gt nq"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">编写面试问题</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">技术开发</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe jz nq"/></div></div></a></div></div></div>    
</body>
</html>