<html>
<head>
<title>Learning C++: Numerical Algorithms of the STL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL的数值算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-numerical-algorithms-of-the-stl-eaa687d98fd3?source=collection_archive---------9-----------------------#2020-05-08">https://levelup.gitconnected.com/learning-c-numerical-algorithms-of-the-stl-eaa687d98fd3?source=collection_archive---------9-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/38ad3372409576c52edc89e3926c1de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hhKipbqP7OOZgpzL"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">约翰·莫塞斯·鲍恩在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ead6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将讨论标准模板库(STL)中的数值算法。这些算法并没有取代<code class="fe le lf lg lh b">cmath</code>中的函数类型的数学库，而是提供了一套不同的算法来解决某些数值处理问题。</p><h1 id="1a97" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">累加函数</h1><p id="18cb" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">一旦开始编程的学生学会了如何在数组中存储一些数据，他们就会被要求编写一个程序来对数组的元素求和。下面是这样一个程序的例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ccae" class="mt lj it lh b gy mu mv l mw mx">int main () {<br/>  const int SZ = 5;<br/>  int numbers[SZ] = {2, 27, 12, 14, 1};<br/>  int sum = 0;<br/>  for (int i = 0;i &lt; SZ; i++) {<br/>    sum += numbers[i];<br/>  }<br/>  cout &lt;&lt; "The sum is: " &lt;&lt; sum &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="ad29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您应该知道，以这种方式编写循环是容易出错的，因为程序有可能超出数组的界限。这个程序的一个改进是使用一个range <code class="fe le lf lg lh b">for </code>循环并将数据放入一个向量中，就像这样:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8c89" class="mt lj it lh b gy mu mv l mw mx">int main () {<br/>  const int SZ = 5;<br/>  vector&lt;int&gt; numbers = {2, 27, 12, 14, 1};<br/>  int sum = 0;<br/>  for (const int number : numbers) {<br/>    sum += number;<br/>  }<br/>  cout &lt;&lt; "The sum is: " &lt;&lt; sum &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="46ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个改进，但是我们还可以做一个改进——完全去掉循环，使用<code class="fe le lf lg lh b">accumulate</code>函数。</p><p id="1f5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">accumulate</code>函数将一个容器起始范围和一个容器结束范围以及一个起始值作为参数，并且在其第一种形式下将产生指定范围内元素的总和。在第二种形式中，它将一个函数作为第四个参数，并使用该函数计算一个值。我将在下面演示这是如何工作的。</p><p id="4651" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是两种形式的<code class="fe le lf lg lh b">accumulate</code>的语法模板:</p><p id="af48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="my"> T accumulate(范围开始，范围结束，初始值)；<br/> T accumulate(范围开始，范围结束，初始值，二元函数)；</em></p><p id="5e48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回类型<em class="my"> T </em>意味着返回类型将在运行时根据函数调用中给出的模板参数决定。</p><p id="c332" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从一个使用加法的例子开始:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3930" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;random&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;ctime&gt;<br/>using namespace std;</span><span id="26b0" class="mt lj it lh b gy mz mv l mw mx">void buildVec(vector&lt;int&gt; &amp;vec) {<br/>  uniform_int_distribution&lt;int&gt; distro(1,20);<br/>  default_random_engine engine(time(0));<br/>  for (int i = 1; i &lt;= 10; i++) {<br/>    vec.push_back(distro(engine));<br/>  }<br/>}</span><span id="0e55" class="mt lj it lh b gy mz mv l mw mx">void printVec(vector&lt;int&gt; &amp;vec) {<br/>  for (const int n : vec) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>}</span><span id="a461" class="mt lj it lh b gy mz mv l mw mx">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  int sum = 0;<br/>  sum = accumulate(numbers.begin(), numbers.end(), 0);<br/>  cout &lt;&lt; "The sum is: " &lt;&lt; sum &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="827d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序运行一次的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8064" class="mt lj it lh b gy mu mv l mw mx">11 13 17 5 3 18 4 3 2 4</span><span id="8cd0" class="mt lj it lh b gy mz mv l mw mx">The sum is: 80</span></pre><p id="6880" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们计算一个向量的乘积。为此，我们将使用<code class="fe le lf lg lh b">multiplies&lt;int&gt;</code>函数对象来改变函数的默认行为:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7e9d" class="mt lj it lh b gy mu mv l mw mx">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  int product = 1;<br/>  product = accumulate(numbers.begin(), numbers.end(),<br/>                       product, multiplies&lt;int&gt;());<br/>  cout &lt;&lt; "The product is: " &lt;&lt; product &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="bdda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序运行一次的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e42f" class="mt lj it lh b gy mu mv l mw mx">11 3 11 10 5 7 14 4 7 2</span><span id="4d1e" class="mt lj it lh b gy mz mv l mw mx">The product is: 99607200</span></pre><p id="5722" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然您通常会将此函数用于数值计算，但是您也可以使用它来做类似字符串/字符连接这样的事情。这里有一个例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="19cd" class="mt lj it lh b gy mu mv l mw mx">int main () {<br/>  vector&lt;char&gt; letters = {'a','b','c','d','e'};<br/>  string s = "";<br/>  s = accumulate(letters.begin(), letters.end(), s);<br/>  cout &lt;&lt; "The first five letters are: " &lt;&lt; s &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="c354" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a1dc" class="mt lj it lh b gy mu mv l mw mx">The first five letters are: abcde</span></pre><p id="ca36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">accumulate</code>函数可以代替大多数执行数字计算的循环，比如容器上的加法或乘法，或者一些字符串/字符连接问题。然而，作为一名计算机编程教师，我仍然会教我的学生如何从索引<code class="fe le lf lg lh b">for</code>循环到范围<code class="fe le lf lg lh b">for </code>循环，因为我真的相信学生在学习一些函数式编程“魔法”之前需要理解编程的基本原则</p><h1 id="eb60" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">计算内积</h1><p id="580d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">计算一对向量的内积在物理、工程和其他领域都有用途。STL有两个功能，类似于计算内积的累加— <code class="fe le lf lg lh b">inner_product</code>。这两种形式都将一个容器的起始和结束范围、第二个容器的起始范围和起始值作为参数，并返回两个容器的内积。第二种形式允许用户提供二元函数来执行计算。</p><p id="acfd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">两个版本的inner_product函数的语法模板是:</p><p id="cbb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="my"> T inner_product(范围1-开始，范围1-结束，范围2-开始，开始值)；<br/> T inner_product(range1-start，range1-end，range2-start，starting-value，binary- <br/>函数)；</em></p><p id="62f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用第一版<code class="fe le lf lg lh b">inner_product</code>计算两个向量内积的例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9cec" class="mt lj it lh b gy mu mv l mw mx">int main () {<br/>  vector&lt;int&gt; one = {1,2,3};<br/>  vector&lt;int&gt; two = {4,5,6};<br/>  int inner = 0;<br/>  inner = inner_product(one.begin(), one.end(),<br/>                        two.begin(), inner);<br/>  cout &lt;&lt; "The inner product is: " &lt;&lt; inner &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="4189" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f106" class="mt lj it lh b gy mu mv l mw mx">The inner product is: 32</span></pre><p id="b950" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了演示inner_product的第二种形式，我调用了两个内置函数对象，<code class="fe le lf lg lh b">minus&lt;int&gt;</code>和<code class="fe le lf lg lh b">divides&lt;int&gt;</code>。程序如下:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9474" class="mt lj it lh b gy mu mv l mw mx">int main () {<br/>  vector&lt;int&gt; one = {1,2,3};<br/>  vector&lt;int&gt; two = {4,5,6};<br/>  int inner = 1;<br/>  inner = inner_product(one.begin(), one.end(), two.begin(),<br/>                        inner, minus&lt;int&gt;(), divides&lt;int&gt;());<br/>  cout &lt;&lt; "The inner product is: " &lt;&lt; inner &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="d630" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4c4f" class="mt lj it lh b gy mu mv l mw mx">The inner product is: 1</span></pre><h1 id="f818" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">计算部分和集</h1><p id="9f05" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">给定下面一组数据<em class="my"> {1，2，3，4，5} </em>，这个数据集的部分和集是<em class="my"> {1，3，6，10，15} </em>。STL有一个生成部分和集的函数— <code class="fe le lf lg lh b">partial_sum</code>。这个函数的返回值是一个输出迭代器，所以您将主要使用这个函数来显示部分和集。如果您不想使用默认的加法计算，还有第二种形式的函数，它将一个二元函数作为第四个参数。</p><p id="b02c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是partial_sum的两种形式的语法模板:</p><p id="bba7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="my">output-iterator partial _ sum(range-start，range-end，output-iterator)；<br/>output-iterator partial _ sum(range-start，range-end，output-iterator，binary- <br/>函数)；</em></p><p id="4859" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的程序生成我在本节开始时给出的部分和集:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2151" class="mt lj it lh b gy mu mv l mw mx">int main () {<br/>  vector&lt;int&gt; numbers = {1,2,3,4,5};<br/>  cout &lt;&lt; "The data set is: " &lt;&lt; endl;<br/>  for (const int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "The partial sum set is: " &lt;&lt; endl;<br/>  partial_sum(numbers.begin(), numbers.end(),<br/>              ostream_iterator&lt;int&gt;(cout, " "));<br/>  return 0;<br/>}</span></pre><p id="a0ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="943a" class="mt lj it lh b gy mu mv l mw mx">The data set is:<br/>1 2 3 4 5</span><span id="fd09" class="mt lj it lh b gy mz mv l mw mx">The partial sum set is:<br/>1 3 6 10 15</span></pre><p id="28a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想要生成部分乘积集，我们可以在函数调用中添加一个二元函数参数。这里有一个程序可以做到这一点:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="643a" class="mt lj it lh b gy mu mv l mw mx">int main () {<br/>  vector&lt;int&gt; numbers = {1,2,3,4,5};<br/>  cout &lt;&lt; "The data set is: " &lt;&lt; endl;<br/>  for (const int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "The partial product set is: " &lt;&lt; endl;<br/>  partial_sum(numbers.begin(), numbers.end(),<br/>              ostream_iterator&lt;int&gt;(cout, " "),<br/>              multiplies&lt;int&gt;());<br/>  return 0;<br/>}</span></pre><p id="7348" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b3d2" class="mt lj it lh b gy mu mv l mw mx">The data set is:<br/>1 2 3 4 5</span><span id="4463" class="mt lj it lh b gy mz mv l mw mx">The partial product set is:<br/>1 2 6 24 120</span></pre><p id="d31c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您没有注意到，当计算一个乘积时，数据集从1开始按顺序排列，计算集的最后一个元素是原始集的最后一个元素的计算阶乘。</p><h1 id="38ae" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">计算相邻差异</h1><p id="5c9e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">相邻差可以这样定义:</p><p id="2380" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果数据集是<em class="my"> a1，a2，a3，a4，a5，a6 </em>，那么相邻的差集<em class="my">是a1，a2-a1，a3–2，a4-a3，a6-a5 </em>。</p><p id="d37c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe le lf lg lh b">adjacent_difference</code>用于计算相邻差异。正如我们在partial_sum中看到的那样，该函数有两种形式，具有相同的参数和返回值。下面是两种形式的<code class="fe le lf lg lh b">adjacent_difference</code>的语法模板:</p><p id="7fd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="my">output-iterator adjacent _ difference(range-start，range-end，output-iterator)；<br/>output-iterator adjacent _ difference(range-start，range-end，output-iterator，<br/>binary-function)；</em></p><p id="29db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个程序演示了如何使用第一种形式的函数来查找一组数字的相邻差集:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a5a4" class="mt lj it lh b gy mu mv l mw mx">int main () {<br/>  vector&lt;int&gt; numbers = {1,2,3,4,5,6};<br/>  cout &lt;&lt; "The data set is: " &lt;&lt; endl;<br/>  for (const int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "The adjacent difference set is: " &lt;&lt; endl;<br/>  adjacent_difference(numbers.begin(), numbers.end(),<br/>                      ostream_iterator&lt;int&gt;(cout, " "));<br/>  return 0;<br/>}</span></pre><p id="a394" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4d43" class="mt lj it lh b gy mu mv l mw mx">The data set is:<br/>1 2 3 4 5 6</span><span id="f2cd" class="mt lj it lh b gy mz mv l mw mx">The adjacent difference set is:<br/>1 1 1 1 1 1</span></pre><p id="3258" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个程序演示了如果我们将默认的差计算改为加法会发生什么:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fe61" class="mt lj it lh b gy mu mv l mw mx">int main () {<br/>  vector&lt;int&gt; numbers = {1,2,3,4,5,6};<br/>  cout &lt;&lt; "The data set is: " &lt;&lt; endl;<br/>  for (const int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "The adjacent difference set is: " &lt;&lt; endl;<br/>  adjacent_difference(numbers.begin(), numbers.end(),<br/>                      ostream_iterator&lt;int&gt;(cout, " "),<br/>                      plus&lt;int&gt;());<br/>  return 0;<br/>}</span></pre><p id="ff3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="702b" class="mt lj it lh b gy mu mv l mw mx">The data set is:<br/>1 2 3 4 5 6</span><span id="9596" class="mt lj it lh b gy mz mv l mw mx">The adjacent difference set is:<br/>1 3 5 7 9 11</span></pre><p id="84de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">容器元素以同样的方式配对，但是执行的是加法而不是减法。</p><h1 id="ba81" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用数字算法</h1><p id="a39c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">诚然，我在本文中讨论的组中唯一可能经常使用的函数是accumulate。不过，这个函数应该取代所有使用索引for循环或范围for循环的次数，因为它通常比您自己编写的循环运行得更快，出错的机会也更少。</p><p id="8e3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>