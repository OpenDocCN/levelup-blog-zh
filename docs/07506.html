<html>
<head>
<title>Comparing Programming Language Efficiency in 4 Programming Languages: Timing Selection Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较4种编程语言的编程语言效率:时序选择排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/comparing-programming-language-efficiency-in-4-programming-languages-timing-selection-sort-29badc8a744f?source=collection_archive---------20-----------------------#2021-02-22">https://levelup.gitconnected.com/comparing-programming-language-efficiency-in-4-programming-languages-timing-selection-sort-29badc8a744f?source=collection_archive---------20-----------------------#2021-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7538d74d0ebb14d460b95cfc95caf366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A25jRA1MuZHFUhAd"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/@veri_ivanova?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Veri Ivanova </a>拍摄的照片</figcaption></figure><p id="1320" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">计算机科学家使用<a class="ae kf" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">大O符号</a>来确定有效的算法。在这篇文章中，我更感兴趣的是计算机编程语言如何执行简单的排序算法。我将通过使用系统时钟来测量使用选择排序对存储在一个数组中的一百万个随机生成的数字进行排序所花费的时间(以毫秒为单位),来进行这种比较。</p><p id="b82c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将在比较中使用的语言是C++、Java、JavaScript和Python。事不宜迟，我们开始吧。</p><h1 id="96b5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测试中使用的计算机</h1><p id="42cb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">以下是我的戴尔笔记本电脑的规格，这是我在这次性能测试中使用的计算机:</p><p id="a597" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">处理器:英特尔酷睿i5–8250 u CPU @ 1.60 GHz 1.80 GHz</p><p id="d642" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装的内存:8.00 GB (7.90 GB可用)</p><p id="ba6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">系统类型:64位操作系统，基于x64的处理器</p><h1 id="b3c7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">选择排序算法</h1><p id="f65c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Selection_sort" rel="noopener ugc nofollow" target="_blank">选择排序</a>是实现起来最简单的排序算法。当然，它不是最有效的算法，但我的目标是测量编程语言的效率，而不是算法的效率。与使用更有效的排序算法(如QuickSort)相比，使用次优算法会更突出编程语言的效率或低效率。</p><p id="245c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是选择排序算法的伪代码实现:</p><p id="37e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mh">设置n为数组大小。<br/> For i from 1 to n — 1: <br/>将最小值设置为I<br/>For j = I+1 to n:<br/>If array[j]&lt;array[minimum]:<br/>将最小值设置为j<br/>End If<br/>End For<br/>Swap(array[I]，array[minimum] <br/> End for </em></p><p id="3719" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们讨论一下如何测量时间，然后当我演示如何在每种语言中实现选择排序时，我将演示如何测量算法的运行时间。</p><h1 id="c24a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测量系统时间</h1><p id="3dfe" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">大多数编程语言都有捕捉系统日期和时间的功能。对于许多语言来说，同一个函数同时包含了两者。我将在这里提供两个例子:一个是有专门的库来记录时间的语言(C++)，另一个是有一个类来提供记录时间的方法(JavaScript)。</p><p id="1b98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript有一个处理时间的类——<code class="fe mi mj mk ml b">Date </code>类。这个类存储关于日期和时间的数据。在我的程序中，我将只使用这个类中的一个方法，即<code class="fe mi mj mk ml b">getMilliseconds </code>方法。下面是一个简短的程序，演示了我将如何用JavaScript测量系统时间:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="7b9d" class="mu lf it ml b gy mv mw l mx my">let numbers = [];<br/>const NUM_ELEMENTS = 1000;<br/>let start = new Date();<br/>for (let i = 1; i &lt;= NUM_ELEMENTS; i++) {<br/>  numbers.push(i);<br/>}<br/>let stop = new Date();<br/>let duration = stop.getMilliseconds() - start.getMilliseconds();<br/>print("Time in milliseconds for loop to run:",duration);</span></pre><p id="683f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="5f11" class="mu lf it ml b gy mv mw l mx my">Time in milliseconds for loop to run: 13</span></pre><p id="a877" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在C++中，<code class="fe mi mj mk ml b">chrono</code>库包含了我测量系统时间所需的函数。下面是一个演示如何使用这个库的程序:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="e9c2" class="mu lf it ml b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;chrono&gt;<br/>using namespace std;</span><span id="70d0" class="mu lf it ml b gy mz mw l mx my">int main()<br/>{<br/>  const int NUM_ELEMENTS = 1000;<br/>  int numbers[NUM_ELEMENTS];<br/>  auto start = chrono::system_clock::now();<br/>  for (int i = 1; i &lt;= NUM_ELEMENTS; i++) {<br/>    numbers[i-1] = i;<br/>  }<br/>  auto stop = chrono::system_clock::now();<br/>  auto lapsed_time =<br/>    chrono::duration_cast&lt;chrono::milliseconds&gt;<br/>                          (stop - start).count();<br/>  cout &lt;&lt;  "It took " &lt;&lt; lapsed_time<br/>       &lt;&lt;  " milliseconds to populate the array."  &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="7cbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="9c9f" class="mu lf it ml b gy mv mw l mx my">It took 0 milliseconds to populate the array.</span></pre><p id="aee4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每种语言都有自己捕捉系统时间的方式，所以我们将在本文中看到五种不同的方法。我在这里给出了两个例子，只是为了让你对如何在程序中捕获系统时间有一点感觉。</p><p id="8a45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这些预备知识，让我们开始在执行选择排序时对编程语言进行计时，看看哪种语言是最有效的。</p><h1 id="4170" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">C++中的选择排序</h1><p id="a1f2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">下面是我写的程序，用来测量C++中选择排序的性能:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="acae" class="mu lf it ml b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;chrono&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>using namespace std;</span><span id="dbc8" class="mu lf it ml b gy mz mw l mx my">void selectionSort(int arr[], int numElements) {<br/>  int minimum;<br/>  for (int i = 0; i &lt; numElements-1; i++) {<br/>    minimum = i;<br/>    for (int j = i+1; j &lt; numElements; j++) {<br/>      if (arr[j] &lt; arr[minimum]) {<br/>        minimum = j;<br/>      }<br/>    }<br/>    int temp = arr[i];<br/>    arr[i] = arr[minimum];<br/>    arr[minimum] = temp;<br/>  }<br/>}</span><span id="4c82" class="mu lf it ml b gy mz mw l mx my">void setArray(int arr[], int numElements) {<br/>  int randNum;<br/>  for (int i = 0; i &lt; numElements; i++) {<br/>    randNum = rand() % 1000000 + 1;<br/>    arr[i] = randNum;<br/>  }<br/>}</span><span id="09b7" class="mu lf it ml b gy mz mw l mx my">int main()<br/>{<br/>  srand(time(0));<br/>  const int NUMELEMENTS = 10000;<br/>  const int MID = NUMELEMENTS / 2;<br/>  const int END = NUMELEMENTS - 1;<br/>  int numbers[NUMELEMENTS];<br/>  setArray(numbers, NUMELEMENTS);<br/>  auto start = chrono::system_clock::now();<br/>  selectionSort(numbers, NUMELEMENTS);<br/>  auto stop = chrono::system_clock::now();<br/>  cout &lt;&lt; numbers[0] &lt;&lt; ", " &lt;&lt; numbers[MID]<br/>       &lt;&lt; ", " &lt;&lt; numbers[END] &lt;&lt; endl;<br/>  auto lapsed_time =<br/>    chrono::duration_cast&lt;chrono::milliseconds&gt;<br/>                        (stop – start).count();<br/>  cout &lt;&lt;  "It took " &lt;&lt; lapsed_time<br/>       &lt;&lt; " milliseconds to sort the array."  &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="b6b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了验证数组已经排序，我显示了第一个元素、位于数组中点的元素和位于数组末尾的元素。</p><p id="ddca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="dbf5" class="mu lf it ml b gy mv mw l mx my">1, 16568, 32765<br/>It took 122 milliseconds to sort the array.</span></pre><p id="6e3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看Java版本。</p><h1 id="c4ec" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Java中的选择排序性能</h1><p id="9ad1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">即使您以前从未用Java编程，按照我的Java程序测试选择排序算法的性能也不会有什么困难。程序如下:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="13a1" class="mu lf it ml b gy mv mw l mx my">import java.util.Random;</span><span id="e146" class="mu lf it ml b gy mz mw l mx my">public class SSort {<br/>  static void selectionSort(int[] arr) {<br/>    int minimum;<br/>    for (int i = 0; i &lt; arr.length-1; i++) {<br/>      minimum = i;<br/>      for (int j = i+1; j &lt; arr.length; j++) {<br/>        if (arr[j] &lt; arr[minimum]) {<br/>          minimum = j;<br/>        }<br/>      }<br/>      int temp = arr[i];<br/>      arr[i] = arr[minimum];<br/>      arr[minimum] = temp;<br/>    }<br/>  }</span><span id="28c5" class="mu lf it ml b gy mz mw l mx my">  static void buildArray(int[] arr) {<br/>    Random rand = new Random();<br/>    for (int i = 0; i &lt; arr.length; i++) {<br/>      arr[i] = rand.nextInt(1000000);<br/>    }<br/>  }</span><span id="e43b" class="mu lf it ml b gy mz mw l mx my">  public static void main(String args[]) {<br/>    final int NUM_ELEMENTS = 10000;<br/>    final int MID = NUM_ELEMENTS/2;<br/>    final int END = NUM_ELEMENTS-1;<br/>    Random rand = new Random();<br/>    int [] numbers = new int[NUM_ELEMENTS];<br/>    buildArray(numbers);<br/>    long start = System.currentTimeMillis();<br/>    selectionSort(numbers);<br/>    long stop = System.currentTimeMillis();<br/>    System.out.println(numbers[0] + "," +<br/>                       numbers[MID] + "," + numbers[END]);<br/>    System.out.println("It took " + (stop - start) +<br/>                       " milliseconds to sort the array.");<br/>  }<br/>}</span></pre><p id="de99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="f67d" class="mu lf it ml b gy mv mw l mx my">99,500997,999990<br/>It took 50 milliseconds to sort the array.</span></pre><p id="7af5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">C++版本用了122毫秒，所以与C++相比，Java并不像有些人说的那样低效。</p><p id="13df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们转到JavaScript版本的性能比较。</p><h1 id="18dd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JavaScript中的选择排序性能</h1><p id="6093" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript是我们测试的第一种解释语言。同样，您不需要了解JavaScript就能理解这段代码，因为JavaScript使用了大量C风格的语法。JavaScript中的数组是不同的，因为JavaScript是不编译的，我将使用push方法向数组添加数据，而不是索引。否则，我的JavaScript代码看起来很像前两个程序。</p><p id="6850" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是JavaScript代码:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="954f" class="mu lf it ml b gy mv mw l mx my">function buildArray(arr) {<br/>  for (let i = 1; i &lt;= 10000; i++) {<br/>    arr.push(Math.floor(Math.random() * Math.floor(1000000)));<br/>  }<br/>}</span><span id="41aa" class="mu lf it ml b gy mz mw l mx my">function selectionSort(arr) {<br/>  let minimum = 0;<br/>  for (let i = 0; i &lt; arr.length-1; i++) {<br/>    minimum = i;<br/>    for (let j = i+1; j &lt; arr.length; j++) {<br/>      if (arr[j] &lt; arr[minimum]) {<br/>        minimum = j;<br/>      }<br/>    }<br/>    let temp = arr[i];<br/>    arr[i] = arr[minimum];<br/>    arr[minimum] = temp;<br/>  }<br/>}</span><span id="7a90" class="mu lf it ml b gy mz mw l mx my">let numbers = [];<br/>const NUM_ELEMENTS = 10000;<br/>const MID = NUM_ELEMENTS/2;<br/>const END = NUM_ELEMENTS-1;<br/>buildArray(numbers);<br/>let start = new Date();<br/>selectionSort(numbers);<br/>let stop = new Date();<br/>let duration = stop.getMilliseconds() - start.getMilliseconds();<br/>print(numbers[0], numbers[MID], numbers[END]);<br/>print("It took",duration,"milliseconds to sort the array.");</span></pre><p id="6933" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="eb79" class="mu lf it ml b gy mv mw l mx my">179 508179 999945<br/>It took 83 milliseconds to sort the array.</span></pre><p id="8d66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序比我的Java程序需要更长的时间来对数组进行排序，但是时间仍然比我的C++版本少40毫秒。</p><p id="1a5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们转到Python版本。</p><h1 id="6316" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Python中的选择排序性能</h1><p id="e585" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">和JavaScript一样，Python和其他语言的主要区别是用于存储数字的数据结构。Python没有数组，但是它有列表，可以以同样的方式使用。Python生成随机数的方式也有所不同，但并没有大到让代码看起来令人困惑的程度。</p><p id="f459" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我的Python选择排序程序的代码:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="33ae" class="mu lf it ml b gy mv mw l mx my">from random import seed<br/>from random import randint<br/>from time import time</span><span id="11ea" class="mu lf it ml b gy mz mw l mx my">def selectionSort(nums):<br/>  for i in range(0, len(nums)-1):<br/>    minimum = i<br/>    for j in range(i+1, len(nums)):<br/>      if (nums[j] &lt; nums[minimum]):<br/>        minimum = j<br/>    temp = nums[i]<br/>    nums[i] = nums[minimum]<br/>    nums[minimum] = temp</span><span id="f666" class="mu lf it ml b gy mz mw l mx my">def buildList(nums):<br/>  seed(1)<br/>  for i in range(1,10000):<br/>    nums.append(randint(1,1000000))<br/>  <br/>numbers = []<br/>mid = 5000<br/>end = 9999<br/>buildList(numbers)<br/>start = int(time() * 1000)<br/>selectionSort(numbers)<br/>stop = int(time() * 1000)<br/>duration = stop-start<br/>print(numbers[0], numbers[mid], numbers[len(numbers)-1])<br/>print("It took", duration, "milliseconds to sort the list.")</span></pre><p id="49eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序运行一次的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="627b" class="mu lf it ml b gy mv mw l mx my">233 498036 999720<br/>It took 2755 milliseconds to sort the list.</span></pre><h1 id="9647" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">绩效结论</h1><p id="393e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">以下是每种语言使用选择排序算法对10000个随机生成的数字进行排序所用的时间，从最快到最慢排列:</p><p id="6931" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java: 50毫秒</p><p id="7f74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript: 83毫秒</p><p id="1eb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">C++: 122毫秒</p><p id="75d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python: 2755毫秒</p><h1 id="4e0d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">讨论</h1><p id="c316" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我有点惊讶于Java比C++快，但我更惊讶于JavaScript比C++快。看到这个结论，我决定研究一下C++性能差是否是由于我使用的编译器(Code::Blocks)造成的。</p><p id="1a81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了测试这一点，我将程序转移到我的Linux系统上，并使用我的Linux发行版中的gcc编译器运行它。我收到的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="2179" class="mu lf it ml b gy mv mw l mx my">114, 490695, 999987<br/>It took 118 milliseconds to sort the array.</span></pre><p id="df04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，改变编程环境并不能提高选择排序的C++性能。</p><p id="23a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我计划进一步调查这些不同语言之间的性能差异，并将我的发现写下来。我的下一个研究将是字符串处理。</p><p id="79f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请回复这篇文章或发邮件给我，告诉我您的意见和建议。</p></div></div>    
</body>
</html>