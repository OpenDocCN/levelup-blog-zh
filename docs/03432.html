<html>
<head>
<title>Learn Programming with Python — Introduction to Compound Data Types: Dictionaries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Python编程——复合数据类型简介:字典</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-programming-with-python-introduction-to-compound-data-types-dictionaries-f9372369e37e?source=collection_archive---------6-----------------------#2020-05-08">https://levelup.gitconnected.com/learn-programming-with-python-introduction-to-compound-data-types-dictionaries-f9372369e37e?source=collection_archive---------6-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/767d6be32f3a392e1cf8dbb9fe4e729f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zvlLebyUS6x5aIP2LPdkgg.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图片来源于@ pix abay<a class="ae jg" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/@pixabay</a></figcaption></figure><div class=""/><p id="cda8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字典是一种非常通用的复合数据类型，允许我们创建键和值之间的映射。字典很有趣！</p><h2 id="0dcd" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">键值对入门。</h2><p id="16fe" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">字典对一系列的键值对进行操作，所以让我们先稍微转移一下注意力，看看键值对。几乎所有的书都可以通过ISBN号来识别。ISBN号是一本书的标识符，它是<em class="mc">键</em>。还有其他方法来识别一本书，但很少有像ISBN号这样普遍有用的。以下是一些畅销书的键值对、ISBN号和书名列表:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="d3e8" class="le lf jj mi b gy mm mn l mo mp">+------------+-------------------------------------------+<br/>| 1510752242 | Restoring Faith in the Promise of Science |<br/>+------------+-------------------------------------------+<br/>| 031670704X | Midnight Sun                              |<br/>+------------+-------------------------------------------+<br/>| 1524763136 | Becoming                                  |<br/>+------------+-------------------------------------------+<br/>| 0735219095 | Where the Crawdads Sing                   |<br/>+------------+-------------------------------------------+<br/>| 1338635174 | The Ballad of Songbirds and Snakes        |<br/>+------------+-------------------------------------------+</span></pre><p id="d1ad" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用Python语言，用这样的<code class="fe mq mr ms mi b">dict</code>来表示第一本书:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8667" class="le lf jj mi b gy mm mn l mo mp">books: dict = {'031670704X': 'Midnight Sun'} #1 key-value pair</span></pre><p id="e6aa" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里首先要注意的是，我们创建了一个带有花括号<code class="fe mq mr ms mi b"> {}</code>的<code class="fe mq mr ms mi b">dict</code>，指定了一个逗号分隔的键值对序列。否则，分配单个值会使用花括号<code class="fe mq mr ms mi b">{}</code>创建一个<code class="fe mq mr ms mi b">set</code>。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0157" class="le lf jj mi b gy mm mn l mo mp">books: set = {'031670704X', 'Midnight Sun'} #two elements </span></pre><p id="085a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Python，让我们创建具有5个键值对的<code class="fe mq mr ms mi b">dict</code>数据类型:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="52e9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的代码编辑器中执行时，我看到的是:</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mv"><img src="../Images/3d1a148b31f094fef35f540ddc437e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxODzJ0SDRAyFq62DZEJSA.png"/></div></div></figure><p id="416c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是怎么回事？</p><ul class=""><li id="7c83" class="mw mx jj ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated">在第6行，我定义了一个名为<code class="fe mq mr ms mi b">Book</code>的新<code class="fe mq mr ms mi b">namedtuple</code>，它有两个命名属性<code class="fe mq mr ms mi b">isbn</code>和<code class="fe mq mr ms mi b">title</code>。</li><li id="f34f" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第10行，我给变量<code class="fe mq mr ms mi b">books_as_list</code>添加了一个新的<code class="fe mq mr ms mi b">Book</code>对象。对于剩余的4本书，这一直持续到第24行。</li><li id="5de3" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第26行，我使用了一个for循环来迭代<code class="fe mq mr ms mi b">books_as_list</code>序列中的所有元素。</li><li id="1969" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第27行，我使用了<em class="mc">多重赋值</em>的构造，在一次操作中给两个变量赋值:<code class="fe mq mr ms mi b">key, value = book.isbn, book.title</code>。</li><li id="ea9b" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第28行，我在字典中创建了一个新元素<code class="fe mq mr ms mi b">books_as_dict</code>。我将新元素的键指定为等于<code class="fe mq mr ms mi b">key</code>变量，对于<code class="fe mq mr ms mi b">value</code>也是如此。</li><li id="6800" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">查看终端窗口中的输出，您可以看到我们有两个单独的序列:有一个包含5个元素的列表，每个元素是一个<code class="fe mq mr ms mi b">Book</code> <code class="fe mq mr ms mi b">namedtuple</code>。还有一个包含5个键值对的字典。</li></ul><h2 id="6651" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">在字典中使用复数值</h2><p id="7b18" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在上面的书籍例子中，我们保持一切都非常简单。我们只有5本书的两个数据元素，每个都表示为一个简单的数据类型。如果我们需要用一个键存储多个值属性，我们该怎么办？这种例子:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c1a3" class="le lf jj mi b gy mm mn l mo mp">+------------+------------------------------------+----------------+<br/>| 1510752242 | Restoring Faith in ... Science     | K Heckenlively |<br/>+------------+------------------------------------+----------------+<br/>| 031670704X | Midnight Sun                       | S Meyer        |<br/>+------------+------------------------------------+----------------+<br/>| 1524763136 | Becoming                           | M Obama        |<br/>+------------+------------------------------------+----------------+<br/>| 0735219095 | Where the Crawdads Sing            | S Owens        |<br/>+------------+------------------------------------+----------------+<br/>| 1338635174 | The Ballad of Songbirds and Snakes | S Collins      |<br/>+------------+------------------------------------+----------------+</span></pre><p id="d3b9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有几个选择。最简单的方法是将标题和作者作为一个元组存储在每个键-值对的值部分中。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a8ea" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这为我们提供了以下终端输出:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3499" class="le lf jj mi b gy mm mn l mo mp">Dict of books: {'1510752242': ('Restoring Faith in ... of Science', 'K Heckenlively'), '031670704X': ('Midnight Sun', 'S Meyer'), '1524763136': ('Becoming', 'M Obama'), '0735219095': ('Where the Crawdads Sing', ' S Owens'), '1338635174': ('The Ballad of Songbirds and Snakes', 'S Collins')}</span></pre><p id="d936" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以做以下事情:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2ec1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这为我们提供了以下终端输出:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="00b5" class="le lf jj mi b gy mm mn l mo mp">Dict of books: {'1510752242': {'title': 'Restoring Faith in ... of Science', 'author': 'K Heckenlively'}, '031670704X': {'title': 'Midnight Sun', 'author': 'S Meyer'}, '1524763136': {'title': 'Becoming', 'author': 'M Obama'}, '0735219095': {'title': 'Where the Crawdads Sing', 'author': ' S Owens'}, '1338635174': {'title': 'The Ballad of Songbirds and Snakes', 'author': 'S Collins'}}</span></pre><p id="ebb0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这看起来非常非常类似于一个<a class="ae jg" href="https://www.json.org/" rel="noopener ugc nofollow" target="_blank"> JSON </a>格式的文本文件，除了引号是单引号，而不是双引号。在Python中打印一个<code class="fe mq mr ms mi b">dict</code>首先将元素转换成适合打印的<code class="fe mq mr ms mi b">str</code>对象，这里我们得到单引号。要从字典中获取有效的JSON字符串，我们可以轻松地<code class="fe mq mr ms mi b">import</code> <code class="fe mq mr ms mi b">json</code>，然后运行它的内置方法<code class="fe mq mr ms mi b">dumps() </code>来转储字符串。</p><p id="a60d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个版本的程序就是这样做的:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b448" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的终端中，我收到有效的JSON文本:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="ee08" class="le lf jj mi b gy mm mn l mo mp">{<br/> "1510752242": {<br/>  "title": "Restoring Faith in ... of Science",<br/>  "author": "K Heckenlively"<br/> },<br/> "031670704X": {<br/>  "title": "Midnight Sun",<br/>  "author": "S Meyer"<br/> },<br/> "1524763136": {<br/>  "title": "Becoming",<br/>  "author": "M Obama"<br/> },<br/> "0735219095": {<br/>  "title": "Where the Crawdads Sing",<br/>  "author": " S Owens"<br/> },<br/> "1338635174": {<br/>  "title": "The Ballad of Songbirds and Snakes",<br/>  "author": "S Collins"<br/> }<br/>}</span></pre><p id="934b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们存储一个字典作为值部分时，我们最终得到一个<em class="mc">嵌套字典结构</em>。这可以是我们想要的深度，并允许我们存储复杂的数据结构，如<code class="fe mq mr ms mi b">networks</code>和<code class="fe mq mr ms mi b">trees</code>。</p><h2 id="5d12" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">一起使用字典、集合和列表</h2><p id="7461" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在前一部分中，我们讨论了集合，使用了下面的“水果”示例:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9a97" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们为什么不把水果改写成字典呢？:)这将具有挑战性——有些水果既是<code class="fe mq mr ms mi b">citrusfruit</code>又是<code class="fe mq mr ms mi b">treefruit</code>，或者是<code class="fe mq mr ms mi b">treefruit</code>又是<code class="fe mq mr ms mi b">stonefruit</code>。但是我们希望我们的字典按照水果的名称进行索引，然后它的值向我们显示它属于哪些不同种类的水果，对吗？水果就是水果，什么类型的水果应该是次要的。</p><p id="42d0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下似乎是存储此信息的合理方式:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="46c3" class="le lf jj mi b gy mm mn l mo mp">'lemons': ['treefruit', 'citrusfruit']</span></pre><p id="78ad" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个键-值映射中，水果的名称被用作键，类别列表是值。字典的关键字不能包含重复项。就像一本真正的单词词典一样，每个键只出现一次，但可能有几种不同的含义。下面的代码显示，如果多次将键添加到字典中，这些键将被覆盖。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/915e7d8b62adaef3794362034e382de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fl_9M8Jwin3KBNt4Jo_6OQ.png"/></div></div></figure><p id="1165" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到只存在一个“oranges”条目，并且“treefruit”值被覆盖。以下程序完成了练习:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6e26" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我运行它时，我在代码编辑器中看到以下内容:</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/d5a401eb07f5aa7835a23762cac82b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GaIbfCXDolxyCamiMgDyzQ.png"/></div></div></figure><p id="7130" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是怎么回事？</p><ul class=""><li id="8aae" class="mw mx jj ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated">在第1行，我创建了一个名为<code class="fe mq mr ms mi b">fruits_dict</code>的空字典</li><li id="410d" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第3-6行，我们重复了我们在本系列的前一部分中看到的关于集合的内容。</li><li id="4431" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第8行，我遍历了所有三组水果的超集。</li><li id="c8c9" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第9行，我将每个<code class="fe mq mr ms mi b">fruit</code>添加为<code class="fe mq mr ms mi b">fruits_dict</code>中的键，并将默认值设置为空列表<code class="fe mq mr ms mi b">[]</code>。</li><li id="796d" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第11行，我使用内置方法<code class="fe mq mr ms mi b">items()</code>遍历<code class="fe mq mr ms mi b">fruits_dict</code>中的键值对，返回一个<code class="fe mq mr ms mi b">tuple</code>。元组的第一个元素分配给名为<code class="fe mq mr ms mi b">key</code>的变量，第二个元素分配给名为<code class="fe mq mr ms mi b">value</code>的变量。</li><li id="9393" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第12、14和16行，使用<code class="fe mq mr ms mi b">in</code>，我测试了三个集合中每个集合的水果成员。</li><li id="b8c2" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">如果集合中存在<code class="fe mq mr ms mi b">fruit</code>，在第13、15和17行，我将添加适当的文本作为值<code class="fe mq mr ms mi b">list</code>中的条目。</li></ul><p id="624f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以从终端输出中看到，我的程序已经正确地将三个集合转换成一个字典。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="4b7d" class="le lf jj mi b gy mm mn l mo mp">{'nectarines': ['citrusfruit', 'stonefruit'], 'cherries': ['treefruit', 'stonefruit'], 'pears': ['treefruit'], 'limes': ['citrusfruit', 'treefruit'], 'plums': ['treefruit', 'stonefruit'], 'peaches': ['treefruit', 'stonefruit'], 'satsumas': ['citrusfruit'], 'apples': ['treefruit'], 'lemons': ['citrusfruit', 'treefruit'], 'oranges': ['citrusfruit', 'treefruit']}</span></pre><p id="1005" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只是为了好玩，你会怎么逆转这个过程？如果你有以前的字典，想创建一个<code class="fe mq mr ms mi b">citrusfruit</code>的<code class="fe mq mr ms mi b">set</code>，你会怎么做？</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e225" class="le lf jj mi b gy mm mn l mo mp">citrusfruit: set = {key for key, value in fruits_dict.items() if "citrusfruit" in value}</span></pre><p id="c7d2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然是用<em class="mc">设定领悟</em>！在本系列的上一篇文章列表中，我们看到了这个结构的使用，并在<em class="mc">列表理解</em>中解释了它。</p><h2 id="790d" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">可变性和字典键</h2><p id="f7ca" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Python的字典数据类型非常非常快。不管字典有多大，从字典中检索一个条目仍然非常快。这令人印象深刻，但真正理解这是如何实现的是有用的。</p><p id="9221" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并非每种Python数据类型都可以用作字典中的键。可以用<code class="fe mq mr ms mi b">str</code>，不能用<code class="fe mq mr ms mi b">list</code>。可以用<code class="fe mq mr ms mi b">int</code>，不能用<code class="fe mq mr ms mi b">set</code>。为什么？密钥必须是不可变的。如果可以改变一个键的值，字典将不能预先计算出这个键在计算机内存中的位置。这是使用哈希表完成的，这意味着键的对象有一个哈希表。一个对象的散列在它的生命周期中从不改变。不可变的数据类型如<code class="fe mq mr ms mi b">int</code>和<code class="fe mq mr ms mi b">str</code>是<em class="mc">可散列的</em>。诸如<code class="fe mq mr ms mi b">list</code>、<code class="fe mq mr ms mi b">dict</code>和<code class="fe mq mr ms mi b">set</code>这样的可变数据类型是不可散列的。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1cf5" class="le lf jj mi b gy mm mn l mo mp">&gt;&gt;&gt; dict1: dict = {<strong class="mi jk">{1,2}</strong>, "value"}<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: <strong class="mi jk">unhashable type: 'set'</strong></span><span id="a463" class="le lf jj mi b gy nm mn l mo mp">&gt;&gt;&gt; dict1: dict = { <strong class="mi jk">{"key":"value"}</strong> , "value"}<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: <strong class="mi jk">unhashable type: 'dict'</strong></span><span id="a422" class="le lf jj mi b gy nm mn l mo mp">&gt;&gt;&gt; dict1: dict = { <strong class="mi jk">[1,2]</strong> , "value"}<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: <strong class="mi jk">unhashable type: 'list'</strong></span></pre><p id="0d4b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有趣的是，<em class="mc">可以使用特殊对象<code class="fe mq mr ms mi b">None</code>作为字典的键，但是请不要在工作中尝试这样做！</em></p><h2 id="1710" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">专业字典数据类型:有序字典</h2><p id="0eda" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated"><code class="fe mq mr ms mi b">list</code>保留它的顺序，但是<code class="fe mq mr ms mi b">dict</code>复合数据类型不能保证保留它的顺序。如果你的代码在低于3.6 的版本<a class="ae jg" href="https://morepypy.blogspot.com/2015/01/faster-more-memory-efficient-and-more.html" rel="noopener ugc nofollow" target="_blank">中被Python执行，那么<code class="fe mq mr ms mi b">dict</code>将会是无序的。总是假设你的字典是无序的。<code class="fe mq mr ms mi b">dict</code>的作者包括注:</a></p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="9476" class="le lf jj mi b gy mm mn l mo mp">Obviously, we recommend that any portable Python program continues to use OrderedDict when ordering is important.</span></pre><p id="57db" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们的使用与常规<code class="fe mq mr ms mi b">dict</code>物品完全一样:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f5d2" class="le lf jj mi b gy mm mn l mo mp">import collections as c</span><span id="b01c" class="le lf jj mi b gy nm mn l mo mp">ordered_dict: c.OrderedDict = c.OrderedDict({'banana': 3, 'apple': 4, 'pear': 1, 'orange': 12})</span></pre><h2 id="65e2" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">词典释义</h2><p id="75da" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">列出理解，设置理解，现在:字典理解！Python为我们提供的非常方便的东西的完整三重奏！</p><p id="f012" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从一个简单的练习开始:制作一个包含所有大写字母及其ASCII代码的字典。我们走吧！</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f26b" class="le lf jj mi b gy mm mn l mo mp">&gt;&gt;&gt; {i : chr(+i) for i in range(65, 91, 1)}</span></pre><ul class=""><li id="6072" class="mw mx jj ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated">这是一种字典理解，因为我们使用了花括号<code class="fe mq mr ms mi b">{}</code> <strong class="ki jk">和</strong>返回的值是由冒号<code class="fe mq mr ms mi b">:</code> <strong class="ki jk">分隔的键值对，并且</strong>里面有一个<code class="fe mq mr ms mi b">for</code>循环。</li><li id="9477" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">我们正在对<code class="fe mq mr ms mi b">in</code>值:<code class="fe mq mr ms mi b">range(65, 91, 1)</code>进行循环。这是一个从65到91的列表，增量为1。</li><li id="471a" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">每个循环中的值被分配给<code class="fe mq mr ms mi b">i</code>，并由<code class="fe mq mr ms mi b">range()</code>给出</li><li id="36e4" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">被返回的密钥是<code class="fe mq mr ms mi b">i</code></li><li id="9b23" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">返回的值是<code class="fe mq mr ms mi b">chr(i)</code>，这是一个内置函数，用于返回<a class="ae jg" href="https://www.asciitable.com/" rel="noopener ugc nofollow" target="_blank"> ASCII字符表</a>中该索引处的字符。</li></ul><p id="4029" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到的输出和预期的一样，是一个键值对字典:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="b551" class="le lf jj mi b gy mm mn l mo mp">{65: 'A', 66: 'B', 67: 'C', 68: 'D', 69: 'E', 70: 'F', 71: 'G', 72: 'H', 73: 'I', 74: 'J', 75: 'K', 76: 'L', 77: 'M', 78: 'N', 79: 'O', 80: 'P', 81: 'Q', 82: 'R', 83: 'S', 84: 'T', 85: 'U', 86: 'V', 87: 'W', 88: 'X', 89: 'Y', 90: 'Z'}</span></pre><p id="994b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以做各种非常奇特的字典理解！就像从两个长度相等的列表中创建一个字典:</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5081" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的代码编辑器中，我得到了这个:</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/847e0ca6f8f10f3be519ed2e56b21362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvRhhjzdmDgI_hwpsgMGBw.png"/></div></div></figure><p id="832c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是怎么回事？</p><ul class=""><li id="41ce" class="mw mx jj ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated">第1–3行和第7–9行是文档字符串。这是在Python中记录模块(文件)和函数的方式。</li><li id="9c3b" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第4行，我正在导入输入模块。接下来这很有用:</li><li id="41e5" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第6行，我定义了一个函数的签名。它取名:<code class="fe mq mr ms mi b">dict_from_list</code>。它接受的第一个参数名为<code class="fe mq mr ms mi b">keys</code>，这必须是一个可散列对象的<code class="fe mq mr ms mi b">list</code>。记住，字典键必须是可哈希的。第二个参数是一只名为<code class="fe mq mr ms mi b">values</code>的<code class="fe mq mr ms mi b">list</code>。该函数返回一个<code class="fe mq mr ms mi b">dict</code>数据类型。</li><li id="4184" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第10行，我进行了测试，以确保键和值的长度相同。</li><li id="75a3" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第11行，如果长度不同，我是<em class="mc">举</em>，或者<em class="mc">抛</em>，一个<code class="fe mq mr ms mi b">ValueError</code>类型的<code class="fe mq mr ms mi b">exception</code>。</li><li id="446d" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在第13行，我调用内置的dict()函数，并传入zip()操作的结果。<a class="ae jg" href="https://docs.python.org/3.3/library/functions.html#zip" rel="noopener ugc nofollow" target="_blank"> Zip </a>接受两个序列并返回一个元组列表。</li></ul><p id="ecc2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以从我的终端的输出中看到，这两个列表，一个包含国家的名称，另一个包含它们的百万人口，现在是字典数据类型。</p><h2 id="03e4" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">我们取得了什么成就？</h2><p id="6399" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">几乎多到无法列举！</p><ul class=""><li id="688a" class="mw mx jj ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated">zip()、range()内置函数</li><li id="0e27" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">在运行时引发以生成ValueError异常</li><li id="c3f7" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">从集合和列表中以编程方式构建字典</li><li id="0d4c" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><em class="mc">的概念有可变的</em>和可变的<em class="mc"/></li><li id="b4eb" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">创建字典理解</li><li id="aaed" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">使用<code class="fe mq mr ms mi b">items()</code>从字典中获取键值对</li></ul><p id="280c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一期文章中，我们将继续使用Python与外部数据进行交互。</p><h1 id="fc6f" class="no lf jj bd lg np nq nr lj ns nt nu lm nv nw nx lp ny nz oa ls ob oc od lv oe bi translated">到目前为止，本系列中的文章:</h1><ul class=""><li id="5702" class="mw mx jj ki b kj lx kn ly kr of kv og kz oh ld nb nc nd ne bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-an-introduction-ee9115d52dbd" rel="noopener">学习Python编程—简介</a></li><li id="20f1" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-introduction-to-functions-1a7213eda13d" rel="noopener">学习Python编程—函数介绍</a></li><li id="2af8" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-controlling-execution-flow-3755d8421d8" rel="noopener">学习Python编程——控制执行流程</a></li><li id="ad57" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-introduction-to-data-types-strings-c5c1f6295940" rel="noopener">学习Python编程—数据类型简介:字符串</a></li><li id="7e27" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-introduction-to-data-types-numbers-b777b100fd3" rel="noopener">学习Python编程—数据类型简介:数字</a></li><li id="fcd9" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-introduction-to-compound-data-types-sets-and-tuples-ac7466881bd5" rel="noopener">学习Python编程—复合数据类型简介:集合和元组</a></li><li id="afae" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><a class="ae jg" href="https://medium.com/@quinn.richard/learn-programming-with-python-introduction-to-compound-data-types-lists-57b50e2633c6" rel="noopener">学习Python编程—复合数据类型简介:列表</a></li><li id="3a0e" class="mw mx jj ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/learn-programming-with-python-introduction-to-compound-data-types-dictionaries-f9372369e37e">学习Python编程—复合数据类型简介:字典</a></li></ul></div></div>    
</body>
</html>