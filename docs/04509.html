<html>
<head>
<title>Introduction to React Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React上下文简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-react-context-f3009e98f34e?source=collection_archive---------35-----------------------#2020-06-29">https://levelup.gitconnected.com/introduction-to-react-context-f3009e98f34e?source=collection_archive---------35-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/da7152bd7bb2b036200c59bbbfb537b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQMe_9djpfjzMptCfYRYww.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@federize" rel="noopener ugc nofollow" target="_blank">费德里科·贝卡里</a>拍摄</figcaption></figure><p id="19df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本帖中，我们将讨论React 16中引入的<code class="fe le lf lg lh b">Context</code> API，以及如何使用它们。</p><h1 id="f4d7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是语境？</h1><p id="861d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">查看来自<a class="ae kf" href="https://reactjs.org/docs/context.html#reactcreatecontext" rel="noopener ugc nofollow" target="_blank"> react docs </a>的定义，它将它描述为一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性。</p><p id="cbaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，上下文是react应用程序的通用数据(或者根据redux定义，是react应用程序的集中存储)。您在上下文中设置的状态在react树中的任何地方都可以访问。</p><h1 id="839f" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么时候应该使用上下文？</h1><p id="0776" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">上下文的思想是解决属性钻取的问题，避免在组件树中的许多组件中传递属性，因为最底层的子组件需要一些中间组件没有使用的数据。</p><p id="5cc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我看来，如果你对不得不在组件树中传递超过3层的属性而感到烦恼，并且最终有太多的属性没有被中间的组件使用，那么就应该使用上下文。因此，这是上下文通过在消费者中提供状态而发挥最大作用的地方。</p><p id="ec20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在调试应用程序时，这可能会有一些影响，因为不像props那样，您知道数据来自哪里以及它是如何被更改的，您不会从上下文中一眼看出这一点，因为您是从组件中获取显式性的。</p><p id="ca70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过一个例子来看看上下文是如何工作的。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b81a" class="li lj it bd lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf bi translated">应用程序接口</h1><h1 id="9dec" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">React.createContext上下文</h1><p id="c900" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">首先，我们创建一个新的上下文对象来描述数据的外观(我们也可以在状态中存储函数)。<br/>无论我们在上下文对象中放入什么，都是我们想要在消费者组件中使用的</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="b8ab" class="nf lj it lh b gy ng nh l ni nj">//NameContext.js<br/>import React from 'react';</span><span id="7ec5" class="nf lj it lh b gy nk nh l ni nj">const NameContext = React.createContext({<br/>  name: '',<br/>  handleNameChange() {},<br/>});</span><span id="8ad2" class="nf lj it lh b gy nk nh l ni nj">export const Provider = NameContext.Provider;<br/>export const Consumer = NameContext.Consumer;</span></pre><p id="9a97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">createContext</code>将为我们提供两个组件<code class="fe le lf lg lh b">Provider</code>和<code class="fe le lf lg lh b">Consumer</code>，我们可以在我们的应用程序中使用它们。</p><h1 id="e426" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">语境。供应者</h1><p id="b3db" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在我们创建了上下文之后，我们就可以使用提供者了，但是在此之前，我们先来看看什么是提供者和消费者组件，以及它们是如何与上下文一起工作的。</p><p id="129a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想象一下，你如何使用火车从A点通勤到B点，你去车站入口并在通过大门(提供商)时提供车票(上下文)以便登上火车。一旦你到达目的地，你把你的票(上下文)交给出口(消费者)去消费。</p><p id="d644" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，我们包装了提供者组件，并将上下文作为值prop传递给我们希望使用消费者组件来消费上下文的区域</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="c46f" class="nf lj it lh b gy ng nh l ni nj">//App.js<br/>import React from 'react';<br/>import { render } from 'react-dom';<br/>import { Provider } from './NameContext';<br/>import Child from './Child';</span><span id="4e63" class="nf lj it lh b gy nk nh l ni nj">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.handleNamechange = this.handleNamechange.bind(this);<br/>    this.state = {<br/>      name: 'Malik',<br/>      handleNameChange: this.handleNamechange,<br/>    };<br/>  }<br/>  handleNamechange(event) {<br/>    let nameValue = event.target.value;<br/>    this.setState(function() {<br/>      return {<br/>        name: nameValue,<br/>      };<br/>    });<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;Provider value={this.state}&gt;<br/>        &lt;h1&gt;Hello&lt;/h1&gt;<br/>        &lt;Child /&gt;<br/>      &lt;/Provider&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="c4cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意我们是如何将从NameContext导入的<code class="fe le lf lg lh b">Provider component</code>包装在<code class="fe le lf lg lh b">Child component</code>周围，并使用应用程序状态作为其值传递给<code class="fe le lf lg lh b">value prop</code>，这样Provider中的任何内容都可以使用<code class="fe le lf lg lh b">Consumer component</code>访问上下文。</p><h1 id="8860" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">语境。消费者</h1><p id="2446" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在我们将Provider组件包装在我们想要使用上下文的应用程序部分之后。消费者组件将使用功能组件订阅上下文更改。</p><p id="498c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，为了使用上下文，组件将需要一个函数作为子组件，该子组件将获得当前上下文值作为参数。该函数将返回一个React节点，该节点将基于上下文值进行呈现。</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="d884" class="nf lj it lh b gy ng nh l ni nj">//Child.js<br/>import React from 'react';<br/>import { Consumer } from './NameContext';<br/>import GrandChild from './GrandChild';</span><span id="ecae" class="nf lj it lh b gy nk nh l ni nj">class Child extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;Consumer&gt;<br/>        {function(context) {<br/>          return (<br/>            &lt;div&gt;<br/>              &lt;h2&gt;{context.name}&lt;/h2&gt;<br/>              &lt;input<br/>                onChange={context.handleNameChange}<br/>                value={context.name}<br/>                placeholder="Name"<br/>              /&gt;<br/>              &lt;GrandChild /&gt;<br/>            &lt;/div&gt;<br/>          );<br/>        }}<br/>      &lt;/Consumer&gt;<br/>    );<br/>  }<br/>}</span><span id="123d" class="nf lj it lh b gy nk nh l ni nj">export default Child;</span></pre><p id="37b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经讨论了如何在渲染函数中使用上下文，如果你想在渲染之外的其他函数中使用上下文来执行你的逻辑呢？我们可以用消费者组件包装导出的组件，并将上下文作为道具传递给组件，以便其他功能可以访问它</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="01ca" class="nf lj it lh b gy ng nh l ni nj">//GrandChild.js<br/>import React from 'react';<br/>import { Consumer } from './NameContext';</span><span id="4359" class="nf lj it lh b gy nk nh l ni nj">class GrandChild extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.handleClick = this.handleClick.bind(this);<br/>  }<br/>  handleClick() {<br/>    console.log(this.props);<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h3&gt;Gabroun&lt;/h3&gt;<br/>        &lt;button onClick={this.handleClick}&gt;Submit&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="b99e" class="nf lj it lh b gy nk nh l ni nj">export default function GrandChildWithContext() {<br/>  return (<br/>    &lt;Consumer&gt;<br/>      {function(context) {<br/>        return &lt;GrandChild data={context} /&gt;;<br/>      }}<br/>    &lt;/Consumer&gt;<br/>  );<br/>}</span></pre><p id="f7d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过将一个提供者包装在另一个提供者周围来访问上下文，可以有多种上下文。</p><h1 id="65a3" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">最后</h1><p id="60ea" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">当props drilling变得难以处理时，Context API是一种在树中的组件之间共享应用程序状态的好方法，这是一种有助于解决该问题的好工具。</p></div></div>    
</body>
</html>