<html>
<head>
<title>Cache in Django makes your App Lighting Fast in 99% of the cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django中的缓存使您的应用程序在99%的情况下都很快</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-simple-and-quick-way-to-cache-in-django-9bf217812a3b?source=collection_archive---------0-----------------------#2021-02-18">https://levelup.gitconnected.com/a-simple-and-quick-way-to-cache-in-django-9bf217812a3b?source=collection_archive---------0-----------------------#2021-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dba0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Django中使用cache_page</h2></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><p id="9cad" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">有很多文章解释了Django中缓存的工作原理。大部分都很复杂，所以我决定为你化繁为简。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/65a36a2088315ddb288513c62e6a5011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ws4YrK1G64TtrRdbwTHcqw.png"/></div></div></figure><h2 id="a1ae" class="lx ly it bd lz ma mb dn mc md me dp mf ky mg mh mi lc mj mk ml lg mm mn mo mp bi translated">为什么要缓存？</h2><p id="0353" class="pw-post-body-paragraph kp kq it kr b ks mq ju ku kv mr jx kx ky ms la lb lc mt le lf lg mu li lj lk im bi translated">您的应用程序中可能有些页面不会经常更改。您的应用程序仍然需要调用您的函数并呈现一个HTML。</p><p id="9688" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果是一些应该计算的统计数据，并且可以访问您的数据库，那就更糟了。例如，它可能是YouTube上某个视频的观看次数。或者点赞数。</p><p id="58dc" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了计算视频的观看次数，服务器需要执行一个SQL请求。如果有数百万用户观看这个视频，那么做一百万次是没有意义的。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="065c" class="lx ly it bd lz ma mb dn mc md me dp mf ky mg mh mi lc mj mk ml lg mm mn mo mp bi translated">如何缓存？</h2><p id="20b5" class="pw-post-body-paragraph kp kq it kr b ks mq ju ku kv mr jx kx ky ms la lb lc mt le lf lg mu li lj lk im bi translated">要缓存一个页面，在视图中添加一个装饰器就足够了。就是这样。</p><p id="fd7e" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">首先，导入装饰器:</p><pre class="lm ln lo lp gt mv mw mx my aw mz bi"><span id="4774" class="lx ly it mw b gy na nb l nc nd">from django.views.decorators.cache import cache_page</span></pre><p id="3c9c" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然后如下装饰您的视图:</p><pre class="lm ln lo lp gt mv mw mx my aw mz bi"><span id="032d" class="lx ly it mw b gy na nb l nc nd">@cache_page(60 * 30)<br/>def index(request):<br/>  ....</span></pre><p id="1c80" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这将为所有用户缓存您的页面30分钟。随意缓存24小时:<code class="fe ne nf ng mw b">60*60*24</code>。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="b06a" class="lx ly it bd lz ma mb dn mc md me dp mf ky mg mh mi lc mj mk ml lg mm mn mo mp bi translated">不同的用户有不同的看法吗？</h2><p id="c8e2" class="pw-post-body-paragraph kp kq it kr b ks mq ju ku kv mr jx kx ky ms la lb lc mt le lf lg mu li lj lk im bi translated">没问题。再加一个装饰工。</p><pre class="lm ln lo lp gt mv mw mx my aw mz bi"><span id="e230" class="lx ly it mw b gy na nb l nc nd">from django.views.decorators.vary import vary_on_cookie<br/>from django.views.decorators.cache import cache_page</span></pre><p id="76ec" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">并按以下顺序使用它们:</p><pre class="lm ln lo lp gt mv mw mx my aw mz bi"><span id="5010" class="lx ly it mw b gy na nb l nc nd">@cache_page(60 * 30)<br/>@vary_on_cookie<br/>def index(request):<br/>  ...</span></pre><p id="3335" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">顺序很重要！参见<a class="ae nh" rel="noopener ugc nofollow" target="_blank" href="/write-your-own-decorators-in-python-in-5-minutes-f32171c50241">我的另一篇文章，更好地理解装修工</a>。</p><p id="7976" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这种“随cookie变化”意味着如果cookie中的内容发生了变化，Django就不应该使用缓存。用户只是其中的一个特例。</p><p id="b389" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">因此，如果用户通过身份验证或注销，缓存将再次被清理。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="de63" class="lx ly it bd lz ma mb dn mc md me dp mf ky mg mh mi lc mj mk ml lg mm mn mo mp bi translated">清理缓存？</h2><p id="8068" class="pw-post-body-paragraph kp kq it kr b ks mq ju ku kv mr jx kx ky ms la lb lc mt le lf lg mu li lj lk im bi translated">假设情况改变了。又过了一天，我们需要更新统计数据。或者视频被删了。或者某些数据已经更改，缓存不再相关。</p><p id="f0e3" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">清理缓存就像这样简单:</p><pre class="lm ln lo lp gt mv mw mx my aw mz bi"><span id="772b" class="lx ly it mw b gy na nb l nc nd">from django.core.cache import cache<br/>cache.clear()</span></pre><p id="1539" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">你把它放在哪里？这取决于你。</p><p id="24b1" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">你可以把它放到模型的“保存”信号中。或者删除视频的方法。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="08c4" class="lx ly it bd lz ma mb dn mc md me dp mf ky mg mh mi lc mj mk ml lg mm mn mo mp bi translated">基于类的视图(REST)呢？</h2><p id="49be" class="pw-post-body-paragraph kp kq it kr b ks mq ju ku kv mr jx kx ky ms la lb lc mt le lf lg mu li lj lk im bi translated">如果使用Django Rest框架，通常使用基于类的视图。</p><p id="c541" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然后装饰器的语法有点不同。</p><pre class="lm ln lo lp gt mv mw mx my aw mz bi"><span id="9de6" class="lx ly it mw b gy na nb l nc nd">from django.utils.decorators import method_decorator<br/>from django.views.decorators.cache import cache_page<br/>from django.views.decorators.vary import vary_on_cookie</span></pre><p id="c222" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">并且用法是:</p><pre class="lm ln lo lp gt mv mw mx my aw mz bi"><span id="a63e" class="lx ly it mw b gy na nb l nc nd">class UserViewSet(viewsets.ViewSet):<br/><br/>    @method_decorator(cache_page(60*60*2))<br/>    @method_decorator(vary_on_cookie)<br/>    def list(self, request):<br/>        ...</span></pre></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="7cf2" class="lx ly it bd lz ma mb dn mc md me dp mf ky mg mh mi lc mj mk ml lg mm mn mo mp bi translated">但是我的URL中有一个正则表达式！</h2><p id="c529" class="pw-post-body-paragraph kp kq it kr b ks mq ju ku kv mr jx kx ky ms la lb lc mt le lf lg mu li lj lk im bi translated">没问题。</p><p id="c5b0" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">Django对每个URL都有一个单独的缓存。</p><p id="dc7a" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">例如，如果您有一个如下所示的URL:</p><pre class="lm ln lo lp gt mv mw mx my aw mz bi"><span id="1163" class="lx ly it mw b gy na nb l nc nd">path(<strong class="mw iu">'groups/&lt;int:id&gt;'</strong>, groups_views.group_view, name=<strong class="mw iu">'group_view'</strong>),</span></pre><p id="ca48" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然后有一个单独的缓存用于<code class="fe ne nf ng mw b">groups/1</code>和<code class="fe ne nf ng mw b">groups/2</code>。所以你不用担心。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="cdc7" class="lx ly it bd lz ma mb dn mc md me dp mf ky mg mh mi lc mj mk ml lg mm mn mo mp bi translated">贴吧，放吧，删吧？</h2><p id="c01a" class="pw-post-body-paragraph kp kq it kr b ks mq ju ku kv mr jx kx ky ms la lb lc mt le lf lg mu li lj lk im bi translated">不会。这些类型的请求不会被缓存。</p><p id="9a81" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">甚至导致错误的GET请求(状态不是“200 OK”的任何内容)也不会被缓存。</p><p id="18d4" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">因此，只有GET请求返回了“200 OK”。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="580d" class="lx ly it bd lz ma mb dn mc md me dp mf ky mg mh mi lc mj mk ml lg mm mn mo mp bi translated">我的申请还是太慢了！</h2><p id="52c1" class="pw-post-body-paragraph kp kq it kr b ks mq ju ku kv mr jx kx ky ms la lb lc mt le lf lg mu li lj lk im bi translated">别担心。</p><p id="1bba" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">您可能需要索引您的数据库:</p><div class="ni nj gp gr nk nl"><a rel="noopener  ugc nofollow" target="_blank" href="/just-one-index-in-django-makes-your-app-15x-faster-742e2f13108e"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">Django中的一个索引就能让您的应用速度提高15倍！</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">你的应用有了索引会快多少？</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz lv nl"/></div></div></a></div></div></div>    
</body>
</html>