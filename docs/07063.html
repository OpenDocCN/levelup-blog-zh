<html>
<head>
<title>How to Implement Likes and Dislikes Using the State Design Pattern in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在C#中使用状态设计模式实现好恶</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-state-design-pattern-to-implement-likes-and-dislikes-958389b379ff?source=collection_archive---------6-----------------------#2021-01-21">https://levelup.gitconnected.com/the-state-design-pattern-to-implement-likes-and-dislikes-958389b379ff?source=collection_archive---------6-----------------------#2021-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1632" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从需求引出开始</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/98c044e04862f02c2701d1a36386619f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*seoTT-ewNXYmeHAP"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@cardmapr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CardMapr </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="95c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据对象的状态，对象的行为会有所不同。例如:</p><ul class=""><li id="cc42" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如果订单被提前取消，则无法发货。</li><li id="f673" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">音频播放器可以在停止或暂停时播放，但不能在播放时播放。</li><li id="8952" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">线程对象只有在以前没有启动过的情况下才能启动。</li></ul><p id="bfb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当对象的行为由其状态决定时，开发人员可以考虑使用状态设计模式。</p><p id="57f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了向您解释经典的状态设计模式，我选择了“喜欢-不喜欢”功能——您在观看YouTube视频或阅读评论后使用该功能来快速表达您的感受。我想马上警告你，在我看来，状态模式的经典实现对于“喜欢-不喜欢”特性来说有点过头了。然而，我发现它非常适合于学习目的，因为现在这个特性是众所周知的，简单并且可以通过状态模式来实现。</p><p id="cb3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进入模式的实现细节之前，我们需要收集我们将要实现的需求。</p><h1 id="44bc" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">需求启发</h1><p id="b450" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">需求必须是可理解的，可行的，明确的等。它们应该在开发阶段之前建立，这样就没有必要做任何多余的工作。</p><p id="df57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“喜欢-不喜欢”功能的功能要求如下:</p><ul class=""><li id="7cee" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如果用户点击“喜欢”按钮，增加喜欢的数量。</li><li id="47e5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果用户点击“不喜欢”按钮—增加不喜欢的数量。</li><li id="9a58" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果用户在之前点击了“喜欢”的情况下点击了“喜欢”按钮，则减少“喜欢”的数量(不喜欢)。</li><li id="fe22" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果用户在之前点击“不喜欢”时点击了“不喜欢”按钮，则减少不喜欢的数量(不喜欢)。</li><li id="5e51" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果用户在之前点击“不喜欢”时点击“喜欢”按钮，则减少不喜欢(不喜欢)的数量，增加喜欢的数量。</li><li id="2ea6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果用户在之前点击“喜欢”的时候点击了“不喜欢”按钮，则减少喜欢的数量，增加不喜欢的数量。</li></ul><p id="bf20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，这些需求可以用更少的文字写成表格:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/37503c524079d7ee74175428efe9f7e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gd_82Y6kGLtFqGS3je8iew.png"/></div></div></figure><p id="344e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过分析给定的需求，我们可以确定对状态设计模式的需求。第一个和第二个需求没有告诉我们任何关于状态模式的信息。但是请看看这两个要求:</p><p id="7909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nh">“如果用户在之前点击了“喜欢”的情况下又点击了“喜欢”按钮——减少喜欢(不喜欢)的数量。”</em></p><p id="cd2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和</p><p id="058c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nh">"如果用户在之前点击“不喜欢”时点击了“喜欢”按钮，则减少不喜欢(不喜欢)的数量，增加喜欢的数量。"</em></p><p id="b788" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，用户执行相同的类似动作。然而，结果是不同的，因为它们不仅由动作决定，而且由<strong class="lb iu">动作加上当前状态</strong>决定。“点击喜欢”是一个动作，而“当喜欢/不喜欢被点击时”是一种状态。对喜欢的组件执行类似的动作导致喜欢的数量减少，而对不喜欢的组件执行类似的动作导致不喜欢的减少和喜欢的增加。“喜欢-不喜欢”组件根据其当前状态表现不同。这是状态设计模式的一个用例。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="017e" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">状态设计模式实现</h1><p id="0ef6" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">状态设计模式由三个组件组成:</p><ul class=""><li id="a6d1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">语境</li><li id="dfdd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">抽象状态</li><li id="249a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">具体状态</li></ul><p id="3bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，上下文将是一个名为LikeDislikeComponent的对象，它封装了两个计数器和一个到其当前状态的链接—一个抽象状态。</p><p id="e889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抽象状态将由ILikeDislikeComponentState接口表示，该接口定义了喜欢和不喜欢的动作。</p><p id="4450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体状态将由三个对象InitialState、LikedState和DislikedState表示。每个特定的状态对象对上下文对象执行两个操作:改变喜欢或不喜欢的数量，并将对象转移到新的状态。</p><p id="6f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是完整的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="b4ff" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">结论</h1><p id="2b5b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">正如我在文章开头提到的，经典的状态设计模式对我来说是一个“喜欢-不喜欢”特性的过度工程。我认为是这样，因为只有三种可能的状态，业务逻辑很简单。但是我想在一些简单的同时又是“真实世界”的东西上演示状态模式。我希望你喜欢它。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="2f09" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">更多设计模式</h1><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/the-simplest-explanation-of-adapter-design-pattern-cd37f02bfecd"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">适配器设计模式的最简单解释</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">C#中的真实世界示例</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-clone-an-object-in-c-d1374ec28efa"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">原型:用C#克隆对象的5种方法</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">各有利弊</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>