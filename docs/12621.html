<html>
<head>
<title>Structuring complex projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建复杂的项目</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/structuring-complex-projects-5a4cb3b80fe5?source=collection_archive---------8-----------------------#2022-06-23">https://levelup.gitconnected.com/structuring-complex-projects-5a4cb3b80fe5?source=collection_archive---------8-----------------------#2022-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="0ecd" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">"简单是可靠的先决条件."<br/> <strong class="jt ir">埃德格·w·迪克斯特拉</strong></p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/6af01806430472237ff1ff00f19426ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OvXH0dmmZF72MagB"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae lf" href="https://unsplash.com/@hasanalmasi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈桑·阿尔马西</a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="e286" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我们都在观察一个范式的转变，使用单个存储库(<em class="js"> monorepos </em>)，而不是单独管理许多独立的git存储库。</p><p id="f507" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我认为这种转变是完全单一的产品设计(当所有连接的部分都紧密链接到根项目时)和完全分布式的产品设计(当连接的部分代表架构量子时，所以可以从设计和部署的角度独立共存)之间的一种妥协。这两个极端都有显著的缺点，会减缓产品开发。</p><p id="9a50" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">Monorepos解决了其中最关键的问题:</p><ul class=""><li id="5705" class="lj lk iq jt b ju jv jy jz lg ll lh lm li ln ko lo lp lq lr bi translated">连接的组件仍然是一个自给自足的架构量子，可以在根项目之外重用</li><li id="2a10" class="lj lk iq jt b ju ls jy lt lg lu lh lv li lw ko lo lp lq lr bi translated">连接组件被设计为使用its的项目的一部分，但不是在真空中，因此最终的采用要顺利得多</li></ul><p id="23cf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我在<a class="ae lf" href="https://medium.com/codex/what-i-was-doing-wrong-dependency-management-and-monorepo-816c698ab9f" rel="noopener">这篇文章</a>中分享了我过去将现有项目迁移为monorepo的经验，以及所有获得的好处。</p><p id="6caf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">作为迁移的一部分，我发现了另一个有趣的用例，我想在这篇文章中分享——支持高效的分层项目结构。</p><h1 id="1750" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">遵守共同封闭原则</h1><p id="6dfe" class="pw-post-body-paragraph jq jr iq jt b ju mv jw jx jy mw ka kb lg mx ke kf lh my ki kj li mz km kn ko ij bi translated">比起Node/JS/TypeScript，我更关注JAVA/Spring/Gradle项目——我已经在脑海中描绘了一个大项目需要如何构建以保持高度的可支持性和可管理性架构特征:</p><ul class=""><li id="96c7" class="lj lk iq jt b ju jv jy jz lg ll lh lm li ln ko lo lp lq lr bi translated"><strong class="jt ir">根项目只是一个由子模块</strong>提供大量服务的外观</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi na"><img src="../Images/1759e67a7a6209fce02d8f21e4ec7e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ds2a5HYJ9OSpffOzga7Qg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">模块层次结构</figcaption></figure><ul class=""><li id="4c30" class="lj lk iq jt b ju jv jy jz lg ll lh lm li ln ko lo lp lq lr bi translated"><strong class="jt ir">子模块封装了所有需要的依赖关系，这些依赖关系没有暴露在</strong>之外</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/6be093047cbdd94aba8243746b89bb47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*JVGGTSdsL_RbWjEGnSeprQ.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">封装的依赖项</figcaption></figure><ul class=""><li id="b652" class="lj lk iq jt b ju jv jy jz lg ll lh lm li ln ko lo lp lq lr bi translated"><strong class="jt ir">子模块是一个自给自足的模块，通过隐藏其内部实现来公开高级API</strong></li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/2026fe0050a9d386f0ed5b7dbdac8371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*-NLJVpMVN20wOgXFtFw8lw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">隐藏复杂性</figcaption></figure><ul class=""><li id="ad98" class="lj lk iq jt b ju jv jy jz lg ll lh lm li ln ko lo lp lq lr bi translated"><strong class="jt ir">子项目是独立管理的，并且有一整套必需的任务和目标来产生一个可构建或可部署的工件</strong></li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/37686ff79e3a35bcd9eb060e197ecefe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*mouOx2QqvHpXhE2e-M53nw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">沙盒开发和推广</figcaption></figure><h1 id="bf61" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">JAVA和Gradle</h1><p id="15df" class="pw-post-body-paragraph jq jr iq jt b ju mv jw jx jy mw ka kb lg mx ke kf lh my ki kj li mz km kn ko ij bi translated">Gradle 构建自动化工具对多项目配置有基本的支持，因此它会基于依赖项配置自动构建一个完整的构建链。</p><p id="1688" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">因此，运行<code class="fe ne nf ng nh b">gradle build</code>命令将产生下一个结果——构建引擎将分析依赖关系树，并根据引用顺序在每个依赖关系中执行构建任务。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ni"><img src="../Images/678159309433dbe764ac79b2d8dcff7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EfmRLsm3xSkhg-NdMbs6g.png"/></div></div></figure><p id="2351" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">项目配置非常简单:</p><p id="2582" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe ne nf ng nh b">settings.gradle</code>对于根项目应该描述所有链接的依赖关系</p><pre class="kq kr ks kt gt nj nh nk nl aw nm bi"><span id="2b96" class="nn ly iq nh b gy no np l nq nr">rootProject.name = 'gradle-hierarchy-example'<br/>include ':packages:core'</span></pre><p id="4a5e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe ne nf ng nh b">build.gradle</code>对于根项目应描述联动类型，如</p><pre class="kq kr ks kt gt nj nh nk nl aw nm bi"><span id="8406" class="nn ly iq nh b gy no np l nq nr">dependencies <strong class="nh ir">{<br/>    </strong>implementation project(":packages:core")<br/>    // other dependencies<br/><strong class="nh ir">}</strong></span></pre><h1 id="efe5" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">JAVA和Maven</h1><p id="0810" class="pw-post-body-paragraph jq jr iq jt b ju mv jw jx jy mw ka kb lg mx ke kf lh my ki kj li mz km kn ko ij bi translated"><a class="ae lf" href="https://maven.apache.org/" rel="noopener ugc nofollow" target="_blank"> Maven </a>构建自动化工具支持类似的多项目范式，唯一相反的父子识别模型——子项目知道它的父引用(而Gradle在父配置中定义所有子项目的链接)。</p><p id="4903" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">子POM设置文件需要声明父引用:</p><pre class="kq kr ks kt gt nj nh nk nl aw nm bi"><span id="a722" class="nn ly iq nh b gy no np l nq nr">&lt;project&gt;</span><span id="5dc9" class="nn ly iq nh b gy ns np l nq nr">  &lt;parent&gt;<br/>    &lt;artifactId&gt;project-hierarchy-maven&lt;/artifactId&gt;<br/>    &lt;groupId&gt;com.example&lt;/groupId&gt;<br/>    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br/>  &lt;/parent&gt;<br/><br/>  ...</span><span id="5367" class="nn ly iq nh b gy ns np l nq nr">&lt;/project&gt;</span></pre><p id="21aa" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">打包父项目时，所有必需的依赖项都将被识别并适当地构建</p><pre class="kq kr ks kt gt nj nh nk nl aw nm bi"><span id="1132" class="nn ly iq nh b gy no np l nq nr">[INFO] Reactor Summary:<br/>[INFO] project-hierarchy-maven 0.0.1-SNAPSHOT .. SUCCESS [ 13.302 s]<br/>[INFO] core 1.0-SNAPSHOT ....................... SUCCESS [ 43.760 s]<br/>[INFO] -------------------------------------------------------------<br/>[INFO] BUILD SUCCESS</span></pre><h1 id="0713" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">诺杰斯和NPM</h1><p id="4df8" class="pw-post-body-paragraph jq jr iq jt b ju mv jw jx jy mw ka kb lg mx ke kf lh my ki kj li mz km kn ko ij bi translated">在JavaScript生态系统中，多项目解决方案是一个全新的范例，传统的构建工具还不能支持它。</p><p id="2f85" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">但是幸运的是，从节点包管理器(NPM)的版本7开始，通过在<code class="fe ne nf ng nh b">package.json</code>项目配置文件中引入一个额外的部分— <code class="fe ne nf ng nh b">workspaces</code>,增加了这种支持</p><blockquote class="jn jo jp"><p id="ad6c" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">工作区</strong>是一个通用术语，指的是npm cli中的一组功能，这些功能支持从单个顶级根包中管理本地文件系统中的多个包。</p></blockquote><p id="632c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">正如它在描述中所说的，这个新的配置允许描述根应用程序应该知道的项目依赖关系(类似于Gradle如何定义它的依赖关系)。</p><p id="db72" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">作为一个例子，让我们回顾一下这个项目，它有两个子模块:<code class="fe ne nf ng nh b">app</code>和<code class="fe ne nf ng nh b">core</code>，其中<code class="fe ne nf ng nh b">app</code>依赖于<code class="fe ne nf ng nh b">core</code>项目。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/ef01f20bfa04ef1c018b926b1f065b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*stnSoaSl3_jPOh4EoqgptA.png"/></div></figure><p id="316a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">要添加对多项目行为的支持，我们所需要的就是扩展包配置，使其链接到子项目。</p><pre class="kq kr ks kt gt nj nh nk nl aw nm bi"><span id="3472" class="nn ly iq nh b gy no np l nq nr">{<br/>  "name": "npm-hierarchy",<br/>  "version": "0.0.1",</span><span id="71d2" class="nn ly iq nh b gy ns np l nq nr">  "workspaces": [<br/>    "packages/**",<br/>    "app"<br/>  ],<br/>  "dependencies": {<br/>    . . .<br/>  }<br/>}</span></pre><p id="4710" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">所有的子包可能已经定义了适合它们范围的任务，然后从根项目中一次运行所有的任务。</p><pre class="kq kr ks kt gt nj nh nk nl aw nm bi"><span id="4229" class="nn ly iq nh b gy no np l nq nr">// this command will run "test" command in all sub-projects<br/>npm run test --workspaces</span></pre><p id="aa18" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">如果一个子对象在其<code class="fe ne nf ng nh b">project.json</code>文件中引用另一个子对象，将获得正确的任务执行顺序。</p><h1 id="4785" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">NodeJS和LernaJS</h1><p id="972a" class="pw-post-body-paragraph jq jr iq jt b ju mv jw jx jy mw ka kb lg mx ke kf lh my ki kj li mz km kn ko ij bi translated"><a class="ae lf" href="https://lerna.js.org/" rel="noopener ugc nofollow" target="_blank"> LernaJS </a>是管理多回购解决方案中模块的下一步。它提供了一个平滑的机制来管理和协调子模块的生命周期。它是NPM工作空间的改进版本，增加了缓存执行结果、排序和任务配置等功能。</p><p id="e2c0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">因此，以正确的顺序运行所有的子任务集不需要引用工作区，根任务可以被配置为这样做，例如</p><pre class="kq kr ks kt gt nj nh nk nl aw nm bi"><span id="b8e5" class="nn ly iq nh b gy no np l nq nr">lerna run compile</span></pre><p id="3c78" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">因此，LernaJS构建工具将分析依赖关系树，还将为每个定义了“编译”任务的项目调用该任务。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/6a3b77a2ff0554ab2161068075a4006d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*IzOlOPcrRRR-MOVWHesnNA.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">执行任务顺序</figcaption></figure></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><div class="kq kr ks kt gt oc"><a href="https://medium.com/codex/what-i-was-doing-wrong-dependency-management-and-monorepo-816c698ab9f" rel="noopener follow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">我做错了什么—依赖管理和monorepo</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">在分布式架构中支持多重依赖是一个巨大的挑战，尤其是当康威定律…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">medium.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq kz oc"/></div></div></a></div><div class="or os gp gr ot oc"><a href="https://medium.com/codex/what-i-was-doing-wrong-managing-micro-services-common-dependencies-7110e5ebbc2f" rel="noopener follow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">我做错了什么——管理微服务的公共依赖性</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">我个人的一系列发现，设计关注，时间浪费活动，模式不适用性，以及其他问题…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">medium.com</p></div></div><div class="ol l"><div class="ou l on oo op ol oq kz oc"/></div></div></a></div></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="8ae8" class="lx ly iq bd lz ma ov mc md me ow mg mh mi ox mk ml mm oy mo mp mq oz ms mt mu bi translated">分级编码</h1><p id="a425" class="pw-post-body-paragraph jq jr iq jt b ju mv jw jx jy mw ka kb lg mx ke kf lh my ki kj li mz km kn ko ij bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae lf" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>。<br/>跟随:<a class="ae lf" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae lf" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae lf" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="jt ir">升一级正在改造理工大招聘➡️ </strong> <a class="ae lf" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>