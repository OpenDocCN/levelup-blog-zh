# 我们需要在浏览器中显示 Deno！🦕

> 原文：<https://levelup.gitconnected.com/we-need-deno-in-the-browser-ea069e4f590a>

## 一个派生的节点替代方案如何为我们的用户界面带来革命性的微前端架构

![](img/44ea3218d85793338c204e568de5ccd3.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上由 [Daiga Ellaby](https://unsplash.com/@daiga_ellaby?utm_source=medium&utm_medium=referral) 拍摄的照片

微前端(MFEs)是一种 UI 架构理念。它最近越来越受关注，但也带来了许多悬而未决的问题。

mfe 与微服务后端架构一起出现，因此有许多一致的想法。以下是关键概念:

1.  每个 MFE 应该是一个完全独立的代码库。
2.  mfe 不应该在相同的资源(包括 DOM、状态、URL)上操作。稍后会详细介绍。)
3.  每个 MFE 需要单独部署，并从唯一的 URL 提供服务。

自包含代码库意味着独立的 Webpack 构建(如果 Webpack 是您的选择)。MFEs 最大的优势之一是能够增量地更新项目的各个部分。我曾经领导过一个项目，我们从 Backbone 到 React 重构了大约 50 万行代码。这是唯一可能的，因为大约有 50，000 行可以单独重构——我应该提到，50，000 行对于 MFE 来说太大了，我们使用了一种混合方法。

不在相同的资源上操作与我们不喜欢全局变量的原因是一样的。如果许多东西可以在同一个资源上操作，那么对代码的推理和调试就变得几乎不可能了。在您可以改变您正在工作的 MFE 之前，您必须了解其他 MFE 是如何工作的，这完全否定了首先进行 MFE 的价值。

两个 mfe 试图操作同一资源的真实镜头。

在 UI 中，我们被困在一些我们无法逃避的共享资源中，例如 DOM。为了解决这个问题，你必须定义 mfe 的边界。例如，当呈现输入 MFE 时，您告诉它 DOM 中允许操作的特定元素。那是它将呈现自己的地方。

第三点是其他两点的结果。如果代码是自包含的，并且它执行的操作也是自包含的，那么在知道它对页面上的其他 mfe 没有影响的情况下，独立部署它是安全的。

因此，如果您的每个 mfe 都是完全隔离的，并且可以放心地独立部署，那么您就一切顺利。问题是，您可能会为每个 MFE 发送大量的包。您可能使用输入组件发送 React v16.8.1，但是使用 TextBox 组件发送 React v16.8.2，使用 DatePicker 发送 React v 16 . 8 . 3...

你可能会争辩说，如果你从 React 切换到像[svelet](https://svelte.dev/)这样在编译时编译的东西，那么你就没有这个问题。虽然这是苗条的一个巧妙卖点，但它并没有解决问题。你的框架并不是你唯一依赖的库。

当我意识到以下几点时，我对 MFEs 有了新的认识:

> 微前端架构将您的依赖性从构建时转移到运行时。

当您将一个输入组件作为一个 MFE 加载时，这有点像将它作为一个依赖项添加到 package.json 中，只不过您是实时获取依赖项，而不是在绑定代码时。

这将我们引向前端开发如何工作的圣杯:

> 如果我们停止将所有的代码捆绑在一起，并使所有的依赖项都活起来，web 开发将更加灵活，最终用户的速度成本将很小，甚至没有。

如果您想知道这可能是什么样子，想象您删除了 package . JSON——因为依赖项是活动的——并且您的组件看起来像这样:

请忽略 shonky html。我开始思考标记的有效性，然后意识到这真的与示例无关…

最终用户没有速度成本的原因是以下几个方面的结合:

1.  使用^16.8.0 语法浏览器可以解决许多依赖一个单一版本的库。
2.  在访问一些网站后，最常见的依赖项将被缓存。
3.  浏览器制造商可能会开始将最常见的依赖项与其更新捆绑在一起。

仔细想想，捆绑是性能优化的噩梦:

> 如果你有 5 个包，那么你必须缓存 5 个包。如果你让人们捆绑这些包的每一个可能的组合，你就有 5 个！(=120)个可能要缓存的包。

## 为什么这听起来很熟悉？

如果是的话，你可能会想到 [Deno](https://deno.land/) 。Deno 是从[Ryan Dahl](https://en.wikipedia.org/wiki/Ryan_Dahl)—[Node . js](https://en.wikipedia.org/wiki/Node.js)的原创者衍生出来的 Node-alternative。Deno 的标题是它支持开箱即用的 TypeScript，但它还有其他技巧来解决 Ryan 描述的“[我对 Node.js](https://github.com/denolib/awesome-deno/blob/master/resources/design-mistakes-in-node/design-mistakes-in-node.pdf) 感到遗憾的 10 件事”。

其中一个特性是，它去掉了 package.json 文件，转而以内联方式处理导入，有点像我上面展示的例子。

第一个 JavaScript 存在于浏览器中。然后 Node 允许我们在服务器上运行 JS。Deno 已经开始尝试修复服务器上的一些问题。现在我想看到 Deno 中的这些修复开始回到浏览器中。

## 那么，我们如何将它放入浏览器呢？

不幸的是，这个问题没有简单的答案。要在 JavaScript 中加入任何新功能，你必须向 TC39 技术委员会提交一份提案。从想法到出现在浏览器中的整个过程可能需要几年时间，如果一切顺利的话。据我所知，还没有人提出这个特性。

如果你今天想使用它，最快的方法可能是定制一个巴别塔插件。你必须做以下事情:

1.  **(可以随便玩玩，但对大规模安全运营至关重要)**设置一个 CDN 来托管您引用的每个 npm 包。你要找的是 npm 前面的 CDN 代理。第一次请求一个包时，它会将它代理给 npm，之后它会缓存在您的 CDN 中。缓存可以是永恒的，因为所有的包都是结合它们的版本号来引用的，即。如果你缓存了 React 16 . 0 . 0 版本，你不需要一天后再回来检查 React 16 . 0 . 0 版本是否还是一样的。 [JSPM 已经这样做了](https://jspm.org/)如果你可以使用外部资源。
2.  创建一个依赖关系管理库，像 npm 一样处理依赖关系树的构建。它必须是动态的。当加载新的 MFE 时——带有新的依赖关系——依赖关系树必须更新以处理它*,而不破坏预先存在的依赖关系*。
3.  创建一个 Babel 插件，将所有导入转换成对依赖管理库的引用。

据我所知，不存在这样的东西，我也不确定如果没有至少一些浏览器的合作，它的可行性或性能如何。由于不是所有的浏览器都支持 JS 模块(感谢 IE11 ),你可能会发现很难让你的依赖管理器公开每个包的导出。您可以通过修改包在窗口上设置一个全局变量来解决这个问题，但是这样做太复杂了，而且可能很慢。

如果你正在做一些类似的事情，请让我知道，我很想知道进展如何。否则，如果时间允许，我可能会尝试将其中一些作为开源项目。

祝一切顺利，
尼克