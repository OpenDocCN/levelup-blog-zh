<html>
<head>
<title>The Whole Docker Shebang: docker build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">整个码头工程:码头建筑</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-whole-docker-shebang-part-1-docker-build-470f0c265702?source=collection_archive---------6-----------------------#2021-08-18">https://levelup.gitconnected.com/the-whole-docker-shebang-part-1-docker-build-470f0c265702?source=collection_archive---------6-----------------------#2021-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c4dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过示例了解Docker构建的每个选项的作用，以及如何使用它</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/3e17a9c8f878348faf48db25b517b586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XT_oBfV7bgT8cT56"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">由<a class="ae ll" href="https://unsplash.com/@saanvi2116?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Saanvi Vavilala </a>在<a class="ae ll" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="767f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以如果你正在读这篇文章，你至少应该熟悉什么是<a class="ae ll" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">容器</a>和<a class="ae ll" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">停靠器</a>。</p><p id="30f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能已经知道了基本知识，如果你不知道，请随时查看Udemy (附属链接)中的<a class="ae ll" href="https://www.udemy.com/course/docker-crash-course-learn-from-experience-for-beginners/?referralCode=BAC861F284EACA8695FD" rel="noopener ugc nofollow" target="_blank">课程。</a></p><p id="86a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是你知道<code class="fe lm ln lo lp b">docker build</code>背靠背吗？你知道每个单独的构建选项有什么作用吗？</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="ec03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没有任何进一步的麻烦，确保您已经安装了<a class="ae ll" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker和</a>并打开了命令行。</p><p id="d865" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请<strong class="js iu">注意</strong>对于每个选项，您都有一个测试docker文件，您必须将它保存到一个名为<code class="fe lm ln lo lp b">Dockerfile</code>的文件中，该文件与您运行<code class="fe lm ln lo lp b">docker build</code>命令的路径相同。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="e025" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你看着<code class="fe lm ln lo lp b">docker build --help</code>时，你会得到相当多的<a class="ae ll" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank">几个选项</a>。</p><p id="7bfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个接一个，让我们看看它们是如何工作的。</p><h1 id="83c3" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--add-host</code></h1><p id="5eae" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">您可以在构建时通过使用一个或多个<code class="fe lm ln lo lp b">—-add-host</code>标志将其他主机添加到中间容器的<code class="fe lm ln lo lp b">/etc/hosts</code> <br/>文件中。</p><p id="1977" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于本例，我们将使用以下docker文件:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="1be4" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>RUN cat /etc/hosts</span></pre><p id="740c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑这个构建，我们为主机<code class="fe lm ln lo lp b">docker</code>添加了一个静态地址:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="a511" class="mx lr it lp b gy my mz l na nb">$ docker build --add-host=docker:10.180.0.1 .</span><span id="2408" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  2.048kB<br/>Step 1/2 : FROM debian AS build-env<br/> ---&gt; 7a4951775d15<br/>Step 2/2 : RUN cat /etc/hosts<br/> ---&gt; Running in 4f4501c62199<br/>127.0.0.1 localhost<br/>::1 localhost ip6-localhost ip6-loopback<br/>fe00::0 ip6-localnet<br/>ff00::0 ip6-mcastprefix<br/>ff02::1 ip6-allnodes<br/>ff02::2 ip6-allrouters<br/><strong class="lp iu">10.180.0.1 docker<br/></strong>172.17.0.2 4f4501c62199</span><span id="9c6c" class="mx lr it lp b gy nc mz l na nb">...<br/>Removing intermediate container 4f4501c62199<br/> ---&gt; ac7aeb6b6379<br/>Successfully built ac7aeb6b6379</span></pre><p id="d3a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，该主机仅在构建时可用。要使定制的主机到IP映射对容器可用，请使用带有<code class="fe lm ln lo lp b">docker run</code>命令的<code class="fe lm ln lo lp b">--add-host</code>选项。</p><h1 id="e455" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--build-arg</code></h1><p id="49fd" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">使用这个选项，您可以参数化您的Docker构建。考虑以下Dockerfile文件中的参数<code class="fe lm ln lo lp b">param1</code>:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="54d7" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>ARG param1=defaultValue<br/>RUN echo $param1</span></pre><p id="d901" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，它采用值<code class="fe lm ln lo lp b">defaultValue</code>。但是您可以在构建时通过执行以下操作来更改它:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="a330" class="mx lr it lp b gy my mz l na nb"># docker build --build-arg param1=MYNEWVALUE .</span><span id="41ad" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  2.048kB<br/>Step 1/3 : FROM debian AS build-env<br/> ---&gt; 7a4951775d15<br/>Step 2/3 : ARG param1=defaultValue<br/> ---&gt; Using cache<br/> ---&gt; 13274abd003b<br/>Step 3/3 : RUN echo $param1<br/> ---&gt; Running in 4cbc04f56883<br/><strong class="lp iu">MYNEWVALUE</strong><br/>Removing intermediate container 4cbc04f56883<br/> ---&gt; 1569fce8d8a5<br/>Successfully built 1569fce8d8a5</span></pre><h1 id="0ba9" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--cache-from</code></h1><p id="e633" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">此选项需要BuildKit后端。到目前为止，您已经注意到，当您从同一个Docker文件中重新构建一个映像时，没有任何更改，Docker将使用以前构建的缓存来加速您当前的构建。你可以从上面的例子中看到这一点，在第2/3步，Docker告诉你“<em class="nd"> - &gt;使用缓存</em>”。</p><p id="f597" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，Docker使用本地缓存，但是您也可以决定使用远程缓存，以便在您第一次构建某个映像的机器上加速映像构建。</p><p id="6122" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您正在使用<strong class="js iu">机器A </strong>，并且您正在使用以下Docker文件构建一个名为<em class="nd"> ccordeiro/cache-from </em>的Docker映像:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="af78" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>RUN apk add curl</span></pre><p id="5e88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使这个图像在<code class="fe lm ln lo lp b">--cache-from</code>选项中可用，需要用一个特殊的参数来构建它:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="85f4" class="mx lr it lp b gy my mz l na nb">$ # enable BuildKit and use the special BUILDKIT_INLINE_CACHE arg<br/>$ DOCKER_BUILDKIT=1 docker build -t ccordeiro/cache-from -f D --build-arg BUILDKIT_INLINE_CACHE=1 .</span><span id="2eb0" class="mx lr it lp b gy nc mz l na nb">[+] Building 2.5s (7/7) FINISHED<br/>=&gt; [internal] load build definition                                                                                                                                                          =&gt; =&gt; transferring dockerfile: 63B                                                                                                                                                                       =&gt; [internal] load .dockerignore                                                                                                                                                                         =&gt; =&gt; transferring context: 2B                                                                                                                                                                           =&gt; [internal] load metadata for docker.io/library/alpine:latest                                                                                                                                          =&gt; CACHED [1/2] FROM docker.io/library/alpine                                                                                                                                                            =&gt; [2/2] RUN apk add curl                                                                                                                                                                                =&gt; exporting to image                                                                                                                                                                                    =&gt; =&gt; exporting layers                                                                                                                                                                                   =&gt; =&gt; writing image sha256:bea0e1eb14c6ede29db907c262f8969f90a93f10e65aaefe57465c7d2605bbfb                                                                                                              =&gt; =&gt; naming to docker.io/ccordeiro/cache-from                                                                                                                                                           <strong class="lp iu">=&gt; exporting cache                                                                                                                                                                                       =&gt; =&gt; preparing build cache for export</strong></span><span id="f2ce" class="mx lr it lp b gy nc mz l na nb">$ # now you can push this cache image to a Docker registry<br/>$ docker push ccordeiro/cache-from</span></pre><p id="1ce1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您现在移动到<strong class="js iu">机器B </strong>，并且您有以下Dockerfile:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="9505" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>RUN apk add curl<br/>RUN apk add jq</span></pre><p id="6444" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用<em class="nd">ccordeiro/cache-from</em>Docker镜像来加速这个新镜像的构建，方法是为步骤2(<code class="fe lm ln lo lp b">curl</code>安装)使用一个缓存，即:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="814c" class="mx lr it lp b gy my mz l na nb">$ # enable BuildKit and build the image<br/>$ DOCKER_BUILDKIT=1 docker build --cache-from ccordeiro/cache-from .</span><span id="6672" class="mx lr it lp b gy nc mz l na nb">[+] Building 0.6s (8/8) FINISHED<br/>=&gt; [internal] load build definition from Dockerfile1                                                                                                                                                     =&gt; =&gt; transferring dockerfile: 92B                                                                                                                                                                       =&gt; [internal] load .dockerignore                                                                                                                                                                         =&gt; =&gt; transferring context: 2B                                                                                                                                                                           =&gt; [internal] load metadata for docker.io/library/alpine:latest                                                                                                                                          =&gt; importing cache manifest from ccordeiro/cache-from                                                                                                                                                    =&gt; [1/3] FROM docker.io/library/alpine                                                                                                                                                                   =&gt; <strong class="lp iu">CACHED</strong> [2/3] RUN apk add curl                                                                                                                                                                         =&gt; [3/3] RUN ls                                                                                                                                                                                          =&gt; exporting to image                                                                                                                                                                                    =&gt; =&gt; exporting layers                                                                                                                                                                                   =&gt; =&gt; writing image sha256:615204c4038225c2d45420a44a04cf9dcdcd01923e4c988483a90f027f668542                                                                                                              </span></pre><p id="6757" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意上面的步骤2，它是从缓存中取出的，尽管您从未在<strong class="js iu">机器B </strong>上构建过这个映像。</p><h1 id="fd4c" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--cgroup-parent</code></h1><p id="d1e7" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">无需深入研究<em class="nd"> cgroups </em>，这个构建选项只允许您为构建期间使用的容器定义一个父<em class="nd"> cgroup </em>。请注意，该选项不会将<strong class="js iu">中的</strong>表示的<em class="nd">组</em>保留在最终的Docker图像中。所以如果你想让你的容器也有一个父<em class="nd"> cgroup </em>，你仍然需要使用<code class="fe lm ln lo lp b">docker run</code>选项<code class="fe lm ln lo lp b">--cgroup-parent</code>。</p><p id="3ed1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以让我们考虑下面的Dockerfile:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="2f6b" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>RUN sleep 60</span></pre><p id="dafc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个docker文件的目标是让我们构建一个映像，并有足够的时间来实际检查这个构建所使用的运行容器。所以让我们从构建图像开始:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="673d" class="mx lr it lp b gy my mz l na nb">$ docker build -t my-alpine --cgroup-parent my-cgroup --no-cache .</span><span id="dd8f" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  4.096kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/2 : RUN sleep 60<br/> ---&gt; Running in <strong class="lp iu">8430cd382553</strong></span><span id="1e0c" class="mx lr it lp b gy nc mz l na nb"># the build will hang here for 60 seconds</span></pre><p id="a0e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这60秒睡眠期间，打开另一个终端。从上面的片段中，注意ID <strong class="js iu"> 8e3f458ebf15 </strong>。这是为我们的构建运行睡眠指令的容器的ID。所以让我们来检查一下:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="c336" class="mx lr it lp b gy my mz l na nb">$ docker inspect 8e3f458ebf15 -f '{{.HostConfig.CgroupParent}}'</span><span id="fabb" class="mx lr it lp b gy nc mz l na nb">my-cgroup</span></pre><p id="f5d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给你。您的构建容器正在使用我们在构建时指定的父组<em class="nd"> cgroup </em>。</p><h1 id="85ec" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--compress</code></h1><p id="bf11" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">当您构建Docker映像时，Docker将利用Docker文件和<strong class="js iu">上下文</strong>(无论文件和文件夹位于构建的指定路径或URL中，通常都是“.”).</p><p id="80e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构建上下文越大，完成构建所需的时间就越长，因为Docker会加载所有的上下文。</p><p id="dee3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您使用这个<code class="fe lm ln lo lp b">--compress</code>构建选项时，您基本上是在要求Docker压缩上下文，从而加快您的构建时间。让我们用这个docker文件做一个例子:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="020c" class="mx lr it lp b gy my mz l na nb">FROM alpine</span></pre><p id="9dff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们有一个大的上下文(大文件):</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="75f0" class="mx lr it lp b gy my mz l na nb">$ du -sh *<br/>4.0K Dockerfile<br/>109M big-file</span></pre><p id="f33b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果您在没有任何选项的情况下构建您的映像，您将看到如下内容:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="4a60" class="mx lr it lp b gy my mz l na nb">$ time docker build .</span><span id="f610" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  <strong class="lp iu">114.3MB</strong><br/>Step 1/1 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Successfully built d4ff818577bc</span><span id="3093" class="mx lr it lp b gy nc mz l na nb"><strong class="lp iu">real 0m10.528s<br/></strong>user 0m0.653s<br/>sys 0m0.730s</span></pre><p id="6f0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大约10秒钟建立一个超级小码头形象！这太多了，都是因为我们上下文中的一个文件，我们甚至没有使用它😛。</p><p id="e999" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们做同样的事情，但是使用<code class="fe lm ln lo lp b">--compress</code>:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="9478" class="mx lr it lp b gy my mz l na nb">$ time docker build --compress .</span><span id="a06c" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  <strong class="lp iu">12.91MB</strong><br/>Step 1/1 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Successfully built d4ff818577bc</span><span id="a3a2" class="mx lr it lp b gy nc mz l na nb"><strong class="lp iu">real</strong> <strong class="lp iu">0m4.392s</strong><br/>user 0m3.146s<br/>sys 0m0.695s</span></pre><p id="7095" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意现在的上下文大小(几乎比以前小了10倍)。这是因为Docker在将它发送到我们的构建过程之前对它进行了压缩。因此，我们将构建时间减少了50%以上。</p><h1 id="5fd1" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--cpu-period, --cpu-quota</code></h1><p id="b6cf" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">这两个选项一起使用，它们基本上允许您指定构建容器可以使用多少可用的CPU资源。</p><p id="1bce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这个例子，让我们假设你正在从你自己的docker文件(不管那是什么)构建，并且你的计算机只有一个CPU。</p><p id="ca2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您希望您Docker映像构建器只利用50%的CPU，您应该如下运行您的构建器:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="a76b" class="mx lr it lp b gy my mz l na nb">$ docker build --cpu-period=100000 --cpu-quota=50000 .</span></pre><p id="a749" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，选项的值应该以微秒为单位传递。</p><h1 id="5542" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--cpu-shares/-c</code></h1><p id="1d0e" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">只有当机器的CPU周期受限时，该选项才有意义。它基本上为您的构建容器的重量提供了一个软限制，这成比例地转化为它们对机器CPU周期的访问级别。</p><p id="76fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Docker文档为这个选项提供了一个很好的例子:</p><blockquote class="ne nf ng"><p id="e461" class="jq jr nd js b jt ju jv jw jx jy jz ka nh kc kd ke ni kg kh ki nj kk kl km kn im bi translated">例如，考虑一个具有三个以上内核的系统。如果您用运行一个进程的<code class="fe lm ln lo lp b">-c=512</code>启动一个容器<code class="fe lm ln lo lp b">{C0}</code>，用运行两个进程的<code class="fe lm ln lo lp b">-c=1024</code>启动另一个容器<code class="fe lm ln lo lp b">{C1}</code>，这会导致CPU份额的如下划分:<br/> <code class="fe lm ln lo lp b">PID | container | CPU | CPU share<br/> 100 | {C0} | 0 | 100% of CPU0<br/> 101 | {C1} | 1 | 100% of CPU1<br/> 102 | {C1} | 2 | 100% of CPU2</code></p></blockquote><h1 id="f3f7" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">-CPU set-CPU</h1><p id="7fd2" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">假设您的机器有4个CPU。对于Docker来说，这些可以通过数字来识别，从0到3。因此，如果您希望Docker在Docker映像构建期间使用一个或多个特定的CPU，您可以使用该选项，并指定要使用的CPU的范围或逗号分隔的列表。</p><p id="d90f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，假设您希望仅使用第一个CPU构建Docker映像:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="1eef" class="mx lr it lp b gy my mz l na nb">$ docker build --cpuset-cpus=0 .</span></pre><p id="988a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许您想使用第一个和第三个CPU:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="03e2" class="mx lr it lp b gy my mz l na nb">$ docker build --cpuset-cpus=0,2 .</span></pre><p id="8d82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者您可能希望使用除最后一个以外的所有CPU:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="8e6c" class="mx lr it lp b gy my mz l na nb">$ docker build --cpuset-cpus=0-2 . </span></pre><h1 id="72d9" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">- cpuset-mems</h1><p id="b315" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">对于NUMA系统，这个选项提供了与上面非常相似的东西，允许您选择在Docker构建期间使用哪些NUMA内存节点。</p><p id="8c25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，您希望将构建容器限制为仅使用第一个可用的内存节点，您应该:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="b263" class="mx lr it lp b gy my mz l na nb">$ docker build --cpuset-mems=0 .</span></pre><h1 id="c6f6" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--disable-content-trust</code></h1><p id="fc64" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">顾名思义，此选项允许您对构建中使用的图像禁用信任检查。显然，这仅适用于在DOCKER设置中启用了DOCKER_CONTENT_TRUST的情况，默认情况下<strong class="js iu">不是</strong>。</p><p id="cc7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是为了这个教程，让我们启用它并运行一个示例。对于这个例子，我们将需要使用一个无符号的Docker图像，否则，我们将无法区分(所有的Ubuntu/Alpine/等)。码头工人的图像是官方的，默认情况下是签名的)。让我们使用下面的Dockerfile，它是我的一个基本图像:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="5822" class="mx lr it lp b gy my mz l na nb">FROM ccordeiro/from-cache<br/># this is the cache image we've built above...<br/># good enough for this exercise</span></pre><p id="d32f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们确保启用了Docker_CONTENT_TRUST，并尝试从此DOCKER文件构建一个新的DOCKER映像:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="280d" class="mx lr it lp b gy my mz l na nb">$ DOCKER_CONTENT_TRUST=1 docker build .</span><span id="bea1" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon</span><span id="8f38" class="mx lr it lp b gy nc mz l na nb">error during connect: Post "<a class="ae ll" href="http://%2Fvar%2Frun%2Fdocker.sock/v1.41/build?buildargs=%7B%7D&amp;cachefrom=%5B%5D&amp;cgroupparent=&amp;cpuperiod=0&amp;cpuquota=0&amp;cpusetcpus=&amp;cpusetmems=&amp;cpushares=0&amp;dockerfile=Dockerfile&amp;labels=%7B%7D&amp;memory=0&amp;memswap=0&amp;networkmode=default&amp;rm=1&amp;shmsize=0&amp;target=&amp;ulimits=null&amp;version=1" rel="noopener ugc nofollow" target="_blank">http://%2Fvar%2Frun%2Fdocker.sock/v1.41/build?buildargs=%7B%7D&amp;cachefrom=%5B%5D&amp;cgroupparent=&amp;cpuperiod=0&amp;cpuquota=0&amp;cpusetcpus=&amp;cpusetmems=&amp;cpushares=0&amp;dockerfile=Dockerfile&amp;labels=%7B%7D&amp;memory=0&amp;memswap=0&amp;networkmode=default&amp;rm=1&amp;shmsize=0&amp;target=&amp;ulimits=null&amp;version=1</a>": Error: <strong class="lp iu">remote trust data does not exist for docker.io/ccordeiro/cache-from</strong>: notary.docker.io does not have trust data for docker.io/ccordeiro/cache-from</span></pre><p id="1a36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您所看到的，Docker会抱怨，因为它不信任Docker的基本形象。但是假设你可以信任我😬无论如何，您都想构建…您可以DOCKER_CONTENT_TRUST=0、<strong class="js iu">或</strong>:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="dd71" class="mx lr it lp b gy my mz l na nb">$ DOCKER_CONTENT_TRUST=1 docker build --disable-content-trust .</span><span id="644f" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  2.048kB<br/>Step 1/1 : FROM ccordeiro/cache-from<br/> ---&gt; bea0e1eb14c6<br/><strong class="lp iu">Successfully</strong> built bea0e1eb14c6</span></pre><p id="b02f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就这样。</p><h1 id="8574" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--file/-f</code></h1><p id="3fe1" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">这个很简单。它允许您告诉Docker在构建中使用什么Docker文件。我们知道，默认情况下，Docker会简单地将您当前路径中的任何文件命名为“Dockerfile ”,但是如果您想要使用另一个Dockerfile呢？</p><p id="4964" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们假设您有以下文件，名为“Dockerfile”:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="ac99" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>RUN echo "I am the original Dockerfile"</span></pre><p id="5504" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们假设在同一个目录中有第二个文件，叫做“旧文件”:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="d9a6" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>RUN echo "I am the old Dockerfile, with a custom filename"</span></pre><p id="02b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您只是像我们到目前为止所做的那样运行一个构建，您会得到:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="a9c8" class="mx lr it lp b gy my mz l na nb">$ docker build .</span><span id="8e2d" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  3.072kB<br/>Step 1/2 : FROM alpine<br/>---&gt; d4ff818577bc<br/><strong class="lp iu">Step 2/2 : RUN echo "I am the original Dockerfile"<br/>---&gt; Running in 69b3cb013ce1<br/>I am the original Dockerfile</strong><br/>Removing intermediate container 69b3cb013ce1<br/>---&gt; b14d64d6d99e<br/>Successfully built b14d64d6d99e</span></pre><p id="e523" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果您想从您的“旧文件”构建，您必须:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="8df5" class="mx lr it lp b gy my mz l na nb">$ docker build -f OldDockerfile .</span><span id="6a71" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  3.072kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; d4ff818577bc<br/><strong class="lp iu">Step 2/2 : RUN echo "I am the old Dockerfile, with a custom filename"<br/> ---&gt; Running in 350aaf37f180<br/>I am the old Dockerfile, with a custom filename</strong><br/>Removing intermediate container 350aaf37f180<br/> ---&gt; 39d840852b9c<br/>Successfully built 39d840852b9c</span></pre><h1 id="ae15" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--force-rm</code></h1><p id="f204" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">每当您构建Docker映像时，Docker都会创建Docker容器来执行您的Docker文件中的指令。Docker的一个很酷的故障诊断功能是，如果构建出错，Docker将不会销毁引发异常的容器。通过使用这个<code class="fe lm ln lo lp b">--force-rm</code>选项，您告诉Docker无论如何都要删除那些构建容器。</p><p id="8d78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们以下面的Dockerfile为例:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="c922" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>RUN echo Hello World</span></pre><p id="1540" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您从这个Dockerfile构建，您将看到:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="6ee9" class="mx lr it lp b gy my mz l na nb">$ docker build .</span><span id="2ac8" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  2.048kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/2 : RUN echo Hello World<br/> ---&gt; Running in 1d41f5398782<br/><strong class="lp iu">Hello World</strong><br/>Removing intermediate container 1d41f5398782<br/> ---&gt; 569b42fa341b<br/>Successfully built 569b42fa341b</span></pre><p id="4442" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为它是成功的，你会看到没有容器是这个构建遗留下来的:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="c139" class="mx lr it lp b gy my mz l na nb">$ docker ps -a</span><span id="61d4" class="mx lr it lp b gy nc mz l na nb">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span></pre><p id="1375" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果我们在Dockerfile中引入运行时错误:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="e99b" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/># echox is not a valid command<br/>RUN echox Hello World </span></pre><p id="4d49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么构建将失败:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="d0b7" class="mx lr it lp b gy my mz l na nb">$ docker build .</span><span id="9051" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  2.048kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/2 : RUN echox Hello World<br/> ---&gt; Running in 3af17dec07b4<br/><strong class="lp iu">/bin/sh: echox: not found<br/></strong>The command '/bin/sh -c echox Hello World' returned a non-zero code: <strong class="lp iu">127</strong></span></pre><p id="26dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会发现这个建筑遗留下来的一个容器:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="1675" class="mx lr it lp b gy my mz l na nb">$ docker ps -a</span><span id="a6d6" class="mx lr it lp b gy nc mz l na nb">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                        PORTS     NAMES<br/>3af17dec07b4   d4ff818577bc   "/bin/sh -c 'echox H…"   58 seconds ago   Exited (127) 58 seconds ago             affectionate_satoshi</span><span id="bb5c" class="mx lr it lp b gy nc mz l na nb">$ docker container prune  # just to clean this up</span></pre><p id="fd9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是Docker的标准行为。现在，如果您不想以这些有缺陷的容器结束，您可以在构建过程中使用<code class="fe lm ln lo lp b">--force-rm</code>选项，就像这样(使用上面相同的有缺陷的Dockerfile):</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="daf9" class="mx lr it lp b gy my mz l na nb">$ docker build --force-rm .</span><span id="a727" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  2.048kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/2 : RUN echox Hello World<br/> ---&gt; Running in 3af17dec07b4<br/>/bin/sh: echox: not found<br/>The command '/bin/sh -c echox Hello World' returned a non-zero code: 127</span><span id="6173" class="mx lr it lp b gy nc mz l na nb">$ # but this time, no leftover containers<br/>$ docker ps -a</span><span id="65ea" class="mx lr it lp b gy nc mz l na nb">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span></pre><h1 id="b6ac" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--iidfile</code></h1><p id="1a30" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">所有的Docker图片都有一个ID，对吗？这是每次构建结束时都会得到的字符串，如"<em class="nd">成功构建</em><strong class="js iu"><em class="nd">&lt;id&gt;</em></strong><em class="nd">"</em>。使用这个构建选项，为了方便起见，您可以要求Docker将ID保存到一个文件中。</p><p id="7211" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以让我们假设最简单的Dockerfile:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="bc0f" class="mx lr it lp b gy my mz l na nb">FROM alpine </span></pre><p id="8452" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后运行:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="5f8e" class="mx lr it lp b gy my mz l na nb">$ docker build --iidfile my-image-id .</span><span id="a6b4" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon  2.048kB<br/>Step 1/1 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Successfully built <strong class="lp iu">d4ff818577bc</strong></span></pre><p id="6f41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后您会在同一个目录中找到一个新文件“my-image-id ”:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="5526" class="mx lr it lp b gy my mz l na nb">$ cat my-image-id</span><span id="869d" class="mx lr it lp b gy nc mz l na nb">sha256:<strong class="lp iu">d4ff818577bc193b309b355b02ebc9220427090057b54a59e73b79bdfe139b83</strong></span></pre><h1 id="2855" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--isolation</code></h1><p id="58ed" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">如您所知，在Linux操作系统上，Docker利用内核名称空间为容器提供一个隔离层。</p><p id="9b29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，在非Linux系统(如Windows)上，您可以选择要使用的隔离技术。在这种情况下，您可以使用<code class="fe lm ln lo lp b">--isolation</code>来告诉Docker在您的映像构建期间使用哪种隔离技术。</p><p id="3e70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可接受的值为:</p><ul class=""><li id="05fd" class="nk nl it js b jt ju jx jy kb nm kf nn kj no kn np nq nr ns bi translated"><strong class="js iu">默认:【Linux用的就是这个。例如，在Windows上，该值取自Docker守护进程的配置。如果不存在，则<strong class="js iu">默认</strong>回退到<strong class="js iu">流程</strong>，</strong></li><li id="6924" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn np nq nr ns bi translated"><strong class="js iu">流程:</strong>同名称空间隔离，</li><li id="2683" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn np nq nr ns bi translated"><strong class="js iu"> hyperv: </strong> Hyper-V虚拟机管理程序隔离。</li></ul><h1 id="479f" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--label</code></h1><p id="3bd4" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">顾名思义，这个选项允许您为Docker图像设置标签。大多数Docker图像都有标签。这是一个很好的实践。例如，让我们看看现有的Docker图像:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="31a9" class="mx lr it lp b gy my mz l na nb">$ docker pull nginx <br/>$ --format '{{json .Config.Labels}}'</span><span id="49ae" class="mx lr it lp b gy nc mz l na nb">{"maintainer":"NGINX Docker Maintainers &lt;docker-maint@nginx.com&gt;"}</span></pre><p id="7068" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，图像有元数据，您可以在其中留下一些对其他开发人员和最终用户有用的附加信息。</p><p id="44b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以通过Dockerfile中的<code class="fe lm ln lo lp b">LABEL</code>指令来设置这些标签，但是也可以在构建时通过CLI来设置它们。所以让我们假设下面的Dockerfile:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="f847" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>LABEL my_dockerfile_label foo</span></pre><p id="0a7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们在没有任何额外选项的情况下构建这个映像:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="6e3e" class="mx lr it lp b gy my mz l na nb">$ docker build -t myimage .</span><span id="3e4f" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/2 : LABEL my_dockerfile_label foo<br/> ---&gt; Running in d326ccec797c<br/>Removing intermediate container d326ccec797c<br/> ---&gt; 80de62a0f1f0<br/>Successfully built 80de62a0f1f0<br/>Successfully tagged myimage:latest</span><span id="f8ed" class="mx lr it lp b gy nc mz l na nb">$ docker inspect myimage --format '{{json .Config.Labels}}'<br/><strong class="lp iu">{"my_dockerfile_label":"foo"}</strong></span></pre><p id="9f5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以看到我们的Dockerfile标签已经设置好了。但是让我们使用构建选项<code class="fe lm ln lo lp b">--label</code>再添加几个:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="392e" class="mx lr it lp b gy my mz l na nb">$ docker build -t myimage --label my_build_label=bar --label x=1 .</span><span id="2b46" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/4 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/4 : LABEL my_dockerfile_label foo<br/> ---&gt; Using cache<br/> ---&gt; 80de62a0f1f0<br/>Step 3/4 : LABEL my_build_label=bar<br/> ---&gt; Running in 789de28ba48d<br/>Removing intermediate container 789de28ba48d<br/> ---&gt; f48f1fb8f187<br/>Step 4/4 : LABEL x=1<br/> ---&gt; Running in c1483a7ac7d8<br/>Removing intermediate container c1483a7ac7d8<br/> ---&gt; 9fa6da3c3818<br/>Successfully built 9fa6da3c3818<br/>Successfully tagged myimage:latest</span><span id="cc84" class="mx lr it lp b gy nc mz l na nb">$ docker inspect myimage --format '{{json .Config.Labels}}'<br/><strong class="lp iu">{"my_build_label":"bar","my_dockerfile_label":"foo","x":"1"}</strong></span></pre><h1 id="88b8" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--memory</code></h1><p id="2bda" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">类似于上面提到的<code class="fe lm ln lo lp b">--cpu</code> *选项，该选项允许您定义映像构建可以占用的内存量的限制。</p><p id="0e25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请<strong class="js iu">注意</strong>这个选项只有在你的内核支持并且相应的内存cgroup被启用时才有效。否则，该选项将不起作用，您将在构建过程中看到如下内容:</p><blockquote class="ne nf ng"><p id="f78e" class="jq jr nd js b jt ju jv jw jx jy jz ka nh kc kd ke ni kg kh ki nj kk kl km kn im bi translated">—--&gt;[警告]您的内核不支持内存限制功能，或者未安装cgroup。取消限制。</p></blockquote><p id="4346" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管如此，让我们假设您的系统支持这个选项，让我们使用下面的docker文件</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="155d" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/># Generate some memory load<br/>RUN tail /dev/zero</span></pre><p id="d1c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在没有任何附加选项的情况下从这个docker文件构建，您会注意到构建永远不会结束(如预期的那样)，而底层构建容器会过度消耗系统资源:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="a942" class="mx lr it lp b gy my mz l na nb">$ docker build .</span></pre><p id="18f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(然后在一个单独的外壳中)</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="c328" class="mx lr it lp b gy my mz l na nb">$ docker stats</span><span id="9593" class="mx lr it lp b gy nc mz l na nb">Name: wonderful_wozniak MemPerc: 44.49% MemUsage: 1.711GiB / 3.844GiB</span></pre><p id="68e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们假设你不希望你的构建占用超过10MB的内存。然后我们做:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="6bcd" class="mx lr it lp b gy my mz l na nb">$ docker build --memory 10000000 .</span><span id="f851" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/2 : RUN tail /dev/zero<br/> ---&gt; Running in 93385ffc4a40<br/><strong class="lp iu">The command '/bin/sh -c tail /dev/zero' returned a non-zero code: 137</strong></span></pre><p id="2cef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您会注意到构建会立即退出，并出现一个奇怪的非显式错误。然而，如果你检查你的Docker系统日志，你会发现这个(或类似的):</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="8ad8" class="mx lr it lp b gy my mz l na nb">[1052731.872450] Memory cgroup out of memory: Killed process 89836 (tail) total-vm:20848kB, anon-rss:8960kB, file-rss:716kB, shmem-rss:0kB, UID:0 pgtables:80kB oom_score_adj:0</span></pre><h1 id="2d0c" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--memory-swap</code></h1><p id="1e79" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">这和上面的完全一样，只是交换内存。您可以传递“-1”来启用无限制交换。</p><h1 id="57da" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--network</code></h1><p id="e3d9" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">就像你运行一个容器一样，你也可以定义一个网络来构建图像。这意味着您的构建容器将在构建期间连接到该网络。</p><p id="44d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以让我们考虑下面的Dockerfile:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="6639" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>RUN apk add curl<br/>RUN curl http://mywebserver</span></pre><p id="65e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你所看到的，在构建过程中，我们试图用一个自定义的本地DNS名称“mywebserver”来访问某种web服务。</p><p id="f831" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出于演示目的，让我们创建这个自定义的本地web服务器:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="5157" class="mx lr it lp b gy my mz l na nb">$ docker network create my-custom-net<br/>$ docker run -d --net my-custom-net --name mywebserver nginx</span></pre><p id="6461" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果我们只是建立我们的形象，而没有任何<code class="fe lm ln lo lp b">--network</code>选项，就会出现这种情况:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="c02c" class="mx lr it lp b gy my mz l na nb">$ docker build .</span><span id="29a7" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/3 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/3 : RUN apk add curl<br/> ---&gt; Running in 0373f7596592<br/>fetch <a class="ae ll" href="https://dl-cdn.alpinelinux.org/alpine/v3.14/main/x86_64/APKINDEX.tar.gz" rel="noopener ugc nofollow" target="_blank">https://dl-cdn.alpinelinux.org/alpine/v3.14/main/x86_64/APKINDEX.tar.gz</a><br/>fetch <a class="ae ll" href="https://dl-cdn.alpinelinux.org/alpine/v3.14/community/x86_64/APKINDEX.tar.gz" rel="noopener ugc nofollow" target="_blank">https://dl-cdn.alpinelinux.org/alpine/v3.14/community/x86_64/APKINDEX.tar.gz</a><br/>(1/5) Installing ca-certificates (20191127-r5)<br/>(2/5) Installing brotli-libs (1.0.9-r5)<br/>(3/5) Installing nghttp2-libs (1.43.0-r0)<br/>(4/5) Installing libcurl (7.78.0-r0)<br/>(5/5) Installing curl (7.78.0-r0)<br/>Executing busybox-1.33.1-r2.trigger<br/>Executing ca-certificates-20191127-r5.trigger<br/>OK: 8 MiB in 19 packages<br/>Removing intermediate container 0373f7596592<br/> ---&gt; e3e65f857725<br/>Step 3/3 : RUN curl <a class="ae ll" href="http://mywebserver" rel="noopener ugc nofollow" target="_blank">http://mywebserver</a><br/> ---&gt; Running in 63ded670458d<br/>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br/>                                 Dload  Upload   Total   Spent    Left  Speed<br/>  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0curl: (6) <strong class="lp iu">Could not resolve host: mywebserver</strong><br/>The command '/bin/sh -c curl <a class="ae ll" href="http://mywebserver'" rel="noopener ugc nofollow" target="_blank">http://mywebserver'</a> returned a non-zero code: 6</span></pre><p id="da96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们正期待着呢，对吗？我们的构建容器如何找到这样的宿主呢？</p><p id="d7ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果我们让我们的构建在与之前部署的<code class="fe lm ln lo lp b">mywebserver</code> Nginx容器相同的Docker网络中运行，会怎么样？</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="a420" class="mx lr it lp b gy my mz l na nb">$ docker build --network my-custom-net .</span><span id="ca66" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/3 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/3 : RUN apk add curl<br/> ---&gt; Using cache<br/> ---&gt; e3e65f857725<br/>Step 3/3 : RUN curl mywebserver<br/> ---&gt; Running in af0f8eff84e0<br/>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br/>                                 Dload  Upload   Total   Spent    Left  Speed<br/>  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>&lt;style&gt;<br/>    body {<br/>        width: 35em;<br/>        margin: 0 auto;<br/>        font-family: Tahoma, Verdana, Arial, sans-serif;<br/>    }<br/>&lt;/style&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br/>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br/>working. Further configuration is required.&lt;/p&gt;</span><span id="b489" class="mx lr it lp b gy nc mz l na nb">&lt;p&gt;For online documentation and support please refer to<br/>&lt;a href="<a class="ae ll" href="http://nginx.org/" rel="noopener ugc nofollow" target="_blank">http://nginx.org/</a>"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br/>Commercial support is available at<br/>&lt;a href="<a class="ae ll" href="http://nginx.com/" rel="noopener ugc nofollow" target="_blank">http://nginx.com/</a>"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><span id="0df2" class="mx lr it lp b gy nc mz l na nb">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;<br/>100   612  100   612    0     0  81372      0 --:--:-- --:--:-- --:--:--   99k<br/>Removing intermediate container af0f8eff84e0<br/> ---&gt; 04ce6c5fce49<br/>Successfully built 04ce6c5fce49</span></pre><p id="9d1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们走吧！</p><h1 id="4969" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--no-cache</code></h1><p id="b4d7" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">我们已经简要讨论了构建选项<code class="fe lm ln lo lp b">--cache-from</code>的缓存机制。所以你现在可能已经注意到，当你从同一个Docker文件重建一个映像而不改变它的指令时，Docker将利用以前的构建的缓存来加速你当前的构建。</p><p id="0c93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个选项的作用是指示Docker<strong class="js iu">不要使用其缓存</strong>，即使Docker文件保持不变。示例:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="ff41" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>RUN apk add wget</span></pre><p id="78de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一次<strong class="js iu">从这个Dockerfile文件构建时，您会得到:</strong></p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="3517" class="mx lr it lp b gy my mz l na nb">$ docker build .</span><span id="d6a8" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/2 : RUN apk add wget<br/> ---&gt; Running in 4a4c1cc30b18<br/>fetch <a class="ae ll" href="https://dl-cdn.alpinelinux.org/alpine/v3.14/main/x86_64/APKINDEX.tar.gz" rel="noopener ugc nofollow" target="_blank">https://dl-cdn.alpinelinux.org/alpine/v3.14/main/x86_64/APKINDEX.tar.gz</a><br/>fetch <a class="ae ll" href="https://dl-cdn.alpinelinux.org/alpine/v3.14/community/x86_64/APKINDEX.tar.gz" rel="noopener ugc nofollow" target="_blank">https://dl-cdn.alpinelinux.org/alpine/v3.14/community/x86_64/APKINDEX.tar.gz</a><br/>(1/3) Installing libunistring (0.9.10-r1)<br/>(2/3) Installing libidn2 (2.3.1-r0)<br/>(3/3) Installing wget (1.21.1-r1)<br/>Executing busybox-1.33.1-r2.trigger<br/>OK: 8 MiB in 17 packages<br/>Removing intermediate container 4a4c1cc30b18<br/> ---&gt; 093923a789ae<br/>Successfully built 093923a789ae</span></pre><p id="c5d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，<strong class="js iu">第二次</strong>要短得多，也快得多，因为有缓存:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="3146" class="mx lr it lp b gy my mz l na nb">$ docker build .</span><span id="0002" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/2 : RUN apk add wget<br/> ---&gt; <strong class="lp iu">Using cache</strong><br/> ---&gt; 093923a789ae<br/>Successfully built 093923a789ae</span></pre><p id="2f24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以如果你不想这样，你可以使用<code class="fe lm ln lo lp b">--no-cache</code>选项，而<strong class="js iu">第三次</strong>你从它那里构建你又得到:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="cfd3" class="mx lr it lp b gy my mz l na nb">$ docker build --no-cache .</span><span id="a9a5" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; d4ff818577bc<br/>Step 2/2 : RUN apk add wget<br/> ---&gt; Running in 21533387bb7a<br/>fetch <a class="ae ll" href="https://dl-cdn.alpinelinux.org/alpine/v3.14/main/x86_64/APKINDEX.tar.gz" rel="noopener ugc nofollow" target="_blank">https://dl-cdn.alpinelinux.org/alpine/v3.14/main/x86_64/APKINDEX.tar.gz</a><br/>fetch <a class="ae ll" href="https://dl-cdn.alpinelinux.org/alpine/v3.14/community/x86_64/APKINDEX.tar.gz" rel="noopener ugc nofollow" target="_blank">https://dl-cdn.alpinelinux.org/alpine/v3.14/community/x86_64/APKINDEX.tar.gz</a><br/>(1/3) Installing libunistring (0.9.10-r1)<br/>(2/3) Installing libidn2 (2.3.1-r0)<br/>(3/3) Installing wget (1.21.1-r1)<br/>Executing busybox-1.33.1-r2.trigger<br/>OK: 8 MiB in 17 packages<br/>Removing intermediate container 21533387bb7a<br/> ---&gt; ff4325b5e414<br/>Successfully built ff4325b5e414</span></pre><h1 id="8537" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--pull</code></h1><p id="c787" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">您的构建总是有一个父映像(除非您是从<code class="fe lm ln lo lp b">scratch</code>构建的，但是我们不要去那里)。根据您使用的父映像，更新可能发生在上游，并且您的本地Docker守护进程不会获取它们，因为您已经在磁盘上有了那个映像标记。例如，每次有新的Ubuntu版本时,<code class="fe lm ln lo lp b">ubuntu:latest</code>都会在Docker Hub上更新，但是在本地，你可能仍然有6个月前发布的<code class="fe lm ln lo lp b">ubuntu:latest</code>映像。</p><p id="5ad9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe lm ln lo lp b">--pull</code>选项，您可以告诉Docker总是检查更新，并提取您试图在构建中使用的父映像。</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="549a" class="mx lr it lp b gy my mz l na nb">FROM alpine</span></pre><p id="71a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="b2cd" class="mx lr it lp b gy my mz l na nb">$ docker build --pull .</span><span id="3898" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/1 : FROM alpine<br/><strong class="lp iu">latest: Pulling from library/alpine<br/>Digest: sha256:eb3e4e175ba6d212ba1d6e04fc0782916c08e1c9d7b45892e9796141b1d379ae<br/>Status: Image is up to date for alpine:latest</strong><br/> ---&gt; 021b3423115f<br/>Successfully built 021b3423115f</span></pre><p id="5563" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">观察步骤1/1，Docker正在检查我们的“alpine”图像的更新。</p><h1 id="c28d" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--quiet</code></h1><p id="5865" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">顾名思义，通过防止Docker将最终图像ID之外的任何输出打印到您的终端，悄悄地构建您的图像。</p><p id="26f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以以下面的Dockerfile为例:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="18e4" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>RUN echo hello world</span></pre><p id="7ba7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，我们会得到:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="a7fa" class="mx lr it lp b gy my mz l na nb">$ docker build .</span><span id="e85b" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; 021b3423115f<br/>Step 2/2 : RUN echo hello world<br/> ---&gt; Running in 2ecee6b0bec0<br/><strong class="lp iu">hello world</strong><br/>Removing intermediate container 2ecee6b0bec0<br/> ---&gt; a54c702708de<br/>Successfully built a54c702708de</span></pre><p id="cd90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，通过使用此选项:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="0e67" class="mx lr it lp b gy my mz l na nb">$ docker build --quiet .</span><span id="4c1e" class="mx lr it lp b gy nc mz l na nb">sha256:a54c702708deae44841b07c858fb06e6dfea3f6cd09c2f1656aafe56c641a3af</span></pre><p id="56ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这对于编程构建非常有用，可以让您的脚本将生成的图像ID直接保存到变量中。</p><h1 id="02ab" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">--rm</code></h1><p id="348b" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">还记得上面的<code class="fe lm ln lo lp b">--force-rm</code>选项吗？这很相似，但它只适用于成功的构建。默认情况下，在成功构建之后，用于该构建的所有中间容器都将被移除。这意味着你再也看不到它们了，即使有了<code class="fe lm ln lo lp b">docker ps -a</code>。</p><p id="1c79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这已经是默认的Docker行为，所以你不需要明确这个选项……事实上，你根本不需要使用它。</p><h1 id="72ab" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">-</code>-安全-选择</h1><p id="b0f0" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">在大多数系统中，当您使用此选项时，您会发现类似以下的错误:</p><blockquote class="ne nf ng"><p id="882d" class="jq jr nd js b jt ju jv jw jx jy jz ka nh kc kd ke ni kg kh ki nj kk kl km kn im bi translated">来自守护程序的错误响应:此平台上的守护程序不支持在构建时设置安全选项</p></blockquote><p id="4b26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Docker开发人员自己声称这种选择对于构建是有限的，因为它会导致跨平台的问题。</p><p id="da15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于在运行容器时可以使用这个选项，在我看来，它不值得研究，因此我建议你跳过它(事实上，在最新的Docker构建引擎BuildKit中，这个选项甚至不再存在)。</p><h1 id="1e0e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">-</code>-shm-尺寸</h1><p id="3840" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">如果您的构建需要I/O和/或使用大量临时文件，那么您可能希望增加构建容器可以使用的共享内存，以便加快速度。</p><p id="e9a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑以下Dockerfile文件:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="d44e" class="mx lr it lp b gy my mz l na nb">FROM alpine<br/>RUN df -hk /dev/shm</span></pre><p id="99fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，默认情况下，当您构建这个时，Docker会给您64MB的共享内存:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="03ff" class="mx lr it lp b gy my mz l na nb">$ docker build --no-cache .</span><span id="a42d" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; 021b3423115f<br/>Step 2/2 : RUN df -hk /dev/shm<br/> ---&gt; Running in 43765967cbf1<br/>Filesystem                Size      Used Available Use% Mounted on<br/><strong class="lp iu">shm                      64.0M         0     64.0M   0% /dev/shm<br/></strong>Removing intermediate container 43765967cbf1<br/> ---&gt; 2da9e462a529<br/>Successfully built 2da9e462a529</span></pre><p id="f059" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，假设您需要100MB:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="7096" class="mx lr it lp b gy my mz l na nb">docker build --shm-size 100m --no-cache .</span><span id="7a04" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; 021b3423115f<br/>Step 2/2 : RUN df -hk /dev/shm<br/> ---&gt; Running in 5a3b9fff2da1<br/>Filesystem                Size      Used Available Use% Mounted on<br/><strong class="lp iu">shm                     100.0M         0    100.0M   0% /dev/shm<br/></strong>Removing intermediate container 5a3b9fff2da1<br/> ---&gt; b7563e0bd9b8<br/>Successfully built b7563e0bd9b8</span></pre><h1 id="38c9" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">-</code>-标签/-t</h1><p id="ace3" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">这可能是Docker构建中最常用的选项。它基本上通过在构建时给你的图像分配一个标签来节省一些时间，而不是在之后用命令<code class="fe lm ln lo lp b">docker tag</code>。</p><p id="be83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您有这样一个docker文件:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="30ba" class="mx lr it lp b gy my mz l na nb">FROM alpine</span></pre><p id="5cbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且您想要构建以下标签:"<em class="nd"> mylocalimage:v1" </em>和<em class="nd"> "myrepo/image:latest" </em>。你应该这样做:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="563a" class="mx lr it lp b gy my mz l na nb">$ docker build -t mylocalimage:v1 -t myrepo/image:latest .</span><span id="b151" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/1 : FROM alpine<br/> ---&gt; 021b3423115f<br/>Successfully built 021b3423115f<br/><strong class="lp iu">Successfully tagged mylocalimage:v1<br/>Successfully tagged myrepo/image:latest</strong></span></pre><h1 id="3549" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">-</code>-目标</h1><p id="981d" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">此选项仅对多阶段构建有用。因此，让我们假设下面的模拟mock文件:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="6a26" class="mx lr it lp b gy my mz l na nb">FROM alpine as stage1<br/>RUN echo stage 1<br/>RUN touch /tmp/myfile</span><span id="c105" class="mx lr it lp b gy nc mz l na nb">FROM alpine as stage2<br/>RUN echo stage 2<br/>COPY --from=stage1 /tmp/myfile /</span></pre><p id="42ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构建此映像时，所有构建阶段都将按顺序执行:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="20b4" class="mx lr it lp b gy my mz l na nb">$ docker build --no-cache .</span><span id="941c" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/6 : FROM alpine as stage1<br/> ---&gt; 021b3423115f<br/>Step 2/6 : RUN echo stage 1<br/> ---&gt; Running in 5e9de2e786c6<br/>stage 1<br/>Removing intermediate container 5e9de2e786c6<br/> ---&gt; 6eada12d7407<br/>Step 3/6 : RUN touch /tmp/myfile<br/> ---&gt; Running in dc14a0455666<br/>Removing intermediate container dc14a0455666<br/> ---&gt; a85f2471ec88<br/>Step 4/6 : FROM alpine as stage2<br/> ---&gt; 021b3423115f<br/>Step 5/6 : RUN echo stage 2<br/> ---&gt; Running in 234689881d2b<br/>stage 2<br/>Removing intermediate container 234689881d2b<br/> ---&gt; d9b11230c9a2<br/>Step 6/6 : COPY --from=stage1 /tmp/myfile /<br/> ---&gt; c55de6ea33dd<br/>Successfully built c55de6ea33dd</span></pre><p id="1d6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，有时您可能只想构建一个特定阶段:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="f1cc" class="mx lr it lp b gy my mz l na nb">$ docker build --target stage1 --no-cache .</span><span id="9e08" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/3 : FROM alpine as stage1<br/> ---&gt; 021b3423115f<br/>Step 2/3 : RUN echo stage 1<br/> ---&gt; Running in cb7f20322f89<br/>stage 1<br/>Removing intermediate container cb7f20322f89<br/> ---&gt; f3b9169b7860<br/>Step 3/3 : RUN touch /tmp/myfile<br/> ---&gt; Running in 8c1c2dc49874<br/>Removing intermediate container 8c1c2dc49874<br/> ---&gt; 153965a2d5a0<br/>Successfully built 153965a2d5a0</span></pre><p id="fb72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在这种情况下，不考虑“阶段2”。</p><p id="6542" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">请注意</strong>，如果你在这个例子中说<code class="fe lm ln lo lp b">docker build --target stage2</code>，那么“阶段1”也将在“阶段2”之前构建。</p><h1 id="ec4e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><code class="fe lm ln lo lp b">-</code>-乌利米特</h1><p id="85ee" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">If基本上允许您为构建容器设置“ulimit”标志值。该选项指定了软限制和硬限制:<code class="fe lm ln lo lp b">&lt;type&gt;=&lt;soft limit&gt;[:&lt;hard limit&gt;]</code>。因此，使用这个Dockerfile文件:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="6f4b" class="mx lr it lp b gy my mz l na nb">FROM alpine <br/>RUN ulimit -n</span></pre><p id="7643" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以证明我们的“ulimit”是由Docker设置的，如下所示:</p><pre class="kw kx ky kz gt mt lp mu mv aw mw bi"><span id="fcd1" class="mx lr it lp b gy my mz l na nb">$ docker build --ulimit nofile=2024:2024 .</span><span id="4267" class="mx lr it lp b gy nc mz l na nb">Sending build context to Docker daemon   5.12kB<br/>Step 1/2 : FROM alpine<br/> ---&gt; 021b3423115f<br/>Step 2/2 : RUN ulimit -n<br/> ---&gt; Running in 6a349b2a3c69<br/><strong class="lp iu">2024</strong><br/>Removing intermediate container 6a349b2a3c69<br/> ---&gt; ccd9b4c94333<br/>Successfully built ccd9b4c94333</span></pre></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="331e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">乌夫😅我想现在差不多就这样了。最新的Docker BuildKit提供了一些额外的选项，所以我们将在本系列的另一篇文章中介绍。</p><p id="a4d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这对你有用，并作为我的<a class="ae ll" href="https://www.udemy.com/course/docker-crash-course-learn-from-experience-for-beginners/?referralCode=BAC861F284EACA8695FD" rel="noopener ugc nofollow" target="_blank">我的Docker初学者课程</a>(附属链接)的一个很好的补充。</p></div></div>    
</body>
</html>