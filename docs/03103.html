<html>
<head>
<title>Prototypal Inheritance in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的原型继承</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/prototypal-inheritance-in-javascript-c03725a0d789?source=collection_archive---------13-----------------------#2020-04-19">https://levelup.gitconnected.com/prototypal-inheritance-in-javascript-c03725a0d789?source=collection_archive---------13-----------------------#2020-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/833cd5c55aff48d2b05b7db535c6d1a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q60IszqHud-LeY3W5XBGsw.png"/></div></div></figure><h1 id="f335" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="ab3e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">JavaScript是这个街区里最奇怪的孩子。这很奇怪，但是在我看来，这些奇怪之处使得JavaScript成为最灵活的语言。然而，许多开发人员不熟悉这些专业，这阻碍了他们编写好的代码。</p><p id="6492" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">本文是我试图阐明大多数开发人员不熟悉的JavaScript基本概念的系列文章的第一篇。</p><p id="9e0f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在这篇文章中，我将关注的主要概念是<strong class="lb iu">继承</strong>。<strong class="lb iu">继承</strong>很可能是JavaScript中最重要但被误解的概念，尤其是对于具有基于类的语言背景的开发人员来说。</p><p id="fb5e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">尽管JavaScript在<strong class="lb iu"> ES2015 </strong>中引入了类，但它并不依赖它们来实现<strong class="lb iu">继承</strong>，而是仅仅是语法上的糖。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/d79bac3ab4bafa9715e195e62a93807a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnCJdECrpSGZ9sfCEOEgFA.png"/></div></div></figure><p id="1a79" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">JavaScript类被美化为<strong class="lb iu">构造函数，</strong>并且在幕后，它们仍然使用<strong class="lb iu">原型继承</strong>。</p><h1 id="e14f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是原型继承？</h1><p id="65b4" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在JavaScript中，我们可以创建一个对象而不用定义它的类。对象也可以直接从其他对象继承属性。这个特性将JavaScript与基于类的语言区分开来，在基于类的语言中，类继承自其他类。</p><p id="4843" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在我们深入研究<strong class="lb iu">原型继承</strong>如何工作之前，让我们讨论一下对象在JavaScript中的行为。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="0592" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">JavaScript中的对象是键值对。创建对象最简单的方法是使用花括号(<strong class="lb iu">字面形式</strong>)，在花括号内定义属性和方法。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="2b6b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您可以使用<strong class="lb iu">点号</strong>在对象中查找属性。您也可以使用<strong class="lb iu">圆点国家</strong>来添加或修改属性。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="a8c4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果我们查找一个存在于对象中的属性，我们得到分配给它的值。如果我们在一个对象中查找<em class="mq">不存在</em>的属性，我们得到<code class="fe mr ms mt mu b">undefined</code>作为值。这两条规则适用于<em class="mq">，除非</em>属性存在于<strong class="lb iu">原型链</strong>中。</p><h2 id="ea4e" class="mv kc it bd kd mw mx dn kh my mz dp kl lk na nb kp lo nc nd kt ls ne nf kx ng bi translated">什么是<strong class="ak">原型链</strong>？</h2><p id="9450" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">每个对象都有一个到另一个对象的链接，称为其原型<strong class="lb iu"/>。那个对象也有一个<strong class="lb iu">原型</strong>，这一直持续到我们到达一个对象，其中<strong class="lb iu">原型</strong>是<code class="fe mr ms mt mu b">null</code>。由此产生的一系列相互连接的对象被称为<strong class="lb iu">原型链</strong>。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/a772a35e0731887c526a3f6828417fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISblNaDIenezoiVJXvbQyQ.png"/></div></div></figure><p id="ae63" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们可以使用Google DevTools来研究这种关系。如您所见，我已经创建了一个空对象，但是它只有一个名为<code class="fe mr ms mt mu b">__proto__</code>的属性，并分配了一个对象。<code class="fe mr ms mt mu b">__proto__</code>是保存对象的<strong class="lb iu">原型</strong>的键(也称为<strong class="lb iu">委托原型</strong>)。从这一点开始，我将把这个属性称为<strong class="lb iu"> [[prototype]] </strong>，因为这是标准。</p><p id="9d61" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">当我们试图访问一个对象中的属性时，将在对象本身中查找该属性，然后在它的<strong class="lb iu">原型</strong>中查找，依此类推，直到找到具有匹配名称的属性<em class="mq">或</em>，到达<strong class="lb iu">原型链</strong>的末端。一旦找到匹配的名称，查找就会终止。</p><p id="1afd" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这种行为在下面给出的例子中很明显。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7a66" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">object . setprototypeof()</strong></a><strong class="lb iu"/>将一个对象(或<code class="fe mr ms mt mu b">null</code>)设置为给定对象的<strong class="lb iu">[[原型]] </strong>。</p><p id="14d1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">由于<code class="fe mr ms mt mu b">book</code> <em class="mq">没有</em>一个名为<code class="fe mr ms mt mu b">title</code>的属性，查找委托给<strong class="lb iu"/><code class="fe mr ms mt mu b">book</code><code class="fe mr ms mt mu b">publication</code>的<strong class="lb iu">【原型】</strong>。<code class="fe mr ms mt mu b">publication</code>有一个名为<code class="fe mr ms mt mu b">title</code>的属性，因此分配给它的值将被打印到控制台。</p><p id="9486" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">因为<code class="fe mr ms mt mu b">book</code> <em class="mq">有</em>一个名为<code class="fe mr ms mt mu b">publishedYear</code>的属性，所以查找不会委托给<code class="fe mr ms mt mu b">publication</code>，分配给<code class="fe mr ms mt mu b">book.publishedYear</code>的值会打印到控制台。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e39d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">上面，你可以看到使用<a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">object . create()</strong></a><em class="mq">实现的相同场景。</em> <strong class="lb iu"> Object.create() </strong>接受一个对象(或<code class="fe mr ms mt mu b">null</code>)并将其设置为一个全新对象的<strong class="lb iu">[[原型]] </strong>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="4c00" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">Object . set prototypeof()</strong>和<strong class="lb iu">对象。当我们需要利用<strong class="lb iu">原型继承</strong>时，Create() </strong>就派上了用场。但是这两种方法对JavaScript来说都相对较新。实现<strong class="lb iu">原型继承</strong>的古老机制是使用c <strong class="lb iu">构造函数</strong>。</p><h2 id="448c" class="mv kc it bd kd mw mx dn kh my mz dp kl lk na nb kp lo nc nd kt ls ne nf kx ng bi translated">什么是构造函数？</h2><p id="fbc3" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><strong class="lb iu">构造函数</strong>是用<code class="fe mr ms mt mu b">new</code>操作符执行时初始化对象的常规函数。用<code class="fe mr ms mt mu b">new</code>关键字执行<strong class="lb iu">构造函数</strong>被称为<strong class="lb iu">构造函数调用</strong>。</p><p id="945c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在我们继续之前，有一件关于函数的事情你应该知道。</p><p id="10d7" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">所有的JavaScript函数(除了箭头函数)都有一个名为<code class="fe mr ms mt mu b">prototype</code>的内置属性。<strong class="lb iu">不要把这个属性和</strong> <a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function#Function_prototype_object" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">【原型】</strong> </a> <strong class="lb iu">混淆。</strong></p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/fcfb5df9ce9a0062d3e537650a51548e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62ztxn5Hi6xcQe9VobhOVg.png"/></div></div></figure><p id="9307" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">一个函数的<code class="fe mr ms mt mu b">prototype</code>属性，<em class="mq">除非变异</em>，有一个自己的属性，名为<code class="fe mr ms mt mu b">constructor</code>，指向函数的内存位置。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4de0" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">一个c <strong class="lb iu">构造器调用</strong>导致三件事。</p><ol class=""><li id="5f12" class="ni nj it lb b lc lx lg ly lk nk lo nl ls nm lw nn no np nq bi translated">创建了一个全新的对象。它可以是新构造的对象，也可以是函数返回的替代对象。</li><li id="ea91" class="ni nj it lb b lc nr lg ns lk nt lo nu ls nv lw nn no np nq bi translated">创建的对象被设置为该特定调用的<code class="fe mr ms mt mu b">this</code>上下文。</li><li id="ee22" class="ni nj it lb b lc nr lg ns lk nt lo nu ls nv lw nn no np nq bi translated">函数的<code class="fe mr ms mt mu b">prototype</code>属性被设置为新对象的<strong class="lb iu"> [[prototype]] </strong>。</li></ol><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="8e51" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">上面的例子结合了我们已经讨论过的所有概念来模拟一个<strong class="lb iu">继承</strong>的经典案例。</p><p id="01ef" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">为了提供对<code class="fe mr ms mt mu b">Publication</code>的属性和方法以及<code class="fe mr ms mt mu b">Book</code>的新实例的访问，我使用<strong class="lb iu">function . prototype . call()</strong>将<code class="fe mr ms mt mu b">Book</code>中的<code class="fe mr ms mt mu b">this</code>上下文传递给<code class="fe mr ms mt mu b">Publication</code>。因为<code class="fe mr ms mt mu b">Book</code>中的<code class="fe mr ms mt mu b">this</code>上下文引用了新的实例，所以<code class="fe mr ms mt mu b">Publication</code>的属性和方法被添加到其中。</p><p id="98bc" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">由于<code class="fe mr ms mt mu b">Book</code>的实例也应该能够访问驻留在<code class="fe mr ms mt mu b">Publication</code>的<strong class="lb iu"> [[prototype]] </strong>中的自定义方法，所以我使用<strong class="lb iu"> object.setPrototypeOf() </strong>到<strong class="lb iu"> </strong>链接<code class="fe mr ms mt mu b">vehicle</code>和<code class="fe mr ms mt mu b">book</code>的<strong class="lb iu"> [[prototype]] </strong>。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/43c5f2a6259ef5ba799b2f4861132d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aV9ZbrUVjR4kQv5S_2iJ5g.png"/></div></div></figure><p id="904e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们可以使用  <strong class="lb iu"> </strong>操作符的<a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">实例来验证<strong class="lb iu">构造函数</strong>的<code class="fe mr ms mt mu b">prototype</code>属性是否出现在<strong class="lb iu">原型链</strong>的任何地方。</strong></a></p><h1 id="9c12" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">概述</h1><p id="fe93" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在JavaScript中，对象可以从其他对象继承。每个对象都有一个祖先对象，这导致了一系列相互链接的对象。这个链中的对象可以访问位于它们之前的对象的属性和方法。<strong class="lb iu">object . set prototypeof()</strong>，<strong class="lb iu"> Object.create() </strong>和<strong class="lb iu">构造函数</strong>是三种方法，你可以用它们来链接对象，实现<strong class="lb iu">继承</strong>。</p><h1 id="9b90" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">下一个</h1><ul class=""><li id="609a" class="ni nj it lb b lc ld lg lh lk nw lo nx ls ny lw nz no np nq bi translated">班级和他们如何在引擎盖下工作</li><li id="e220" class="ni nj it lb b lc nr lg ns lk nt lo nu ls nv lw nz no np nq bi translated"><strong class="lb iu">串联继承</strong>(<a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">object . assign()</strong></a>，<a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">展开语法</strong> </a>等。)</li><li id="0362" class="ni nj it lb b lc nr lg ns lk nt lo nu ls nv lw nz no np nq bi translated"><strong class="lb iu">功能继承</strong> ( <strong class="lb iu">工厂功能</strong>)</li></ul><p id="f68a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">再见，注意安全！👋</p></div></div>    
</body>
</html>