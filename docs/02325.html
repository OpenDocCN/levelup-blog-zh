<html>
<head>
<title>Differentiating Logarithmic and Linearithmic Time Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区分对数和线性时间复杂度</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/differentiating-logarithmic-and-linearithmic-time-complexity-976cd49c351b?source=collection_archive---------2-----------------------#2020-03-06">https://levelup.gitconnected.com/differentiating-logarithmic-and-linearithmic-time-complexity-976cd49c351b?source=collection_archive---------2-----------------------#2020-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6f6666da4dbbd418cc04f94bdeae26d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqpHHlfkeTvU2Q6FhmIxXg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">是木头，是木头！总比不好，好！</figcaption></figure><p id="ff49" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我最近想知道时间复杂度低的算法的用例。什么时候使用具有二次时间:<code class="fe la lb lc ld b">O(n^2)</code>、多项式时间:<code class="fe la lb lc ld b">O(n^c)</code>、指数时间:<code class="fe la lb lc ld b">O(2^n)</code>或阶乘时间:<code class="fe la lb lc ld b">O(n!)</code>的算法才是合适的、更有利的？我需要做更多的研究，但是从目前我所能告诉你的来看，这些时间复杂度根本就不是<em class="le">有利的。最好避免使用它们，尤其是如果开发软件或编写程序是为了扩展，并且是出于需要或天真而使用。</em></p><p id="e4dd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我研究这个课题的过程中，我确实有所领悟:我澄清了我对对数时间:<code class="fe la lb lc ld b">O(log n)</code>和线性时间:<code class="fe la lb lc ld b">O(n log n)</code>的理解和区别。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="bf0d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">两种时间复杂度都与对数有关。在数学中，对数是一个表示某个固定数(底数)的幂的量，它必须被提升以产生一个给定的数，<em class="le">即</em>对数是某个固定数(底数)需要被相乘以产生结果的次数。</p><pre class="lm ln lo lp gt lq ld lr ls aw lt bi"><span id="8073" class="lu lv iq ld b gy lw lx l ly lz">log2(8) = 3 -&gt; "log base 2 of 8 is 3"</span><span id="21c9" class="lu lv iq ld b gy ma lx l ly lz">which is the inverse of:</span><span id="a269" class="lu lv iq ld b gy ma lx l ly lz">2^3 = 8 -&gt; "2 to the 3rd power is 8"</span></pre><p id="6c9d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对数本质上决定了指数相乘时应用于底数的指数，因此执行逆运算:<em class="le">除法</em>。具有对数和线性时间复杂度的算法都利用除法来计算数据并产生输出，但有一个关键的区别。让我们先来看看每个时间复杂度的常见实现，然后突出它们的区别。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="9c9b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对数时间复杂度的普通算法是用于二分搜索法的。想象一个程序接收一个<strong class="ke ir">排序的</strong>整数数组和一个目标整数。程序必须搜索数组以确定是否包含目标整数，并相应地输出<code class="fe la lb lc ld b">true</code>或<code class="fe la lb lc ld b">false</code>。</p><pre class="lm ln lo lp gt lq ld lr ls aw lt bi"><span id="762c" class="lu lv iq ld b gy lw lx l ly lz"><em class="le">(JavaScript)</em></span><span id="84c4" class="lu lv iq ld b gy ma lx l ly lz">const arr = [1, 3, 4, 6, 12, 32, 43, 45, 78, 98]</span><span id="04ea" class="lu lv iq ld b gy ma lx l ly lz">function binarySearch(arr, num) {<br/>  let begin = 0<br/>  let end = arr.length - 1</span><span id="f531" class="lu lv iq ld b gy ma lx l ly lz">  while (begin &lt;= end) {<br/>    let mid = Math.floor((begin + end) / 2)<br/>    let aNum = arr[mid]</span><span id="6592" class="lu lv iq ld b gy ma lx l ly lz">    if (num === aNum) return true<br/>    if (num &gt; aNum) begin = mid + 1<br/>    if (num &lt; aNum) end = mid - 1<br/>  }<br/>  return false<br/>}</span><span id="61ff" class="lu lv iq ld b gy ma lx l ly lz">////////////////////////////////////////////////////////////////////</span><span id="6b14" class="lu lv iq ld b gy ma lx l ly lz">binarySearch(arr, 100)<br/>//=&gt; false</span><span id="1422" class="lu lv iq ld b gy ma lx l ly lz">////////////////////////////////////////////////////////////////////</span><span id="b775" class="lu lv iq ld b gy ma lx l ly lz">binarySearch(arr, 12)<br/>//=&gt; true</span></pre><p id="d68d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">与连续评估每个元素的线性时间(<code class="fe la lb lc ld b">O(n)</code>)方法相反，这种对数时间(<code class="fe la lb lc ld b">O(log n)</code>)方法通过建立数组的开始、中间和结束索引，然后<em class="le">在中间索引处将数组分成两半</em>，更有效地确定目标整数是否包括在数组中；如果中间索引处的元素等于目标整数，则返回<code class="fe la lb lc ld b">true</code>，或者确定目标整数是小于还是大于中间索引处的元素。根据评估结果，可能包含目标整数的数组的一半被回收，另一半被丢弃(放入一个大头针！).<code class="fe la lb lc ld b">while loop</code>重复这种模式，开始、中间和结束索引被重新分配给回收的那一半。循环继续进行，直到找到目标整数，或者终止并前进到函数的默认返回值:<code class="fe la lb lc ld b">false</code>，这意味着目标整数不包含在数组中。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="d1c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">线性时间复杂度的常见算法是用于合并排序。假设一个程序接收一个整数数组，并返回排序后的数组。当然也有类似<code class="fe la lb lc ld b">Array.sort()</code>的内置，但是不同的浏览器或者程序在不同的情况下，出于不同的原因，可以使用不同的算法。像合并排序这样的算法是高效的，并且在规模上更有性能。</p><pre class="lm ln lo lp gt lq ld lr ls aw lt bi"><span id="741f" class="lu lv iq ld b gy lw lx l ly lz"><em class="le">(JavaScript)</em></span><span id="f723" class="lu lv iq ld b gy ma lx l ly lz">const arr = [9, 56, 3, 47, 8, 23, 1, 5, 20]</span><span id="3368" class="lu lv iq ld b gy ma lx l ly lz">// auxiliary function</span><span id="416c" class="lu lv iq ld b gy ma lx l ly lz">function merge(arr1, arr2) {<br/>  const mergedArr = []</span><span id="ba24" class="lu lv iq ld b gy ma lx l ly lz">  while (arr1.length &gt; 0 &amp;&amp; arr2.length &gt; 0) {<br/>    arr1[0] &lt; arr2[0] ?<br/>      mergedArr.push(arr1.shift()) :<br/>        mergedArr.push(arr2.shift())<br/>  }<br/>  return [...mergedArr, ...arr1, ...arr2]<br/>}</span><span id="d04d" class="lu lv iq ld b gy ma lx l ly lz">// primary function</span><span id="8f35" class="lu lv iq ld b gy ma lx l ly lz">function mergeSort(arr) {<br/>  const midIdx = arr.length / 2<br/>  const spanA = arr.slice(0, midIdx)<br/>  const spanB = arr.slice(midIdx, arr.length)</span><span id="dfcb" class="lu lv iq ld b gy ma lx l ly lz">  if (arr.length === 1) return arr</span><span id="818a" class="lu lv iq ld b gy ma lx l ly lz">  const sortedArr = merge(mergeSort(spanA), mergeSort(spanB))</span><span id="3dd3" class="lu lv iq ld b gy ma lx l ly lz">  return sortedArr<br/>}</span><span id="ff36" class="lu lv iq ld b gy ma lx l ly lz">////////////////////////////////////////////////////////////////////</span><span id="2ca6" class="lu lv iq ld b gy ma lx l ly lz">mergeSort(arr)<br/>//=&gt; [1, 3, 5, 8, 9, 20, 23, 47, 56]</span></pre><p id="3837" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="le">*注8/11/20:我注意到在辅助</em> <code class="fe la lb lc ld b">merge()</code> <em class="le">函数的while循环中使用</em> <code class="fe la lb lc ld b">Array.prototype.shift()</code> <em class="le">表示二次运算，暗示这个具体归并排序例子的实际时间复杂度是</em> <code class="fe la lb lc ld b">O(n² log n)</code> <em class="le">。我不确定使用shift方法的影响——有一些有趣的细节需要考虑——但是我添加了一个替代代码示例作为本文的附录，它使用索引计数器代替shift方法，以提供一个具有线性时间复杂度的明确示例。</em></p><p id="07ff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种线性时间(<code class="fe la lb lc ld b">O(n log n)</code>)方法是线性时间(<code class="fe la lb lc ld b">O(n)</code>)和对数时间(<code class="fe la lb lc ld b">O(log n)</code>)的组合。<code class="fe la lb lc ld b">mergeSort</code>函数利用指示对数时间复杂度的除法。注意与二分搜索法算法的相似之处，其中输入被重复地分成两半，<em class="le">，例如</em> <code class="fe la lb lc ld b">spanA</code>和<code class="fe la lb lc ld b">spanB</code>。递归被用来进一步划分每一半，在每一步，辅助函数<code class="fe la lb lc ld b">merge</code>被用来将结果<code class="fe la lb lc ld b">sub-Array</code>按排序顺序重新组合。<code class="fe la lb lc ld b">merge</code>函数和递归的时间复杂度是线性的:<code class="fe la lb lc ld b">O(n)</code>。与<code class="fe la lb lc ld b">mergeSort</code>函数中的对数时间配对，合并排序算法的最终评估是线性时间:<code class="fe la lb lc ld b">O(n log n)</code>。我见过这种描述的一种简化方式是<code class="fe la lb lc ld b">O(n * log(n))</code>、<em class="le">即</em>“做<code class="fe la lb lc ld b">log(n)</code>工作<code class="fe la lb lc ld b">n</code>次”。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="6d56" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对数时间复杂度和线性时间复杂度都使用对数并划分数据，但是请注意上面解释的两种算法之间的关键区别。当二分搜索法算法继续划分输入时，每次运算都有一半的输入被丢弃，重复地将待评估的数据量减半。合并排序算法重复地将输入减半，但是<em class="le">保留了</em>的两半并合并了排序后的<code class="fe la lb lc ld b">sub-Array</code>。保留并返回输入的完整长度的数据是必要的。</p><p id="dc5c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些时间复杂度的性能如何比较？</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/b38b449b177a1794c93ec69985b3f251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCbivj65Dc1De8DuhvftZg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">阿德里安·梅希亚<a class="ae mc" href="https://adrianmejia.com/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/" rel="noopener ugc nofollow" target="_blank">的一篇文章中的大O时间复杂性的图形表示</a></figcaption></figure><p id="0707" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对数时间(<code class="fe la lb lc ld b">O(log n)</code>)是时间复杂性的<em class="le">粉吐司人</em>。它是高性能和高度赞扬。它偏离恒定时间不远(<code class="fe la lb lc ld b">O(1)</code>)。它比线性时间快。</p><p id="e640" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">线性时间(<code class="fe la lb lc ld b">O(n log n)</code>)是时间复杂性的<em class="le">泥巴弹涂鱼</em>——最好的中的最坏的(尽管，没那么灰暗和表里不一)。这是一个中等的复杂度，在线性时间(<code class="fe la lb lc ld b">O(n)</code>)左右浮动，直到输入达到高级大小。它比对数时间慢，但比不太有利的、低性能的时间复杂性快。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="9354" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这篇文章是关于来自BLAMMO的满载日志的时间复杂性的！</p><p id="44c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">【github.com/dangrammer<br/><a class="ae mc" href="https://www.linkedin.com/in/danieljromans/" rel="noopener ugc nofollow" target="_blank">linked.com/in/danieljromans</a><br/><a class="ae mc" href="http://danromans.com/" rel="noopener ugc nofollow" target="_blank">danromans.com</a></p><h2 id="de68" class="lu lv iq bd md me mf dn mg mh mi dp mj kn mk ml mm kr mn mo mp kv mq mr ms mt bi translated">附录:</h2><p id="a801" class="pw-post-body-paragraph kc kd iq ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated">不使用shift方法的替代合并排序示例:</p><pre class="lm ln lo lp gt lq ld lr ls aw lt bi"><span id="4cf5" class="lu lv iq ld b gy lw lx l ly lz">// auxiliary function</span><span id="4dfe" class="lu lv iq ld b gy ma lx l ly lz">function merge(arr1, arr2) {<br/>  const mergedArr = []<br/>  let i = 0<br/>  let j = 0</span><span id="6a1f" class="lu lv iq ld b gy ma lx l ly lz">  while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) {<br/>    if (arr1[i] &lt; arr2[j]) {<br/>      mergedArr.push(arr1[i])<br/>      i++<br/>    } else {<br/>      mergedArr.push(arr2[j])<br/>      j++<br/>    }<br/>  }</span><span id="a90c" class="lu lv iq ld b gy ma lx l ly lz">  return arr1[i] ?<br/>    mergedArr.concat(arr1.slice(i)) :<br/>      mergedArr.concat(arr2.slice(j))<br/>}</span><span id="6da1" class="lu lv iq ld b gy ma lx l ly lz">// primary function</span><span id="b2ae" class="lu lv iq ld b gy ma lx l ly lz">function mergeSort(arr) {<br/>  const midIdx = arr.length / 2<br/>  const spanA = arr.slice(0, midIdx)<br/>  const spanB = arr.slice(midIdx, arr.length)</span><span id="5340" class="lu lv iq ld b gy ma lx l ly lz">  if (arr.length === 1) return arr<br/>  const sortedArr = merge(mergeSort(spanA), mergeSort(spanB))</span><span id="c437" class="lu lv iq ld b gy ma lx l ly lz">  return sortedArr<br/>}</span></pre></div></div>    
</body>
</html>