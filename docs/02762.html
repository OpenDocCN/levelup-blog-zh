<html>
<head>
<title>Conquering Derived State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">征服派生状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/conquering-derived-state-57087036b230?source=collection_archive---------5-----------------------#2020-04-03">https://levelup.gitconnected.com/conquering-derived-state-57087036b230?source=collection_archive---------5-----------------------#2020-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4103" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何识别和替换React组件中的派生状态</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1a18ca52418dddc14731cc2b522af340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZGNagmTNsfoKpQET"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@mavrick?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">里卡多·克鲁斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="11d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章最初发表在我的博客上<a class="ae kv" href="https://mskelton.dev/blog/conquering-derived-state" rel="noopener ugc nofollow" target="_blank">。看看我的其他文章吧！</a></p><p id="5dd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几周前，我在Widen的前端开发同事就我们的一个共享React组件进行了一次谈话，我们正在努力在我们的一个应用程序中实现该组件。虽然大多数React组件是完全受控的(通过props)或完全不受控的(内部状态)，但该组件使用了所谓的“派生状态”，即在某种程度上由props控制的内部状态。虽然派生状态看起来是一个好的解决方案，但是它经常会导致比它试图解决的问题更多的问题。</p><p id="cb2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在本文中的目标并不是说服您应该避免派生状态。React有一篇关于派生状态的极好的<a class="ae kv" href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" rel="noopener ugc nofollow" target="_blank">博客文章，它很好地解释了为什么派生状态是一种反模式。本文的重点将是关于如何识别组件中的派生状态以及派生状态的几种替代方案。</a></p><h1 id="9498" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">识别派生状态</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/97e6242af3d5e1625dbd1fe4c55a5f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n4qYLnca_ckHysdj"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@olloweb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">通讯社跟随</a>于<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="48e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我继续之前，让我提供几个派生状态的例子来帮助您开始识别派生状态模式。我将从基于类的组件开始，因为它们比基于函数的组件更容易识别。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="2f38" class="mq lt iq mm b gy mr ms l mt mu">class PartiallyControlledInput extends React.Component {<br/>  state = {<br/>    value: this.props.value,<br/>  };</span><span id="9136" class="mq lt iq mm b gy mv ms l mt mu">  componentWillReceiveProps(nextProps) {<br/>    if (nextProps.value !== this.props.value) {<br/>      this.setState({ value: nextProps.value });<br/>    }<br/>  }</span><span id="ba7f" class="mq lt iq mm b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;input<br/>        onChange={(e) =&gt; this.setState({ value: e.target.value })}<br/>        value={this.state.value}<br/>      /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="322a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们有一个部分受控输入字段的组件。组件在内部管理它的状态，但是它也允许父组件通过改变<code class="fe mw mx my mm b">value</code>属性来更新状态。这个例子的关键部分是<code class="fe mw mx my mm b">componentWillReceiveProps</code>,它是一个红色的标志，表示组件的状态来自于props。</p><p id="7235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为<code class="fe mw mx my mm b">componentWillReceiveProps</code>已经被弃用，React有了一个更新的生命周期方法，名为<code class="fe mw mx my mm b">getDerivedStateFromProps</code>。这个方法几乎不需要例子，因为它的名字就说明了一切，但是一个简单的例子不会有什么坏处。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="dd9d" class="mq lt iq mm b gy mr ms l mt mu">class PartiallyControlledInput extends React.Component {<br/>  state = {<br/>    value: this.props.value,<br/>    prevFormId: this.props.formId,<br/>  };</span><span id="e4f0" class="mq lt iq mm b gy mv ms l mt mu">  static getDerivedStateFromProps(props, state) {<br/>    if (props.formId !== state.prevFormId) {<br/>      return {<br/>        prevFormId: props.formId,<br/>        value: props.value,<br/>      };<br/>    }</span><span id="7280" class="mq lt iq mm b gy mv ms l mt mu">    return null;<br/>  }</span><span id="7427" class="mq lt iq mm b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;input<br/>        onChange={(e) =&gt; this.setState({ value: e.target.value })}<br/>        value={this.state.value}<br/>      /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="4c8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，<code class="fe mw mx my mm b">getDerivedStateFromProps</code>变得更加复杂，因为我们需要在状态中存储一个属性值，所以当属性改变时，我们可以基于属性重置状态。</p><p id="c4cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着我们转向基于功能的组件，派生状态有点难以识别，因为你必须寻找的不仅仅是<code class="fe mw mx my mm b">componentWillReceiveProps</code>或<code class="fe mw mx my mm b">getDerivedStateFromProps</code>。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="9a6e" class="mq lt iq mm b gy mr ms l mt mu">function PartiallyControlledInput(props) {<br/>  const [value, setValue] = useState(props.value);</span><span id="96e9" class="mq lt iq mm b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    setValue(props.value)<br/>  }, [props.value])</span><span id="7a21" class="mq lt iq mm b gy mv ms l mt mu">  return (<br/>    &lt;input<br/>      onChange={(e) =&gt; setValue(e.target.value)}<br/>      value={value}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="4b39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，前面的例子是派生状态的一个更微妙的用法。当<code class="fe mw mx my mm b">props.value</code>改变时，将运行一个效果，用新的属性值设置输入值。这与我们上面展示的第一个例子本质上是相同的，并且遭受完全相同的问题。仅仅因为它是用钩子编写的，并不意味着它比基于类的等价类神奇地更好！</p><h1 id="9095" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">派生状态的替代方案</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/80fb6c04a70caa23ce93fd1154bec56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hWj0pElVxnhsMKev"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Javier Allegue Barros<a class="ae kv" href="https://unsplash.com/@soymeraki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ddd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经看到了派生状态的一些例子，让我们来看看一些替代的解决方案。</p><h2 id="93c5" class="mq lt iq bd lu na nb dn ly nc nd dp mc lf ne nf me lj ng nh mg ln ni nj mi nk bi translated">带钥匙的完全不受控制的组件</h2><p id="c1c5" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">第一种选择是使组件完全不受控制，并使用React的特殊<code class="fe mw mx my mm b">key</code>道具，这将创建组件的一个新实例，而不是更新现有的实例。这包括用提供的初始值重新初始化组件状态。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="6b9c" class="mq lt iq mm b gy mr ms l mt mu">function FullyUncontrolledInput({ initialValue }) {<br/>  const [value, setValue] = useState(initialValue);</span><span id="1954" class="mq lt iq mm b gy mv ms l mt mu">  return (<br/>    &lt;input<br/>      onChange={(e) =&gt; setValue(e.target.value)}<br/>      value={value}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="a66b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用这个组件，我们只需要提供一个<code class="fe mw mx my mm b">initialValue</code>道具和一个<code class="fe mw mx my mm b">key</code>道具。要重新初始化输入的内部状态，我们只需更改<code class="fe mw mx my mm b">key</code>。在下面的代码块中，我们使用了一个名为<code class="fe mw mx my mm b">formId</code>的变量，当表单需要重置时，我们可以更改这个变量。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="33e6" class="mq lt iq mm b gy mr ms l mt mu">function Form() {<br/>  return (<br/>    &lt;FullyUncontrolledInput key={formId} initialValue="Initial" /&gt;<br/>  )<br/>}</span></pre><h2 id="c523" class="mq lt iq bd lu na nb dn ly nc nd dp mc lf ne nf me lj ng nh mg ln ni nj mi nk bi translated">完全受控组件</h2><p id="1863" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">下一个选项是让输入完全受控，并让父组件管理其状态。该选项要求我们向输入组件添加一个<code class="fe mw mx my mm b">onChange</code>属性，这样父组件就可以监听变化并相应地更新状态。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3b7c" class="mq lt iq mm b gy mr ms l mt mu">function FullyControlledInput({ value, onChange }) {<br/>  return (<br/>    &lt;input<br/>      onChange={(e) =&gt; onChange(e.target.value)}<br/>      value={value}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="707e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了完全受控的输入组件，我们现在可以向表单组件添加一个简单的<code class="fe mw mx my mm b">useState</code>钩子来管理输入的状态。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="1d6f" class="mq lt iq mm b gy mr ms l mt mu">function Form() {<br/>  const [value, setValue] = useState("Initial");</span><span id="4085" class="mq lt iq mm b gy mv ms l mt mu">  return (<br/>    &lt;FullyControlledInput onChange={setValue} value={value} /&gt;<br/>  );<br/>}</span></pre><h2 id="ab57" class="mq lt iq bd lu na nb dn ly nc nd dp mc lf ne nf me lj ng nh mg ln ni nj mi nk bi translated">定制挂钩！</h2><p id="12bb" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">虽然前面的例子听起来像是简单的解决方案，但是许多真实世界的组件要比那些简单的例子复杂得多。在这些情况下，创建一个定制挂钩可能正是您在没有大量样板文件的情况下实现高级定制所需要的。</p><p id="001e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，考虑一个日期选择器组件，它接受当前所选日期和月份的属性，以及当用户更改日期或月份时的事件处理程序。与其让表单组件管理所有的状态和事件处理程序，不如将该逻辑包装在一个自定义的<code class="fe mw mx my mm b">useDatePicker</code>钩子中！</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="d3ad" class="mq lt iq mm b gy mr ms l mt mu">function useDatePicker(initialValues = { day: 1, month: "Jan" }) {<br/>  const [month, setMonth] = useState(initialValues.month);<br/>  const [day, setDay] = useState(initialValues.day);</span><span id="60c0" class="mq lt iq mm b gy mv ms l mt mu">  return {<br/>    datePickerProps: {<br/>      day,<br/>      month,<br/>      onDayChange: setDay,<br/>      onMonthChange: setMonth,<br/>    },<br/>    day,<br/>    month,<br/>    setDay,<br/>    setMonth,<br/>  };<br/>}</span></pre><p id="4598" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以很容易地调用表单组件中的<code class="fe mw mx my mm b">useDatePicker</code>钩子，并将<code class="fe mw mx my mm b">datePickerProps</code>传递给日期选择器组件，该组件将添加管理组件状态所需的所有属性。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="377c" class="mq lt iq mm b gy mr ms l mt mu">function Form() {<br/>  const { datePickerProps, day, month } = useDatePicker();</span><span id="0269" class="mq lt iq mm b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    // Do something when day or month changes<br/>  }, [day, month]);</span><span id="d40e" class="mq lt iq mm b gy mv ms l mt mu">  return &lt;DatePicker {...datePickerProps} theme="dark" /&gt;;<br/>}</span></pre><p id="5d18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为挂钩不直接绑定到组件，所以我们可以实现高级别的定制。例如，如果我们想在天气变化时触发一些副作用，我们可以简单地添加一个依赖于<code class="fe mw mx my mm b">day</code>变量的<code class="fe mw mx my mm b">useEffect</code>钩子。或者，如果我们需要定制<code class="fe mw mx my mm b">onDayChange</code>逻辑，我们可以用定制的<code class="fe mw mx my mm b">onDayChange</code>属性覆盖<code class="fe mw mx my mm b">datePickerProps</code>中返回的属性。我们甚至可以在表单组件中创建一个reset按钮，单击该按钮，使用<code class="fe mw mx my mm b">setDay</code>和<code class="fe mw mx my mm b">setMonth</code>函数将日期选择器重置为当前日期。可能性是无穷无尽的，所以发挥你的想象力，想出一些伟大的东西！</p></div></div>    
</body>
</html>