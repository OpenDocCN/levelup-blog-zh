<html>
<head>
<title>Proper Ways to Clone an Object in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中克隆对象的正确方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/proper-ways-to-clone-an-object-in-javascript-c7dc41bab96c?source=collection_archive---------14-----------------------#2020-07-22">https://levelup.gitconnected.com/proper-ways-to-clone-an-object-in-javascript-c7dc41bab96c?source=collection_archive---------14-----------------------#2020-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a0d6bcdcee3ef9372528237284bdcbd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3MBOGQB4P2dtrBud"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@bedeviere?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Bimata Prathama </a>在<a class="ae kf" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="92f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript中的对象是引用值，可以存储复杂的键值属性。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c5c0" class="ln lo it lj b gy lp lq l lr ls">let story = {<br/>    title: 'Proper Ways to Copy(Clone) an Object in JavaScript',<br/>    author:{<br/>            name:'pkoulianos',<br/>            email:'petran@pkoulianos.com'<br/>    },<br/>    tags:['Javascript','programming']<br/>};</span></pre><p id="95a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">复制一个对象可能有点棘手。但是不要担心，在这个故事中，我们将介绍如何以适当的方式复制一个对象。</p><h1 id="3b73" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">1.致命的😡复制对象的方式</h1><p id="6740" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">尝试复制对象的一个致命方法是使用赋值<code class="fe mv mw mx lj b">=</code>操作符。原因是赋值操作符只会将引用传递给新变量。</p><p id="3ece" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个简单的例子</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e667" class="ln lo it lj b gy lp lq l lr ls">let car1 = { color:’white’, type:’4X4' };// fatal way to copy an object<br/>let car2 = car1;//change the color property</span><span id="cd5d" class="ln lo it lj b gy my lq l lr ls">car2.color = ‘red’;</span><span id="f767" class="ln lo it lj b gy my lq l lr ls">console.log(car1);<br/><strong class="lj iu">// { color: 'red', type: '4X4' }</strong></span><span id="812f" class="ln lo it lj b gy my lq l lr ls">console.log(car2);<br/><strong class="lj iu">// { color: 'red', type: '4X4' }</strong></span></pre><p id="e009" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们创建了一个新的对象<code class="fe mv mw mx lj b">car1</code>，并用<code class="fe mv mw mx lj b">=</code>操作符将它复制到一个新的变量<code class="fe mv mw mx lj b">car2</code>中，并且我们改变了颜色属性。打印两个对象我们可以看到是相同的，原因是<code class="fe mv mw mx lj b">car1</code>和<code class="fe mv mw mx lj b">car2</code>都有相同的对象引用。</p><h1 id="0c7d" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">2.得到一个浅薄的💧复制</h1><blockquote class="mz na nb"><p id="da95" class="kg kh nc ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank"><em class="it"/></a><em class="it">浅复制将所有</em> <a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable" rel="noopener ugc nofollow" target="_blank"> <em class="it">可枚举的</em> </a> <em class="it"> </em> <a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" rel="noopener ugc nofollow" target="_blank"> <em class="it">自身属性</em> </a> <em class="it">从源对象复制到目标对象。</em></p></blockquote><p id="18b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单来说，肤浅的复制<strong class="ki iu">不会真正复制</strong>:</p><ol class=""><li id="2197" class="ng nh it ki b kj kk kn ko kr ni kv nj kz nk ld nl nm nn no bi translated">数组、集合等</li><li id="3555" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">内部对象</li></ol><p id="c554" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe mv mw mx lj b">Object.assign()</code>获得浅拷贝</p><p id="6ac9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx lj b">Object.assign()</code>会给你一个目标对象的浅层拷贝:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="fbd2" class="ln lo it lj b gy lp lq l lr ls">let post = {<br/>   title:'How to copy objects in JS',<br/>   tags:['js','js-basics','programming'],<br/>   date: new Date(),<br/>   author:{<br/>         name:'petros',<br/>         email:'petran@pkoulianos.com'<br/>   },<br/>   getAuthorData: function(){<br/>              return this.author.name+'-'+this.author.email;<br/>   }<br/>};let newPost = Object.assign({},post);<br/>newPost.title = 'I love js'<br/>newPost.tags[0] = 'web-programming'<br/>newPost.author.name = 'Petran';<br/>newPost.date = new Date(1970);console.log(post);<br/>console.log(newPost);//console output<br/>{ title: 'How to copy objects in JS',<br/>  tags: [ 'web-programming', 'js-basics', 'programming' ],<br/>  date: 2020-07-21T18:48:29.112Z,<br/>  author: { name: 'Petran', email: '<a class="ae kf" href="mailto:petran@pkoulianos.com" rel="noopener ugc nofollow" target="_blank">petran@pkoulianos.com</a>' },<br/>  getAuthorData: [Function: getAuthorData] }<br/>{ title: 'I love js',😀<br/>  tags: [ 'web-programming', 'js-basics', 'programming' ],😂<br/>  date: 1970-01-01T00:00:01.970Z,😀<br/>  author: { name: 'Petran', email: '<a class="ae kf" href="mailto:petran@pkoulianos.com" rel="noopener ugc nofollow" target="_blank">petran@pkoulianos.com</a>' },😂<br/>  getAuthorData: [Function: getAuthorData] }😀</span></pre><p id="a1b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们创建了一个新的对象<code class="fe mv mw mx lj b">post</code>，并用<code class="fe mv mw mx lj b">Object.assign()</code>将它复制到一个新的变量<code class="fe mv mw mx lj b">newPost</code>中，并且我们改变了所有的属性。打印两个对象我们可以看到，浅拷贝<code class="fe mv mw mx lj b">newPost</code>正确地拷贝了<code class="fe mv mw mx lj b">title</code>、<code class="fe mv mw mx lj b">date</code>和<code class="fe mv mw mx lj b">getAuthorData</code>，但是<code class="fe mv mw mx lj b">tags</code>和<code class="fe mv mw mx lj b">author</code>被引用通过。</p><h1 id="35e7" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">用… Spread运算符获得浅层副本</h1><p id="1a94" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">spread操作符还会得到目标对象的一个浅层副本:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2200" class="ln lo it lj b gy lp lq l lr ls">/ *** / <br/><strong class="lj iu">let newPost = {...post}</strong><br/>/ *** /<br/>console.log(post);<br/>console.log(newPost);//console output</span><span id="5cb6" class="ln lo it lj b gy my lq l lr ls">{ title: 'How to copy objects in JS',<br/>  tags: [ 'web-programming', 'js-basics', 'programming' ],<br/>  date: 2020-07-21T18:48:29.112Z,<br/>  author: { name: 'Petran', email: '<a class="ae kf" href="mailto:petran@pkoulianos.com" rel="noopener ugc nofollow" target="_blank">petran@pkoulianos.com</a>' },<br/>  getAuthorData: [Function: getAuthorData] }</span><span id="77e1" class="ln lo it lj b gy my lq l lr ls">{ title: 'I love js',<br/>  tags: [ 'web-programming', 'js-basics', 'programming' ],<br/>  date: 1970-01-01T00:00:01.970Z,<br/>  author: { name: 'Petran', email: '<a class="ae kf" href="mailto:petran@pkoulianos.com" rel="noopener ugc nofollow" target="_blank">petran@pkoulianos.com</a>' },<br/>  getAuthorData: [Function: getAuthorData] }</span></pre><h1 id="2e0f" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">3.深入了解🌊复制</h1><p id="f06b" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">一个对象的深层拷贝将解决获得内部对象和数组、集合等的正确拷贝的秘密，但是日期对象将被转换成字符串，函数将根本不会被拷贝。</p><p id="7576" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过使用JSON对象获得深层副本。</p><p id="ec89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx lj b"><strong class="ki iu">let targetObj = JSON.parse(JSON.stringify(sourceObj));</strong></code></p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1fbd" class="ln lo it lj b gy lp lq l lr ls">/ *** / <br/>let newPost = JSON.parse(JSON.stringify(post));<br/>/ *** /<br/>console.log(post);<br/>console.log(newPost);//console output<br/>{ title: 'How to copy objects in JS',<br/>  tags: [ 'js', 'js-basics', 'programming' ],<br/>  date: 2020-07-21T18:54:35.964Z,<br/>  author: { name: 'petros', email: '<a class="ae kf" href="mailto:petran@pkoulianos.com" rel="noopener ugc nofollow" target="_blank">petran@pkoulianos.com</a>' },<br/>  getAuthorData: [Function: getAuthorData] }<br/>{ title: 'I love js',<br/>  tags: [ 'web-programming', 'js-basics', 'programming' ],<br/>  date: <strong class="lj iu">'2020-07-21T18:54:35.964Z'</strong>,😂<br/>  author: { name: 'Petran', email: '<a class="ae kf" href="mailto:petran@pkoulianos.com" rel="noopener ugc nofollow" target="_blank">petran@pkoulianos.com</a>' } }</span></pre><p id="d313" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">打印这两个对象我们可以看到深度副本<code class="fe mv mw mx lj b">newPost</code>正确地复制了<code class="fe mv mw mx lj b">title</code>、<code class="fe mv mw mx lj b">tags</code>和<code class="fe mv mw mx lj b">author</code>，但是<code class="fe mv mw mx lj b">date</code>被转换为一个字符串，而<code class="fe mv mw mx lj b">getAuthorData</code>根本没有被复制。</p><h1 id="ba2a" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">5.结论</h1><p id="a974" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">浅拷贝和深拷贝各有利弊。在我们决定哪个副本是正确的之前，我们必须确定对象的属性。</p><h1 id="defd" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">参考</h1><ul class=""><li id="2dfc" class="ng nh it ki b kj mq kn mr kr nu kv nv kz nw ld nx nm nn no bi translated"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Object/assign</a></li></ul><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div></div>    
</body>
</html>