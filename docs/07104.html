<html>
<head>
<title>gRPC: How to Make Server Streaming Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC:如何进行服务器流调用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/grpc-how-to-make-server-streaming-calls-763b42895481?source=collection_archive---------10-----------------------#2021-01-25">https://levelup.gitconnected.com/grpc-how-to-make-server-streaming-calls-763b42895481?source=collection_archive---------10-----------------------#2021-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/55abee5202743d06d858cec817d916e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oL7etuMhPm4lERBRLXhdsQ.png"/></div></div></figure><p id="6bd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将介绍使用服务器流响应的gRPC调用——实现客户机和服务器Go应用程序。</p><p id="69b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是本系列的第三篇文章:</p><ol class=""><li id="adad" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-effective-unary-calls-4c9fa68cd9d5">如何进行有效的一元调用</a></li><li id="b71f" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-client-streaming-calls-5c731197585">如何进行客户端流媒体通话</a></li><li id="07d9" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">如何进行服务器流调用</li><li id="233c" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-bi-directional-streaming-calls-70b4a0569b5b">如何进行双向流媒体通话</a></li></ol><p id="069f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在服务器流rpc调用中，客户端发送一个请求，服务器用一个消息流进行响应。当服务器需要进行批量操作时，这很有用，服务器可以使用流一个接一个地发送对象，而不是等到服务器处理完数据。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lo"><img src="../Images/43caf1ae7fa416ac7b5c7d16240edab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1GjibJpAUbnl9hLAjIK3iQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">服务器流响应</figcaption></figure><h2 id="1d00" class="lx ly it bd lz ma mb dn mc md me dp mf km mg mh mi kq mj mk ml ku mm mn mo mp bi translated">项目描述</h2><p id="d8cb" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">对于这个项目，我们将创建一个带有一个gRPC端点的Documents服务，它将允许客户机发送一个获取文档的请求。</p><p id="7dbd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">端点不需要任何请求消息，所以我们将发送一个空散列。</p><p id="82f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，服务器将处理一些文档，并开始向客户机发送流响应。</p><p id="bf3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">客户端也可以在任何时候停止接受来自服务器的消息，要么是因为它已经得到了它想要的，要么是因为服务器发送消息的时间太长。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="0d39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们在grpc_calls中创建另一个文件夹，并将其命名为server_stream。</p><p id="e645" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件夹中创建以下结构。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e146ee9cc716cebc97e17cfa920b66ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*qkVhoAc0KBMtN8KcxAnm-w.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">gRPC服务器流文件夹结构</figcaption></figure><p id="a197" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">documents.proto文件的定义如下:</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f82b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个原型文件中，我为这个请求定义了服务文档、端点和相应的消息。</p><p id="0a6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这个端点，客户端不需要在请求消息中发送任何数据，所以我们将其声明为空请求。</p><p id="633e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于响应，服务器将发送Document类型的消息。</p><h2 id="3229" class="lx ly it bd lz ma mb dn mc md me dp mf km mg mh mi kq mj mk ml ku mm mn mo mp bi translated">原型文件定义:</h2><ol class=""><li id="14ee" class="kz la it kd b ke mq ki mr km nf kq ng ku nh ky le lf lg lh bi translated"><strong class="kd iu"> GetDocuments: </strong>这是rpc端点定义，它接受请求中的空消息，并返回一个GetDocumentsRes流。</li><li id="7ba7" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><strong class="kd iu"> EmptyReq: </strong>这是请求消息。</li><li id="f0c5" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><strong class="kd iu"> GetdocumentsRes: </strong>这是响应消息，它有一个名为Document的字段，类型为Document。</li><li id="e9b1" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><strong class="kd iu">文档:</strong>该消息代表一个文档对象，具有名称、文档类型和大小字段。</li></ol><p id="3c2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们为这个原型文件生成go代码。</p><p id="f6db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在proto文件夹中运行以下命令:</p><pre class="lp lq lr ls gt ni nj nk nl aw nm bi"><span id="cfba" class="lx ly it nj b gy nn no l np nq">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative documents.proto</span></pre><p id="15da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以继续并实现服务器了。这是server go应用程序的代码。</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b28d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，对于这个文件，我们首先创建一个新的grpc服务器，它将监听端口3000，然后我们注册documents服务并开始监听连接。</p><p id="5311" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如你所见，我正在导入proto_server_stream包。因为有本地进口的Go会投诉。</p><p id="c75e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">要解决这个问题，您可以执行以下操作:</strong></p><ol class=""><li id="cd45" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">将proto文件夹的内容推送到Github，然后从那里导入。</li><li id="653d" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">将proto文件夹的内容放在<strong class="kd iu">包/src </strong>文件夹中，作为go版本路径。在我的情况下，这是路径:</li></ol><pre class="lp lq lr ls gt ni nj nk nl aw nm bi"><span id="696f" class="lx ly it nj b gy nn no l np nq">golang/1.15.5/packages/src</span></pre><p id="2d20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件夹中，我创建了一个proto_server_stream文件夹，并粘贴了包含生成代码的proto文件夹中的文件和documents.proto文件。</p><p id="5146" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样我就可以导入这个包，而不用把它推到Github。采取你认为更方便的方法。</p><p id="bba3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于<strong class="kd iu"> GetDocuments </strong>函数，我们首先初始化一些虚拟数据，然后遍历文档，执行一些验证，并使用流对象开始向客户端发送流响应。</p><p id="ed9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还使用睡眠功能来模拟服务器中的一些延迟。</p><p id="0644" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们实现客户端代码。</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d1f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于客户机代码，我们使用documents包提供的<strong class="kd iu"> NewDocumentsClient </strong>方法在端口3000上创建一个新的客户机-服务器。</p><p id="7464" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于<strong class="kd iu"> fetchDocuments </strong>函数，我们首先初始化请求消息，在本例中，是一个空消息。然后，它获取流对象，并开始从服务器接收流消息。</p><p id="0845" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，客户端也可以决定何时停止接收来自服务器的消息，在这种情况下，客户端会一直等到服务器完成消息流传输。</p><p id="6676" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是客户机和服务器go应用程序的必要代码，如果你读了上一篇关于客户机流请求的文章，你会发现proto文件的定义差别很小。以及客户端和服务器的实现。</p><p id="2c40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以尝试一下。转到控制台，在服务器文件夹中，使用以下命令启动服务器。</p><pre class="lp lq lr ls gt ni nj nk nl aw nm bi"><span id="59c5" class="lx ly it nj b gy nn no l np nq">go run .</span></pre><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/b5ef4343f90c1984555e583bab547987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8A-D1zrr24_HX-KyMLz6mA.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">服务器Go应用程序日志</figcaption></figure><p id="d723" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后使用相同的命令启动客户机，但是是在客户机文件夹下。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/601be5199c62815022e25b9f7a852c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QHg4FlTybPxAcFsFI9k3ug.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">客户端Go应用程序日志</figcaption></figure><p id="7110" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太棒了，我们已经实现了服务器流rpc响应。</p><p id="c0de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望你觉得有用。在本系列的下一篇文章中，我们将处理双向流。</p><p id="bd7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您花时间阅读该系列！</p></div></div>    
</body>
</html>