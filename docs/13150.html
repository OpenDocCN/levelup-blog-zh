<html>
<head>
<title>Join Data from PostgreSQL Declaratively in GraphQL Without Writing SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在GraphQL中以声明方式连接PostgreSQL中的数据，而无需编写SQL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/join-data-from-postgresql-declaratively-in-graphql-without-writing-sql-e27489d03cac?source=collection_archive---------16-----------------------#2022-08-11">https://levelup.gitconnected.com/join-data-from-postgresql-declaratively-in-graphql-without-writing-sql-e27489d03cac?source=collection_archive---------16-----------------------#2022-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bbf8e4b12e1757b8ad95560dd28d61b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w-K0AZ4aiOqht7iC.png"/></div></div></figure><p id="35c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SQL是与PostgreSQL等关系数据库交互的首选方式。在为PostgreSQL数据库创建API时，无论是REST还是GraphQL，您都需要了解SQL来获取和输出数据。ORM(对象关系映射)工具通常可以帮助开发人员与数据库进行通信，这些工具抽象了一些构建API所需的SQL知识。</p><p id="6f93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管这些工具可以帮助您入门，但它们并不能帮助您创建高效的SQL。您不会是第一个编写低效查询，导致数据库过载或超时的开发人员。在StepZen，我们已经构建了工具和服务来以声明方式创建GraphQL APIs包括改进您与数据库连接和通信的方式。这消除了编写高效SQL查询的一些痛苦。</p><p id="5907" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将展示如何为PostgreSQL数据库自动生成GraphQL API，并仅使用GraphQL SDL以声明方式连接数据。如果您认为SQL已经是声明性的，我想您会喜欢StepZen中的自定义指令。</p><h2 id="e033" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">从PostgreSQL创建一个GraphQL API</h2><p id="241d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">使用StepZen，您可以为任何数据源创建GraphQL API，包括PostgreSQL数据库。如果已经有了一个数据库，可以使用StepZen CLI将其模式导入GraphQL API。否则，您可以在<a class="ae lu" href="https://stepzen.com/getting-started?details=examples&amp;example=postgresql" rel="noopener ugc nofollow" target="_blank">本页</a>使用我们演示数据库中的凭证。</p><p id="683b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从终端/命令行使用<code class="fe lv lw lx ly b">psql</code>连接到数据库:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="2d4b" class="kw kx iq ly b gy mh mi l mj mk">psql -h postgresql.introspection.stepzen.net -d introspection -U testUserIntrospection</span></pre><p id="d0e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用密码:<code class="fe lv lw lx ly b">HurricaneStartingSample1934</code>。</p><p id="d356" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦连接上，您就可以与PostgreSQL数据库通信了。使用命令<code class="fe lv lw lx ly b">\dt</code>，您可以检查这个数据库中的表:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="3187" class="kw kx iq ly b gy mh mi l mj mk">List of relations<br/> Schema |      Name       | Type  |  Owner<br/>--------+-----------------+-------+----------<br/> public | address         | table | postgres<br/> public | customer        | table | postgres<br/> public | customeraddress | table | postgres<br/> public | lineitem        | table | postgres<br/> public | order           | table | postgres<br/> public | product         | table | postgres<br/>(6 rows)</span></pre><p id="0691" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在上面的结果中看到的，数据库有六个表。我们可以使用SQL查询每个表，或者使用StepZen从这个数据库中获取数据。因此，我们首先需要基于这个数据库的自省生成一个GraphQL API。</p><p id="85f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要为这个数据库生成GraphQL API，您需要安装StepZen CLI:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="bb13" class="kw kx iq ly b gy mh mi l mj mk">npm i -g stepzen</span></pre><p id="b169" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并运行命令:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="914c" class="kw kx iq ly b gy mh mi l mj mk">stepzen import postgresql</span></pre><p id="48c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CLI会询问数据库凭证，如果您自己没有PostgreSQL数据库，您可以从我们的<a class="ae lu" href="https://stepzen.com/getting-started?details=examples&amp;example=postgresql" rel="noopener ugc nofollow" target="_blank">入门示例</a>中复制这些凭证。</p><blockquote class="ml mm mn"><p id="b001" class="jy jz mo ka b kb kc kd ke kf kg kh ki mp kk kl km mq ko kp kq mr ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:CLI将询问您是否想要使用<code class="fe lv lw lx ly b">@materializer</code>链接类型。在此选择“是”。</p></blockquote><p id="ce77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当CLI完成PostgreSQL模式的导入并生成GraphQL模式时，您可以找到一个名为<code class="fe lv lw lx ly b">postgresql/index.graphql</code>的新文件。该文件包含数据库的GraphQL模式，并具有类型声明和一组操作。要部署GraphQL模式并创建API，可以运行<code class="fe lv lw lx ly b">stepzen start</code>。</p><p id="b26b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，StepZen部署GraphQL模式，并在终端中直接返回您的端点。</p><p id="0afb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在下一节继续，我们将在GraphQL模式中查看来自不同表的连接数据。</p><h2 id="3410" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">将表格与<code class="fe lv lw lx ly b">@materializer</code>链接</h2><p id="8338" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">通过运行<code class="fe lv lw lx ly b">stepzen import postgresql</code>为PostgreSQL数据库生成的GraphQL模式已经包含了一个查询，该查询组合了来自不同数据库表的数据。假设您想要获取一个客户的地址，该地址存储在一个单独的表中；您需要在SQL中连接不同的表。</p><p id="2d80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当使用SQL获取id为<code class="fe lv lw lx ly b">1</code>的客户以及该客户的地址时，您需要编写如下SQL查询:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="14c9" class="kw kx iq ly b gy mh mi l mj mk">SELECT T."city", T."countryregion", T."id", T."postalcode", T."stateprovince", T."street" FROM "public"."address" T, "public"."customeraddress" V WHERE V."customerid" = 1 AND V."addressid" = T."id"</span></pre><p id="a0c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个SQL查询组合了来自表<code class="fe lv lw lx ly b">customer</code>和<code class="fe lv lw lx ly b">customeraddress</code>的数据。</p><p id="4df2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在StepZen中，您可以使用这个相同的“原始”SQL查询创建一个GraphQL查询来组合这些表。但是您也可以以声明的方式组合这些数据，而无需编写SQL查询。例如，当您使用GraphQL查询<code class="fe lv lw lx ly b">getCustomer,</code>时，StepZen从<code class="fe lv lw lx ly b">table</code>客户那里获取信息，正如您在下面的<code class="fe lv lw lx ly b">@dbquery</code>指令中看到的:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="2420" class="kw kx iq ly b gy mh mi l mj mk">getCustomer(id: Int!): Customer<br/>    @dbquery(<br/>      type: "postgresql"<br/>      schema: "public"<br/>      table: "customer"<br/>      configuration: "postgresql_config"<br/>    )</span></pre><p id="9dc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是看看它的响应类型<code class="fe lv lw lx ly b">Customer.</code>注意，请求的字段包含地址信息和客户下的订单。响应类型<code class="fe lv lw lx ly b">Customer</code>包含到这些表的连接，使用自定义指令<code class="fe lv lw lx ly b">@materializer</code>。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="2bd3" class="kw kx iq ly b gy mh mi l mj mk">type Customer {<br/>  addressList: [Address] @materializer(query: "getAddressUsingCustomeraddress")<br/>  email: String!<br/>  id: Int!<br/>  name: String!<br/>  orderList: [Order] @materializer(query: "getOrderUsingCustomerid")<br/>}</span></pre><p id="1cf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您查询<code class="fe lv lw lx ly b">getCustomer</code>时，StepZen首先从<code class="fe lv lw lx ly b">table</code>客户那里获取信息。当您包含字段<code class="fe lv lw lx ly b">addressList</code>或<code class="fe lv lw lx ly b">orderList</code>时，它使用<code class="fe lv lw lx ly b">@materializer</code>中链接的GraphQL查询来获取这些字段的数据。</p><p id="35bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的GraphQL查询从PostgreSQL数据库的<code class="fe lv lw lx ly b">customer</code>表中获取字段<code class="fe lv lw lx ly b">id</code>和<code class="fe lv lw lx ly b">email</code>的数据；通过执行<code class="fe lv lw lx ly b">getAddressUsingCustomerid</code>查询得到<code class="fe lv lw lx ly b">addressList</code>的数据。字段<code class="fe lv lw lx ly b">Customer.id</code>的值作为参数传递给这个查询。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="a248" class="kw kx iq ly b gy mh mi l mj mk">{<br/>  getCustomer(id: "1") {<br/>    id<br/>    email<br/>    addressList {<br/>      street<br/>      city<br/>    }<br/>  }<br/>}</span></pre><p id="ec18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查询<code class="fe lv lw lx ly b">getAddressUsingCustomerid</code>使用一个原始SQL查询来获取基于客户id的地址。这很简单，因为<code class="fe lv lw lx ly b">customeraddress</code>表包含字段<code class="fe lv lw lx ly b">customerid</code>:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="6018" class="kw kx iq ly b gy mh mi l mj mk">getAddressUsingCustomerid(id: Int!): [Address]<br/>    @dbquery(<br/>      type: "postgresql"<br/>      query: """<br/>      SELECT T."city", T."countryregion", T."id", T."postalcode", T."stateprovince", T."street"<br/>        FROM "public"."address" T, "public"."customeraddress" V<br/>        WHERE V."customerid" = $1<br/>          AND V."addressid" = T."id"<br/>      """<br/>      configuration: "postgresql_config"<br/>    )</span></pre><p id="7eb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了包含原始SQL查询或使用<code class="fe lv lw lx ly b">@materializer</code>之外，您还可以使用另一个定制指令(<code class="fe lv lw lx ly b">@sequence</code>)来执行一系列查询并收集结果，您将在下一节中看到。</p><h2 id="0c76" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">使用<code class="fe lv lw lx ly b">@sequence</code>收集数据</h2><p id="fede" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">有时，要合并的数据并不直接在另一个表中，而是在一个表中，该表通过一个包含要连接的字段的表链接。假设您想要合并本文中使用的数据库中的表<code class="fe lv lw lx ly b">order</code>和<code class="fe lv lw lx ly b">product</code>;您将看到两个表都没有对另一个表的引用。相反，数据库包含一个名为<code class="fe lv lw lx ly b">lineitem</code>的表，该表只包含字段<code class="fe lv lw lx ly b">orderid</code>和<code class="fe lv lw lx ly b">productid</code>。</p><p id="a131" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用这个表来连接原始SQL查询中的数据，以获得订单的产品信息。并将其链接到新的GraphQL查询:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="821d" class="kw kx iq ly b gy mh mi l mj mk">getProductsUsingOrderid(orderid: Int!): [Product]<br/>  @dbquery(<br/>    type: "postgresql"<br/>    query: """<br/>    SELECT T."id", T."title", T."description", T."image" FROM "public"."product" T, "public"."lineitem" V WHERE V."orderid" = $1 AND T."id" = V."productid"<br/>    """<br/>    configuration: "postgresql_config"<br/>  )</span></pre><p id="9d6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个查询可以用<code class="fe lv lw lx ly b">@materializer</code>指令链接到<code class="fe lv lw lx ly b">Order</code>类型。这样，您可以将产品信息添加到订单中。但是您可以做同样的事情，而不需要编写原始SQL来连接表<code class="fe lv lw lx ly b">lineitem</code>和<code class="fe lv lw lx ly b">product</code>。</p><p id="1b8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，你可以使用自定义指令<code class="fe lv lw lx ly b">@sequence</code>。使用<code class="fe lv lw lx ly b">@sequence</code>您可以分步执行查询并收集结果:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="5678" class="kw kx iq ly b gy mh mi l mj mk">getProductsUsingOrderid(id: Int!): [Product]<br/>    @sequence(<br/>      steps: [<br/>        { query: "getLineitemUsingOrderid" }<br/>        { query: "getProduct", arguments: [{ name: "id", field: "productid" }] }<br/>      ]<br/>    )</span></pre><p id="00c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码首先执行查询<code class="fe lv lw lx ly b">getLineitemUsingOrderid</code>并获取订单产品的id。这些id被传递给<code class="fe lv lw lx ly b">getProduct</code>查询来收集产品信息。这样，您就可以获得产品数据，而无需编写SQL查询来连接不同数据库表中的数据。</p><p id="85d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以用这个序列做更多的事情。假设您想要限制这个新的GraphQL查询返回的字段数量。然后，您可以使用一个<code class="fe lv lw lx ly b">collect</code> GraphQL查询来只收集您想要公开的字段:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="209a" class="kw kx iq ly b gy mh mi l mj mk">collect(<br/>    id: Int!<br/>    title: String<br/>  ): Product @connector(type: "echo")<br/>getProductsUsingOrderid(id: Int!): [Product]<br/>    @sequence(<br/>      steps: [<br/>        { query: "getLineitemUsingOrderid" }<br/>        { query: "getProduct", arguments: [{ name: "id", field: "productid" }] }<br/>        { query: "collect" }<br/>      ]<br/>    )</span></pre><p id="d47d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过添加这第三步，由<code class="fe lv lw lx ly b">product</code>表公开的字段现在只限于<code class="fe lv lw lx ly b">id</code>和<code class="fe lv lw lx ly b">title</code>。您还可以使用这个<code class="fe lv lw lx ly b">collect</code>查询从<code class="fe lv lw lx ly b">@sequence</code>中的任何其他步骤获取数据。</p><h2 id="0110" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结论</h2><p id="c3b2" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在本文中，您了解了如何连接不同PostgreSQL表中的数据，而不必编写原始的SQL查询。相反，您可以使用StepZen的自定义指令来声明性地构建和联合GraphQL APIs。我们很想听听你开始用StepZen和PostgreSQL构建什么项目。加入我们的<a class="ae lu" href="https://discord.com/invite/9k2VdPn2FR" rel="noopener ugc nofollow" target="_blank"> Discord </a>来了解我们社区的最新动态。</p></div></div>    
</body>
</html>