<html>
<head>
<title>Building a Simple Database in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Javascript构建简单的数据库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-simple-database-in-javascript-438672814cec?source=collection_archive---------16-----------------------#2022-11-08">https://levelup.gitconnected.com/building-a-simple-database-in-javascript-438672814cec?source=collection_archive---------16-----------------------#2022-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/db058467ac81275b1f4e2d1e9ee1e09f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QaR_z-6Y3Pu_nM63oqYmVw.png"/></div></div></figure><p id="8063" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">最初发布于</em><a class="ae la" href="https://devtails.xyz/@adam/building-a-simple-database-in-javascript" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://devtails . XYZ</em></a><em class="kz">。</em></p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="5479" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我大约从2015年开始使用<a class="ae la" href="https://www.mongodb.com/atlas/database" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>。我喜欢不定义模式和不断运行迁移的灵活性。尤其是在原型和实验方面。</p><p id="7f08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为我的项目<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/engram">https://github.com/engramhq/engram</a>的一部分，我正在重新学习、探索和分享web开发的不同部分是如何构建的。现在很容易拉别人的代码或者程序就收工了。但我发现这通常会让我们对它实际上是如何工作的缺乏了解，并限制了可能的事情。</p><p id="3044" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章将介绍如何创建一个简单的NoSQL数据库，将数据持久地存储在<code class="fe li lj lk ll b">json</code>文件中。</p><p id="6544" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将逐步开发它，让每一个CRUD(创建、读取、更新、删除)首字母缩略词在进入下一个之前工作，因为每一个都建立在前一个的基础上。</p><p id="9877" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我录下了整个过程的视频。我可能最终会在顶部添加口头解释，但现在如果你把它调到2倍的速度，应该可以看到它全部聚集在一起，一起工作。有标记的章节对应于本教程的标题。</p><figure class="lm ln lo lp gt ju"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h2 id="411e" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">构建TCP服务器</h2><p id="6460" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">一般来说，大多数数据库通过TCP连接进行通信。我们将使用node中内置的<code class="fe li lj lk ll b">net</code>包来创建一个服务器，该服务器监听连接并回显客户端发送给它的任何内容。</p><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="1ba9" class="ls lt it ll b gy mu mv l mw mx">// server.js<br/>const net = require('net')<br/><br/>const port = 3939;<br/>const hostname = '127.0.0.1'<br/><br/>const server = net.createServer()<br/>server.listen(port, hostname, () =&gt; {<br/>  console.log("listening on port", port)<br/>})<br/><br/>server.on('connection', (sock) =&gt; {<br/>  sock.on('data', (data) =&gt; {<br/>    console.log("Received", String(data));<br/>    sock.write(data);<br/>  })<br/>})</span></pre><h2 id="c825" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">构建Hello World客户端</h2><p id="ee4d" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">为了测试服务器，我们需要一个单独的客户端程序。这个使用一个套接字连接到创建服务器的特定主机(“127.0.0.1”)和端口(3939)。它使用<code class="fe li lj lk ll b">write</code>方法向服务器写入一条消息，并在接收到数据后将其返回控制台。</p><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="936b" class="ls lt it ll b gy mu mv l mw mx">// client.js<br/>const net = require('net')<br/><br/>const port = 3939;<br/>const hostname = '127.0.0.1'<br/><br/>const socket = new net.Socket();<br/><br/>socket.connect(port, hostname, () =&gt; {<br/>  socket.write("Hello World!")<br/>  socket.on('data', (data) =&gt; {<br/>    console.log(String(data));<br/>  })<br/>})</span></pre><h2 id="4379" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">测试Hello World客户端</h2><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="e57d" class="ls lt it ll b gy mu mv l mw mx">node server.js<br/>node client.js</span></pre><p id="49d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您必须首先启动服务器，以便它准备好接受来自客户端的连接。</p><h2 id="fc89" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">创建—实现insertOne</h2><p id="88c9" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">既然我们已经在服务器和客户机之间有了一些基本的通信，那么是时候添加我们的第一个命令<code class="fe li lj lk ll b">insertOne</code>了。这为之后的所有事情奠定了基础，所以这是拼图中重要的一块。</p><p id="2746" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以很快看到的第一个设计决策是服务器和客户机之间的数据格式转换为JSON字符串。这使得结构化数据变得极其简单。在一个更大的数据库系统中，使用JSON格式的浪费可能是一个问题，但是对于我们的目的来说，我们没有通过二进制协议发送信息是一点也不明显的。</p><p id="8dc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了进一步简化，<code class="fe li lj lk ll b">_id</code>属性只是作为unix epoch的毫秒数的时间戳生成的。这意味着在同一毫秒内创建两个文档会给我们带来duplicate _ ids，这会导致各种各样的问题。在engram notes数据库的实际使用中，我很难在同一毫秒内手动生成两个项目，所以这是目前可以接受的限制。</p><p id="6808" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际数据存储在一个JavaScript对象<code class="fe li lj lk ll b">collections</code>中。为每个集合创建另一个对象来存放特定集合中的“文档”。</p><p id="744c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是将单个文档添加到<code class="fe li lj lk ll b">notes</code>集合后，<code class="fe li lj lk ll b">collections</code>变量的样子。</p><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="3547" class="ls lt it ll b gy mu mv l mw mx">{<br/>  "notes": {<br/>    "1667863798986": {<br/>      _id: "1667863798986",<br/>      body: "Hello World!"<br/>    }<br/>  }<br/>}</span></pre><p id="10ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这些数据即使在数据库服务器停止运行后也能持续存在，这意味着这些数据需要在某个时候写入磁盘。现在，我决定这将作为一个<code class="fe li lj lk ll b">json</code>文件为每个集合编写。每当对集合进行更新时，整个集合都将被字符串化并写入磁盘。在高容量的情况下，这在许多方面可能是低效的，但是这使得理解一切变得极其简单。</p><h2 id="7d4d" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">server.js</h2><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="c0c1" class="ls lt it ll b gy mu mv l mw mx">const net = require("net");<br/>const fs = require("fs");<br/><br/>const collections = {};<br/><br/>const port = 3939;<br/>const hostname = "127.0.0.1";<br/><br/>const server = net.createServer();<br/>server.listen(port, hostname, () =&gt; {<br/>  console.log("listening on port", port);<br/>});<br/><br/>server.on("connection", (sock) =&gt; {<br/>  sock.on("data", (data) =&gt; {<br/>    const jsonData = JSON.parse(data);<br/>    const collection = getCollection(jsonData.collection);<br/>    let response = "1";<br/><br/>    if (jsonData.insertOne) {<br/>      const _id = new Date().getTime();<br/><br/>      collection[_id] = {<br/>        ...jsonData.insertOne,<br/>        _id<br/>      }<br/><br/>      saveToFile(jsonData.collection)<br/><br/>      response = JSON.stringify({ insertedId: _id });<br/>    }<br/><br/>    sock.write(response);<br/>  });<br/>});<br/><br/>function getCollection(collectionName) {<br/>  if (!collections[collectionName]) {<br/>    collections[collectionName] = {};<br/>  }<br/>  return collections[collectionName];<br/>}<br/><br/>function saveToFile(collectionName) {<br/>  fs.writeFileSync(`${collectionName}.json`, JSON.stringify(getCollection(collectionName)));<br/>}</span></pre><h2 id="0e4f" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">client.js</h2><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="ac1d" class="ls lt it ll b gy mu mv l mw mx">const net = require('net')<br/><br/>const port = 3939;<br/>const hostname = '127.0.0.1'<br/><br/>const socket = new net.Socket();<br/><br/>socket.connect(port, hostname, () =&gt; {<br/>  socket.write(JSON.stringify({<br/>    collection: "blocks",<br/>    insertOne: {<br/>      body: "Hello World!"<br/>    }<br/>  }))<br/>  socket.on('data', (data) =&gt; {<br/>    console.log(String(data));<br/>  })<br/>})</span></pre><h2 id="61a4" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">阅读—实现findOne</h2><p id="57e8" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">既然我们能够创建文档，自然下一步就是能够获取这些文档。现在，我只关心通过id获取它们，所以我实现了一个<code class="fe li lj lk ll b">findOne</code>操作。</p><p id="d0a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了两个可能的操作，有必要为不同的操作创建辅助函数。虽然旧的<code class="fe li lj lk ll b">client.js</code>只能在数据返回时将其注销，但我承诺了请求/响应，这样我就可以从新创建的文档中获取<code class="fe li lj lk ll b">insertedId</code>。这样，我就能够查询刚刚创建的特定文档。</p><h2 id="ecc2" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">server.js</h2><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="471d" class="ls lt it ll b gy mu mv l mw mx">// server.js<br/>const net = require("net");<br/>const fs = require("fs");<br/><br/>const collections = {};<br/><br/>const port = 3939;<br/>const hostname = "127.0.0.1";<br/><br/>const dbFolderName = 'db'<br/><br/>try {<br/>  fs.statSync(dbFolderName)<br/>} catch(err) {<br/>  fs.mkdirSync(dbFolderName)<br/>}<br/><br/>const filenames = fs.readdirSync(dbFolderName);<br/>for (const filename of filenames) {<br/>  const collectionName = filename.split('.')[0]<br/>  const collectionFileContents = fs.readFileSync(`${dbFolderName}/${filename}`);<br/>  if (collectionFileContents) {<br/>    collections[collectionName] = JSON.parse(collectionFileContents)<br/>  }<br/>}<br/><br/>const server = net.createServer();<br/>server.listen(port, hostname, () =&gt; {<br/>  console.log("listening on port", port);<br/>});<br/><br/>server.on("connection", (sock) =&gt; {<br/>  sock.on("data", (data) =&gt; {<br/>    const jsonData = JSON.parse(data);<br/>    const collection = getCollection(jsonData.collection);<br/>    let response = "1";<br/><br/>    if (jsonData.insertOne) {<br/>      const _id = new Date().getTime();<br/><br/>      collection[_id] = {<br/>        ...jsonData.insertOne,<br/>        _id,<br/>      };<br/><br/>      saveToFile(jsonData.collection);<br/><br/>      response = JSON.stringify({ insertedId: _id });<br/>    } else if (jsonData.findOne) {<br/>      const filter = jsonData.findOne.filter;<br/>      if (filter._id) {<br/>        const data = collection[filter._id];<br/><br/>        response = JSON.stringify(data);<br/>      }<br/>    }<br/><br/>    sock.write(response);<br/>  });<br/>});<br/><br/>function getCollection(collectionName) {<br/>  if (!collections[collectionName]) {<br/>    collections[collectionName] = {};<br/>  }<br/>  return collections[collectionName];<br/>}<br/><br/>function saveToFile(collectionName) {<br/>  fs.writeFileSync(<br/>    `${dbFolderName}/${collectionName}.json`,<br/>    JSON.stringify(getCollection(collectionName))<br/>  );<br/>}</span></pre><h2 id="1225" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">client.js</h2><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="83f4" class="ls lt it ll b gy mu mv l mw mx">const net = require("net");<br/><br/>async function run() {<br/>  const port = 3939;<br/>  const hostname = "127.0.0.1";<br/><br/>  const socket = new net.Socket();<br/><br/>  socket.connect(port, hostname, async () =&gt; {<br/>    const { insertedId } = await insertOne(socket, {<br/>      collection: "blocks",<br/>      data: {<br/>        body: "Hello World!",<br/>      },<br/>    });<br/><br/>    const note = await findOne(socket, {<br/>      collection: "blocks",<br/>      filter: {<br/>        _id: insertedId,<br/>      },<br/>    });<br/><br/>    console.log(note);<br/>  });<br/>}<br/><br/>function insertOne(socket, { collection, data }) {<br/>  return new Promise((resolve) =&gt; {<br/>    socket.once("data", (data) =&gt; {<br/>      resolve(JSON.parse(String(data)));<br/>    });<br/><br/>    socket.write(<br/>      JSON.stringify({<br/>        collection,<br/>        insertOne: data,<br/>      })<br/>    );<br/>  });<br/>}<br/><br/>function findOne(socket, { collection, filter }) {<br/>  return new Promise((resolve) =&gt; {<br/>    socket.once("data", (data) =&gt; {<br/>      resolve(JSON.parse(String(data)));<br/>    });<br/><br/>    socket.write(<br/>      JSON.stringify({<br/>        collection,<br/>        findOne: {<br/>          filter,<br/>        },<br/>      })<br/>    );<br/>  });<br/>}<br/><br/>run();</span></pre><h2 id="71f2" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">更新-实施updateOne</h2><p id="f079" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">updateOne遵循我们对findOne操作所做的操作。唯一的区别是它现在随请求一起发送一个<code class="fe li lj lk ll b">data</code>属性，这样服务器就可以更新现有的文档。</p><h2 id="0e07" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">server.js</h2><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="9da9" class="ls lt it ll b gy mu mv l mw mx">const net = require("net");<br/>const fs = require("fs");<br/><br/>const collections = {};<br/><br/>const port = 3939;<br/>const hostname = "127.0.0.1";<br/><br/>const dbFolderName = 'db'<br/><br/>try {<br/>  fs.statSync(dbFolderName)<br/>} catch(err) {<br/>  fs.mkdirSync(dbFolderName)<br/>}<br/><br/>const filenames = fs.readdirSync(dbFolderName);<br/>for (const filename of filenames) {<br/>  const collectionName = filename.split('.')[0]<br/>  const collectionFileContents = fs.readFileSync(`${dbFolderName}/${filename}`);<br/>  if (collectionFileContents) {<br/>    collections[collectionName] = JSON.parse(collectionFileContents)<br/>  }<br/>}<br/><br/>const server = net.createServer();<br/>server.listen(port, hostname, () =&gt; {<br/>  console.log("listening on port", port);<br/>});<br/><br/>server.on("connection", (sock) =&gt; {<br/>  sock.on("data", (data) =&gt; {<br/>    const jsonData = JSON.parse(data);<br/>    const collectionName = jsonData.collection;<br/>    const collection = getCollection(collectionName);<br/>    let response = "1";<br/><br/>    if (jsonData.insertOne) {<br/>      const _id = new Date().getTime();<br/><br/>      collection[_id] = {<br/>        ...jsonData.insertOne,<br/>        _id,<br/>      };<br/><br/>      saveToFile(collectionName);<br/><br/>      response = JSON.stringify({ insertedId: _id });<br/>    } else if (jsonData.findOne) {<br/>      const filter = jsonData.findOne.filter;<br/>      if (filter._id) {<br/>        const data = collection[filter._id];<br/><br/>        response = JSON.stringify(data);<br/>      }<br/>    } else if (jsonData.updateOne) {<br/>      const filter = jsonData.updateOne.filter;<br/>      if (filter._id) {<br/>        collection[filter._id] = {<br/>          ...collection[filter._id],<br/>          ...jsonData.updateOne.data<br/>        };<br/><br/>        saveToFile(collectionName);<br/><br/>        response = "0";<br/>      }<br/>    }<br/><br/>    sock.write(response);<br/>  });<br/>});<br/><br/>function getCollection(collectionName) {<br/>  if (!collections[collectionName]) {<br/>    collections[collectionName] = {};<br/>  }<br/>  return collections[collectionName];<br/>}<br/><br/>function saveToFile(collectionName) {<br/>  fs.writeFileSync(<br/>    `${dbFolderName}/${collectionName}.json`,<br/>    JSON.stringify(getCollection(collectionName))<br/>  );<br/>}</span></pre><h2 id="52b1" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">client.js</h2><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="e84b" class="ls lt it ll b gy mu mv l mw mx">const net = require("net");<br/><br/>async function run() {<br/>  const port = 3939;<br/>  const hostname = "127.0.0.1";<br/><br/>  const socket = new net.Socket();<br/><br/>  socket.connect(port, hostname, async () =&gt; {<br/>    const { insertedId } = await insertOne(socket, {<br/>      collection: "blocks",<br/>      data: {<br/>        body: "Hello World!",<br/>      },<br/>    });<br/><br/>    await updateOne(socket, {<br/>      collection: "blocks",<br/>      filter: {<br/>        _id: insertedId<br/>      },<br/>      data: {<br/>        body: "Goodbye World!"<br/>      }<br/>    })<br/><br/>    const note = await findOne(socket, {<br/>      collection: "blocks",<br/>      filter: {<br/>        _id: insertedId,<br/>      },<br/>    });<br/><br/>    console.log(note);<br/>  });<br/>}<br/><br/>function insertOne(socket, { collection, data }) {<br/>  return new Promise((resolve) =&gt; {<br/>    socket.once("data", (data) =&gt; {<br/>      resolve(JSON.parse(String(data)));<br/>    });<br/><br/>    socket.write(<br/>      JSON.stringify({<br/>        collection,<br/>        insertOne: data,<br/>      })<br/>    );<br/>  });<br/>}<br/><br/>function findOne(socket, { collection, filter }) {<br/>  return new Promise((resolve) =&gt; {<br/>    socket.once("data", (data) =&gt; {<br/>      resolve(JSON.parse(String(data)));<br/>    });<br/><br/>    socket.write(<br/>      JSON.stringify({<br/>        collection,<br/>        findOne: {<br/>          filter,<br/>        },<br/>      })<br/>    );<br/>  });<br/>}<br/><br/>function updateOne(socket, { collection, filter, data }) {<br/>  return new Promise((resolve) =&gt; {<br/>    socket.once("data", () =&gt; {<br/>      resolve();<br/>    });<br/><br/>    socket.write(<br/>      JSON.stringify({<br/>        collection,<br/>        updateOne: {<br/>          filter,<br/>          data<br/>        },<br/>      })<br/>    );<br/>  });<br/>}<br/><br/>run();</span></pre><h2 id="4294" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">删除—实现deleteOne</h2><p id="dd98" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">现在我们已经完成了一些操作，deleteOne应该很容易理解，甚至可以自己实现，而无需遵循。它只是从集合中删除对象，并将json文件重新保存到磁盘。</p><h2 id="9981" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">server.js</h2><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="8187" class="ls lt it ll b gy mu mv l mw mx">// server.js<br/>const net = require("net");<br/>const fs = require("fs");<br/><br/>const collections = {};<br/><br/>const port = 3939;<br/>const hostname = "127.0.0.1";<br/><br/>const dbFolderName = "db";<br/><br/>try {<br/>  fs.statSync(dbFolderName);<br/>} catch (err) {<br/>  fs.mkdirSync(dbFolderName);<br/>}<br/><br/>const filenames = fs.readdirSync(dbFolderName);<br/>for (const filename of filenames) {<br/>  const collectionName = filename.split(".")[0];<br/>  const collectionFileContents = fs.readFileSync(`${dbFolderName}/${filename}`);<br/>  if (collectionFileContents) {<br/>    collections[collectionName] = JSON.parse(collectionFileContents);<br/>  }<br/>}<br/><br/>const server = net.createServer();<br/>server.listen(port, hostname, () =&gt; {<br/>  console.log("listening on port", port);<br/>});<br/><br/>server.on("connection", (sock) =&gt; {<br/>  sock.on("data", (data) =&gt; {<br/>    const jsonData = JSON.parse(data);<br/>    const collectionName = jsonData.collection;<br/>    const collection = getCollection(collectionName);<br/>    let response = "1";<br/><br/>    if (jsonData.insertOne) {<br/>      const _id = new Date().getTime();<br/><br/>      collection[_id] = {<br/>        ...jsonData.insertOne,<br/>        _id,<br/>      };<br/><br/>      saveToFile(collectionName);<br/><br/>      response = JSON.stringify({ insertedId: _id });<br/>    } else if (jsonData.findOne) {<br/>      const filter = jsonData.findOne.filter;<br/>      if (filter._id) {<br/>        const data = collection[filter._id];<br/><br/>        response = JSON.stringify(data);<br/>      }<br/>    } else if (jsonData.updateOne) {<br/>      const filter = jsonData.updateOne.filter;<br/>      if (filter._id) {<br/>        collection[filter._id] = {<br/>          ...collection[filter._id],<br/>          ...jsonData.updateOne.data,<br/>        };<br/><br/>        saveToFile(collectionName);<br/><br/>        response = "0";<br/>      }<br/>    } else if (jsonData.deleteOne) {<br/>      const filter = jsonData.deleteOne.filter;<br/>      if (filter._id) {<br/>        delete collection[filter._id];<br/><br/>        saveToFile(collectionName);<br/><br/>        response = "0";<br/>      }<br/>    }<br/><br/>    sock.write(response);<br/>  });<br/>});<br/><br/>function getCollection(collectionName) {<br/>  if (!collections[collectionName]) {<br/>    collections[collectionName] = {};<br/>  }<br/>  return collections[collectionName];<br/>}<br/><br/>function saveToFile(collectionName) {<br/>  fs.writeFileSync(<br/>    `${dbFolderName}/${collectionName}.json`,<br/>    JSON.stringify(getCollection(collectionName))<br/>  );<br/>}</span></pre><h2 id="82c1" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">client.js</h2><pre class="lm ln lo lp gt mq ll mr ms aw mt bi"><span id="4b00" class="ls lt it ll b gy mu mv l mw mx">// client.js<br/>const net = require("net");<br/><br/>async function run() {<br/>  const port = 3939;<br/>  const hostname = "127.0.0.1";<br/><br/>  const socket = new net.Socket();<br/><br/>  socket.connect(port, hostname, async () =&gt; {<br/>    const { insertedId } = await insertOne(socket, {<br/>      collection: "blocks",<br/>      data: {<br/>        body: "Hello World!",<br/>      },<br/>    });<br/><br/>    await updateOne(socket, {<br/>      collection: "blocks",<br/>      filter: {<br/>        _id: insertedId<br/>      },<br/>      data: {<br/>        body: "Goodbye World!"<br/>      }<br/>    })<br/><br/>    const note = await findOne(socket, {<br/>      collection: "blocks",<br/>      filter: {<br/>        _id: insertedId,<br/>      },<br/>    });<br/><br/>    await deleteOne(socket, {<br/>      collection: "blocks",<br/>      filter: {<br/>        _id: insertedId<br/>      }<br/>    })<br/>  });<br/>}<br/><br/>function insertOne(socket, { collection, data }) {<br/>  return new Promise((resolve) =&gt; {<br/>    socket.once("data", (data) =&gt; {<br/>      resolve(JSON.parse(String(data)));<br/>    });<br/><br/>    socket.write(<br/>      JSON.stringify({<br/>        collection,<br/>        insertOne: data,<br/>      })<br/>    );<br/>  });<br/>}<br/><br/>function findOne(socket, { collection, filter }) {<br/>  return new Promise((resolve) =&gt; {<br/>    socket.once("data", (data) =&gt; {<br/>      resolve(JSON.parse(String(data)));<br/>    });<br/><br/>    socket.write(<br/>      JSON.stringify({<br/>        collection,<br/>        findOne: {<br/>          filter,<br/>        },<br/>      })<br/>    );<br/>  });<br/>}<br/><br/>function updateOne(socket, { collection, filter, data }) {<br/>  return new Promise((resolve) =&gt; {<br/>    socket.once("data", () =&gt; {<br/>      resolve();<br/>    });<br/><br/>    socket.write(<br/>      JSON.stringify({<br/>        collection,<br/>        updateOne: {<br/>          filter,<br/>          data<br/>        },<br/>      })<br/>    );<br/>  });<br/>}<br/><br/>function deleteOne(socket, { collection, filter }) {<br/>  return new Promise((resolve) =&gt; {<br/>    socket.once("data", () =&gt; {<br/>      resolve();<br/>    });<br/><br/>    socket.write(<br/>      JSON.stringify({<br/>        collection,<br/>        deleteOne: {<br/>          filter<br/>        },<br/>      })<br/>    );<br/>  });<br/>}<br/><br/>run();</span></pre><h2 id="9bc3" class="ls lt it bd lu lv lw dn lx ly lz dp ma km mb mc md kq me mf mg ku mh mi mj mk bi translated">包裹</h2><p id="d17e" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">多年来，我一直在考虑建立一个数据库的想法。我已经开始和停止这些项目几次了。我认为真正深入了解它的唯一方法是在实际应用中开始使用它。从这里开始，我将转换我现有的<a class="ae la" href="https://github.com/engramhq/engram" rel="noopener ugc nofollow" target="_blank"> engram </a>应用程序来使用这个数据库，而不是它当前的mongodb。我希望这样做将自然地引入构建数据库时存在的一些挑战，以便我可以更好地了解幕后真正发生的事情。</p></div></div>    
</body>
</html>