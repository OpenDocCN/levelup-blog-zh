<html>
<head>
<title>A Guide to RSA Encryption in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的RSA加密指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-guide-to-rsa-encryption-in-go-1a18d827f35d?source=collection_archive---------7-----------------------#2020-11-09">https://levelup.gitconnected.com/a-guide-to-rsa-encryption-in-go-1a18d827f35d?source=collection_archive---------7-----------------------#2020-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ca1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何加密或签署数据。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/52c5bf2cccb8ee58973660e236978392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzUbNNf1XuKJY6jmpx6HaA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@cytonn_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Cytonn摄影</a>在<a class="ae ky" href="https://unsplash.com/s/photos/signature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</figcaption></figure><p id="864b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非对称加密或公钥加密是现代系统安全的基础部分。它保证了加密的认证和不可否认原则(更多关于原则的内容<a class="ae ky" href="https://www.thegeekstuff.com/2012/07/cryptography-basics/" rel="noopener ugc nofollow" target="_blank">在这里</a>)。</p><p id="bcef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将看到如何使用Go实现它。</p><blockquote class="lv lw lx"><p id="df35" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">注</strong>:本文使用的Go版本为1.15.3。</p></blockquote><p id="e865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">TL；博士</strong>:你可以在这里找到完整的代码<a class="ae ky" href="https://gist.github.com/ustropo/3887e7db364bcff720730e7aac9af7a3" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="a517" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">介绍</h1><p id="b843" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">RSA是一种公钥算法。它以它的创造者命名(<em class="ly"> Rivest-Shamir-Adleman)。</em>它于1977年公开，是当今使用最多的算法之一。</p><p id="c98f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公钥加密，也称为非对称加密，使用两种不同的密钥，一种用于加密，另一种用于解密:</p><ul class=""><li id="0216" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">只要不涉及秘密，例如加密或验证，就在该过程中使用公钥。</li><li id="e330" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">当涉及到秘密时，如解密或签名，就使用私钥。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/6ffa30cb8c63e6439712a08c2d0c13e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ogC0NyHAhpcxRi4lu7fxA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</figcaption></figure><p id="c4c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可以与任何人共享公钥，因此他们可以加密他们想发送给我们的任何信息。访问这些信息的唯一方法是使用私钥解密。这就是为什么它必须保密。</p><p id="d8eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公钥和私钥是一起生成的(公钥是从私钥派生的)并形成一个密钥对。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d57ac86abb9d39bda495dd97bfcc44f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*PM4L1lTYsxTR6Oz5qFOW_Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">密钥对生成过程。</figcaption></figure><blockquote class="lv lw lx"><p id="2a1f" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:如果你想了解更多关于密钥是如何产生的或者加密的过程是如何工作的，你可以查看这个<a class="ae ky" href="https://www.youtube.com/watch?v=wXB-V_Keiu8" rel="noopener ugc nofollow" target="_blank">视频</a>。</p></blockquote><p id="08e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用Go来实现它。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="0a24" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">密钥对生成</h1><p id="acb2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们要做的第一件事是生成公钥和私钥。如果您已经有一对，您可以跳过这个过程，从文件中读取它。</p><p id="800f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包<code class="fe nw nx ny nz b"><a class="ae ky" href="https://golang.org/pkg/crypto/rsa/" rel="noopener ugc nofollow" target="_blank">crypto/rsa</a></code>生成密钥，包<code class="fe nw nx ny nz b"><a class="ae ky" href="https://golang.org/pkg/crypto/rand/" rel="noopener ugc nofollow" target="_blank">crypto/rand</a></code>生成随机数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="8fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在其他程序中使用该密钥，或者在其他时候，您可以将密钥保存到文件中。通常的做法是保存为<a class="ae ky" href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail" rel="noopener ugc nofollow" target="_blank"> PEM格式，</a>使用包<code class="fe nw nx ny nz b">encoding/pem</code>。</p><p id="db85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公钥是私钥结构的一部分，所以不需要同时保存它们。但是记住不要和任何人分享这个文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以使用包<code class="fe nw nx ny nz b"><a class="ae ky" href="https://golang.org/pkg/crypto/x509/" rel="noopener ugc nofollow" target="_blank">crypto/x509</a></code>和<code class="fe nw nx ny nz b">encoding/pem</code>从文件中读取密钥。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><blockquote class="lv lw lx"><p id="b7c8" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:为了简单起见，省略了错误处理。您应该在实际应用中检查它们。</p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="19fc" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">加密</h1><p id="9060" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了加密，我们将使用函数<code class="fe nw nx ny nz b"><a class="ae ky" href="https://golang.org/pkg/crypto/rsa/#EncryptOAEP" rel="noopener ugc nofollow" target="_blank">EncryptOAEP</a></code>。该函数使用方法<a class="ae ky" href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding" rel="noopener ugc nofollow" target="_blank"> OAEP </a>来确保对同一消息加密两次不会产生相同的密文。</p><p id="9d14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它接收五个参数:</p><ol class=""><li id="1911" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu oc nm nn no bi translated">哈希函数。SHA256算法是合适的。</li><li id="bafa" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu oc nm nn no bi translated">产生随机位的随机阅读器。</li><li id="35b0" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu oc nm nn no bi translated">先前生成(或读取)的公钥。请记住，加密是用公钥完成的。</li><li id="fbfb" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu oc nm nn no bi translated">我们要加密的消息。它必须短于公共模数(在我们的例子中是2048位)减去散列长度的两倍(32字节)再减去2。在我们的例子中，消息最大长度必须是190字节。</li><li id="d27d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu oc nm nn no bi translated">可选标签(在我们的例子中省略)。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="cc60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生一个加密的消息，每次我们尝试加密时，它都是不同的。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="970b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">[通信]解密</h1><p id="9910" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">要访问加密字节中包含的信息，我们必须解密它。</p><p id="61a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只能通过使用属于用于加密消息的密钥对的私钥来完成。</p><p id="4c99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要解密它，我们只需要使用函数<code class="fe nw nx ny nz b">rsa.DecryptOAEP</code>。它也接收五个参数，但是现在我们必须传递加密的消息和私钥。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="b1ca" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">签名和验证</h1><p id="a7dc" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">RSA也用于签名和验证。它不同于加密。目标是确保发送者是他们所说的人(真实性)。</p><p id="bab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着不是混合原始消息内容，而是生成新的数据。这一块叫做<strong class="lb iu">签名</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/99eeb77f9b278ce02035f29120ac064d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sb_rgXy5-WzbZ0Nywm-XA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">签名流程。</figcaption></figure><p id="afcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">验证是用公钥完成的。这是使用签名和原始消息完成的。如果它们不匹配，验证过程就会失败。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/13398f8c0fbc05fb367fa86f4b0050ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hvf_j6kuTPdnBoZN2b-haQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">验证过程。</figcaption></figure><p id="f944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Go中，这是通过使用<code class="fe nw nx ny nz b"><a class="ae ky" href="https://golang.org/pkg/crypto/rsa/" rel="noopener ugc nofollow" target="_blank">rsa</a></code>包中的函数<code class="fe nw nx ny nz b"><a class="ae ky" href="https://golang.org/pkg/crypto/rsa/#SignPSS" rel="noopener ugc nofollow" target="_blank">rsa.SignPSS</a></code>和<code class="fe nw nx ny nz b"><a class="ae ky" href="https://golang.org/pkg/crypto/rsa/#VerifyPSS" rel="noopener ugc nofollow" target="_blank">rsa.VerifyPSS</a></code>来完成的。</p><p id="c406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">签名过程是使用消息哈希而不是原始消息来完成的。因为散列是原始消息的指纹，我们可以假设如果消息改变了，散列也会改变它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><blockquote class="lv lw lx"><p id="9fa1" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:每次我们调用函数<code class="fe nw nx ny nz b">SignPSS</code>时，都会给出一个不同的签名。</p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="d78b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="58eb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们已经了解了如何生成RSA密钥对，以及如何使用它们来加密、解密、签名和验证给定消息。</p><p id="7079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，您要加密的消息必须短于"<em class="ly">公共模数的长度减去散列长度的两倍，再减去2" </em>(从<a class="ae ky" href="https://pkg.go.dev/crypto/rsa#EncryptOAEP" rel="noopener ugc nofollow" target="_blank">到这里的</a>)。</p><p id="6a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想了解更多有关哈希或对称加密的信息，请查看以下文章:</p><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/a-short-guide-to-hashing-in-go-e8bb0173e97e" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">围棋散列法简明指南</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">如何散列一个字符串或文件</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/a-short-guide-to-encryption-using-go-da97c928259f"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">使用Go加密的简短指南</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">以及如何保护您的数据。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ks oi"/></div></div></a></div><p id="9b3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里找到完整的代码<a class="ae ky" href="https://gist.github.com/ustropo/3887e7db364bcff720730e7aac9af7a3" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>