<html>
<head>
<title>Running a Fargate task from a Lambda Python function to automate Pull Request creation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Lambda Python函数运行Fargate任务来自动创建拉请求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/running-a-fargate-task-from-a-lambda-python-function-to-automate-pull-request-creation-e49dafac51b0?source=collection_archive---------6-----------------------#2020-01-14">https://levelup.gitconnected.com/running-a-fargate-task-from-a-lambda-python-function-to-automate-pull-request-creation-e49dafac51b0?source=collection_archive---------6-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/884b1b31467a72c94d25f1a10e07625b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64Io23eVHdWD_WB_s7PTvQ.jpeg"/></div></div></figure><p id="62d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Reaction Commerce，我们遵循GitOps部署工作流程。我们在Kubernetes集群中运行我们的服务，并使用<a class="ae kz" href="https://github.com/kubernetes-sigs/kustomize" rel="noopener ugc nofollow" target="_blank"> kustomize </a>来定义每个服务的清单。给定服务的部署最常见的是通过针对托管Kubernetes清单的GitHub存储库(我们称之为“gitops”repo)的Pull请求来更改kustomization.yaml文件中的Docker图像标记。</p><p id="bac0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦PR被批准和合并，在我们的Kubernetes集群中运行的一个<a class="ae kz" href="https://fluxcd.io/" rel="noopener ugc nofollow" target="_blank"> flux </a> pod将从GitHub中提取变更，并将其应用到正在运行的集群中，从而导致所述服务的部署。</p><p id="6fa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们找到了一种方法，通过调用CircleCI管道中的脚本来自动创建这些Pull请求，circle ci管道与给定服务的GitHub存储库相关联。该脚本使用<a class="ae kz" href="https://hub.github.com/" rel="noopener ugc nofollow" target="_blank"> hub </a> CLI创建一个针对gitops repo的PR，并将其分配给审阅者。</p><p id="29ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近收到的一个DevOps请求是找到一种方法来使用一个集中的组织范围的webhook，这样当PR合并时，只有一段代码在运行，它知道在适当的环境(开发、集成等)中根据gitops repo中适当的kustomization.yaml文件创建PR。这将减少许多管道中的样板文件和重复测试。</p><p id="88d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我找到的解决方案是创建一个用Python编写的Lambda函数，它作为webhook从CircleCI调用，并通过<a class="ae kz" href="https://boto3.amazonaws.com/v1/documentation/api/latest/index.html" rel="noopener ugc nofollow" target="_blank"> boto </a>运行Fargate任务。Fargate任务执行实际的PR创建。</p><p id="d610" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是关于这个流程的各种元素的一些细节。</p><h2 id="aa0f" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">从CircleCI调用webhook</h2><p id="2a0a" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">我发现一个方便的CircleCI Orb<a class="ae kz" href="https://circleci.com/orbs/registry/orb/eddiewebb/webhook" rel="noopener ugc nofollow" target="_blank">https://circleci.com/orbs/registry/orb/eddiewebb/webhook</a>已经写好了，它做了我想做的事情:通过JSON有效负载将当前circle ci作业的信息发布到我选择的webhook。</p><p id="1976" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了在CircleCI管道中调用webhook，我使用了一个这样的代码片段，其中为了调用Orb功能，我需要做的唯一定制就是将<code class="fe ly lz ma mb b">webhook/notify</code> <code class="fe ly lz ma mb b">endpoint</code>值设置为我的Lambda函数的REST端点。</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="ab9b" class="la lb it mb b gy mk ml l mm mn">version: 2.1</span><span id="7d15" class="la lb it mb b gy mo ml l mm mn">orbs:<br/>  webhook: eddiewebb/webhook@volatile</span><span id="308f" class="la lb it mb b gy mo ml l mm mn">jobs:<br/>  docker-build-tag-push:<br/>    &lt;&lt;: *defaults<br/>    steps:<br/>      - checkout<br/>      - setup_remote_docker:<br/>          docker_layer_caching: true<br/>      - run:<br/>          name: 'docker: myservice'<br/>          command: |<br/>            ${CI_SCRIPTS} docker-labels &gt;&gt; Dockerfile<br/>            ${CI_SCRIPTS} build-metadata<br/>            ${CI_SCRIPTS} docker-build-tag-push . myservice<br/>      - webhook/notify:<br/>          endpoint: '<a class="ae kz" href="https://w603b5hwp1.execute-api.us-east-1.amazonaws.com/dev/pullrequests'" rel="noopener ugc nofollow" target="_blank">https://SOME-ID.execute-api.us-east-1.amazonaws.com/dev/pullrequests'</a></span></pre><h2 id="3d8f" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">使用无服务器平台创建并运行Lambda webhook</h2><p id="57e3" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">我取了无服务器的例子<a class="ae kz" href="https://github.com/serverless/examples/tree/master/aws-python-rest-api-with-dynamodb" rel="noopener ugc nofollow" target="_blank">https://github . com/server less/examples/tree/master/AWS-python-rest-API-with-dynamo db</a>，把它变成了我需要的。</p><p id="af20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">特别是，我修改了<code class="fe ly lz ma mb b">create.py</code>模块，以便通过<code class="fe ly lz ma mb b">webhook</code> Orb正确地检索CircleCI发布的有效载荷。一旦有效载荷信息被解析成单独的变量，我感兴趣的变量将通过<code class="fe ly lz ma mb b">boto3.client.run_task</code>方法的<code class="fe ly lz ma mb b">overrides</code>参数作为环境变量传递给Fargate任务。</p><p id="379e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是<code class="fe ly lz ma mb b">pullrequests/create.py</code>模块的样子:</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="815c" class="la lb it mb b gy mk ml l mm mn">import json<br/>import logging<br/>import os<br/>import time<br/>import uuid<br/>from datetime import datetime<br/>import boto3</span><span id="7fe0" class="la lb it mb b gy mo ml l mm mn">REGION = os.environ['REGION']<br/>DYNAMODB_TABLE = os.environ['DYNAMODB_TABLE']<br/>FARGATE_CLUSTER = os.environ['FARGATE_CLUSTER']<br/>FARGATE_TASK_DEF_NAME = os.environ['FARGATE_TASK_DEF_NAME']<br/>FARGATE_SUBNET_ID = os.environ['FARGATE_SUBNET_ID']</span><span id="b4ec" class="la lb it mb b gy mo ml l mm mn">def run_fargate_task(dockerhub_repo, rc_service, docker_tag):<br/>    client = boto3.client('ecs', region_name=REGION)<br/>    response = client.run_task(<br/>        cluster=FARGATE_CLUSTER,<br/>        launchType = 'FARGATE',<br/>        taskDefinition=FARGATE_TASK_DEF_NAME,<br/>        count = 1,<br/>        platformVersion='LATEST',<br/>        networkConfiguration={<br/>            'awsvpcConfiguration': {<br/>                'subnets': [<br/>                    FARGATE_SUBNET_ID,<br/>                ],<br/>                'assignPublicIp': 'ENABLED'<br/>            }<br/>        },<br/>        overrides={<br/>            'containerOverrides': [<br/>                {<br/>                    'name': 'automated-gitops-pr',<br/>                    'environment': [<br/>                        {<br/>                            'name': 'DOCKER_REPOSITORY',<br/>                            'value': dockerhub_repo<br/>                        },<br/>                        {<br/>                            'name': 'SERVICE',<br/>                            'value': service<br/>                        },<br/>                        {<br/>                            'name': 'CIRCLE_SHA1',<br/>                            'value': docker_tag<br/>                        },<br/>                    ],<br/>                },<br/>            ],<br/>        },<br/>    )</span><span id="61aa" class="la lb it mb b gy mo ml l mm mn">return str(response)</span><span id="bd79" class="la lb it mb b gy mo ml l mm mn">def create(event, context):<br/>    data = json.loads(event['body'])</span><span id="e22f" class="la lb it mb b gy mo ml l mm mn">    build_num = data.get('build_num', "")<br/>    branch = data.get('branch', "")<br/>    username = data.get('username', "")<br/>    job = data.get('job', "")<br/>    build_url = data.get('build_url', "")<br/>    vcs_revision = data.get('vcs_revision', "")<br/>    reponame = data.get('reponame', "")<br/>    workflow_id = data.get('workflow_id', "")<br/>    workflow_url = data.get('workflow_url', "")<br/>    pull_request = data.get('pull_request', "")<br/>    user = data.get('user', "")<br/>    api_link = data.get('api_link', "")<br/>    status = data.get('status', "")</span><span id="f9e1" class="la lb it mb b gy mo ml l mm mn">    if reponame == "":<br/>        response = {<br/>            "statusCode": 400,<br/>            "body": "Did not find reponame in the request payload"<br/>        }<br/>        return response</span><span id="1727" class="la lb it mb b gy mo ml l mm mn">    if job == "":<br/>        response = {<br/>            "statusCode": 400,<br/>            "body": "Did not find job in the request payload"<br/>        }<br/>        return response</span><span id="39be" class="la lb it mb b gy mo ml l mm mn">    if vcs_revision == "":<br/>        response = {<br/>            "statusCode": 400,<br/>            "body": "Did not find vcs_revision in the request payload"<br/>        }<br/>        return response</span><span id="3452" class="la lb it mb b gy mo ml l mm mn">    dynamodb = boto3.resource('dynamodb', region_name=REGION)<br/>    table = dynamodb.Table(DYNAMODB_TABLE)</span><span id="d765" class="la lb it mb b gy mo ml l mm mn">    timestamp = str(datetime.utcnow().timestamp())<br/>    item = {<br/>        'id': str(uuid.uuid1()),<br/>        'build_num': build_num,<br/>        'branch': branch,<br/>        'username': username,<br/>        'job': job,<br/>        'build_url': build_url,<br/>        'vcs_revision': vcs_revision,<br/>        'reponame': reponame,<br/>        'workflow_id': workflow_id,<br/>        'workflow_url': workflow_url,<br/>        'pull_request': pull_request,<br/>        'user': user,<br/>        'api_link': api_link,<br/>        'status': status,<br/>        'createdAt': timestamp,<br/>    }</span><span id="f124" class="la lb it mb b gy mo ml l mm mn">    # write the pullrequest to the database<br/>    table.put_item(Item=item)</span><span id="d617" class="la lb it mb b gy mo ml l mm mn">    # run Fargate task which creates the PR against the gitops repo<br/>    dockerhub_repo = "myorgname/" + reponame<br/>    service = reponame<br/>    docker_tag = vcs_revision</span><span id="1228" class="la lb it mb b gy mo ml l mm mn">    resp = run_fargate_task(dockerhub_repo, service, docker_tag)<br/>    response = {<br/>        "statusCode": 200,<br/>        "body": resp<br/>    }<br/>    return response</span></pre><p id="12f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">无服务器平台的配置在<code class="fe ly lz ma mb b">serverless.yaml</code>文件中，如下所示:</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="5e58" class="la lb it mb b gy mk ml l mm mn">service: serverless-gitops-pr</span><span id="a387" class="la lb it mb b gy mo ml l mm mn">frameworkVersion: "&gt;=1.1.0 &lt;2.0.0"</span><span id="ca5a" class="la lb it mb b gy mo ml l mm mn">plugins:<br/>  - serverless-pseudo-parameters</span><span id="4476" class="la lb it mb b gy mo ml l mm mn">custom:<br/>  execRoleArn: { "Fn::Join" : ["", [ "arn:aws:iam::", { "Ref" : "AWS::AccountId" }, ":role/ecsTaskExecutionRole" ] ] }</span><span id="893d" class="la lb it mb b gy mo ml l mm mn">provider:<br/>  name: aws<br/>  runtime: python3.7<br/>  environment:<br/>    DYNAMODB_TABLE: ${self:service}-${opt:stage, self:provider.stage}<br/>    REGION: us-east-1<br/>    FARGATE_CLUSTER: utility<br/>    FARGATE_TASK_DEF_NAME: automated-gitops<br/>    FARGATE_SUBNET_ID: subnet-some-id<br/>  iamRoleStatements:<br/>    - Effect: Allow<br/>      Action:<br/>        - dynamodb:Query<br/>        - dynamodb:Scan<br/>        - dynamodb:GetItem<br/>        - dynamodb:PutItem<br/>        - dynamodb:UpdateItem<br/>        - dynamodb:DeleteItem<br/>      Resource: "arn:aws:dynamodb:${opt:region, self:provider.region}:*:table/${self:provider.environment.DYNAMODB_TABLE}"<br/>    - Effect: Allow<br/>      Action:<br/>        - ecs:RunTask<br/>      Resource: "*"<br/>    - Effect: Allow<br/>      Action:<br/>        - iam:PassRole<br/>      Resource: ${self:custom.execRoleArn}</span><span id="1197" class="la lb it mb b gy mo ml l mm mn">functions:<br/>  create:<br/>    handler: pullrequests/create.create<br/>    events:<br/>      - http:<br/>          path: pullrequests<br/>          method: post<br/>          cors: true</span><span id="c422" class="la lb it mb b gy mo ml l mm mn">list:<br/>    handler: pullrequests/list.list<br/>    events:<br/>      - http:<br/>          path: pullrequests<br/>          method: get<br/>          cors: true</span><span id="b3c2" class="la lb it mb b gy mo ml l mm mn">get:<br/>    handler: pullrequests/get.get<br/>    events:<br/>      - http:<br/>          path: pullrequests/{id}<br/>          method: get<br/>          cors: true</span><span id="c906" class="la lb it mb b gy mo ml l mm mn">delete:<br/>    handler: pullrequests/delete.delete<br/>    events:<br/>      - http:<br/>          path: pullrequests/{id}<br/>          method: delete<br/>          cors: true</span><span id="85e7" class="la lb it mb b gy mo ml l mm mn">resources:<br/>  Resources:<br/>    TodosDynamoDbTable:<br/>      Type: 'AWS::DynamoDB::Table'<br/>      DeletionPolicy: Retain<br/>      Properties:<br/>        AttributeDefinitions:<br/>          -<br/>            AttributeName: id<br/>            AttributeType: S<br/>        KeySchema:<br/>          -<br/>            AttributeName: id<br/>            KeyType: HASH<br/>        ProvisionedThroughput:<br/>          ReadCapacityUnits: 1<br/>          WriteCapacityUnits: 1<br/>        TableName: ${self:provider.environment.DYNAMODB_TABLE}</span></pre><p id="3070" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一些需要注意的事项:</p><ul class=""><li id="51ad" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">我按照<a class="ae kz" href="https://serverless.com/blog/serverless-application-for-long-running-process-fargate-lambda/" rel="noopener ugc nofollow" target="_blank">https://server less . com/blog/server less-application-for-long-running-process-fargate-lambda/</a>上的精彩文章安装了serverless-pseudo-parameters插件(通过“NPM I server less-pseudo-parameters-save-dev ”,这样我就能够定义变量了</li></ul><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="2424" class="la lb it mb b gy mk ml l mm mn">execRoleArn: { “Fn::Join” : [“”, [ “arn:aws:iam::”, { “Ref” : “AWS::AccountId” }, “:role/ecsTaskExecutionRole” ] ] }</span></pre><ul class=""><li id="086a" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">我在iamRoleStatements部分使用了这个变量，以便允许Lambda函数调用PassRole API:</li></ul><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="5192" class="la lb it mb b gy mk ml l mm mn">- Effect: Allow<br/>      Action:<br/>        - iam:PassRole<br/>      Resource: ${self:custom.execRoleArn}</span></pre><ul class=""><li id="b0f4" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">我还必须允许Lambda函数调用<code class="fe ly lz ma mb b">RunTask</code> API:</li></ul><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="0d74" class="la lb it mb b gy mk ml l mm mn">- Effect: Allow<br/>      Action:<br/>        - ecs:RunTask</span></pre><p id="b71d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了部署Lambda函数，我运行了:</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="572a" class="la lb it mb b gy mk ml l mm mn">serverless deploy</span></pre><h2 id="8d7d" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">为自动拉式请求创建创建ECS Fargate集群、容器定义和任务定义</h2><p id="40cc" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">难题的最后一部分是为容器定义Dockerfile，该容器将作为Fargate任务运行，并创建针对gitops存储库的Pull请求。</p><p id="9478" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是我使用的Dockerfile文件:</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="86cc" class="la lb it mb b gy mk ml l mm mn">FROM circleci/node:12-stretch</span><span id="9716" class="la lb it mb b gy mo ml l mm mn">ENV CIRCLE_SHA1=""<br/>ENV DOCKER_REPOSITORY=""<br/>ENV GITHUB_TOKEN=""<br/>ENV GH_EMAIL=""<br/>ENV GH_USERNAME=""<br/>ENV HUB_VERSION="2.12.8"<br/>ENV KUSTOMIZE_VERSION="3.2.1"<br/>ENV ENVIRONMENT="dev"<br/>ENV SERVICE=""<br/>ENV GITOPS_REVIEWERS="github-id-of-reviewer"</span><span id="d815" class="la lb it mb b gy mo ml l mm mn">WORKDIR /tmp</span><span id="52c5" class="la lb it mb b gy mo ml l mm mn"># Download kustomize<br/>RUN wget -q "<a class="ae kz" href="https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize/v${KUSTOMIZE_VERSION}/kustomize_kustomize.v${KUSTOMIZE_VERSION}_linux_amd64" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize/v${KUSTOMIZE_VERSION}/kustomize_kustomize.v${KUSTOMIZE_VERSION}_linux_amd64</a>"<br/>RUN sudo install --mode 755 kustomize_kustomize.v"${KUSTOMIZE_VERSION}"_linux_amd64 /usr/local/bin/kustomize</span><span id="dbd9" class="la lb it mb b gy mo ml l mm mn"># Download hub<br/>RUN wget -q "<a class="ae kz" href="https://github.com/github/hub/releases/download/v${HUB_VERSION}/hub-linux-amd64-${HUB_VERSION}.tgz" rel="noopener ugc nofollow" target="_blank">https://github.com/github/hub/releases/download/v${HUB_VERSION}/hub-linux-amd64-${HUB_VERSION}.tgz</a>"<br/>RUN tar xfz hub-linux-amd64-"${HUB_VERSION}".tgz<br/>RUN sudo install --mode 755 hub-linux-amd64-"${HUB_VERSION}"/bin/hub /usr/local/bin/hub</span><span id="f3a5" class="la lb it mb b gy mo ml l mm mn">COPY . .</span><span id="eb22" class="la lb it mb b gy mo ml l mm mn">CMD ["./automate-gitops-pull-request.sh"]</span></pre><p id="fa72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意环境变量<code class="fe ly lz ma mb b">CIRCLE_SHA1</code>、<code class="fe ly lz ma mb b">DOCKER_REPOSITORY</code>和<code class="fe ly lz ma mb b">SERVICE</code>，它们是从<code class="fe ly lz ma mb b">overrides</code>参数中的Lambda函数传递过来的。</p><p id="3fa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际的PR创建是在<code class="fe ly lz ma mb b">automate-gitops-pull-request.sh</code> shell脚本中完成的。这是它最重要的部分:</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="cd98" class="la lb it mb b gy mk ml l mm mn"># Clone gitops repository and configure username and email for signing off commits<br/>cd "$(mktemp -d "/tmp/gitops-XXX")"<br/>hub clone "https://${GITHUB_TOKEN}<a class="ae kz" href="http://twitter.com/github" rel="noopener ugc nofollow" target="_blank">@github</a>.com/org/gitops.git"<br/>cd gitops<br/>hub config user.name "${GH_USERNAME}"<br/>hub config user.email "${GH_EMAIL}"<br/>cd kustomize/"${SERVICE}"/overlays/"${ENVIRONMENT:-dev}"</span><span id="c289" class="la lb it mb b gy mo ml l mm mn"># Create new branch<br/>hub checkout -b "update-image-${SERVICE}-${CIRCLE_SHA1}"</span><span id="0875" class="la lb it mb b gy mo ml l mm mn"># Modify image tag in kustomization.yaml by calling 'kustomize edit set image'<br/>kustomize edit set image docker.io/"${DOCKER_REPOSITORY}":"${CIRCLE_SHA1}"<br/>hub add kustomization.yaml</span><span id="669f" class="la lb it mb b gy mo ml l mm mn"># Commit with sign-off<br/>hub commit -s -m "changed ${SERVICE} image tag to ${CIRCLE_SHA1}"</span><span id="7cb7" class="la lb it mb b gy mo ml l mm mn"># Push branch to origin<br/>hub push --set-upstream origin "update-image-${RC_SERVICE}-${CIRCLE_SHA1}"</span><span id="3900" class="la lb it mb b gy mo ml l mm mn"># Create PR<br/>hub pull-request --no-edit -r "${GITOPS_REVIEWERS}"</span></pre><p id="1e80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在本地构建并标记了一个Docker映像，然后将它推送到AWS ECR。我通过<a class="ae kz" href="https://console.aws.amazon.com/ecs/home?region=us-east-1#/firstRun" rel="noopener ugc nofollow" target="_blank"> AWS ECS“首次运行”向导</a>为上面定义的Docker映像创建了一个ECS集群和一个Fargate任务定义和容器定义。下面是一个任务定义JSON文件，它对应于我通过GUI创建的文件:</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="3bef" class="la lb it mb b gy mk ml l mm mn">$ cat ecs-task-definition.json <br/>{<br/>  "executionRoleArn": "arn:aws:iam::ACCOUNTID:role/ecsTaskExecutionRole",<br/>  "containerDefinitions": [<br/>    {<br/>      "logConfiguration": {<br/>        "logDriver": "awslogs",<br/>        "options": {<br/>          "awslogs-group": "/ecs/automated-gitops",<br/>          "awslogs-region": "us-east-1",<br/>          "awslogs-stream-prefix": "ecs"<br/>        }<br/>      },<br/>      "entryPoint": [],<br/>      "portMappings": [],<br/>      "command": [],<br/>      "cpu": 1,<br/>      "environment": [<br/>        {<br/>          "name": "CIRCLE_SHA1",<br/>          "value": ""<br/>        },<br/>        {<br/>          "name": "DOCKER_REPOSITORY",<br/>          "value": ""<br/>        },<br/>        {<br/>          "name": "GH_EMAIL",<br/>          "value": "my-github-email"<br/>        },<br/>        {<br/>          "name": "GH_USERNAME",<br/>          "value": "my-github-username"<br/>        },<br/>        {<br/>          "name": "HUB_VERSION",<br/>          "value": "2.12.8"<br/>        },<br/>        {<br/>          "name": "KUSTOMIZE_VERSION",<br/>          "value": "3.2.1"<br/>        },<br/>        {<br/>          "name": "ENVIRONMENT",<br/>          "value": "dev"<br/>        },<br/>        {<br/>          "name": "SERVICE",<br/>          "value": ""<br/>        },<br/>        {<br/>          "name": "GITOPS_REVIEWERS",<br/>          "value": "github-id-of-reviewer"<br/>        }<br/>      ],<br/>      "secrets": [<br/>        {<br/>          "valueFrom": "arn:aws:ssm:us-east-1:ACCOUNTID:parameter/fargate/automated-gitops-pr/github-token",<br/>          "name": "GITHUB_TOKEN"<br/>        }<br/>      ],</span><span id="28f2" class="la lb it mb b gy mo ml l mm mn">"memoryReservation": 1024,<br/>      "volumesFrom": [],<br/>      "image": "ACCOUNTID.dkr.ecr.us-east-1.amazonaws.com/automated-gitops-pr",<br/>      "essential": true,<br/>      "links": [],<br/>      "name": "automated-gitops-pr"<br/>    }<br/>  ],<br/>  "placementConstraints": [],<br/>  "memory": "1024",<br/>  "taskRoleArn": "arn:aws:iam::773713188930:role/ecsTaskExecutionRole",<br/>  "family": "automated-gitops",<br/>  "requiresCompatibilities": [<br/>    "FARGATE"<br/>  ],<br/>  "networkMode": "awsvpc",<br/>  "cpu": "512",<br/>  "volumes": []<br/>}</span></pre><p id="84db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，<code class="fe ly lz ma mb b">GITHUB_TOKEN</code>环境变量使用了SSM参数存储秘密，<code class="fe ly lz ma mb b">automate-gitops-pull-request.sh</code>脚本使用它来以写入模式克隆gitops repo。我手动创建了一个名为<code class="fe ly lz ma mb b">/fargate/automated-gitops-pr/github-token</code>的SSM变量，并将其值设置为gitops repo的适当Github令牌。</p><p id="1cba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了注册上面创建的任务定义，我使用了<code class="fe ly lz ma mb b">aws</code>命令行:</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="ad7a" class="la lb it mb b gy mk ml l mm mn">#!/bin/bash</span><span id="12a5" class="la lb it mb b gy mo ml l mm mn">REGION=us-east-1</span><span id="b3a7" class="la lb it mb b gy mo ml l mm mn">aws ecs register-task-definition --region $REGION --cli-input-json file://ecs-task-definition.json</span></pre><p id="42e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了测试它，我使用了这个shell脚本:</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="f7a0" class="la lb it mb b gy mk ml l mm mn">#!/bin/bash</span><span id="e041" class="la lb it mb b gy mo ml l mm mn">REGION=us-east-1<br/>CLUSTER=utility<br/>TASK_DEF_NAME=automated-gitops<br/>SUBNET_ID=subnet-some-id</span><span id="f8e1" class="la lb it mb b gy mo ml l mm mn">aws ecs run-task --region $REGION --cluster $CLUSTER --launch-type FARGATE --task-definition $TASK_DEF_NAME \<br/>--network-configuration "awsvpcConfiguration={subnets=[$SUBNET_ID],assignPublicIp=ENABLED}" --overrides file://overrides.json</span></pre><p id="e358" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其中文件<code class="fe ly lz ma mb b">overrides.json</code>包含从一个任务调用到另一个任务调用的变量:</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="084f" class="la lb it mb b gy mk ml l mm mn">{<br/>    "containerOverrides": [{<br/>        "name": "automated-gitops-pr",<br/>        "environment": [<br/>            {<br/>            "name": "DOCKER_REPOSITORY",<br/>            "value": "reactioncommerce/example-storefront"<br/>            },<br/>            {<br/>            "name": "SERVICE",<br/>            "value": "myservice"<br/>            },<br/>            {<br/>            "name": "CIRCLE_SHA1",<br/>            "value": "some-sha-obtained-from-circleci"<br/>            }</span><span id="ec43" class="la lb it mb b gy mo ml l mm mn">]<br/>    }]<br/>}</span></pre><p id="591e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在你知道了。现在，当CircleCI为与给定服务相关联的GitHub repo运行管道时，Lambda webhook将在该服务的Docker映像被推送到DockerHub后被调用。webhook将决定为哪个服务和哪个环境创建Pull请求，并将适当的变量传递给Fargate任务，该任务将创建PR。</p></div></div>    
</body>
</html>