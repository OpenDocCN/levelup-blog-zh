<html>
<head>
<title>How to Secure Webhook Endpoints with HMAC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过HMAC保护Webhook端点</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-secure-webhook-endpoints-with-hmac-231ae547fe93?source=collection_archive---------14-----------------------#2022-05-25">https://levelup.gitconnected.com/how-to-secure-webhook-endpoints-with-hmac-231ae547fe93?source=collection_archive---------14-----------------------#2022-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2e196e5363eae64a50a3b377c1c29a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpwfSohxefuXml2VPbBbPg.png"/></div></div></figure><p id="a926" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Webhooks在SaaS集成中无处不在，这是有原因的。它们是一种简单快捷的方式，可以根据系统中数据的变化，通过HTTP回调在系统之间传输数据。我的公司帮助SaaS团队构建与他们客户的其他应用的本机集成，我们的许多客户使用webhooks进行集成。</p><p id="dd84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的几周里，我们帮助了几个需要确保其webhook端点安全的客户。在本帖中，我们将描述我们推荐的方法。但首先，让我们打好一些基础。</p><h1 id="a4c1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">webhooks是如何工作的？</h1><p id="9308" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">简而言之，源app有webhook，目的app有webhook端点；基于源应用中发生的一些事件，webhook向webhook端点发送HTTP请求。</p><p id="8a77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个HTTP请求体(或有效负载)的简单示例:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1147" class="mj ky iq mf b gy mk ml l mm mn">{<br/>  <em class="mo">"event"</em>: <em class="mo">"WAREHOUSE_UPDATE"</em>,<br/>  <em class="mo">"updates"</em>: [<br/>    {<br/>      <em class="mo">"item"</em>: <em class="mo">"gadgets"</em>,<br/>      <em class="mo">"action"</em>: <em class="mo">"add"</em>,<br/>      <em class="mo">"quantity"</em>: 20<br/>    },<br/>    {<br/>      <em class="mo">"item"</em>: <em class="mo">"widgets"</em>,<br/>      <em class="mo">"action"</em>: <em class="mo">"remove"</em>,<br/>      <em class="mo">"quantity"</em>: 10<br/>    }<br/>  ]<br/>}</span></pre><p id="bd4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如何确保目标应用程序从源应用程序接收到有效数据，而不是从欺骗了webhook的坏人那里接收到虚假数据呢？</p><p id="8be9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，您需要设置webhook来为端点提供HTTP请求和端点可以用来验证数据的惟一键。但是，在我们进入细节之前，让我们简要地介绍一下散列。</p><h1 id="9c2f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">哈希是什么？</h1><p id="297c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最简单地说，散列是将一个值(或键)转换成另一个值的过程。即使您以前没有广泛使用过散列法，您也可能知道MD5、SHA-256或RipeMD-128。其中的每一个都是哈希算法(也称为加密哈希函数)的名称。</p><p id="eaa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看每个算法对经典字符串做了什么:</p><ul class=""><li id="cb86" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">MD5哈希<code class="fe my mz na mf b">Hello World!</code>到<code class="fe my mz na mf b">ed076287532e86365e841e92bfc50d8c</code></li><li id="738b" class="mp mq iq ka b kb nb kf nc kj nd kn ne kr nf kv mu mv mw mx bi translated">SHA-256将<code class="fe my mz na mf b">Hello World!</code>散列到<code class="fe my mz na mf b">7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069</code></li><li id="b739" class="mp mq iq ka b kb nb kf nc kj nd kn ne kr nf kv mu mv mw mx bi translated">RipeMD-128哈希<code class="fe my mz na mf b">Hello World!</code>到<code class="fe my mz na mf b">24e23e5c25bc06c8aa43b696c1e11669</code></li></ul><p id="5047" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的是，算法每次都以相同的方式散列一个值。如果我们不改变我们的字符串(' Hello World！')，得到的哈希值也不会改变。</p><p id="ee3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果字符串中的<em class="mo">任何内容</em>发生变化，哈希也会发生变化。例如，让我们将“H”小写，这样我们就有了“hello World！”看看这能做什么:</p><ul class=""><li id="ef4f" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">MD5哈希<code class="fe my mz na mf b">hello World!</code>到<code class="fe my mz na mf b">41d0c351efedf7fdb9a5dc8a1ed4b4e3</code></li><li id="5339" class="mp mq iq ka b kb nb kf nc kj nd kn ne kr nf kv mu mv mw mx bi translated">SHA-256将<code class="fe my mz na mf b">hello World!</code>哈希到<code class="fe my mz na mf b">e4ad0102dc2523443333d808b91a989b71c2439d7362aca6538d49f76baaa5ca</code></li><li id="036a" class="mp mq iq ka b kb nb kf nc kj nd kn ne kr nf kv mu mv mw mx bi translated">RipeMD-128哈希<code class="fe my mz na mf b">hello World!</code>到<code class="fe my mz na mf b">b5cf338f17d6796ba0312e0d78c70831</code></li></ul><p id="9582" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">细微的变化，但由此产生的差异是明显的。</p><p id="a539" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管散列法不能让我们完全解决我们最初的问题(有人向webhook端点发送虚假数据)，但它确实将我们直接引向了HMAC。</p><h1 id="2b7f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是HMAC？</h1><p id="e079" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">HMAC或散列消息认证码是一种使用两个密钥而不是一个密钥的认证方法。第一个密钥是HTTP请求主体，而第二个密钥是秘密的加密密钥。当您为您的webhook实现HMAC时，您将使用这两个密钥加上一个算法，如MD5、SHA-256或RipeMD-128，以确保出现在您的webhook端点的HTTP请求是合法的。</p><h1 id="6094" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">HMAC是如何工作的？</h1><p id="05e6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在源应用程序通过webhook发送HTTP请求之前，它使用秘密密钥通过HMAC散列有效负载(请求体)。然后，产生的散列被捆绑到HTTP请求中作为头部，整个请求(头部和主体)被发送到webhook端点。</p><p id="4400" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">收到HTTP请求后，目标应用程序使用密钥对请求体进行哈希处理，然后将结果与报头中提供的哈希进行比较。如果值匹配，目标应用程序知道数据是合法的，并处理它。如果值不匹配，目标应用程序会拒绝数据并执行为该场景编写的任何代码——可能会创建日志条目或发送通知。</p><p id="2583" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有人试图欺骗有效载荷，他们将无法生成有效的散列，因为他们没有密钥。门关上了。</p><p id="83b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们想象一下，你有一个电子商务平台连接到你的应用程序。你的应用程序会定期向平台的webhook端点发送有效负载，以创建订单和退款。使用HMAC可以确保不会有随机(或不那么随机)的人向电子商务平台发送虚假订单或退款。</p><p id="2013" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，你会说，难道没有人可以捕获一个HTTP请求，并对报头中的散列进行逆向工程，从而找出秘密吗？简而言之:不是。<a class="ae kw" href="https://mathworld.wolfram.com/One-WayFunction.html" rel="noopener ugc nofollow" target="_blank">哈希是单向函数</a>。要破解一个具有足够复杂秘密的散列，我们需要的计算能力和时间比我们任何人都要多。</p><h1 id="e50e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">依赖HMAC作为webhook端点的应用</h1><p id="68c0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一些知名应用目前使用HMAC来保护其webhook端点:</p><ul class=""><li id="f5f6" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated"><a class="ae kw" href="https://api.slack.com/authentication/verifying-requests-from-slack" rel="noopener ugc nofollow" target="_blank"> Slack </a>:在你创建Slack app的时候提供一个<em class="mo">签名秘密</em>。当它发送一个webhook有效负载时，它使用SHA256将有效负载和webhook的时间戳与该秘密进行散列。webhook请求将结果散列作为名为<code class="fe my mz na mf b">X-Slack-Signature</code>的头。</li><li id="821b" class="mp mq iq ka b kb nb kf nc kj nd kn ne kr nf kv mu mv mw mx bi translated"><a class="ae kw" href="https://www.dropbox.com/developers/reference/webhooks#notifications" rel="noopener ugc nofollow" target="_blank"> Dropbox </a>:当你创建一个Dropbox应用时，会生成一个<em class="mo">应用秘密</em>，并使用该秘密生成webhook HMAC哈希，并使用OAuth 2.0认证用户。它使用SHA256散列webhook有效负载，并将散列作为名为<code class="fe my mz na mf b">X-Dropbox-Signature</code>的头发送。</li><li id="bcd5" class="mp mq iq ka b kb nb kf nc kj nd kn ne kr nf kv mu mv mw mx bi translated"><a class="ae kw" href="https://shopify.dev/apps/webhooks/configuration/https#step-5-verify-the-webhook" rel="noopener ugc nofollow" target="_blank"> Shopify </a>:创建一个<em class="mo"> API密匙</em>并用这个密匙和SHA256散列它的有效负载。它将散列作为名为<code class="fe my mz na mf b">X-Shopify-Hmac-SHA256</code>的报头发送。</li></ul><h1 id="d824" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">HMAC有广泛的语言支持</h1><p id="5df9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">你可以使用任何现代语言来计算HMAC散列。以下是一些具有HMAC功能的流行语言的链接:</p><ul class=""><li id="e231" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated"><a class="ae kw" href="https://nodejs.org/api/crypto.html" rel="noopener ugc nofollow" target="_blank">节点JS </a></li><li id="e72a" class="mp mq iq ka b kb nb kf nc kj nd kn ne kr nf kv mu mv mw mx bi translated"><a class="ae kw" href="https://docs.python.org/3/library/hmac.html" rel="noopener ugc nofollow" target="_blank"> Python </a></li><li id="f0a4" class="mp mq iq ka b kb nb kf nc kj nd kn ne kr nf kv mu mv mw mx bi translated"><a class="ae kw" href="https://www.php.net/manual/en/function.hash-hmac.php" rel="noopener ugc nofollow" target="_blank"> PHP </a></li><li id="6d45" class="mp mq iq ka b kb nb kf nc kj nd kn ne kr nf kv mu mv mw mx bi translated"><a class="ae kw" href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmac?view=net-6.0" rel="noopener ugc nofollow" target="_blank">。NET C# </a></li></ul><h1 id="e396" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">HMAC代码示例</h1><p id="1425" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最后，如果没有代码，这一切会变成什么样？下面是如何使用内置加密模块在NodeJS中进行设置的示例:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a720" class="mj ky iq mf b gy mk ml l mm mn">const crypto = require(<em class="mo">"crypto"</em>);</span><span id="1aa2" class="mj ky iq mf b gy ng ml l mm mn">const SECRET_KEY = <em class="mo">"secret-FA782CF7-060E-484E-B3DC-055CF2C9ED99"</em>;</span><span id="2d4e" class="mj ky iq mf b gy ng ml l mm mn">const payload = JSON.stringify({<br/>  <em class="mo">event</em>: <em class="mo">"REFUND_REQUEST"</em>,<br/>  <em class="mo">user</em>: <em class="mo">"realcustomer@notabaddie.com"</em>,<br/>  <em class="mo">amount</em>: <em class="mo">"50.25"</em>,<br/>});</span><span id="364a" class="mj ky iq mf b gy ng ml l mm mn">const hash = crypto<br/>  .createHmac(<em class="mo">"sha256"</em>, SECRET_KEY)<br/>  .update(payload, <em class="mo">"utf-8"</em>)<br/>  .digest(<em class="mo">"hex"</em>);</span><span id="64b5" class="mj ky iq mf b gy ng ml l mm mn">console.log(hash); <em class="mo">// Prints d12f95e3f98240cff00b2743160455fdf70cb8d431db2981a9af8414fc4ad5f8</em></span></pre><p id="5542" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用HMAC的相应HTTP请求可能如下所示:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d92c" class="mj ky iq mf b gy mk ml l mm mn">curl https://my.webhook.endpoint.com/callback \<br/>  --request POST \<br/>  --header <em class="mo">"x-hmac-hash: d12f95e3f98240cff00b2743160455fdf70cb8d431db2981a9af8414fc4ad5f8"</em> \<br/>  --data <em class="mo">'{"event":"REFUND_REQUEST","user":"realcustomer@notabaddie.com","amount":"50.25"}'</em></span></pre><p id="746a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使一个坏演员拦截了你的HTTP请求，他们也不能向他们自己的电子邮件地址发出100万美元的退款请求，因为没有密钥他们不能正确地签署请求。</p><h1 id="7b92" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="a469" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">使用HMAC并不要求你学习一门新的语言或者对加密有深入的了解，但是它可以保护你通过webhooks传输的数据的完整性。</p></div></div>    
</body>
</html>