<html>
<head>
<title>10 Web Component challenges you should consider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该考虑的10个Web组件挑战</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/10-web-component-challenges-you-should-consider-2a435d8ccec9?source=collection_archive---------14-----------------------#2021-01-19">https://levelup.gitconnected.com/10-web-component-challenges-you-should-consider-2a435d8ccec9?source=collection_archive---------14-----------------------#2021-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9e14a4daa736d72c4e7901729db10a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PqudMUu8fP9zpZTg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@gentlestache?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">博尼瓦尔·塞巴斯蒂安</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3f68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在web上创建可重用的组件并不是一个简单的挑战。你将把重点放在保持它们的轻量级、易用性和高性能上，记住每一个都应该只服务于一个目的。每个主要的前端框架都定义了指导原则，可以帮助您做到这一点。</p><p id="bb15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果你打算使用Web组件实现一个设计系统，有一些挑战会影响你的团队的开发速度。</p><h2 id="f9c1" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">1.需要新的开发人员技能</h2><p id="7d69" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">因为Web Components使用新的浏览器API，所以您的开发人员可能不熟悉它们，并且需要一段时间来理解它们是如何工作的。学习时间不要太乐观；可能需要3周以上的时间才能完全适应。</p><p id="6e28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是开发人员应该了解的完整规格列表:</p><div class="mc md gp gr me mf"><a href="https://drazvan91.medium.com/skills-you-should-have-before-using-webcomponents-ceb8008fb742" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">使用WebComponents前应具备的技能</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">自定义元素、影子Dom、模板很常见，但列表不全；还有几个没人…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">drazvan91.medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jz mf"/></div></div></a></div><h2 id="a7df" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">2.资产管理</h2><p id="8f5d" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">如果您需要添加图像或字体等资源，有不同的方法。最简单的选择是使用<strong class="ki iu"> base64编码</strong>将它们嵌入到web组件中。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="313e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">维护base64值对开发人员来说并不是一种很好的体验，这就是为什么有解决方案可以在构建时自动将URL转换为base64。Postcssurl 插件是一个很好的例子，在postcss管道中非常流行。它还可以与使用webpack或rollup等工具构建的项目集成。</p><p id="b26c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，这可能会导致包大小的问题，尤其是当您需要在多个web组件中重用相同的资源时。剩下的唯一选择是使用静态或相对的<code class="fe na nb nc nd b">url(...)</code> CSS值来交付它们。如果组件包与使用它的应用程序分开托管，那么静态URL是一个很好的选择，但是如果您必须在它们内部托管，您将必须处理配置。</p><p id="f2f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数WebComponents框架不支持处理资产，即使支持，也是最低限度的。例如，<a class="ae kf" href="https://stenciljs.com/docs/local-assets" rel="noopener ugc nofollow" target="_blank"> StencilJS </a>有一个名为<code class="fe na nb nc nd b">getAssetsPath</code>的实用程序，它受到限制，因为它只能在类型脚本代码中使用，而不能在样式表文件中使用。</p><h2 id="0373" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">3.UI测试自动化</h2><p id="03c5" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">最有可能的是，您将使用<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank"> Shadow DOM </a>，这是允许DOM封装的机制。这意味着您不能像以前一样访问web组件中的DOM元素；您首先必须获得对WebComponent的影子根的引用，然后查询您正在寻找的元素。</p><p id="8c88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您的自动化测试人员会觉得这很痛苦。虽然有些UI自动化框架如<a class="ae kf" href="https://docs.cypress.io/api/commands/shadow.html#Syntax" rel="noopener ugc nofollow" target="_blank"> Cypress </a>已经为影子DOM添加了足够好的支持，但有些却没有。不幸的是，Selenium就是其中之一，您必须实现类似于这篇好文章中的解决方法。</p><h2 id="43d8" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">4.易接近</h2><p id="fdf8" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">几个月前，在一次会议上，发言者说，如果你是一名开发人员，不关心可访问性，你是一个可怕的人。我感到尴尬，因为她是对的。</p><p id="40cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，因为阴影DOM边界属性像<code class="fe na nb nc nd b">tab-index</code>、<code class="fe na nb nc nd b">label for</code>、<code class="fe na nb nc nd b">aria-pressed</code>和<code class="fe na nb nc nd b">role</code>并没有像你预期的那样工作。解决方法很痛苦，它使用了一个新的浏览器API，叫做<a class="ae kf" href="https://github.com/WICG/aom" rel="noopener ugc nofollow" target="_blank">可访问性对象模型</a>。</p><h2 id="af41" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">5.表单提交</h2><p id="17f6" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">当所有的web应用程序都使用服务器端渲染时，<code class="fe na nb nc nd b">form</code>标签已经不那么流行了。如今，即使它被用作语义标签，提交动作也不是很流行，因为在单页面应用程序中，与服务器的交互将使用HTTP客户端库来完成，如Axios、HttpClient for Angular或简单的<code class="fe na nb nc nd b">fetch()</code>浏览器API。</p><p id="4aad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果你仍然需要实现一个HTML <code class="fe na nb nc nd b">&lt;form&gt;</code>，你会因为影子DOM而遇到两个挑战。举个例子:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1b58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这在默认情况下不起作用，因为<code class="fe na nb nc nd b">&lt;input/&gt;</code>标记将只把表单数据填充到影子DOM内部的<code class="fe na nb nc nd b">&lt;form /&gt;</code>标记中，而不填充到影子DOM外部的标记中，这意味着当提交外部表单时，它将没有任何值。这是一个很大的限制！</p><p id="4aa4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是有一个解决方法，它需要使用<a class="ae kf" href="https://docs.google.com/document/d/1JO8puctCSpW-ZYGU8lF-h4FWRIDQNDVexzHoOQ2iQmY/edit" rel="noopener ugc nofollow" target="_blank">表单参与API手动处理web组件表示的表单值。</a>同样的方法也适用于<code class="fe na nb nc nd b">&lt;button type="submit" /&gt;</code>。</p><h2 id="a9b9" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">6.服务器端渲染和搜索引擎优化</h2><p id="916c" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我记得像AngularJS这样的第一个前端web框架流行起来的时候。他们都面临着同样的SSR挑战，现在依然如此。尽管VueJS、React和Angular对服务器端渲染有现成的支持，但很有可能您使用的是不支持它的第三方UI组件。</p><p id="cb51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，5年多过去了，同样的事情正在WebComponents上发生，如果你需要服务器端渲染，这可能是一个很大的技术挑战。StencilJS正在使用一种叫做<a class="ae kf" href="https://stenciljs.com/docs/hydrate-app" rel="noopener ugc nofollow" target="_blank">水合物应用</a>的机制来支持它。</p><h2 id="c3b0" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">7.自定义封装样式</h2><p id="8de4" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">DOM封装很棒，因为它在使用您的组件的所有应用程序之间创建了一致性。开发人员将很难尝试打破外观和感觉，并根据他们的需求进行定制。而且这是故意的！您不希望您的开发人员开始使用<code class="fe na nb nc nd b">!important</code>指令并制造混乱。另一方面，您仍然希望在遵循您的设计系统规则的同时允许一点灵活性。</p><p id="0bbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一些项目中，我看到了一种通过使用属性来实现这些扩展点的糟糕方式:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c02f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正确的设计方法是使用CSS变量，因为它们允许级联。您将在<code class="fe na nb nc nd b">html {}</code>级别声明所有的设计令牌，然后所有的web组件都将使用这些变量。不仅如此，您还可以使用内联的<code class="fe na nb nc nd b">style</code>属性或样式表来定制特定的元素。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a7ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，挑战不在于如何实现CSS自定义变量，而在于如何决定组件的哪些部分是可自定义的，哪些是不可自定义的。</p><p id="da20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">允许定制的另一种方式是使用<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/CSS/::part" rel="noopener ugc nofollow" target="_blank"> CSS部件</a>。尽管如此，我还是不推荐使用它，因为如果你给了开发者这样的权力，他们会滥用它，开始破坏设计系统的一致性。另外，在撰写本文的时候，<code class="fe na nb nc nd b">::part()</code>并不被所有的浏览器完全支持。</p><h2 id="56c0" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">8.z指数</h2><p id="2601" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">像下拉菜单、工具提示、弹出窗口这样需要在其他元素之上显示动态元素的组件，实现起来会变得很困难。即使在我实现了自定义下拉菜单之后，我也没有弄清楚Shadow DOM内部的z-index如何影响web组件外部的呈现。</p><h2 id="a34e" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">9.IDE支持</h2><p id="630b" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">如果您正在使用Angular或React with TypeScript，那么当您使用组件时，您很有可能会喜欢这两者都具有智能感知和漂亮的linters这一事实。</p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/3eb50db719588ea28fccdeedc3ba9e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5kgHTE6U1AVusXMuMo8Sw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用React组件时的智能感知示例</figcaption></figure><p id="3f58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些Web组件框架生成类型定义和文档，这样IDE就可以获取它们，然后帮助开发人员。</p><h2 id="0089" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">10.旧浏览器支持</h2><p id="ccb2" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我真的相信2021年将是我最后一次提到11。希望，微软停止支持的决定会被其他公司效仿，尤其是大企业。</p><p id="0900" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同时，许多web组件polyfills是可用的，但是它们的性能不是很好，而且尺寸相当大。在某些情况下，有一些限制肯定会惹恼开发人员。</p><h2 id="c411" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">结论</h2><p id="1b03" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">一旦你克服了这些挑战，并设法构建了一些组件，你将开始注意到使用它们的新方法或它们适用的新情况。只要想到<a class="ae kf" href="https://micro-frontends.org" rel="noopener ugc nofollow" target="_blank">微前端</a>。</p></div></div>    
</body>
</html>