<html>
<head>
<title>Make Your Bot Recognize the Intent of Human Language Inputs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你的机器人识别人类语言输入的意图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/make-your-bot-recognize-the-intent-of-human-language-inputs-72f90b1d341a?source=collection_archive---------8-----------------------#2020-04-20">https://levelup.gitconnected.com/make-your-bot-recognize-the-intent-of-human-language-inputs-72f90b1d341a?source=collection_archive---------8-----------------------#2020-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0f0b8e389c7d898fcd7509670d31cef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSp1m0YWt9d2tgD0YGxYVg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">谢尔盖·阿里安诺夫摄影</figcaption></figure><div class=""/><p id="6336" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">自然语言的样本通常是上下文相关的，并且主要由意图驱动。因此，作为一名聊天机器人开发者，你的主要任务是“教”你的机器人如何理解用户说话的意图和上下文。在我之前的<a class="ae la" href="https://medium.com/@jxireal/make-your-bot-understand-the-context-of-a-discourse-4b740d46166c" rel="noopener">文章</a>中，我提到了如何让你的机器人识别正在处理的句子的上下文，在之前的话语中找到替代的先行词。在本文中，我将分享一些技巧，告诉你如何使用句法依赖标签和命名实体让你的机器人识别句子背后的意图。</p><h1 id="8a5c" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">用户请求的例子</strong></h1><p id="2e6e" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">无论你的聊天机器人是用于点餐、订票还是叫出租车，它都需要理解顾客的意图，从而正确地接受订单。例如，考虑以下可能提交给订票聊天机器人应用程序的请求:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5c5c" class="mn lc jf mj b gy mo mp l mq mr">I want to book two tickets to Thailand tomorrow morning.</span></pre><p id="077a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">经过处理后，上面的句子应该分解成如下所示的结构:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="293d" class="mn lc jf mj b gy mo mp l mq mr">Intent: bookTicket<br/>Quantity: two<br/>Destination: Thailand<br/>Date: tomorrow<br/>Time: morning</span></pre><p id="1b45" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要用spaCy这样的NLP工具实现这一点，您需要使用两种基于语法依赖解析和命名实体识别的技术，这将在下一节中解释。</p><h1 id="4667" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">句法依存标签</strong></h1><p id="ee97" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">句法依存分析是从句子中提取意图时所依赖的关键技术。spaCy有一个句法依存解析器，可以揭示句子中各个单词之间的句法关系，用一条弧线连接句法上相关的单词对。以下脚本说明了如何从示例句子中导出语法弧:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1f5c" class="mn lc jf mj b gy mo mp l mq mr">import spacy<br/>nlp = spacy.load('en')<br/>doc = nlp(u'I want to book two tickets to Thailand tomorrow morning.')<br/>for token in doc:<br/>  print(token.text, token.dep_, token.head.text)</span></pre><p id="07a8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将为您提供以下输出:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3944" class="mn lc jf mj b gy mo mp l mq mr">I         nsubj     want<br/>want      ROOT      want<br/>to        aux       book<br/>book      xcomp     want<br/>two       nummod    tickets<br/><strong class="mj jg">tickets   dobj      book<br/></strong>to        prep      book<br/>Thailand  pobj      to<br/>tomorrow  compound  morning<br/>morning   npadvmod  book<br/>.         punct     want</span></pre><p id="6636" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意连接“book”和“tickets”的弧线(以粗体突出显示)。在这一语法相关对中，单词“tickets”是直接宾语，如分配给该单词的“dobj”依存标签所示。</p><h1 id="969a" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">为意图提取导航依存关系树</strong></h1><p id="cca7" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">这个关系中的中心词是动词“book ”,它是句子的及物动词。在大多数情况下，及物动词/直接宾语对，如果能在句子中找到的话，最能描述句子背后的意图。下面的代码片段显示了如何从句子中提取这个语法对:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="062d" class="mn lc jf mj b gy mo mp l mq mr">…</span><span id="237b" class="mn lc jf mj b gy ms mp l mq mr">doc = nlp(u'I want to book two tickets to Thailand tomorrow morning.')<br/>for token in doc:<br/>  if token.dep_ == 'dobj':<br/>    print(token.head.text+token.lemma_.capitalize())</span></pre><p id="2c26" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是要注意，有时表达意图的句子可能不包括及物动词/直接宾语对，如下例所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="593f" class="mn lc jf mj b gy mo mp l mq mr">I need to sign up for a cloud service.</span></pre><p id="434c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个例子中，动作动词“sign”通过介词“for”连接到名词“service”(动作所应用的对象)。</p><h1 id="eb58" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">寻找具有句法依赖性的必要细节</strong></h1><p id="eeb0" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">探索句子中的依存关系不仅在意图识别时有用。在我们的特定示例中，您可以搜索要预订的机票数量作为直接对象的数字修饰符，如下面的代码片段所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="357b" class="mn lc jf mj b gy mo mp l mq mr">…</span><span id="4e6e" class="mn lc jf mj b gy ms mp l mq mr">doc = nlp(u'I want to book two tickets to Thailand tomorrow morning.')<br/>for token in doc:<br/>if token.dep_ == 'dobj':<br/>print('Intent: ', token.head.text+token.lemma_.capitalize())<br/>print('Quantity: ', [t.text for t in token.lefts if t.pos_ == 'NUM'][0])</span></pre><p id="1cbc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将为您提供以下输出:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d25a" class="mn lc jf mj b gy mo mp l mq mr">Intent:   bookTicket<br/>Quantity: two</span></pre><p id="a53b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如您可能猜到的，这是一个简化的实现。在现实世界的代码中，你必须从用户可能使用另一个及物动词的事实出发，比如说:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1ae2" class="mn lc jf mj b gy mo mp l mq mr">I’d like two tickets to Thailand tomorrow morning.</span></pre><p id="eda1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个例子说明，当涉及到意图识别时，直接宾语可能比它的及物动词更重要。你可能会争辩说，在句子中充当直接宾语的词也可能有同义词，比如说:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8caa" class="mn lc jf mj b gy mo mp l mq mr">I’d like two seats to Thailand tomorrow morning.</span></pre><p id="9637" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要解决这个问题，您可以使用同义词列表。</p><h1 id="fed4" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">用命名实体提取细节</strong></h1><p id="fc53" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">既然您已经提取了样本的意图，您还需要收集一些细节，比如目的地、日期和时间。在spaCy中，这可以通过命名实体识别器来完成。在最简单的形式中，这可以如下实现:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5eea" class="mn lc jf mj b gy mo mp l mq mr">…</span><span id="f807" class="mn lc jf mj b gy ms mp l mq mr">doc = nlp(u’I want to book two tickets to Thailand tomorrow morning.’)</span><span id="f2af" class="mn lc jf mj b gy ms mp l mq mr">…</span><span id="dd1e" class="mn lc jf mj b gy ms mp l mq mr">for ent in doc.ents:<br/>  if ent.label_ == 'GPE':<br/>    print('Destination: ', ent.text)<br/>  if ent.label_ == 'DATE':<br/>    print('Date: ', ent.text)<br/>  if ent.label_ == 'TIME':<br/>    print('Time: ', ent.text)</span></pre><p id="c9f8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">产生以下输出:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6997" class="mn lc jf mj b gy mo mp l mq mr">Destination:  Thailand<br/>Date:         tomorrow<br/>Time:         morning</span></pre><p id="57ca" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可能还是需要把‘明天’变成一个确定的数据。这就是日期时间库派上用场的地方。</p></div></div>    
</body>
</html>