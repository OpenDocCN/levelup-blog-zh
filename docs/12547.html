<html>
<head>
<title>How to Send an Asynchronous Request at the End of a Page Session</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在页面会话结束时发送异步请求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-send-an-asynchronous-request-at-the-end-of-a-page-session-90bf7229448c?source=collection_archive---------9-----------------------#2022-06-19">https://levelup.gitconnected.com/how-to-send-an-asynchronous-request-at-the-end-of-a-page-session-90bf7229448c?source=collection_archive---------9-----------------------#2022-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ffb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么避免使用unload和beforeunload</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd51e729633eb0f76ce5f031f46273c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A3Z3oRm0Fx26ciVO"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@epicantus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">达里娅·内布里亚希娜·🇺🇦</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1ac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果网站希望在用户完成页面后发送分析，但页面可能已经卸载，此时浏览器可能不会发送异步请求。那么我们该怎么办呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c2a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们可能会想到beforeunload事件。它使网页能够触发一个确认对话框，询问用户是否想离开该页面。当用户输入未保存的数据，但意外关闭页面或刷新页面时，数据将会丢失。使用beforeunload允许用户确认两次。比如下面的截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/cc97de0a307c35031f5cceac5111e2ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*PTMsPUtQ0vN1WuC9Wfag-w.png"/></div></figure><p id="2202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是点击离开或者取消并没有相应的回调函数供我们使用，只能作为二次确认。</p><p id="68dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是卸载事件。卸载文档时会激发此事件。它发生在beforeunload事件之后。如果我们在这个事件中发送一个异步请求，正如我在开头所说的，浏览器可能会选择不发送这个异步请求，也可能会中止这个请求。</p><p id="cf62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们可以像下面这样发送阻塞同步XMLHttpRequest请求吗？</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="84a5" class="mi mj it me b gy mk ml l mm mn">const request = new XMLHttpRequest();</span><span id="590b" class="mi mj it me b gy mo ml l mm mn">// open(method, url, async)<br/>request.open('GET', '<a class="ae ky" href="https://httpbin.org/get'" rel="noopener ugc nofollow" target="_blank">https://httpbin.org/get'</a>, false);<br/>request.onreadystatechange = () =&gt; {<br/>  if (request.readyState == 4 &amp;&amp; request.status == 200) {<br/>    console.log(JSON.parse(request.responseText));<br/>  } else {<br/>    console.log(request);<br/>  }<br/>};<br/>request.send();</span></pre><p id="4ef9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是肯定的。但是这阻止了文档被卸载，从而降低了浏览器导航到下一页的速度。下一页无法避免这一点，因为新的一页看起来很慢，即使是上一页的错。</p><p id="8092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与此类似:创建一个<code class="fe mp mq mr me b">&lt;img&gt;</code>元素并设置它的src，创建一个几秒钟内什么都不做的同步循环，等等。</p><p id="0063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这些都不是好的解决方案。幸运的是，浏览器为此提供了有针对性的API—<code class="fe mp mq mr me b">Navigator.sendBeacon()</code></p><p id="ea75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">该事件允许在页面会话结束时异步发送分析数据，而不会延迟阻止下一个页面的加载。并且它保证数据被可靠地发送。</strong></p><p id="d0df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的语法是这样的:<code class="fe mp mq mr me b">navigator.sendBeacon(url [, data])</code>。数据是可选参数，可以是<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" rel="noopener ugc nofollow" target="_blank">ArrayBuffer</a></code>、<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" rel="noopener ugc nofollow" target="_blank">TypedArray</a></code>、<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" rel="noopener ugc nofollow" target="_blank">DataView</a></code>、<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank">Blob</a></code>、字符串或对象、<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" rel="noopener ugc nofollow" target="_blank">FormData</a></code>或<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" rel="noopener ugc nofollow" target="_blank">URLSearchParams</a></code>对象。</p><p id="2da4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的例子:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="8b47" class="mi mj it me b gy mk ml l mm mn">document.addEventListener('visibilitychange', function logData() {<br/>  if (document.visibilityState === 'hidden') {<br/>    navigator.sendBeacon('/log', new URLSearchParams({ user: 1 }));<br/>  }<br/>});</span></pre><p id="a3bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到我在这里使用了<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event" rel="noopener ugc nofollow" target="_blank">visibilitychange</a></code>事件，而不是<code class="fe mp mq mr me b"><a class="ae ky" href="https:%20//developer.mozilla.org/en-US/docs/Web/API/Window/unload_event" rel="noopener ugc nofollow" target="_blank">unload</a></code>或<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Window%20/beforeunload_event" rel="noopener ugc nofollow" target="_blank">beforeunload</a></code>事件。这是因为这两个事件都极不可靠。在移动设备下尤其严重，比如用户使用手机的应用管理器关闭浏览器应用时，不同应用之间切换时等。</p><p id="4faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，这两个事件不兼容现代浏览器的<a class="ae ky" href="https://web.dev/bfcache/" rel="noopener ugc nofollow" target="_blank">后退/前进缓存</a> (bfcache)。这对性能不好。因此，表示用户会话结束的最佳事件是<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event" rel="noopener ugc nofollow" target="_blank">visibilitychange</a></code>事件。在不支持它的浏览器中，下一个最好的选择是<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/pagehide_event" rel="noopener ugc nofollow" target="_blank">pagehide</a></code> event，它也不能被可靠地触发，但是它与bfcache兼容。</p><p id="5d81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们来看看数据的类型。当我们像上面一样使用<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" rel="noopener ugc nofollow" target="_blank">URLSearchParams</a></code>时，请求头<code class="fe mp mq mr me b">content-type</code>将被设置为<code class="fe mp mq mr me b">text/plain;charset=UTF-8</code>。类似地，如果我们使用<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" rel="noopener ugc nofollow" target="_blank">FormData</a></code>，那么请求头的<code class="fe mp mq mr me b">content-type</code>将被设置为<code class="fe mp mq mr me b">multipart/form-data</code>。但是如果我们使用<code class="fe mp mq mr me b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" rel="noopener ugc nofollow" target="_blank">Blob</a></code>，我们可以像这样定制请求头和请求内容:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="4228" class="mi mj it me b gy mk ml l mm mn">const obj = { user: 1 };<br/>const blob = new Blob([JSON.stringify(obj, null, 2)], {<br/>  type: 'application/json',<br/>});<br/>navigator.sendBeacon('/log', blob);</span></pre><p id="da8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么你用过这个API吗？欢迎留下你的想法。</p><h1 id="dbd0" class="ms mj it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">参考</h1><p id="664b" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">[1]<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Navigator/send beacon</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a28c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="no">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="no">中会员</em> </a> <em class="no">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="no">我的链接</em> </a> <em class="no">报名，我会得到一点佣金。</em></p><p id="863d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的支持对我来说很重要——谢谢。</p></div></div>    
</body>
</html>