<html>
<head>
<title>Using Dart’s ffigen package — a practical example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dart的ffigen包—一个实际例子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-darts-ffigen-package-a-practical-example-a014b86f2ee6?source=collection_archive---------10-----------------------#2022-12-31">https://levelup.gitconnected.com/using-darts-ffigen-package-a-practical-example-a014b86f2ee6?source=collection_archive---------10-----------------------#2022-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ceb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我维护了一个名为<a class="ae kl" href="https://pub.dev/packages/mraa" rel="noopener ugc nofollow" target="_blank"> mraa </a>的Dart包，这是一个使用Dart的<a class="ae kl" href="https://dart.dev/guides/libraries/c-interop" rel="noopener ugc nofollow" target="_blank"> FFI </a>机制的<a class="ae kl" href="https://iotdk.intel.com/docs/master/mraa/index.html" rel="noopener ugc nofollow" target="_blank">英特尔MRAA Linux </a>库的实现。这个包现在已经有3年的历史了，它是通过手工制作FFI绑定来实现的，这些FFI绑定是Dart到MRAA头文件中提供的MRAA C API所需要的。这已经足够好了，但是不容易维护，MRAA API中的任何变化都必须检查，并且相应地更新软件包，这既耗时又容易出错，需要一个更好的长期解决方案。</p><p id="74ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，Dart现在有了<a class="ae kl" href="https://pub.dev/packages/ffigen" rel="noopener ugc nofollow" target="_blank"> ffigen </a>包。这个包扫描一个或多个基于C的API头文件，并自动创建一个带有已经生成的必要FFI绑定的Dart类文件。因为这个类是自动生成的，所以MRAA API中的任何更改都会被自动拾取，不需要任何手动检查。这对维护来说是一个很大的好处，所以我决定从这个生成的文件中采用mraa包所需的FFI绑定。</p><p id="5a37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，在这样做时，有几个需要考虑的事项</p><ol class=""><li id="5900" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">不得以任何方式接触生成的文件，即不应应用手动编辑，节省时间删除手动FFI绑定代码是没有意义的，因为每次重新生成生成的文件时都必须应用手动编辑。</li><li id="083d" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">必须保持包的现有API结构，即通过相应的命名Dart类访问MRAA API的不同部分，例如像这样访问GPIO函数“mraa . GPIO . initialize…”。这允许更好的功能命名空间，我们不希望一个API提供给用户的函数可能有100个，就像生成的文件一样长。</li><li id="d1b0" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">mraa包的公共API必须保持最小的变化，我们不希望为升级mraa的用户做不必要的工作，因此ffigen生成的任何类型都必须移植到现有的包类型命名结构中。</li></ol><p id="994f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本质上，我们需要用生成的类的代码替换现有的手工制作的FFI绑定代码，并且影响最小。</p><p id="f47e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种方法是使用C++世界中常见的方法，称为<a class="ae kl" href="https://en.cppreference.com/w/cpp/language/pimpl" rel="noopener ugc nofollow" target="_blank"> Pimpl习语</a>。这种技术本质上是通过将类的实现细节放在一个单独的类中，并通过一个不透明的指针来访问，从而将类的实现细节从其对象表示中移除。对于模式爱好者来说，它是桥模式的变体，即隐藏实现的一种方式，主要是为了打破编译依赖，而完整的桥模式是支持多种实现的一种方式，尽管C++中的Pimpl习语在设计模式正式化之前已经存在了很多年。</p><h2 id="9395" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">Ffigen 'd Pimpl类</h2><p id="8aa7" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">让我们从生成我们的ffigen d类开始，称为“pimpl”类，这不是一篇关于ffigen或如何使用它的文章，请参见它的文档，所以下面是我的ffigen_pubspec.yaml文件的亮点:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="fed3" class="mh lb iq md b be mi mj l mk ml">figen:  <br/>  output: 'mraa_impl.dart'  <br/>  name: 'MraaImpl'  <br/>  description: 'Holds ffigen generated implementation bindings to MRAA.'  <br/>  headers:  <br/>    entry-points:  <br/>      - 'mraa/mraa.h'  <br/>    include-directives:  <br/>      - '**mraa/*.h'  <br/>  comments: true  <br/>  preamble: |</span></pre><p id="c0c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们正在生成一个名为mraa_impl.dart的文件，该文件包含一个名为MraaImpl的类，该类来自一个单独的mraa.h头文件，该头文件本身包含每个API区域的头文件(这是C语言中的标准做法)，我们保留了注释，并为该类添加了一个序言，用于许可等。ffigen处理这个生成没有问题，生成的类可以在这里看到<a class="ae kl" href="https://github.com/shamblett/mraa/blob/master/lib/src/implementation/mraa_impl.dart" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9e89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看如何更新mraa包来使用这个类。</p><h2 id="68e0" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">主要mraa类别更新</h2><p id="bee0" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">从主mraa类开始，我们可以看到原始结构依赖于底层的mraa共享库，我们现在需要删除它，使mraa类依赖于pimpl类，所以:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="6c92" class="mh lb iq md b be mi mj l mk ml">Mraa() {  <br/>  _lib = DynamicLibrary.open('libmraa.so');  <br/>}</span></pre><p id="85e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变成:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="f0d7" class="mh lb iq md b be mi mj l mk ml">Mraa() {  <br/>  _impl = mraaimpl.MraaImpl(DynamicLibrary.open('libmraa.so'));  <br/>}</span></pre><p id="a93f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们补充说:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="bc6e" class="mh lb iq md b be mi mj l mk ml">// The MRAA Implementation class  <br/>late mraaimpl.MraaImpl _impl;</span></pre><p id="6d1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，单个API的构造已经从:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="b73a" class="mh lb iq md b be mi mj l mk ml">common = MraaCommon(_lib, noJsonLoading, useGrovePi);</span></pre><p id="a2b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">致:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="b619" class="mh lb iq md b be mi mj l mk ml">common = MraaCommon(_impl, noJsonLoading, useGrovePi);</span></pre><p id="8a7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将mraa共享库的依赖项替换到我们的pimpl类中，注意没有影响公共API的变化。</p><h2 id="991f" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">API类更新</h2><p id="2f0a" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">我们现在需要更新我们的单个API类，以通用API为例，构造更改为:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="f3f2" class="mh lb iq md b be mi mj l mk ml">MraaCommon(this._impl, this._noJsonLoading, this._useGrovePi) {  <br/>  // Set up the pin offset for grove pi usage.  <br/>  if (_useGrovePi) {  <br/>    _grovePiPinOffset = Mraa.grovePiPinOffset;  <br/>  }  <br/>}  <br/>  <br/>// The MRAA implementation  <br/>final mraaimpl.MraaImpl _impl;</span></pre><p id="284c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，我们现在使用我们的pimpl类，查看初始化方法，我们看到它已经从:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="f369" class="mh lb iq md b be mi mj l mk ml">MraaReturnCode initialise() =&gt; returnCode.fromInt(_initFunc());</span></pre><p id="6b79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="0a39" class="mh lb iq md b be mi mj l mk ml">MraaReturnCode initialise() =&gt; MraaReturnCode.<br/>returnCode(_impl.mraa_init());</span></pre><p id="f549" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，返回类型没有改变，所以对公共API没有影响。底层C调用现在通过pimpl类调用，而不是通过我们手工制作的FFI绑定调用共享库，这允许我们删除原始类中存在的数百行代码，行数现在是316而不是658。还要注意返回代码的派生，这是因为我们也升级了包的枚举，稍后会详细介绍。</p><p id="f365" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看一个传递参数并返回类型的方法:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="46c2" class="mh lb iq md b be mi mj l mk ml">String platformVersion(int platformOffset) {  <br/>  final ptr = _platformVersionFunc(platformOffset);  <br/>  if (ptr != nullptr) {  <br/>    ptr.toDartString();  <br/>  }  <br/>  return 'Platform Version is unavailable';  <br/>}</span></pre><p id="7fcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">成为</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="a9eb" class="mh lb iq md b be mi mj l mk ml">String platformVersion(int platformOffset) {  <br/>  final ptr = _impl.mraa_get_platform_version(platformOffset);  <br/>  if (ptr != nullptr) {  <br/>    return ptr.cast&lt;ffi.Utf8&gt;().toDartString();  <br/>  }  <br/>  return 'Platform Version is unavailable';  <br/>}</span></pre><p id="eb5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请再次注意，公共方法签名没有改变，指针处理有一点重新编码，但是这是可以预料到的，因为我们已经从现有的类中删除了对它的任何支持。这些更新简单直观，更重要的是在我们的公共方法中。</p><p id="e002" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有其他API类中的所有其他方法都进行了相应的更新，与节省的维护时间相比，这花费的时间非常少。</p><h2 id="08c6" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">公共类型更新</h2><p id="bb9d" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">该包使用了许多公开的类型，我们不想更改这些类型的名称，所以我们不想直接从pilpl类中使用这些类型，而是想将pilpl类中使用的名称映射到现有的名称，让我们看一些例子。</p><p id="07e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多API调用采用“context”参数，这是一种不透明的类型，它被初始化，然后根据需要传递给API方法，这在基于C的API中是常见的做法，一个例子是GPIO类上下文类型，它被定义为:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="64b5" class="mh lb iq md b be mi mj l mk ml">class MraaGpioContext extends Opaque {}</span></pre><p id="5671" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不透明的FFI类型，我们现在不能使用它，我们必须使用皮条客类提供的定义，所以现在变成:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="c272" class="mh lb iq md b be mi mj l mk ml">typedef MraaGpioContext = mraaimpl.mraa_gpio_context;</span></pre><p id="2d03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">pimpl类中的mraa_gpio_context本身就是一个typedef，所以我们现在用typedef创建一个typedef(整洁),重要的是保留我们现有的类型名。然而，这确实对公共API产生了破坏性的影响，在pimpl类中声明的typedef是一个指针，</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="c950" class="mh lb iq md b be mi mj l mk ml">ffi.Pointer&lt;_gpio&gt;; </span></pre><p id="1624" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为现有的类是一个不透明的类型，所以没有成员可以访问，这没问题，但是任何声明这个的用户，</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="93a3" class="mh lb iq md b be mi mj l mk ml">Pointer&lt;MraaGpioContext&gt;</span></pre><p id="3e17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在将看到破损，因为我们的新typedef已经是一个指针，所以这个用法现在需要改为“MraaGpioContext”。这是一个简化的变化，因为这些类型只初始化一次，不应该导致太多的更新，我相信这是可以接受的。</p><p id="7a35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我们也必须用皮条客类中的类型替换我们现有的手工类类型，以MraaGpioEvent类为例，我们改变了原来的:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="edbb" class="mh lb iq md b be mi mj l mk ml">class MraaGpioEvent extends Struct {  <br/>  /// Construction  <br/>  MraaGpioEvent(int id, int timestamp) {  <br/>    id = id;  <br/>    timestamp = timestamp;  <br/>  }  <br/>  <br/>  @Int32()  <br/>  <br/>  /// Id  <br/>  external int id;  <br/>  <br/>  @Int64()  <br/>  <br/>  /// Timestamp  <br/>  external int timestamp;  <br/>}</span></pre><p id="4b91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="c9c9" class="mh lb iq md b be mi mj l mk ml">typedef MraaGpioEvent = mraaimpl.mraa_gpio_event;</span></pre><p id="8911" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，我们再次使用来自pimpl类的定义，在这种情况下，mraa_gpio_event是一个类，而不是一个typedef，所以我们仍然可以使用来自单元测试套件的声明，例如:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="1c18" class="mh lb iq md b be mi mj l mk ml">final events = &lt;MraaGpioEvent&gt;[];</span></pre><p id="06ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且仍然访问类成员，因此在不改变任何现有代码的情况下大大简化了我们的代码。</p><p id="6177" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其余的类型都按照这些思路进行了适当的更新。这就留下了另一个需要解决的大问题，枚举。</p><h2 id="7be6" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">公共枚举更新</h2><p id="0152" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">MRAA等封装的C API声明包含许多选择电压阈值、引脚方向、频率等的配置值。由各种C API函数使用。以pin方向为例，我们可以看到MRAA GPIO C报头包含以下内容:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="6a83" class="mh lb iq md b be mi mj l mk ml">typedef enum {  <br/>    MRAA_GPIO_OUT = 0,      /**&lt; Output. A Mode can also be set */  <br/>    MRAA_GPIO_IN = 1,       /**&lt; Input */<br/>    .....</span></pre><p id="ad17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有其他方法，在某些情况下使用直接定义指令。这表示为:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="5d71" class="mh lb iq md b be mi mj l mk ml">abstract class mraa_gpio_dir_t {  <br/>  /// &lt; Output. A Mode can also be set  <br/>  static const int MRAA_GPIO_OUT = 0;  <br/>  <br/>  /// &lt; Input  <br/>  static const int MRAA_GPIO_IN = 1;<br/>...</span></pre><p id="fff9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在由ffigen编写的皮条客类中，我们现在需要将这些值合并到我们的mraa包中。</p><p id="9f46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最初，该包使用标准的Dart枚举，其中不能为单个枚举提供值，提供了支持映射表和访问函数来将Dart枚举转换为实际值，这些都是手工制作的，容易出错并且维护起来很繁琐。你可以在上面的API类更新部分看到一个例子，参见“fromInt”帮助函数。</p><p id="1030" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，随着Dart中增强枚举的出现，我们可以大大简化这一过程，并大大减少维护工作。MraaGpioDirection枚举现在变成:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="d798" class="mh lb iq md b be mi mj l mk ml">enum MraaGpioDirection {  <br/>  /// Out  <br/>  out(mraaimpl.mraa_gpio_dir_t.MRAA_GPIO_OUT),  <br/>  <br/>  /// In  <br/>  inn(mraaimpl.mraa_gpio_dir_t.MRAA_GPIO_IN),<br/>  ....</span></pre><p id="bcfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着代码的减少，即使有一些覆盖和帮助方法，当然我们的公共枚举名称也没有改变，单个枚举的名称也没有改变，我们不再关心这些值是什么，它们只是从pimpl类中选取的。</p><p id="6370" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的维护节省不能被低估，必须以某种方式检查这些值在MRAA的不同版本之间没有发生变化是一项非常累人的工作，希望最好的结果并不是一个可行的替代方案。</p><p id="a41b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意上面列举的' inn '，这应该是' in '作为一个方向，但是我们不能有' in '，它的语法高亮用' in '不能作为一个标识符，因为它是一个关键字。。我想，不可能拥有一切！</p><h2 id="f739" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">结果</h2><p id="0f78" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">那么，我们是否按照我们上面陈述的考虑实现了包的更新，也就是说，我们对用户的影响很小或者没有影响吗？快速查看的一个方法是检查我们找到公共API用户的文件，在这个包中是单元测试套件和示例的目录。</p><p id="fc6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在mraa_uart_details.dart示例中看到一个更新:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="4b8f" class="mh lb iq md b be mi mj l mk ml">'${returnCode.asString(ret)}');</span></pre><p id="bd4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">成为</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="f000" class="mh lb iq md b be mi mj l mk ml">'$ret)');</span></pre><p id="9ae3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新的enum实现带来的简化。</p><p id="2524" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在整个单元测试套件中，我们在mraa_common_test.dart中只有一个影响:-</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="8eac" class="mh lb iq md b be mi mj l mk ml">mraa.common.resultPrint(returnCode.asInt(MraaReturnCode.success));  <br/>mraa.common  <br/>    .resultPrint(returnCode.asInt(MraaReturnCode.errorInvalidHandle));</span></pre><p id="9cc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">成为</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="6445" class="mh lb iq md b be mi mj l mk ml">mraa.common.resultPrint(MraaReturnCode.success.code);  <br/>mraa.common.resultPrint(MraaReturnCode.errorInvalidHandle.code);</span></pre><p id="dcaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次简化，不需要对测试套件进行其他更新，测试套件运行完全没有错误。</p><p id="db29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我认为这是一个值得考虑的胜利。在其他项目中使用这个包可能会产生一些其他的不一致，但是绝对不对用户产生任何影响将是奇迹，我们正在努力实现“最小化到没有变化”，而不是一点变化都没有。</p><p id="62af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的考虑1和2似乎完全符合。</p><h2 id="a4da" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">结论</h2><p id="5bdb" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">如果你正在使用FFI和一个基于C的API做一些严肃的工作，ffigen是一个不错的选择，我发现它简单易用，直观，代码生成完整，不需要手工修饰，没有惊喜，而且工作正常。</p><p id="0706" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我建议，虽然你可以，但你不应该直接向你的用户公开你的ffigen 'd类，把它包在另一个Dart层下面，从长远来看这是值得的。</p><p id="a752" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝你快乐！</p></div></div>    
</body>
</html>