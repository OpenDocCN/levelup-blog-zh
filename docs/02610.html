<html>
<head>
<title>You’re not a Software Engineer if You’re Writing N+1 Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果你写N+1个查询，你就不是软件工程师</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/youre-not-a-software-engineer-if-you-re-writing-n-1-queries-3421910c0f14?source=collection_archive---------5-----------------------#2020-03-25">https://levelup.gitconnected.com/youre-not-a-software-engineer-if-you-re-writing-n-1-queries-3421910c0f14?source=collection_archive---------5-----------------------#2020-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5da0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">了解N+1查询，为什么以及如何避免它们</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a8155798a8fea487a3a948d60ee572e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NS0tRmS_fU5edSezR9obPA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">托拜厄斯·菲舍尔在<a class="ae le" href="https://unsplash.com/s/photos/database?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="f6a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好的。你仍然是一名软件工程师，但是你编写的低效查询很容易修复。这是几乎每个新开发人员都会写的一个模式，包括我自己，当我开始我的第一个Ruby on Rails开发角色时。</p><p id="b0f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它之所以如此恶毒，是因为当你的数据规模很小时，负面影响是最小的。但是，由于它的成本随着数据的增长而线性增长，当你的平台开始接纳大量新用户时，它不可避免地会达到破坏应用程序的程度。</p><p id="f5a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将遍历假设几种不同环境(SQL、Python、Rails)的示例，并向您展示如何纠正它们。</p><p id="c0ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1)纯SQL <br/> 2) Python <br/> 3) Rails</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="98a6" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">什么是N+1查询？</h1><p id="2fe4" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">简单地说，就是当查询中的每个加载记录执行自己的查询时。</p><p id="20b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果您在数据库中加载一个所有文章的列表，然后对每篇文章执行一个单独的查询来加载该文章的作者，这将是N+1。</p><p id="899e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首选的解决方案是在单个事务中将作者的文章与数据库级别的文章结合起来。</p><p id="9f89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为ORM(对象关系映射)提供了如此多的抽象，并且喜欢延迟加载对象，所以经常很容易不小心做到这一点。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="4798" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">SQL示例</h1><p id="9906" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">下面是上面的SQL示例。我们执行一个查询来检索文章。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="7134" class="mu ln it mq b gy mv mw l mx my">SELECT * FROM articles</span></pre><p id="235e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，对于每篇文章，我们执行另一个查询来获取文章的作者。因此，如果有25篇文章，那么第二个查询将运行25次。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="fe7c" class="mu ln it mq b gy mv mw l mx my">SELECT * FROM authors WHERE authors.id = article.author_id</span></pre><p id="407a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而不是以上，我们应该这样做。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="e768" class="mu ln it mq b gy mv mw l mx my">SELECT <br/>  * <br/>FROM articles<br/>LEFT JOIN authors ON authors.id = articles.author_id</span></pre><p id="1983" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一次加载所有内容。</p><p id="a07b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，当编写没有其他约束或cruft的纯SQL时，很容易发现这一点，所以让我们看看更复杂的例子。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="fd6d" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Python示例</h1><p id="31d1" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">让我们重写上面的代码，但是在实际的Python代码中，你可以在Jupyter笔记本或Python应用程序中运行。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="99b0" class="mu ln it mq b gy mv mw l mx my">import psycopg2 as pg</span><span id="e556" class="mu ln it mq b gy mz mw l mx my">conn = psycopg2.connect(dbname='mydb')<br/>cur = conn.cursor()</span><span id="ab40" class="mu ln it mq b gy mz mw l mx my"># Get all articles<br/>cur.execute("""SELECT id,title from articles""")<br/>articles = cur.fetchall()</span><span id="0014" class="mu ln it mq b gy mz mw l mx my"># For each article, get the author<br/>for a in articles:<br/>    cur.execute("""<br/>      SELECT name from authors where authors.id = {}""".format(a[0]) <br/>    )<br/>    author = cur.fetchall()[0]<br/>    print(a[1], author)</span><span id="561f" class="mu ln it mq b gy mz mw l mx my">cur.close()<br/>conn.close()</span></pre><p id="2185" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面我们导入了<code class="fe na nb nc mq b">pyscopg2</code>,它允许我们在python中执行SQL，打开到数据库的连接，并执行一个查询来获取每篇文章的<code class="fe na nb nc mq b">id</code>和<code class="fe na nb nc mq b">title</code>。然后，我们遍历这些文章，对每篇文章执行另一个查询来加载该文章的作者。</p><p id="34d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们应该写这个。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="5400" class="mu ln it mq b gy mv mw l mx my">import psycopg2 as pg</span><span id="241b" class="mu ln it mq b gy mz mw l mx my">conn = psycopg2.connect(dbname='mydb')<br/>cur = conn.cursor()</span><span id="e3ea" class="mu ln it mq b gy mz mw l mx my"># Get articles and their authors at the same time<br/>cur.execute("""<br/>    SELECT <br/>        articles.id,<br/>        articles.title, <br/>        authors.name<br/>    from articles <br/>    left join authors on authors.article_id = articles.id<br/>""")<br/>articles = cur.fetchall()</span><span id="c702" class="mu ln it mq b gy mz mw l mx my"># for each article, print the article title and author name<br/>for a in articles:<br/>    print(a[1],a[2])</span><span id="6c8a" class="mu ln it mq b gy mz mw l mx my">cur.close()<br/>conn.close()</span></pre><p id="d5e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们同时检索文章及其作者。</p><p id="fe08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时，您实际上想要像这样(或成批)加载数据，特别是当加载的对象非常大并且可能超过您的机器的内存时。这在数据管道或训练机器学习模型时更为普遍。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="3042" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Rails示例</h1><p id="7d26" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">在框架环境中，甚至更容易意外地编写N+1个查询。如果您没有Rails背景知识，请注意控制器包含支持视图的逻辑。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="1a8f" class="mu ln it mq b gy mv mw l mx my"># Controller<br/>@articles = Article.all</span><span id="0ec8" class="mu ln it mq b gy mz mw l mx my"># View<br/>@articles.each do |a|<br/>  &lt;%= a.title %&gt;<br/>  &lt;%= a.author.name %&gt;</span></pre><p id="904f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述操作将导致执行以下查询。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="c649" class="mu ln it mq b gy mv mw l mx my">SELECT "articles".* FROM "articles"<br/><br/>SELECT "authors".* FROM "authors" WHERE "articles"."id" = $1 LIMIT 1 [["id", 1]]<br/>SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT 1 [["id", 2]]<br/>SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT 1 [["id", 3]]<br/>SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT 1 [["id", 4]]<br/>SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT 1 [["id", 5]]<br/>SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT 1 [["id", 6]]<br/>SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT 1 [["id", 7]]<br/>...</span></pre><p id="0c48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这太可怕了！我们应该写信的。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="c3cd" class="mu ln it mq b gy mv mw l mx my"># Controller<br/>@articles = Article.includes(:author)</span><span id="26ce" class="mu ln it mq b gy mz mw l mx my"># View<br/>@articles.each do |a|<br/>  &lt;%= a.title %&gt;<br/>  &lt;%= a.author.name %&gt;</span></pre><p id="46da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这导致下面的SQL被执行。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="cc2d" class="mu ln it mq b gy mv mw l mx my">SELECT  "articles".* FROM "articles"</span><span id="185e" class="mu ln it mq b gy mz mw l mx my">SELECT "authors".* FROM "authors" WHERE "authors"."article_id" IN (1, 2, 3,...)</span></pre><p id="367f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管这不是一个单独的查询，但这是一个显著的改进，尤其是当第一个查询返回了数千条记录时。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="04ed" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="ba00" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">N+1查询很容易做，并且(通常)很容易修复。但是当记录的数量很大时，对性能的影响会很大，所以即使你的应用很小，也最好避免这种查询模式，这样当你扩展时就不会成为问题。</p><p id="c5c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你有其他处理N+1的方法，我很乐意在评论中分享。</p></div></div>    
</body>
</html>