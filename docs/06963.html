<html>
<head>
<title>Watch out for nulls from Java’s collections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">注意Java集合中的空值</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/watch-out-for-nulls-from-javas-collections-d3a90b939af?source=collection_archive---------6-----------------------#2021-01-14">https://levelup.gitconnected.com/watch-out-for-nulls-from-javas-collections-d3a90b939af?source=collection_archive---------6-----------------------#2021-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8d1c6817993b3c9807eb37f976e4d52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QMPpYlJlOCLXtKSj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@yu62ballena?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">于(</a>)在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="cd14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，当我得到一个<code class="fe lb lc ld le b">NullPointerException</code>时，那是因为我在我的Java源文件中犯了一些愚蠢的错误，我可以很容易地改正。不过，有时候，这是因为一些Java集合允许空值从缝隙中掉出来，直到它们引起问题时才被发现。</p><p id="0b24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑一下<code class="fe lb lc ld le b">java.util.HashMap&lt;K, V&gt;</code>。它提供了一种非常方便的方法来将键对象映射到值对象。调用map的<code class="fe lb lc ld le b">put()</code>来添加一个键-值对，调用<code class="fe lb lc ld le b">get()</code>来通过键获取a值。</p><p id="d003" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">举个简单的例子，假设你正在开发一个日历程序，它每天都会给出一段鼓舞人心的引言。您已经创建了一个<code class="fe lb lc ld le b">Quotation</code>类，它提供了所有必要的功能，并且符合所有的最佳实践，包括空安全的最佳实践。</p><p id="3dab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">程序中的适当类创建了一个<code class="fe lb lc ld le b">HashMap&lt;LocalDate, Quotation&gt;</code>。获得今天的灵感引语可能是在散列表上调用<code class="fe lb lc ld le b">get(LocalDate.now())</code>的简单事情。</p><p id="7e52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设<code class="fe lb lc ld le b">Quotation</code>类提供了一个<code class="fe lb lc ld le b">formatAsHTML()</code>函数，然后您可以使用它将励志名言作为带有适当HTML标记的<code class="fe lb lc ld le b">String</code>发送给JavaFX <code class="fe lb lc ld le b">WebView</code>。一切都如你所愿。</p><p id="ac1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当散列映射被调用来给出一个没有键的值时会发生什么？它应该做一些类似throw <code class="fe lb lc ld le b">NoSuchElementException</code>的事情(和<code class="fe lb lc ld le b">HashMap&lt;K, V&gt;</code>一样，来自于<code class="fe lb lc ld le b">java.util</code>大杂烩)。</p><p id="f8ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但事实并非如此。它只是悄悄地返回null。这几乎总会导致一个<code class="fe lb lc ld le b">NullPointerException</code>错误，并带有一个没有价值的异常消息和一个令人困惑的堆栈跟踪。</p><p id="6b32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在开发我的扫雷器实现时遇到了这个问题(<a class="ae kc" href="https://github.com/Alonso-del-Arte/minesweeper" rel="noopener ugc nofollow" target="_blank">源代码和测试在GitHub </a>上)。它最终会有一个图形用户界面。</p><p id="d250" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是现在，你可以在命令行上玩这个游戏。如果你注意正确地输入位置，你可以玩得很好，例如，如果你想要标记位置O5，你必须输入“flag o5”。如果你输入“flag 05 ”,程序就会崩溃，并出现一个<code class="fe lb lc ld le b">NullPointerException</code>……我必须解决这个问题。</p><p id="63f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在我修复它之前，我必须找出是什么导致了这个异常。我很快就发现<code class="fe lb lc ld le b">Board</code>类中的一个哈希映射为越界位置返回空值，而不是我错误地认为的任何类型的异常。</p><p id="a792" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我甚至开始怀疑我是否只是想象了<code class="fe lb lc ld le b">NoSuchElementException</code>，也许在Java开发工具包(JDK)中没有这样的例外。或者这是Scala的事情。</p><p id="7399" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你可能知道的，Scala是一种用于Java虚拟机的编程语言。它提供了对整个JDK的访问，但它也提供了一些JDK类的更好版本，尤其是集合。</p><p id="73a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Scala有自己的可变<code class="fe lb lc ld le b">HashMap[K, V]</code>，这很像Java的<code class="fe lb lc ld le b">HashMap&lt;K, V&gt;</code>，也是不可变的<code class="fe lb lc ld le b">HashMap[K, V]</code>。</p><p id="c2ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到灵感引语日历，为了举例，假设我们的不可变散列图有今年除了今天之外的每一天的引语。获取两天前和昨天的励志名言非常简单:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="82b7" class="ln lo iq le b gy lp lq l lr ls">scala&gt; scalaImmutableHashMap(twoDaysAgo).formatAsHTML<br/>res8: String = &lt;blockquote&gt;&amp;ldquo;I have not failed. I've just found 10,000 ways that won't work.&amp;rdquo; &amp;mdash; Thomas Edison&lt;/blockquote&gt;</span><span id="d0fc" class="ln lo iq le b gy lt lq l lr ls">scala&gt; scalaImmutableHashMap(yesterday)<br/>res9: Quotation = "Unthinking respect for authority is the greatest enemy of truth." -- Albert Einstein</span></pre><p id="6b5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是当我们试图得到今天的报价时，这种情况发生了:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e02f" class="ln lo iq le b gy lp lq l lr ls">scala&gt; scalaImmutableHashMap(LocalDate.now)<br/>java.util.NoSuchElementException<br/>  at scala.collection.immutable.BitmapIndexedMapNode.apply(HashMap.scala:608)<br/>  at scala.collection.immutable.HashMap.apply(HashMap.scala:131)<br/>  ... 28 elided</span></pre><p id="6df0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">的确<code class="fe lb lc ld le b">NoSuchElementException</code>来自JDK。</p><p id="5dbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您愿意，也可以使用Java中熟悉的“<code class="fe lb lc ld le b">.get()</code>”语法。但是那个总是返回一个<code class="fe lb lc ld le b">Option[T]</code>(很像Java的<code class="fe lb lc ld le b">Optional&lt;T&gt;</code>)，其中类型<code class="fe lb lc ld le b">T</code>是相关的类型<code class="fe lb lc ld le b">V</code>。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="bcfa" class="ln lo iq le b gy lp lq l lr ls">scala&gt; scalaImmutableMap(threeDaysAgo)<br/>res14: Option[Quotation] = Some("Optimism is the faith that leads to achievement." -- Helen Keller)</span></pre><p id="39e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以在今天的日期使用<code class="fe lb lc ld le b">get()</code>会返回一个<code class="fe lb lc ld le b">None</code>。可变和不可变散列映射都是如此，更广泛使用的<code class="fe lb lc ld le b">Map[K, V]</code>也是如此，它既不需要导入也不需要完全限定名。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="6b19" class="ln lo iq le b gy lp lq l lr ls">scala&gt; scalaMutableHashMap.get(LocalDate.now)<br/>res24: Option[Quotation] = None</span></pre><p id="ba2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是当<code class="fe lb lc ld le b">NoSuchElementException</code>出现在Scala的可变哈希映射中时，异常消息会更有帮助:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="19dc" class="ln lo iq le b gy lp lq l lr ls">scala&gt; scalaMutableHashMap(LocalDate.now)<br/>java.util.NoSuchElementException: <strong class="le ir">key not found: 2021-01-13</strong><br/>  at scala.collection.MapOps.default(Map.scala:246)<br/>  at scala.collection.MapOps.default$(Map.scala:245)<br/>  at scala.collection.AbstractMap.default(Map.scala:376)<br/>  at scala.collection.mutable.HashMap.apply(HashMap.scala:405)<br/>  ... 28 elided</span></pre><p id="fb1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意上面写着“找不到钥匙:2021–01–13”为了便于比较，我们重新构建一个与Java <code class="fe lb lc ld le b">HashMap&lt;K, V&gt;</code>相同的map。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="36e8" class="ln lo iq le b gy lp lq l lr ls">scala&gt; val javaHashMap: java.util.HashMap[LocalDate, Quotation] = new java.util.HashMap<br/>javaHashMap: java.util.HashMap[java.time.LocalDate,Quotation] = {}</span><span id="2050" class="ln lo iq le b gy lt lq l lr ls">scala&gt; javaHashMap.put(threeDaysAgo, kellerQuote) <br/>                                                  // etc., etc.</span></pre><p id="0887" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了从Java散列映射中检索值，我们必须使用“<code class="fe lb lc ld le b">.get()</code>”语法。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="3b51" class="ln lo iq le b gy lp lq l lr ls">scala&gt; javaHashMap.get(fourDaysAgo)<br/>res39: Quotation = "Knowing what must be done does away with fear." -- Rosa Parks</span></pre><p id="f700" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将上一条异常消息与下一条异常消息进行比较:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="24c7" class="ln lo iq le b gy lp lq l lr ls">scala&gt; javaHashMap.get(LocalDate.now).formatAsHTML<br/>java.lang.NullPointerException<br/>  ... 28 elided</span></pre><p id="ade2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这是在本地Scala REPL上，所以很容易立即知道是什么导致了问题，即使堆栈跟踪几乎是零(28个省略的堆栈帧是特定于REPL的)。</p><p id="c638" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个异常不会把我们踢出REPL，但是我的扫雷程序中的一个异常会把我们踢出游戏。这就好像，即使你玩得很好，你仍然发现并引爆了一个地雷位置，而不是标记它。</p><p id="c58a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">堆栈跟踪确实给出了一些问题的指示，但是问题出在一个过程中，我已经允许它增长到大约四十行。这是另一个喜欢短单元的原因。我需要把<code class="fe lb lc ld le b">processCommand()</code>分成更小的单元。</p><p id="e48a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是为了解决游戏因玩家的小错误而崩溃的直接问题，我重写了<code class="fe lb lc ld le b">Board</code>类，这样当它的实例被要求在界外的位置操作时就会抛出<code class="fe lb lc ld le b">NoSuchElementException</code>。</p><p id="bfdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我重写了<code class="fe lb lc ld le b">ui.text.Game</code>,这样它除了通知玩家之外，不会对界外位置做任何事情。我仍然有工作要做的程序，显示相邻的空位置，但除此之外，我很满意我目前所得到的。</p><p id="52fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，这对于有图形用户界面的游戏来说不是问题。玩家可以随心所欲地点击出界，但除了消耗他们的游戏时间之外，不会有任何其他影响。</p><p id="b082" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下次当你在Java程序中遇到<code class="fe lb lc ld le b">NullPointerException</code>时，不要急于责怪自己。考虑它可能来自JDK或第三方库的可能性。</p></div></div>    
</body>
</html>