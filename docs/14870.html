<html>
<head>
<title>5 Tips for Optimizing Angular Bundle Size</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化角度束尺寸的5个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-tips-for-optimizing-angular-bundle-size-f0ce5be7c0de?source=collection_archive---------0-----------------------#2022-12-30">https://levelup.gitconnected.com/5-tips-for-optimizing-angular-bundle-size-f0ce5be7c0de?source=collection_archive---------0-----------------------#2022-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="b2cf" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="d2f3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">欢迎阅读我们关于优化角度束大小的文章！如果您是Angular开发人员，您会知道包的大小对应用程序的性能有很大的影响。包越大，应用程序加载和运行的时间就越长。</p><p id="4791" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这就是为什么关注包的大小并采取措施最小化它是很重要的。在这篇文章中，我们将分享5个技巧来减少角度束的大小并提高应用程序的性能。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/7f71e858d0719d3ad854b3676ec569ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGDDA2mfYkjiIhGaN8gDoA.png"/></div></div></figure><p id="fa1d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们将从仔细研究代码分割开始，这是一种将代码分成可以按需加载的小块的技术。我们还将讨论树抖动，这是一种从您的包中删除不必要的代码的方法。</p><p id="eea9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">接下来，我们将讨论优化依赖关系的重要性，以及选择正确的依赖关系如何有助于减少包的大小。我们还将讨论bundler优化器在最小化包大小方面的作用，以及如何根据您的需求选择合适的优化器。</p><p id="dd73" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">最后，我们将讨论聚合填充对束尺寸的影响，以及如何最大限度地减少它们的使用以减小束尺寸。</p><p id="a40d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">到本文结束时，您将对如何优化角度束大小和提高应用程序的性能有一个坚实的理解。我们开始吧！</p><h1 id="9e7e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">技巧1:使用代码分割策略</h1><p id="83b4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">代码分割是一种将代码分成可以按需加载的小块的技术。这对于角度应用尤其有用，由于其模块化架构，这些应用可能具有较大的束尺寸。</p><p id="c319" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">代码分割的工作原理是这样的:您可以使用Webpack这样的工具将代码分割成更小的块，而不是将所有代码捆绑到一个文件中。然后可以根据需要加载这些块，而不是一次全部加载。这可以显著减少应用程序的初始加载时间，尤其是当您有大量代码或大量依赖项时。</p><p id="0060" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">有几种方法可以在Angular中实现代码拆分。一种选择是使用角度路由器来延迟加载模块。这意味着只有当用户导航到使用该模块的路线时，才会加载该模块及其依赖项。这是减少包大小的一个很好的方法，特别是如果您有一个包含许多路由和模块的大型应用程序。</p><p id="d99c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">另一个选择是使用角度延迟加载特性，它允许您延迟加载组件及其依赖项。对于优化应用程序的性能来说，这是一项非常有用的技术，尤其是当您有很多组件并不是在每个页面上都要用到的时候。</p><p id="3d16" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">要在Angular应用程序中实现代码分割，您需要使用Webpack这样的捆绑器。Webpack内置了对代码分割的支持，有几个插件和工具可以帮助您设置它。</p><h2 id="62ea" class="ma jo iq bd jp mb mc dn jt md me dp jx kw mf mg kb la mh mi kf le mj mk kj ml bi translated">示例Webpack配置</h2><p id="548c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，您需要安装Webpack和必要的依赖项，比如<code class="fe mm mn mo mp b">@ngtools/webpack</code>插件:</p><pre class="lp lq lr ls gt mq mp mr bn ms mt bi"><span id="5038" class="mu jo iq mp b be mv mw l mx my">npm install --save-dev webpack webpack-cli @ngtools/webpack</span></pre><p id="3ade" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">接下来，您需要配置Webpack来使用代码分割。下面是一个Webpack配置文件的例子，它使用<code class="fe mm mn mo mp b">SplitChunksPlugin</code>设置代码分割:</p><pre class="lp lq lr ls gt mq mp mr bn ms mt bi"><span id="1782" class="mu jo iq mp b be mv mw l mx my">const path = require('path');<br/>const { AngularCompilerPlugin } = require('@ngtools/webpack');<br/>const { SplitChunksPlugin } = require('webpack').optimize;<br/><br/>module.exports = {<br/>  // Other Webpack configuration options...<br/>  optimization: {<br/>    splitChunks: {<br/>      chunks: 'all',<br/>      minSize: 30000,<br/>      maxSize: 0,<br/>      minChunks: 1,<br/>      maxAsyncRequests: 5,<br/>      maxInitialRequests: 3,<br/>      automaticNameDelimiter: '~',<br/>      name: true,<br/>      cacheGroups: {<br/>        vendors: {<br/>          test: /[\\/]node_modules[\\/]/,<br/>          priority: -10<br/>        },<br/>        default: {<br/>          minChunks: 2,<br/>          priority: -20,<br/>          reuseExistingChunk: true<br/>        }<br/>      }<br/>    }<br/>  },<br/>  plugins: [<br/>    // Other Webpack plugins...<br/>    new AngularCompilerPlugin({<br/>      // AngularCompilerPlugin options...<br/>      // This option specifies the Angular module to be loaded on demand<br/>      entryModule: path.join(__dirname, 'src/app/app.module#AppModule')<br/>    })<br/>  ]<br/>};</span></pre><p id="f1b3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这个Webpack配置使用<code class="fe mm mn mo mp b">SplitChunksPlugin</code>设置代码分割，它将您的代码分成更小的块，并按需加载。您可以通过修改<code class="fe mm mn mo mp b">splitChunks</code>选项来定制代码分割策略，比如最小块大小和将代码分割成块的标准。</p><p id="246b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">要在Angular应用程序中使用代码分割，您需要将<code class="fe mm mn mo mp b">loadChildren</code>属性添加到您的routes中，并指定应该按需加载的块的路径。以下是一个带有代码分割的路由配置示例:</p><pre class="lp lq lr ls gt mq mp mr bn ms mt bi"><span id="1290" class="mu jo iq mp b be mv mw l mx my">const routes: Routes = [<br/>  {<br/>    path: 'dashboard',<br/>    loadChildren: () =&gt; import('./dashboard/dashboard.module').then(m =&gt; m.DashboardModule)<br/>  },<br/>  {<br/>    path: 'users',<br/>    loadChildren: () =&gt; import('./users/users.module').then(m =&gt; m.UsersModule)<br/>  }<br/>  // Other routes...<br/>];</span></pre><p id="27fc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在本例中，<code class="fe mm mn mo mp b">dashboard</code>和<code class="fe mm mn mo mp b">users</code>路线被配置为使用代码分割。当用户导航到这些路线之一时，相应的块将按需加载。这有助于减少初始包的大小，提高应用程序的性能。</p><p id="0b42" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">您还可以通过在<code class="fe mm mn mo mp b">Routes</code>数组中指定<code class="fe mm mn mo mp b">loadChildren</code>属性，将代码拆分与角度延迟加载结合使用。下面是一个带有延迟加载和代码分割的路由配置示例:</p><pre class="lp lq lr ls gt mq mp mr bn ms mt bi"><span id="5be6" class="mu jo iq mp b be mv mw l mx my">const routes: Routes = [<br/>  {<br/>    path: 'dashboard',<br/>    loadChildren: () =&gt; import('./dashboard/dashboard.module').then(m =&gt; m.DashboardModule)<br/>  },<br/>  {<br/>    path: 'users',<br/>    loadChildren: () =&gt; import('./users/users.module').then(m =&gt; m.UsersModule)<br/>  }<br/>  // Other routes...<br/>];</span></pre><p id="ca62" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在这个例子中，<code class="fe mm mn mo mp b">dashboard</code>和<code class="fe mm mn mo mp b">users</code>路由被配置为使用代码分割和延迟加载。当用户导航到这些路线之一时，相应的块将按需加载，并且块中的组件和依赖项将仅在需要时加载。这有助于进一步减小初始包的大小，并提高应用程序的性能。</p><p id="bb94" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">需要注意的是，代码分割和延迟加载会增加应用程序的复杂性，而且它们并不适合所有的项目。仔细考虑权衡并决定这些技术是否适合您的特定需求是一个好主意。</p><p id="60a9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在决定是否在Angular应用程序中使用代码分割和延迟加载时，有几个因素需要考虑。以下是一些需要记住的事情:</p><ul class=""><li id="ed3f" class="mz na iq kn b ko lj ks lk kw nb la nc le nd li ne nf ng nh bi translated">包大小:如果您的应用程序有一个大的包大小，代码分割和延迟加载可以帮助减少初始加载时间和提高性能。</li><li id="6303" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">用户体验:通过减少初始加载时间，代码分割和延迟加载可以改善用户体验，特别是对于使用较慢连接或设备的用户。</li><li id="ce19" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">开发时间:实现代码分割和延迟加载可能需要额外的开发时间，因为您需要设置必要的依赖项并配置您的应用程序来使用这些技术。</li><li id="4037" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">维护:代码分割和延迟加载会增加应用程序的复杂性，从而增加维护和调试的难度。</li></ul><p id="6dca" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在决定是否在您的Angular应用程序中使用这些技术之前，仔细权衡代码分割和延迟加载的利弊是很重要的。在某些情况下，减少包大小和提高性能的好处可能超过额外的开发和维护成本。在其他情况下，增加的复杂性可能是不合理的，以其他方式优化您的应用程序可能更有效。</p><p id="cab7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">总之，代码分割和延迟加载是优化Angular应用程序性能的强大工具，但它们并不适合所有项目。仔细考虑权衡并决定这些技术是否适合您的特定需求是很重要的。</p><h1 id="13ff" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">技巧2:使用摇树方法</h1><p id="13dc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">树抖动是一种通过消除未使用的代码来减少包大小的技术。通过只包含实际使用的代码，您可以显著减小包的大小并提高应用程序的性能。以下是在角度模式下实现树抖动的一些技巧:</p><ul class=""><li id="4ce1" class="mz na iq kn b ko lj ks lk kw nb la nc le nd li ne nf ng nh bi translated">使用支持树抖动的捆绑器:要在Angular中使用树抖动，您需要使用像Webpack这样支持树抖动的捆绑器。您还需要配置您的bundler来对您的应用程序代码执行树抖动。</li><li id="dfe9" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">谨慎使用<code class="fe mm mn mo mp b">forRoot()</code>方法:当导入一个包含<code class="fe mm mn mo mp b">forRoot()</code>方法的模块时，确保只在应用程序的根模块中调用一次。这将有助于确保树抖动可以从导入的模块中删除不必要的代码。</li><li id="715c" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">在构建应用程序时使用<code class="fe mm mn mo mp b">--prod</code>标志:在为生产构建Angular应用程序时，一定要使用<code class="fe mm mn mo mp b">--prod</code>标志来启用树抖动和其他优化技术。</li><li id="ff8f" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">避免使用通配符导入:通配符导入，如<code class="fe mm mn mo mp b">import * as myModule from './my-module'</code>，可以阻止树抖动有效工作。不要使用通配符导入，考虑使用命名导入，比如<code class="fe mm mn mo mp b">import { myFunction } from './my-module'</code>。</li><li id="9711" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">使用<code class="fe mm mn mo mp b">@angular/cli</code> <code class="fe mm mn mo mp b">build</code>和<code class="fe mm mn mo mp b">test</code>命令:<code class="fe mm mn mo mp b">@angular/cli</code> <code class="fe mm mn mo mp b">build</code>和<code class="fe mm mn mo mp b">test</code>命令可以通过自动设置必要的编译器选项来帮助优化您的树抖动应用程序。</li></ul><h2 id="1b45" class="ma jo iq bd jp mb mc dn jt md me dp jx kw mf mg kb la mh mi kf le mj mk kj ml bi translated">示例树摇动配置</h2><pre class="lp lq lr ls gt mq mp mr bn ms mt bi"><span id="58d0" class="mu jo iq mp b be mv mw l mx my">const path = require('path');<br/>const { AngularCompilerPlugin } = require('@ngtools/webpack');<br/><br/>module.exports = {<br/>  // Other Webpack configuration options...<br/>  optimization: {<br/>    usedExports: true<br/>  },<br/>  plugins: [<br/>    // Other Webpack plugins...<br/>    new AngularCompilerPlugin({<br/>      // AngularCompilerPlugin options...<br/>      // This option enables tree shaking for the imported modules<br/>      tsConfigPath: path.join(__dirname, 'tsconfig.json'),<br/>      skipCodeGeneration: true,<br/>      sourceMap: true,<br/>      compilerOptions: {<br/>        enableIvy: true,<br/>        fullTemplateTypeCheck: true,<br/>        strictInjectionParameters: true,<br/>        enableTreeShaking: true<br/>      }<br/>    })<br/>  ]<br/>};</span></pre><p id="47e0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在本例中，<code class="fe mm mn mo mp b">AngularCompilerPlugin</code>配置为使用<code class="fe mm mn mo mp b">enableTreeShaking</code>选项启用树摇动。<code class="fe mm mn mo mp b">optimization.usedExports</code>选项也被设置为<code class="fe mm mn mo mp b">true</code>,以确保只有使用过的导出包含在捆绑包中。</p><p id="bc5b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">要使用这个配置，您需要在您的项目中包含<code class="fe mm mn mo mp b">@ngtools/webpack</code>包，并配置您的Webpack构建来使用<code class="fe mm mn mo mp b">AngularCompilerPlugin</code>。您还需要将<code class="fe mm mn mo mp b">tsConfigPath</code>选项设置为TypeScript配置文件的路径，并将<code class="fe mm mn mo mp b">skipCodeGeneration</code>和<code class="fe mm mn mo mp b">sourceMap</code>选项设置为适合您的项目。</p><p id="4fbd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">有了这个配置，当您为生产构建应用程序时，Webpack将对您的Angular应用程序代码执行树抖动。这有助于减小包的大小，提高应用程序的性能。</p><p id="ca3b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">需要注意的是，这只是一个如何在Angular应用中实现树抖动的例子。根据您的具体需求和要求，在您的应用程序中还有许多其他方式来配置树抖动。</p><h1 id="6ad3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">技巧3:优化你的依赖关系</h1><p id="cae4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">影响包大小的一个关键因素是应用程序中包含的依赖项的数量和大小。通过优化您的依赖项，您可以帮助减少您的包的大小并提高您的应用程序的性能。以下是一些在Angular中优化依赖性的技巧:</p><ul class=""><li id="c899" class="mz na iq kn b ko lj ks lk kw nb la nc le nd li ne nf ng nh bi translated">使用轻量级库:在为应用程序选择库和依赖项时，寻找提供所需功能的轻量级选项，而不添加大量不必要的代码。例如，您可以使用一个更小、更集中的库，比如Bamburgh UI，它只提供您需要的组件，而不是使用像Material这样的全功能UI库。</li><li id="507d" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">使用依赖项分析器工具:有几种工具可以帮助您分析应用程序中的依赖项，并确定可以优化或删除不必要的依赖项的区域。例如，Webpack bundle Analyzer插件可以向您展示您的Bundle的可视化，并突出显示最大的依赖项，因此您可以看到哪些库对您的Bundle的大小贡献最大。</li><li id="3f53" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">考虑使用代码分割和延迟加载方法:通过将代码分割成更小、更集中的代码块，并且只延迟加载需要的代码，您可以帮助减少代码包的大小并提高应用程序的性能。</li><li id="91d6" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">使用<code class="fe mm mn mo mp b">ng build --prod</code>命令:在为生产构建应用程序时，一定要使用<code class="fe mm mn mo mp b">ng build --prod</code>命令，它可以帮助优化您的依赖关系，并从您的包中删除不必要的代码。</li></ul><p id="40d2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通过遵循这些提示并优化您的依赖项，您可以帮助减少您的包的大小并提高您的Angular应用程序的性能。</p><p id="f59f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">总之，优化依赖关系是减少包的大小和提高Angular应用程序性能的重要一步。通过选择轻量级库、使用依赖项分析器工具以及考虑代码分割和延迟加载方法，您可以帮助确保您的应用程序尽可能高效。</p><h1 id="42b8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">技巧4:使用捆绑器优化器</h1><p id="ef3f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">bundler optimizer是一种工具，可以分析您的应用程序代码并针对生产进行优化，有助于减少您的包的大小并提高您的应用程序的性能。Angular有几个可用的bundler优化器，每个都有自己的一套功能和优点。以下是选择和使用捆绑器优化器的一些提示:</p><ul class=""><li id="579c" class="mz na iq kn b ko lj ks lk kw nb la nc le nd li ne nf ng nh bi translated">选择一个非常适合您需求的捆绑器优化器:有许多捆绑器优化器可用，每一个都有自己的特性和功能。选择bundler优化器时，请考虑应用程序的大小和复杂性，以及您的特定性能和优化目标。</li><li id="c8a1" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">使用与您的工作流程集成的捆绑器优化器:选择一个能够无缝融入您的工作流程且易于使用的捆绑器优化器非常重要。寻找一个有好的文档并受到社区良好支持的工具。</li><li id="bfc7" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">正确配置bundler优化器:要充分利用bundler优化器，请确保正确配置它。这可能涉及到设置选项或在配置文件中添加插件。请务必仔细阅读所选bundler optimizer的文档，以确保正确使用它。</li><li id="7fe1" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">在构建应用程序时使用<code class="fe mm mn mo mp b">--prod</code>标志:在为生产构建Angular应用程序时，确保使用<code class="fe mm mn mo mp b">--prod</code>标志来启用bundler优化和其他优化技术。</li></ul><p id="48a7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通过遵循这些提示并使用捆绑器优化器，您可以帮助减少捆绑器的大小，并提高角度应用程序的性能。</p><h2 id="33fe" class="ma jo iq bd jp mb mc dn jt md me dp jx kw mf mg kb la mh mi kf le mj mk kj ml bi translated">示例Webpack捆绑包分析器插件配置</h2><pre class="lp lq lr ls gt mq mp mr bn ms mt bi"><span id="7c80" class="mu jo iq mp b be mv mw l mx my">npm install --save-dev webpack-bundle-analyzer</span></pre><p id="7b09" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">接下来，更新Webpack配置文件以包含插件:</p><pre class="lp lq lr ls gt mq mp mr bn ms mt bi"><span id="5ba7" class="mu jo iq mp b be mv mw l mx my">const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');<br/><br/>module.exports = {<br/>  // Other Webpack configuration options...<br/>  plugins: [<br/>    // Other Webpack plugins...<br/>    new BundleAnalyzerPlugin()<br/>  ]<br/>};</span></pre><p id="e0c0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">最后，构建您的Angular应用程序并运行bundle analyzer:</p><pre class="lp lq lr ls gt mq mp mr bn ms mt bi"><span id="236e" class="mu jo iq mp b be mv mw l mx my">ng build --prod<br/>webpack-bundle-analyzer dist/&lt;your-project-name&gt;/stats.json</span></pre><p id="256f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这将在您的默认浏览器中打开Webpack Bundle Analyzer，显示您的Bundle的可视化表示，并突出显示最大的依赖项。您可以使用这些信息来确定可以优化或删除不必要的依赖项的区域，以减小包的大小。</p><p id="b595" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">需要注意的是，这只是在Angular应用程序中使用捆绑器优化器的一个例子。还有许多其他可用的bundler优化器，每一个都有自己的特性和功能。请确保选择最适合您特定需求和要求的工具。</p><h1 id="9441" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">提示#5:最小化有角度的多边形填充</h1><p id="e319" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">聚合填充是为并非所有现代浏览器都提供的功能提供支持的库。虽然polyfills有助于确保您的应用程序在各种平台上运行，但它们也会增加包的大小并影响性能。以下是一些在角度上最小化聚合填充的提示:</p><ul class=""><li id="6c60" class="mz na iq kn b ko lj ks lk kw nb la nc le nd li ne nf ng nh bi translated">使用有针对性的聚合填充策略:不要在应用程序中包含所有可能的聚合填充，可以考虑使用有针对性的方法，只包含特定目标平台所需的聚合填充。这有助于减小包的大小，提高应用程序的性能。</li><li id="fbf3" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">使用<code class="fe mm mn mo mp b">ng add</code>命令添加聚合填充:向角度应用添加聚合填充时，考虑使用<code class="fe mm mn mo mp b">ng add</code>命令，该命令可帮助您选择和配置应用所需的聚合填充。</li><li id="7673" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">使用<code class="fe mm mn mo mp b">browserlist</code>配置文件:<code class="fe mm mn mo mp b">browserlist</code>配置文件允许您为您的应用指定目标平台，并相应地配置必要的polyfills。通过使用<code class="fe mm mn mo mp b">browserlist</code>文件，可以确保只包含目标平台所需的聚合填充。</li><li id="ac21" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">使用<code class="fe mm mn mo mp b">@angular/cli</code> <code class="fe mm mn mo mp b">build</code>和<code class="fe mm mn mo mp b">test</code>命令:<code class="fe mm mn mo mp b">@angular/cli</code> <code class="fe mm mn mo mp b">build</code>和<code class="fe mm mn mo mp b">test</code>命令可以通过自动设置必要的编译器选项来帮助优化多填充应用程序。</li></ul><p id="00ec" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通过遵循这些提示并最大限度地减少聚合填充的使用，您可以帮助减小束的大小并提高角度应用的性能。</p><p id="0988" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">总之，最大限度地减少多孔填料的使用是减小束尺寸和提高角度应用性能的重要一步。通过使用有针对性的多填充策略并利用像<code class="fe mm mn mo mp b">ng add</code>和<code class="fe mm mn mo mp b">browserlist</code>命令这样的工具，您可以帮助确保您的应用程序尽可能高效。</p><h2 id="854a" class="ma jo iq bd jp mb mc dn jt md me dp jx kw mf mg kb la mh mi kf le mj mk kj ml bi translated">样本配置</h2><p id="e09a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，在Angular项目的根目录下创建一个<code class="fe mm mn mo mp b">.browserlistrc</code>文件，并为您的应用程序指定目标平台:</p><pre class="lp lq lr ls gt mq mp mr bn ms mt bi"><span id="b18a" class="mu jo iq mp b be mv mw l mx my"># This configuration targets the last 2 versions of each browser<br/>last 2 versions</span></pre><p id="b4b6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">接下来，更新您的<code class="fe mm mn mo mp b">tsconfig.app.json</code>文件以包含<code class="fe mm mn mo mp b">browserlist</code>配置:</p><pre class="lp lq lr ls gt mq mp mr bn ms mt bi"><span id="1a1b" class="mu jo iq mp b be mv mw l mx my">{<br/>  "extends": "./tsconfig.json",<br/>  "compilerOptions": {<br/>    "outDir": "./out-tsc/app",<br/>    "types": [<br/>      "node"<br/>    ],<br/>    "downlevelIteration": true,<br/>    "experimentalDecorators": true,<br/>    "emitDecoratorMetadata": true,<br/>    "importHelpers": true,<br/>    "baseUrl": "src",<br/>    "paths": {<br/>      "app/*": [<br/>        "app/*"<br/>      ],<br/>      "environments/*": [<br/>        "environments/*"<br/>      ]<br/>    }<br/>  },<br/>  "exclude": [<br/>    "test.ts",<br/>    "**/*.spec.ts"<br/>  ],<br/>  "angularCompilerOptions": {<br/>    "fullTemplateTypeCheck": true,<br/>    "strictInjectionParameters": true,<br/>    "enableIvy": true,<br/>    "preserveWhitespaces": false,<br/>    "buildOptimizer": true,<br/>    "sourceMap": true,<br/>    "polyfills": "./polyfills.ts",<br/>    "browserTarget": "app:build:production"<br/>  }<br/>}</span></pre><p id="5b0b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">注意<code class="fe mm mn mo mp b">angularCompilerOptions</code>部分的<code class="fe mm mn mo mp b">"polyfills": "./polyfills.ts"</code>和<code class="fe mm mn mo mp b">"browserTarget": "app:build:production"</code>选项。这些选项告诉Angular使用<code class="fe mm mn mo mp b">polyfills.ts</code>文件进行聚合填充，并在构建应用程序时以指定平台为目标。</p><p id="009d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">最后，使用<code class="fe mm mn mo mp b">ng build --prod</code>命令构建您的角度应用程序。这将使用<code class="fe mm mn mo mp b">browserlist</code>配置为指定的目标平台优化您的应用程序，并仅包括必要的聚合填充。</p><h1 id="8abe" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="d51a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">总之，优化角度束大小是提高应用程序性能的重要一步。通过遵循本文中概述的技巧，您可以帮助减少束的大小，并提高角度应用的速度和效率。</p><p id="433e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这篇文章的一些要点包括:</p><ul class=""><li id="4437" class="mz na iq kn b ko lj ks lk kw nb la nc le nd li ne nf ng nh bi translated">使用代码分割策略将您的应用程序分成更小、更易管理的块</li><li id="a5cf" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">使用树摇动方法从您的包中删除不必要的代码</li><li id="e1fc" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">优化依赖项，删除不必要或多余的库</li><li id="1250" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">使用捆绑优化器来分析和优化您的捆绑包</li><li id="97b6" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">尽量减少多孔填料的使用，以减小管束尺寸</li></ul><p id="1300" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通过遵循这些最佳实践，您可以帮助确保您的Angular应用程序尽可能高效和高性能。</p><p id="99ff" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">总的来说，优化角度束大小是提高应用性能和效率的重要一步。通过遵循本文中概述的技巧，您可以帮助确保您的应用程序以最佳状态运行。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="e886" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">不要错过我即将推出的内容和技术指南:</strong></p><div class="nu nv gp gr nw nx"><a href="https://medium.com/@nicchong/subscribe" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">每当Nic Chong发布时收到电子邮件。</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">每当Nic Chong发布时收到电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ly nx"/></div></div></a></div><p id="f1ca" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果你有什么问题，我在这里帮忙，在评论区等你:)</p></div></div>    
</body>
</html>