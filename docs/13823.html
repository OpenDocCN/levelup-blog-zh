<html>
<head>
<title>Error Handling in Rest APIs using the Axum Framework and Custom Error Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Axum框架和自定义错误模型处理Rest APIs中的错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/error-handling-in-rest-apis-using-axum-framework-and-custom-error-model-d91d0343c7df?source=collection_archive---------6-----------------------#2022-10-10">https://levelup.gitconnected.com/error-handling-in-rest-apis-using-axum-framework-and-custom-error-model-d91d0343c7df?source=collection_archive---------6-----------------------#2022-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e82000f933d34ec33a3b50f1bbdd3fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j1cnBwZhe-hup8zP.jpg"/></div></div></figure><p id="3b1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文讨论了使用Axum框架和在Rust中编写REST APIs时的错误处理策略。虽然Axum是一个写得非常好的框架，并且有很好的范例，但是作为程序员，我们有责任在框架内优雅而有意义地处理错误。</p><p id="9d7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将研究两种不同的方法，并在此基础上构建一个错误处理模型，每个人都可以使用该模型来共享和编写高质量的处理程序，并处理好错误。</p><h1 id="85b4" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">通用API错误处理</h1><p id="0cce" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Axum提供了一种非常简单的错误处理方式。需要理解的一个原则是，如果出现错误，应用程序不会崩溃。所有错误必须是<code class="fe mc md me mf b">Infallible </code>。</p><p id="3fa7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mg">简单来说，所有的错误都是可以通过HTTP渲染的响应。</em></p><p id="80e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像我们将一个JSON对象表示为一个响应一样，我们可以将我们的错误建模为可以提供给客户的对象——带有正确的响应代码。在这篇文章中，我们将从两个不同的角度来看待这个问题。带有字符串错误的简单状态响应。为了简单起见，我们将从文本响应开始，它可以由AXUM内置的<code class="fe mc md me mf b">StatusCode</code>错误呈现器来呈现。</p><h1 id="268e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">项目设置</h1><p id="155d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们为这个演示创建一个新的应用程序。</p><pre class="mh mi mj mk gt ml mf mm mn aw mo bi"><span id="0dad" class="mp la it mf b gy mq mr l ms mt">cargo new axum-error-handling-demo</span></pre><p id="25f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加以下依赖项，开始编写我们的API。</p><p id="5fd3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将添加一个简单的处理程序，它需要一个查询参数，并在我们的响应中返回相同的参数。这就像一个添加了查询参数值的hello world。下面是我们的应用程序定义，它在<code class="fe mc md me mf b">/hello</code>呈现这个端点</p><h1 id="94ac" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">调用我们的基本API</h1><p id="53f2" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">有了这个设置，我们可以运行我们的服务器(<code class="fe mc md me mf b">cargo run</code>，并在我们的本地机器上测试它。</p><p id="e765" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们尝试使用下面的端点来调用我们的API。</p><pre class="mh mi mj mk gt ml mf mm mn aw mo bi"><span id="b7e7" class="mp la it mf b gy mq mr l ms mt"><a class="ae mu" href="http://localhost:3000/hello?name=test" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/hello?name=test</a></span></pre><p id="2305" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们会看到有我们名字的回复。</p><p id="8c04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，尝试在不传递查询参数的情况下调用这个API。我们看到现在有了以下响应。</p><pre class="mh mi mj mk gt ml mf mm mn aw mo bi"><span id="6c72" class="mp la it mf b gy mq mr l ms mt"><a class="ae mu" href="http://localhost:3000/hello" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/hello</a></span></pre><p id="5dff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们看到的反应是</p><pre class="mh mi mj mk gt ml mf mm mn aw mo bi"><span id="169d" class="mp la it mf b gy mq mr l ms mt">Failed to deserialize query string: missing field `name`</span></pre><p id="d723" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么我们会看到这个？在一个正确的实现规范中，我们应该能够看到一个验证错误消息，说明这个字段是必需的。</p><p id="7d6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是<strong class="kd iu">上面的消息暴露了应用程序实现的细节，这根本不是一个好的实践。</strong></p><h1 id="2cf6" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">解决办法</h1><p id="38cb" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">要解决这个问题，我们可以使用一个简单的方法。我们可以让我们的结构接受一个<code class="fe mc md me mf b">Option&lt;String&gt;</code>，而不是一个字符串参数。这样，如果没有值，我们就不会得到包含内部细节的错误消息。</p><p id="8614" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步是<em class="mg">对输入执行验证，以确保我们可以向客户发送定制的错误响应。</em></p><p id="ecb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请在下面找到更新的结构:</p><p id="9341" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在尝试在没有查询参数的情况下调用同一个端点。您应该会看到一条很好的错误消息，告诉您可能出了什么问题。</p><pre class="mh mi mj mk gt ml mf mm mn aw mo bi"><span id="6577" class="mp la it mf b gy mq mr l ms mt">http://localhost:3000/hello <br/>Required Parameter name is missing within the request.</span></pre><h1 id="adc3" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Json错误</h1><p id="51f0" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">到目前为止，我们已经看到了如何在Axum框架中将错误建模为简单的字符串。</p><p id="7774" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于大多数REST APIs都是作为JSON APIs编写的，所以让我们看看如何将错误建模为JSON格式的响应。</p><p id="b209" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了将错误建模为JSON，我们需要定义我们的应用程序错误模型。我们将创建一个新的<code class="fe mc md me mf b">ApiError</code>对象，它将作为根错误。在其中，我们将存储http状态代码，并添加一些助手方法来初始化错误。我们还使用了一个库<code class="fe mc md me mf b">thiserror</code>,帮助我们在Rust中轻松创建自定义错误。</p><h1 id="36d3" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">将错误转换为响应</h1><p id="ae9d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">正如我们在第一部分中看到的，错误只是对API中某些错误的一种响应方式。它不应该使我们的程序崩溃，但应该为客户提供一个有意义的状态，说明问题可能是什么。当使用自定义结构时，我们有责任将它们转换成正确的响应。</p><p id="a666" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为一个框架，axum使得处理错误变得非常简单。如果调用成功，您可以把它想象成另一个JSON响应。此外，我们将确保调整Http响应代码，以便客户端可以采取必要的措施。</p><p id="024b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了确保axum能够将<code class="fe mc md me mf b">ApiError</code>理解为错误响应类型，我们将尝试为我们的结构实现一个特征<code class="fe mc md me mf b">IntoResponse</code>。这告诉axum这是一个有效的错误类型。该错误中的任何有效负载都将使用Json序列化转换为HttpResponse。</p><p id="3e69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们的结构<code class="fe mc md me mf b">ApiError</code>的实现。</p><p id="5adc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以看到，我们解析了与错误相关的状态代码，并将我们的结构序列化为响应。</p><p id="ed0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过这种方式，我们的用户现在可以以一种良好的json格式预览所有的错误。让我们实现一个处理程序并尝试一下。注意我们的API的方法签名是如何变化的。</p><h1 id="4632" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">测试API</h1><p id="0dd9" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们可以用一个有效的查询参数重复前面的调用，我们应该会看到一个新的响应和正确的结果。</p><pre class="mh mi mj mk gt ml mf mm mn aw mo bi"><span id="35aa" class="mp la it mf b gy mq mr l ms mt"><a class="ae mu" href="http://localhost:3000/hello?name=test" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/hello?name=test</a></span><span id="d4d2" class="mp la it mf b gy mv mr l ms mt">{ "greeting": "hello", "name": "test" }</span></pre><p id="37ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们在没有查询参数的情况下尝试一下。</p><pre class="mh mi mj mk gt ml mf mm mn aw mo bi"><span id="21c6" class="mp la it mf b gy mq mr l ms mt"><a class="ae mu" href="http://localhost:3000/hello?name=test" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/hello?name=test</a></span><span id="9f51" class="mp la it mf b gy mv mr l ms mt">{<br/>    "status_code": 400,<br/>    "errors": [<br/>        "Required Parameter name is missing within the request."<br/>    ]<br/>}</span></pre><h1 id="cbe0" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="7839" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">你在这篇文章中看到的是一个非常简单，但功能强大的技术，用于Rust中Axum框架的错误处理。我们注意到，我们的处理程序定义本身已经简化，我们的<code class="fe mc md me mf b">ApiError</code>结构确保它知道如何向用户发送响应。最初设置这个项目可能很麻烦，但是一旦设置好，应用程序中的所有错误处理无疑都是标准化的。这个ApiError结构甚至可以在一个板条箱中分开，并且可以在多个Axum项目中用于错误处理。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="5aba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mg">原载于2022年10月10日</em><a class="ae mu" href="https://shanmukhsista.com/posts/technology/apis/error-handling-in-rest-apis-using-axum-framework-and-custom-error-model-rest-apis/" rel="noopener ugc nofollow" target="_blank"><em class="mg">【https://shanmukhsista.com】</em></a><em class="mg">。</em></p></div></div>    
</body>
</html>