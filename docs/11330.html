<html>
<head>
<title>Designing Software in a Complex Domain: Domain-Driven Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在复杂领域中设计软件:领域驱动设计</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/designing-software-in-a-complex-domain-domain-driven-design-10604ad08d12?source=collection_archive---------4-----------------------#2022-03-08">https://levelup.gitconnected.com/designing-software-in-a-complex-domain-domain-driven-design-10604ad08d12?source=collection_archive---------4-----------------------#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4804" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">建模软件以符合商业现实</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dffd99379a7f3e5cecd5723b70c0d3c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lsd0Dc3_m2eNK4vuhAZDsA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:【pexels.com T2】</figcaption></figure><p id="c6b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件的核心是处理和解决可用的业务环境和问题。今天的企业业务领域通常很大，而且复杂，并且在不断发展/变化——以及接受这种增强的软件。领域驱动设计(DDD)是一种软件开发方法，其中软件工件与核心业务概念和目标完全一致。</p><p id="3450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">领域驱动设计是由<a class="ae ky" href="https://www.amazon.com/Eric-Evans/e/B001KDCO2I/ref=dp_byline_cont_book_1" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">Eric Evans</strong></a><strong class="lb iu"/>在其著作<a class="ae ky" href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=pd_sbs_14_t_0/137-5419951-0842927?_encoding=UTF8&amp;pd_rd_i=0321125215&amp;pd_rd_r=e2ec0e29-603b-4c31-a76e-b4419a8fe1f9&amp;pd_rd_w=vMMsg&amp;pd_rd_wg=zdDXi&amp;pf_rd_p=5cfcfe89-300f-47d2-b1ad-a4e27203a02a&amp;pf_rd_r=A4XCP34BVJBZC8GPVX5W&amp;psc=1&amp;refRID=A4XCP34BVJBZC8GPVX5W" rel="noopener ugc nofollow" target="_blank"> <em class="lv">领域驱动设计:解决软件核心的复杂性</em> </a> <em class="lv">中提出的。它由模式、原则和集合组成，使团队能够专注于业务成功的核心。</em></p><blockquote class="lw lx ly"><p id="5689" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“领域驱动设计(DDD)是一种为复杂需求开发软件的方法，通过将实现与核心业务概念的演进模型紧密联系起来。”——dddcommunity.org</p></blockquote><h1 id="2916" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题域建模——战略DDD</h1><p id="62cc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">战略DDD关注高层次的架构设计决策。它包括业务流程建模、域到子域的分解以及它们之间的集成模式。无处不在的语言、有界的上下文和上下文图是领域战略图景的关键组成部分。</p><h2 id="39c4" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">无处不在的语言——提炼领域知识</h2><p id="e683" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与领域专家的持续协作是理解和交流领域见解的战略设计的核心。领域概念需要在涉众(领域专家、开发人员、产品经理、设计人员)之间以相同的术语、含义和上下文进行交流，不能有歧义。</p><p id="b1cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终目标是在对话中创建术语/语言的一致性，以创建反映沟通语言的模型/代码。例如，如果您需要在订阅期间定义一个方法来创建用户，请使用方法名称<code class="fe nl nm nn no b">signupForSubscription</code>而不是<code class="fe nl nm nn no b">create</code>方法。</p><p id="71cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有效的领域建模者是优秀的知识消化者。参考<a class="ae ky" href="https://thedomaindrivendesign.io/developing-the-ubiquitous-language/" rel="noopener ugc nofollow" target="_blank">此处</a>关于无处不在的语言的发展和挑战。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/9f8c1ae8967169bbf95b6e4ace525b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uHa5UNSmCSppWZdZ3a-32w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">无处不在的语言</figcaption></figure><h2 id="6eb2" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">有界上下文——大而复杂的领域？分裂以征服</h2><blockquote class="lw lx ly"><p id="2cad" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“哪里有问题，哪里就有太大的问题”——利奥波德·科尔</p></blockquote><p id="5f24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个复杂的领域模型可以被分割成更集中的区域来管理复杂性，并在设计和执行中带来灵活性。为了<strong class="lb iu">划分</strong>(并征服)复杂域，我们需要创建一个逻辑<strong class="lb iu">边界</strong>来分解成<strong class="lb iu">子域</strong>。子域是问题空间的一部分，反映了组织的业务流程。</p><p id="4842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇博文中，我们将考虑一个典型的电子商务应用程序的例子</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/54e8a86ce83e570df5ed7a411e7e811a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0T_M4Boff8_7QBjqgCG0Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图2典型电子商务应用程序中的子域</figcaption></figure><p id="06d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多个子域(核心、支持或通用)。为了解决这个问题，我们引入了一个<strong class="lb iu">有界上下文</strong>，它是子域<strong class="lb iu">适用性</strong>的一个有形边界，在这里一个特定的<strong class="lb iu">域模型</strong>一致地适用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/58e269722602b724356d653a1cd66a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Wz3hSodYuc9Z0HxzZsH8w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">问题空间和有界环境</figcaption></figure><p id="2cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑两个有界的上下文——支付和运输。在支付上下文中，客户表示诸如信用卡信息、税率、业务号码和帐单地址等属性。在运输方面，客户数据可以是交货地址、交货时间偏好。这两种上下文的术语(语言)和领域专家可以是不同的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/aed1f0f6aa1699f8d7e17c4d2a187238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5NT0cAM7cV9ONnY7Bj2U3w.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图1 .相同的对象承载不同的上下文</figcaption></figure><h2 id="32ed" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">识别您的领域中的有界上下文</h2><p id="5320" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">领域知识的深度洞察力对于识别有界环境是必不可少的。业务相关性、自主性、语言边界、数据流以及与其他上下文的关系是识别有界上下文的线索。<a class="ae ky" href="https://www.eventstorming.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">事件风暴</strong></a><strong class="lb iu"/>(workshop approach for a high-level overview)<strong class="lb iu"/>&amp;<a class="ae ky" href="https://github.com/ddd-crew/bounded-context-canvas" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">有界语境画布</strong> </a>(设计&amp;文档的工具)有助于有界语境的探索。</p><h2 id="43b9" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">上下文映射</h2><p id="bd54" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就实现业务目标而言，有界上下文不是独立的。它们之间的集成是必需的。上下文映射是对系统的不同有界上下文之间的关系进行识别、分类和可视化描述的过程。有<a class="ae ky" href="https://github.com/ddd-crew/context-mapping" rel="noopener ugc nofollow" target="_blank">种不同的上下文映射模式</a>，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/d5a7cfcb2bf247adde77f5a9d038e8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLfR-2Vf1yqBUCyNFPQy5w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图:上下文映射模式(图片来源:<a class="ae ky" href="https://github.com/ddd-crew" rel="noopener ugc nofollow" target="_blank">https://github.com/ddd-crew</a></figcaption></figure><h1 id="b113" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">战术设计模式——在有限的上下文中塑造代码</h1><p id="c572" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">战术设计模式是在代码级别上实现有界上下文的指南。一个<strong class="lb iu">域模型</strong>需要精确地定义，并在一个有界的上下文中应用。</p><ul class=""><li id="ca26" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated"><strong class="lb iu">实体:</strong>实体是具有唯一标识(数据库中的主键或系统生成的ID)的对象，该标识会随着时间的推移而保持不变。客户可以是电子商务应用程序中具有名称、电子邮件和地址属性的实体。</li><li id="1ef7" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><strong class="lb iu">值对象:</strong>没有完全由其属性定义的标识的对象。让我们考虑一个货币价值对象- <code class="fe nl nm nn no b">100 AUD</code>。这个值对象是可比较的(可以和<code class="fe nl nm nn no b">90 USD</code>比较)、不可变的(创建一个新的而不是替换它)、自我验证器(不能有一个货币无效的值对象<code class="fe nl nm nn no b">25 ABC</code>)。</li><li id="e383" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><strong class="lb iu">聚合:</strong>聚合是定义事务一致性边界的实体和值对象的封装。假设你有一个带有<code class="fe nl nm nn no b">OrderInfo</code>和<code class="fe nl nm nn no b">OrderItems</code>的<code class="fe nl nm nn no b"><strong class="lb iu">Order</strong></code>。<code class="fe nl nm nn no b">OrderInfo</code>的变化可能会改变订单的状态。类似地，订单总量会随着<code class="fe nl nm nn no b">OrderItems</code>的变化而变化，所有这些都有一个严格的交易边界，需要始终保持一致。<code class="fe nl nm nn no b">Order</code>、<code class="fe nl nm nn no b">OrderInfo</code>和<code class="fe nl nm nn no b">OrderItems</code>一起构成一个<strong class="lb iu"> <em class="lv">集合体</em> </strong>。聚合中只有一个实体是根，其标识符用于查找。根实体的子实体通过跟随来自根的指针来引用。</li><li id="7ee6" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><strong class="lb iu">储存库和工厂:</strong>工厂用于通过提供实体和值对象来创建新的集合。存储库提供了访问持久存储的逻辑封装。</li></ul><h1 id="2d20" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分层架构</h1><p id="b62b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每个有界的上下文被划分成以下内聚的水平层。</p><h2 id="f811" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">用户界面</h2><p id="5450" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这一层向用户提供接口。这一层负责显示数据和捕获用户命令。</p><h2 id="1969" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">应用层</h2><p id="2844" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">业务流程流在这一层处理。域实体在这里被创建和更新。</p><h2 id="6259" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">领域模型层</h2><p id="fc3e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">领域的数据和行为在概念上在领域模型中建模。这里定义了<strong class="lb iu">实体、值对象、集合、工厂和接口</strong>来表达领域规则和逻辑。领域模型的设计通常不依赖于其他层、第三方或持久层。然后，应用层协调这些决策。领域模型层和应用层分离的细节参见<a class="ae ky" href="https://enterprisecraftsmanship.com/posts/domain-vs-application-services/" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h2 id="063f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">基础设施层</h2><p id="6faa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最初保存在域实体中的数据被持久保存在数据库或另一个持久存储中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/500a59bf821ecbf10a1a214861c40322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H9h6el_TzZdDMgjWar-k7A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图3 DDD的不同层次</figcaption></figure><h2 id="db82" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">代码实现</h2><ul class=""><li id="3c19" class="nu nv it lb b lc mu lf mv li oj lm ok lq ol lu nz oa ob oc bi translated"><a class="ae ky" href="https://github.com/mahad96/adm-vs-ddd/tree/master/src" rel="noopener ugc nofollow" target="_blank">贫血域模型vs DDD </a></li><li id="1dab" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">ASP。NET <a class="ae ky" href="https://github.com/abpframework/abp/" rel="noopener ugc nofollow" target="_blank"> ABP框架</a></li><li id="9444" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://www.baeldung.com/hexagonal-architecture-ddd-spring" rel="noopener ugc nofollow" target="_blank">弹簧框架</a></li><li id="c36e" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://github.com/joshuaalpuerto/node-ddd-boilerplate" rel="noopener ugc nofollow" target="_blank"> Node.js样板文件</a></li></ul><h1 id="7ecd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">DDD什么时候适用？</strong></h1><p id="a6cf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">DDD不仅仅是一个编码食谱。它是关于对需要理解业务语义(概念和行为)的系统有帮助的战略思维。然而，这不是一个全有或全无的交易。我们可以根据您的项目实施这些想法(战略或战术方法)。DDD方法可能不太适合以CRUD为中心的系统。</p><p id="7f34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">沃恩·弗农唤起他的<a class="ae ky" href="http://www.informit.com/articles/article.aspx?p=1944876&amp;seqNum=2" rel="noopener ugc nofollow" target="_blank"> DDD记分卡</a>来决定是否值得应用DDD。<a class="ae ky" href="https://github.com/ddd-crew/ddd-starter-modelling-process" rel="noopener ugc nofollow" target="_blank">该回购</a>为DDD的启动提供了极好的洞察力。</p><h1 id="3a0f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">DDD和微服务</h1><p id="07d1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://martinfowler.com/articles/microservices.html" rel="noopener ugc nofollow" target="_blank">微服务</a>是一种架构模式，通过松散耦合、可独立部署、小型且可重用的服务(微单元)来设计应用程序。DDD有助于通过“有限的上下文”保持较小的服务范围单个有界上下文通常映射到一个微服务，但它可以有一对多的关系。DDD帮助识别子域和上下文映射，这有助于微服务之间的通信。</p><p id="1693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优步实施了基于DDD的<a class="ae ky" href="https://eng.uber.com/microservice-architecture/" rel="noopener ugc nofollow" target="_blank">面向领域的微服务架构(DOMA) </a>。你可以在这里找到指导方针<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice" rel="noopener ugc nofollow" target="_blank">来设计面向DDD的微服务。</a></p><h1 id="533e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理独石</h1><p id="b627" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">单片应用程序是很好的开始。当产品发展时，它将变得难以管理，我们需要转移到<a class="ae ky" href="https://en.wikipedia.org/wiki/Service-oriented_architecture" rel="noopener ugc nofollow" target="_blank"> SOA </a>。这种过渡可以通过基于DDD的中间模块方法<a class="ae ky" href="https://github.com/kgrzybek/modular-monolith-with-ddd" rel="noopener ugc nofollow" target="_blank">来实现</a>。</p><h1 id="6ac1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">应用DDD的挑战</h1><p id="60f3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">应用DDD时的一些常见挑战包括创建无处不在的语言所花费的时间、一开始对领域专家的要求、抽象开销、事务管理、领域建模的合理性。</p><h2 id="9f3e" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">参考</h2><ul class=""><li id="c966" class="nu nv it lb b lc mu lf mv li oj lm ok lq ol lu nz oa ob oc bi translated"><a class="ae ky" href="https://www.amazon.com/Patterns-Principles-Practices-Domain-Driven-Design/dp/1118714709" rel="noopener ugc nofollow" target="_blank">领域驱动设计的模式、原则和实践——Scott Millett和Nick Tune </a></li><li id="0395" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577" rel="noopener ugc nofollow" target="_blank">实现领域驱动设计——沃恩·弗农</a></li><li id="2889" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/architecture/microservice/microservice-DDD-cqrs-patterns/DDD-oriented-microservice</a></li><li id="5a08" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://github.com/ddd-crew/ddd-starter-modelling-process" rel="noopener ugc nofollow" target="_blank">https://github.com/ddd-crew/ddd-starter-modelling-process</a></li><li id="281c" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://eng.uber.com/microservice-architecture/" rel="noopener ugc nofollow" target="_blank">https://eng.uber.com/microservice-architecture/</a></li><li id="2713" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://netflixtechblog.com/ready-for-changes-with-hexagonal-architecture-b315ec967749" rel="noopener ugc nofollow" target="_blank">https://netflixtechblog . com/ready-for-changes with-hexagonal-architecture-b 315 EC 967749</a></li></ul></div></div>    
</body>
</html>