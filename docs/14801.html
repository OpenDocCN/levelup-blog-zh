<html>
<head>
<title>Rust: Result Type Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust:解释的结果类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rust-result-type-explained-c0162b363a5f?source=collection_archive---------2-----------------------#2022-12-26">https://levelup.gitconnected.com/rust-result-type-explained-c0162b363a5f?source=collection_archive---------2-----------------------#2022-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a995" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理解Rust结果类型，用于处理计算中的成功和错误情况，并使用其方法来处理和操作值。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/27f985263bba3747eabc6a34e4ea75cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0uJB2qBaaGR1biF82CBOgw.jpeg"/></div></div></figure><h2 id="3e82" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">定义</h2><p id="39ca" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated"><code class="fe ly lz ma mb b">Result</code>类型是Rust标准库提供的通用枚举。它表示计算的结果，可以是成功的(<code class="fe ly lz ma mb b">Ok</code>变量)，也可以是不成功的(<code class="fe ly lz ma mb b">Err</code>变量)。</p><p id="8fe6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ly lz ma mb b">Result</code>类型定义如下:</p><pre class="kp kq kr ks gt mc mb md bn me mf bi"><span id="1d00" class="mg lb it mb b be mh mi l mj mk">enum Result&lt;T, E&gt; {<br/>    Ok(T),<br/>    Err(E),<br/>}</span></pre><p id="ec5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ly lz ma mb b">T</code>和<code class="fe ly lz ma mb b">E</code>类型参数分别代表成功和不成功结果的类型。例如，您可以使用<code class="fe ly lz ma mb b">Result&lt;T, E&gt;</code>来表示一个计算，如果成功，则返回一个类型为<code class="fe ly lz ma mb b">T</code>的值，如果失败，则返回一个类型为<code class="fe ly lz ma mb b">E</code>的错误。</p><h2 id="0ca9" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">用法示例</h2><p id="ea87" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">下面是一个使用<code class="fe ly lz ma mb b">Result</code>包装可能失败的函数的结果的例子:</p><pre class="kp kq kr ks gt mc mb md bn me mf bi"><span id="5fc7" class="mg lb it mb b be mh mi l mj mk">fn parse_int(s: &amp;str) -&gt; Result&lt;i32, std::num::ParseIntError&gt; {<br/>    s.parse::&lt;i32&gt;().map_err(|e| e.into())<br/>}<br/><br/>fn main() {<br/>    let result = parse_int("5");<br/>    match result {<br/>        Ok(n) =&gt; println!("Parsed integer: {}", n),<br/>        Err(e) =&gt; println!("Error parsing integer: {}", e),<br/>    }<br/>}</span></pre><p id="fedf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，<code class="fe ly lz ma mb b">parse_int</code>函数试图从一个字符串中解析一个整数。如果解析成功，该函数将返回一个包含已解析整数的<code class="fe ly lz ma mb b">Ok</code>变量。如果解析失败，函数返回一个包含发生的<code class="fe ly lz ma mb b">ParseIntError</code>的<code class="fe ly lz ma mb b">Err</code>变量。</p><h2 id="bb3d" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">处理结果</h2><p id="e17c" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">您可以使用模式匹配来处理<code class="fe ly lz ma mb b">Result</code>值。在上面的例子中，我们使用一个<code class="fe ly lz ma mb b">match</code>表达式来处理<code class="fe ly lz ma mb b">Ok</code>和<code class="fe ly lz ma mb b">Err</code>变量。您还可以使用<code class="fe ly lz ma mb b">unwrap</code>方法从<code class="fe ly lz ma mb b">Ok</code>变量中提取值，但是如果值是<code class="fe ly lz ma mb b">Err</code>变量，这将会出错:</p><pre class="kp kq kr ks gt mc mb md bn me mf bi"><span id="e76d" class="mg lb it mb b be mh mi l mj mk">let result = parse_int("5");<br/>let n = result.unwrap(); // Will panic if result is an Err variant<br/>println!("Parsed integer: {}", n);</span></pre><p id="d20b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于可能会引起恐慌，所以非常不鼓励在生产代码中使用<code class="fe ly lz ma mb b">unwrap()</code>。</p><p id="586f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">处理<code class="fe ly lz ma mb b">Result</code>值的另一种方式是使用<code class="fe ly lz ma mb b">map</code>和<code class="fe ly lz ma mb b">map_err</code>方法。这些方法允许您通过对其应用函数来转换<code class="fe ly lz ma mb b">Ok</code>或<code class="fe ly lz ma mb b">Err</code>变量内部的值。</p><p id="a754" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，假设您有一个函数<code class="fe ly lz ma mb b">divide</code>，它将两个整数相除，并返回一个<code class="fe ly lz ma mb b">Result</code>来指示相除是否成功:</p><pre class="kp kq kr ks gt mc mb md bn me mf bi"><span id="4f67" class="mg lb it mb b be mh mi l mj mk">fn divide(x: i32, y: i32) -&gt; Result&lt;i32, DivisionError&gt; {<br/>    if y == 0 {<br/>        return Err(DivisionError::DivideByZero);<br/>    }<br/>    Ok(x / y)<br/>}</span></pre><h2 id="33de" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><code class="fe ly lz ma mb b">map()</code>和<code class="fe ly lz ma mb b">map_err()</code></h2><p id="d23b" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">您可以使用<code class="fe ly lz ma mb b">map</code>方法将除法的成功结果转换成不同的类型，比如浮点数:</p><pre class="kp kq kr ks gt mc mb md bn me mf bi"><span id="ad8e" class="mg lb it mb b be mh mi l mj mk">let result = divide(10, 2);<br/>let f: Result&lt;f32, DivisionError&gt; = result.map(|n| n as f32);</span></pre><p id="a482" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还可以使用<code class="fe ly lz ma mb b">map_err</code>方法将误差值转换成不同的类型:</p><pre class="kp kq kr ks gt mc mb md bn me mf bi"><span id="1cf5" class="mg lb it mb b be mh mi l mj mk">let result = divide(10, 0);<br/>let f: Result&lt;i32, &amp;str&gt; = result.map_err(|e| match e {<br/>    DivisionError::DivideByZero =&gt; "Divide by zero",<br/>    DivisionError::Negative =&gt; "Cannot divide by negative number",<br/>});</span></pre><h2 id="fca5" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">更多结果处理</h2><p id="80f3" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">除了<code class="fe ly lz ma mb b">map</code>和<code class="fe ly lz ma mb b">map_err</code>方法之外，<code class="fe ly lz ma mb b">Result</code>类型还提供了其他几种处理和操作值的方法。这里有几个例子:</p><pre class="kp kq kr ks gt mc mb md bn me mf bi"><span id="20e4" class="mg lb it mb b be mh mi l mj mk">fn add_one(x: i32) -&gt; Result&lt;i32, &amp;'static str&gt; {<br/>    if x &gt; 100 {<br/>        return Err("Number too large");<br/>    }<br/>    Ok(x + 1)<br/>}<br/><br/>fn add_two(x: i32) -&gt; Result&lt;i32, &amp;'static str&gt; {<br/>    if x &gt; 50 {<br/>        return Err("Number too large");<br/>    }<br/>    Ok(x + 2)<br/>}<br/><br/>fn add_three(x: i32) -&gt; Result&lt;i32, &amp;'static str&gt; {<br/>    if x &gt; 30 {<br/>        return Err("Number too large");<br/>    }<br/>    Ok(x + 3)<br/>}<br/><br/>// Using and_then<br/>let result = add_one(5).and_then(|x| add_two(x)).and_then(|x| add_three(x));<br/>assert_eq!(result, Ok(11));<br/><br/>// Using or_else<br/>let result = add_one(105).or_else(|e| add_two(5)).or_else(|e| add_three(5));<br/>assert_eq!(result, Ok(7));<br/><br/>// Using unwrap_or<br/>let result = add_one(105).unwrap_or(100);<br/>assert_eq!(result, 100);<br/><br/>// Using unwrap_or_else<br/>let result = add_one(105).unwrap_or_else(|e| -1);<br/>assert_eq!(result, -1);</span></pre><p id="2088" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这些例子中，我们有三个函数，每个函数执行一个操作并返回一个<code class="fe ly lz ma mb b">Result</code>值。<code class="fe ly lz ma mb b">and_then</code>方法允许我们将这些函数链接在一起，如果所有的计算都成功，就返回最终的操作结果。如果任何计算失败，立即返回<code class="fe ly lz ma mb b">Err</code>变量。</p><p id="7326" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ly lz ma mb b">or_else</code>方法与<code class="fe ly lz ma mb b">and_then</code>相似，但它应用于<code class="fe ly lz ma mb b">Err</code>变体，而不是<code class="fe ly lz ma mb b">Ok</code>变体。它允许我们在原始计算失败时指定一个后备计算。</p><p id="13af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ly lz ma mb b">unwrap_or</code>方法返回<code class="fe ly lz ma mb b">Ok</code>变量内部的值，如果<code class="fe ly lz ma mb b">Result</code>是<code class="fe ly lz ma mb b">Err</code>变量，则返回默认值。当您希望在出现错误时提供默认值，而不是显式处理错误时，这很有用。</p><p id="d423" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ly lz ma mb b">unwrap_or_else</code>方法类似于<code class="fe ly lz ma mb b">unwrap_or</code>，但是它将一个闭包作为参数应用于<code class="fe ly lz ma mb b">Err</code>变量内部的错误值，以产生一个默认值。当您需要根据误差值计算默认值时，这很有用。</p><p id="edce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这些例子有助于阐明Rust中处理和操作<code class="fe ly lz ma mb b">Result</code>值的不同可用方法的用途和功能。</p><h2 id="1daa" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">你想联系吗？</h2><p id="6350" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">如果你想联系我，请通过LinkedIn 联系我。</p><p id="c598" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，请随意查看我的书籍推荐📚。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><div class="kp kq kr ks gt mt"><a href="https://mr-pascal.medium.com/my-book-recommendations-4b9f73bf961b" rel="noopener follow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">我的书籍推荐</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">在接下来的章节中，你可以找到我对所有日常生活话题的书籍推荐，它们对我帮助很大。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">mr-pascal.medium.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh ky mt"/></div></div></a></div><div class="ni nj gp gr nk mt"><a href="https://mr-pascal.medium.com/membership" rel="noopener follow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">通过我的推荐链接加入Medium—Pascal Zwikirsch</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">mr-pascal.medium.com</p></div></div><div class="nc l"><div class="nl l ne nf ng nc nh ky mt"/></div></div></a></div></div></div>    
</body>
</html>