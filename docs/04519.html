<html>
<head>
<title>How To Write GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写GitHub动作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-github-actions-30b54ddf6f52?source=collection_archive---------6-----------------------#2020-06-30">https://levelup.gitconnected.com/how-to-write-github-actions-30b54ddf6f52?source=collection_archive---------6-----------------------#2020-06-30</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="30c5" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用Python在Docker中编写自定义GitHub动作。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/66401a3519771083cbe64309f0d3483b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZ_jv-xjX_FfJR5fQH_6UQ.png"/></div></div></figure><p id="9064" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi lr translated">你听说过GitHub的行动吗？如果不是，那么另一个问题；在提交代码以遵循项目策略之前，您曾经不得不做五个步骤吗？比如运行linter，运行测试，创建一个包含变更分解的CHANGELOG，等等。光是列出它们听起来就有很多工作要做。任何开发人员都想做更多的工作，但是，不管怎样，它们都是重要的步骤。它们不是无缘无故放在那里的，它们有助于整个项目管理。</p><p id="8a2f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">回到主题——GitHub Actions——这是GitHub对编程领域日益发展的DevOps运动的回应。</p><p id="45ec" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">去年11月，在前COVID时代，GitHub宣布了GitHub行动；他们对市场上不断增长的持续集成/持续部署(CI/CD)应用程序和服务的响应。我认为这是一个很好的机会，可以继续留在GitHub社区，而不必再次学习一个单独的工具(虽然我尝试过Travis-CI和Circle-CI，但不是最大的粉丝)。</p><p id="cdec" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><a class="ae ma" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank">摘自GitHub的动作专题网站:</a></p><blockquote class="mb mc md"><p id="3eed" class="kv kw me kx b ky kz jv la lb lc jy ld mf lf lg lh mg lj lk ll mh ln lo lp lq in bi translated">GitHub Actions现在拥有世界一流的CI/CD，可以轻松实现所有软件工作流程的自动化。直接从GitHub构建、测试和部署您的代码。按照您想要的方式进行代码审查、分支管理和问题分类。</p></blockquote><p id="6a60" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">GitHub操作的可能性是无限的:在合并到主分支之前运行linter对每个拉取请求运行完整的测试套件；将您发布的版本部署到像Netlify这样的提供商；你思考它，你编码它，你拥有它。</p><p id="5060" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">目前，<a class="ae ma" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank"> GitHub Marketplace </a>上有4206个动作——我记得在11月份我被加入测试版时还不到40个🤯——而且这个列表还在不断增长(很明显)！我鼓励你尽可能地发挥创造力，拥有你想出的东西！</p><p id="0e1a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">简要概述一下我们将在这篇文章中讨论的内容:</p><ol class=""><li id="f878" class="mi mj iu kx b ky kz lb lc le mk li ml lm mm lq mn mo mp mq bi translated">工作流和操作概念</li><li id="7b58" class="mi mj iu kx b ky mr lb ms le mt li mu lm mv lq mn mo mp mq bi translated">来自<a class="ae ma" href="https://help.github.com/en/actions/" rel="noopener ugc nofollow" target="_blank"> GitHub动作文档</a>的一个简单动作</li><li id="18dc" class="mi mj iu kx b ky mr lb ms le mt li mu lm mv lq mn mo mp mq bi translated">您自己的自定义操作</li></ol></div><div class="ab cl mw mx hy my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="in io ip iq ir"><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nd"><img src="../Images/360001ee03fe71390e2827775d862efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2WUmHRP1l1ciwarH"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated"><a class="ae ma" href="https://unsplash.com/@campaign_creators?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">活动创建者</a>在<a class="ae ma" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="bf78" class="ni nj iu bd nk nl nm nn no np nq nr ns ka nt kb nu kd nv ke nw kg nx kh ny nz bi translated">工作流和操作概念</h1><p id="2dc5" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">那么，到底什么是行动呢？我们从GitHub的片段中讨论了它们是什么，但是坐在电脑前——作为一名程序员，我知道——你必须<em class="me">看到它。</em></p><p id="bc14" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在我们谈论行动之前，还有一些其他的核心概念要谈。</p><h2 id="a16d" class="of nj iu bd nk og oh dn no oi oj dp ns le ok ol nu li om on nw lm oo op ny oq bi translated">工作流程</h2><p id="3723" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">工作流是您编写的描述作业和您想要采取的步骤(操作)的文件。这些文件以`. yml '或`. yaml '格式编写；如果你以前从未使用过，它只是一种简单的人类可读的数据序列化语言。这些工作流文件存储在项目根目录下的`. github `文件夹中。</p><p id="5009" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在您的本地计算机上`/path/to/your/project/。确切地说是github/workflows。</p><p id="59ff" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">那么工作流到底是什么样子的呢？</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj or"><img src="../Images/5d7ad49351afbe061c6832445d9cf539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XT7NzC3cDniwCxeFCK-ywA.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">取自文档。</figcaption></figure><p id="87a0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">为了更清楚起见，让我们慢慢地浏览一下这个文件。</p><p id="b31f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe os ot ou ov b">name</code>是要运行的工作流的名称。</p><p id="816a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe os ot ou ov b">on</code>是触发时工作流将运行的事件类型。它们可以是push、pull和pull请求，但是<a class="ae ma" href="https://help.github.com/en/actions/reference/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank">也可以是更多的</a>。</p><p id="c861" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe os ot ou ov b">jobs</code>是工作流程的最后一块肉。这定义了要运行的作业以及每个作业中要采取的步骤。正如你所看到的，在再次缩进之前，在jobs下面有以下标签:<code class="fe os ot ou ov b">name</code>、<code class="fe os ot ou ov b">runs-on</code>和<code class="fe os ot ou ov b">steps</code>。</p><p id="9a21" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe os ot ou ov b">runs-on</code>定义运行作业的操作系统。关于跑步有几个选择，但我认为最重要的是T7。</p><p id="d44c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe os ot ou ov b">steps</code>是您希望作业运行的实际<strong class="kx iv"> GitHub动作</strong>。请记住，这些步骤是连续的(1、2、3……)，但可以有先前的依赖关系。工作流的步骤是我们将要添加自定义操作的地方。</p><h2 id="484d" class="of nj iu bd nk og oh dn no oi oj dp ns le ok ol nu li om on nw lm oo op ny oq bi translated">行动</h2><p id="c1bd" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">动作在工作流文件中被调用，但是实现本身存储在一个单独的repo中，或者作为项目中的一个文件夹。动作有各种形状和形式，当您创建自己的动作时，您会看到如何将存储在同一个存储库中的动作用作项目的动作。</p></div><div class="ab cl mw mx hy my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="in io ip iq ir"><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ow"><img src="../Images/6c5221248c165b2ce5eca2ac88aa932f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2J8P3tRms2ftOG8y"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">由<a class="ae ma" href="https://unsplash.com/@dvandijk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David van Dijk </a>在<a class="ae ma" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="7fdb" class="ni nj iu bd nk nl nm nn no np nq nr ns ka nt kb nu kd nv ke nw kg nx kh ny nz bi translated">文档中的一个简单动作</h1><p id="8d1e" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">让我们继续并开始教程部分。现在我们已经知道了一些关键概念，我们可以更好地理解如何创建一个动作。</p><h2 id="b15c" class="of nj iu bd nk og oh dn no oi oj dp ns le ok ol nu li om on nw lm oo op ny oq bi translated">创建新的回购协议</h2><p id="8e46" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">首先，打开浏览器，进入<a class="ae ma" href="https://repo.new" rel="noopener ugc nofollow" target="_blank"> repo.new </a>。我不久前了解到的一个简洁的小链接。</p><blockquote class="mb mc md"><p id="7a32" class="kv kw me kx b ky kz jv la lb lc jy ld mf lf lg lh mg lj lk ll mh ln lo lp lq in bi translated">也适用于谷歌文档(<a class="ae ma" href="https://docs.new" rel="noopener ugc nofollow" target="_blank"> docs.new </a>，<a class="ae ma" href="https://sheets.new" rel="noopener ugc nofollow" target="_blank"> sheets.new，</a> <a class="ae ma" href="https://slides.new" rel="noopener ugc nofollow" target="_blank"> slides.new </a>)。</p></blockquote><p id="1d72" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">根据您的喜好设置项目。如果您希望以后发布它，它必须是具有唯一名称的公共文件。创建项目后，将其克隆到本地机器上。</p><p id="d553" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在您的计算机上，运行以下命令在根文件夹中设置初始项目文件夹结构:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ox"><img src="../Images/a1283dc34b9fdf71d2c00ed53e61e7ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzrdUQ93AKjpmlw0AJpaNg.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">您知道吗，您可以使用“；”字符串运行单独的命令？</figcaption></figure><p id="8bfc" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在<code class="fe os ot ou ov b">greetings.yml</code>文件中复制并粘贴代码:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj or"><img src="../Images/5d7ad49351afbe061c6832445d9cf539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XT7NzC3cDniwCxeFCK-ywA.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">文档中的“问候每个人”动作。</figcaption></figure><p id="c42e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">添加文件，提交(类似于“feat:添加了我的第一个工作流”)并推送。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oy"><img src="../Images/8aa1035c0cdf856e99f57ac265f643f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M37_oK68RyPS6IzQ7jk1qQ.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">使劲推。</figcaption></figure><p id="940c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个可以直接上主(<a class="ae ma" href="https://www.cnet.com/news/microsofts-github-is-removing-coding-terms-like-master-and-slave/" rel="noopener ugc nofollow" target="_blank">还是还“主”</a>？)分支，因为它对<em class="me">所有</em>推事件都起作用。触发工作流的事件有<a class="ae ma" href="https://help.github.com/en/actions/reference/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank">多种，您可以查看所有事件的文档。</a></p><h2 id="08d4" class="of nj iu bd nk og oh dn no oi oj dp ns le ok ol nu li om on nw lm oo op ny oq bi translated">查看结果</h2><p id="dd2c" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">一旦你创建了一个新的空白回购，添加-提交-推工作流文件；您现在应该能够看到工作流已经运行了！</p><blockquote class="mb mc md"><p id="ea29" class="kv kw me kx b ky kz jv la lb lc jy ld mf lf lg lh mg lj lk ll mh ln lo lp lq in bi translated"><em class="iu">为将来的票据；取决于什么</em> <a class="ae ma" href="https://help.github.com/en/actions/reference/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank"> <em class="iu">事件</em> </a> <em class="iu">工作流被写入运行，工作流在被推送时可能不会立即运行。</em></p></blockquote><p id="0b94" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">要检查运行的结果，只需进入你在GitHub上做的回购，在顶部栏点击“操作”</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oz"><img src="../Images/85c3db30f3e0e7a4eca387d5236fb49d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYpC_D0jEhoBA5jgX1x1jQ.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">调试动作有时可能很糟糕，但是一旦它准备好了并开始工作，它们会节省很多时间！我喜欢在投入生产之前在单独的回购中进行测试。</figcaption></figure><blockquote class="pa"><p id="18c9" class="pb pc iu bd pd pe pf pg ph pi pj lq dk translated">瞧啊。如果一切按计划进行，您已经运行了您的第一个GitHub操作，干得好！你可以在这里找到我的问候动作<a class="ae ma" href="https://github.com/srepollock/github-actions-temporary/commit/d3e08771bd7e0d10c35aaf66af87823cdb392b94" rel="noopener ugc nofollow" target="_blank">的源代码</a>。忽略混乱的历史，因为我把它变成了后续教程的测试运行程序。</p></blockquote></div><div class="ab cl mw mx hy my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="in io ip iq ir"><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pk"><img src="../Images/cddbc7ffb718c16d4b826e22bf25aa80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gdFRjeCqJSsHgUlX"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">Artur Kornakov 在<a class="ae ma" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="50e2" class="ni nj iu bd nk nl nm nn no np nq nr ns ka nt kb nu kd nv ke nw kg nx kh ny nz bi translated">您的第一个自定义操作</h1><p id="db6d" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">我希望你仍然渴望知识。那是一次很棒的味觉测试，但是现在是时候吃主菜了。让我们继续进行自定义操作。</p><p id="3749" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在我们编码之前，让我们定义保持专注于我们想要创建的东西的需求。该行动应:</p><ul class=""><li id="1ad6" class="mi mj iu kx b ky kz lb lc le mk li ml lm mm lq pl mo mp mq bi translated">基于项目的提交历史生成一个<code class="fe os ot ou ov b">CHANGELOG.md</code>文件</li><li id="42a9" class="mi mj iu kx b ky mr lb ms le mt li mu lm mv lq pl mo mp mq bi translated">仅在接收请求时运行</li><li id="55b1" class="mi mj iu kx b ky mr lb ms le mt li mu lm mv lq pl mo mp mq bi translated">在拉请求合并到主文件之前添加文件</li></ul><h2 id="93f3" class="of nj iu bd nk og oh dn no oi oj dp ns le ok ol nu li om on nw lm oo op ny oq bi translated">制作GitHub动作的方法</h2><p id="9715" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">根据文档，目前(截至2020年6月)有两种方法来创建行动<a class="ae ma" href="https://help.github.com/en/actions/creating-actions" rel="noopener ugc nofollow" target="_blank">:</a></p><ul class=""><li id="b7ae" class="mi mj iu kx b ky kz lb lc le mk li ml lm mm lq pl mo mp mq bi translated">JavaScript (Windows、Linux、MacOS)</li><li id="3594" class="mi mj iu kx b ky mr lb ms le mt li mu lm mv lq pl mo mp mq bi translated">或者Docker (Linux)。</li></ul><p id="3cd7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们将着重于创建一个Docker动作，因为我相信这是一个创建动作的更好的方法，并且能够用不同的语言创建大量的动作！当我们调用<code class="fe os ot ou ov b">Dockerfile</code>中的<code class="fe os ot ou ov b">ENTRYPOINT</code>时，你会看到这一点。</p><p id="37b8" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们继续创建另一个回购。第一个仍然可以工作，(<a class="ae ma" href="https://github.com/srepollock/github-actions-temporary" rel="noopener ugc nofollow" target="_blank">正如你看到的我混乱的历史</a>)，但是你可能想把它放到GitHub市场上，所以我说，“让我们重新开始”。</p><h2 id="b19d" class="of nj iu bd nk og oh dn no oi oj dp ns le ok ol nu li om on nw lm oo op ny oq bi translated">设置</h2><p id="b9c5" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">像以前一样，我们将需要一个工作流文件来运行项目。在与我们之前相同的目录中创建一个(但是对于新项目):</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pm"><img src="../Images/f7b711cfc476b8b1cf0129195f57410f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r639cN_umeoCQVvZ_ivrfg.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">我以前在什么地方见过这个…</figcaption></figure><p id="f6f3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如前所述，我们希望它只在对主机的拉请求上运行。这很简单，但这将是一个多任务工作流，该工作流看起来像:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pn"><img src="../Images/03592ae8585b600aedd64e4466666766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*twuXc9Db_41wpCjg0b3QPg.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">我们的多重工作流程。</figcaption></figure><p id="fd5b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个文件有点难以分解，但是它是如何使用动作get和提交文件的。正如您所见，我不会一一介绍，它的结构与<code class="fe os ot ou ov b">greet-everyone.yaml</code>工作流相似。然而，主要的区别是这个工作流程有两个任务:<code class="fe os ot ou ov b">generate</code>和<code class="fe os ot ou ov b">upload</code>。</p><p id="e124" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">要了解如何运行该操作，请查看中间的两行:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pn"><img src="../Images/380e40ab15cde35b7a1b859f65577b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHEYrnTM0TKLXseFD7NNcg.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">这将调用根项目中定义的操作。</figcaption></figure><p id="771d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这是我们的自定义操作的运行方式。<code class="fe os ot ou ov b">./</code>表示我们想要使用当前文件夹。无论您的<code class="fe os ot ou ov b">action.yaml</code>文件位于何处，它都是您在这里传递的相对文件夹路径。稍后我会详细介绍这个文件，但是要知道，我们正在创建的这个操作的所有文件都应该在根项目文件夹中。</p><p id="4b11" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在我们知道了操作运行的位置，要开始执行这个操作，我们需要创建一些必需的文件。让我们制作<code class="fe os ot ou ov b">README.md</code>、<code class="fe os ot ou ov b">Dockerfile</code>、<code class="fe os ot ou ov b">changelog-generator.py</code>和<code class="fe os ot ou ov b">action.yml</code>文件。现在只是一些空白文件，我们稍后会填充它们。</p><p id="5b4c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">你可以这样做得很快:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj po"><img src="../Images/40ff9f4491c6184c368390d833c0e6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*20b_olsVuOKJSYKOHbJjfA.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">赢得胜利的俏皮话。</figcaption></figure><h2 id="9a0e" class="of nj iu bd nk og oh dn no oi oj dp ns le ok ol nu li om on nw lm oo op ny oq bi translated">Dockerfile文件</h2><p id="ec40" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">让我们先处理一下<code class="fe os ot ou ov b">Dockerfile</code>,因为它将在服务器上运行来运行我们的脚本或动作。</p><p id="10ac" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果你以前从未使用过Docker，不要担心！我不会涉及所有的细节——这真的应该是它自己的帖子——但我会给你最起码的启动和运行这个行动。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pp"><img src="../Images/ef7ead831a39a24b78e6ba6de7cb83f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xx0Q1RZr0yuCOcQX-s01w.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">有时候Docker真的就是这么简单。</figcaption></figure><p id="dfe1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">多克到此为止。对于这个自定义操作，我们不需要任何参数，所以就运行文件而言，它非常简单明了。</p><p id="ed98" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">很快，我们所说的就是设置一个<code class="fe os ot ou ov b">python3</code>环境，复制我们将要编写的脚本，然后运行命令<code class="fe os ot ou ov b">python /changelog_generator.py</code>。</p><p id="4c8d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果你想知道更多，查看一下<a class="ae ma" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Docker文档</a>，因为它非常全面。</p><h2 id="921e" class="of nj iu bd nk og oh dn no oi oj dp ns le ok ol nu li om on nw lm oo op ny oq bi translated">生成器脚本</h2><p id="6ab9" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">现在，我们将继续填写Python脚本。这是提交将被收集、解析并写入<code class="fe os ot ou ov b">CHANGELOG.md</code>文件的地方。</p><blockquote class="pa"><p id="865f" class="pb pc iu bd pd pe pq pr ps pt pu lq dk translated">这就是我们一直在等待的发电机。</p></blockquote><p id="3cee" class="pw-post-body-paragraph kv kw iu kx b ky pv jv la lb pw jy ld le px lg lh li py lk ll lm pz lo lp lq in bi translated">这个脚本将在几个关键点上发挥作用:</p><ul class=""><li id="c1f4" class="mi mj iu kx b ky kz lb lc le mk li ml lm mm lq pl mo mp mq bi translated">从回购中的所有提交中获取信息</li><li id="5584" class="mi mj iu kx b ky mr lb ms le mt li mu lm mv lq pl mo mp mq bi translated">仅使用带有以下前缀的提交:<code class="fe os ot ou ov b">feat</code>、<code class="fe os ot ou ov b">fix</code>、<code class="fe os ot ou ov b">refactor</code>、<code class="fe os ot ou ov b">test</code>、<code class="fe os ot ou ov b">cli</code>。同样，从<a class="ae ma" href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#type" rel="noopener ugc nofollow" target="_blank">角度文档</a></li><li id="6129" class="mi mj iu kx b ky mr lb ms le mt li mu lm mv lq pl mo mp mq bi translated">给你一张显示关键项目变更的幻灯片<code class="fe os ot ou ov b">CHANGELOG.md</code>。</li></ul><p id="37fe" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">考虑到这几点，代码应该是这样的:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pn"><img src="../Images/f921b8dcdf7e4067cdefd9cda4225b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7VM3KTDbUWRWdMOymk5J7A.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">创建重要生产文件的spicey脚本。</figcaption></figure><p id="13ef" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们到了。这就是我们所需要的，真的。要对该文件进行逻辑分解，请执行以下操作:</p><p id="aecd" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">首先，我们调用文件底部的<code class="fe os ot ou ov b">main()</code>。这调用了函数<code class="fe os ot ou ov b">main()</code>，该函数将<code class="fe os ot ou ov b">get_commit_log()</code>的输出收集到<code class="fe os ot ou ov b">commits</code>变量中。从那里，<code class="fe os ot ou ov b">commits</code>在作为参数传递到<code class="fe os ot ou ov b">strip_commits()</code>之前被排序(使用排序函数),然后将过滤后的提交传递回同一个<code class="fe os ot ou ov b">commits</code>变量。从那里，提交被传递给<code class="fe os ot ou ov b">overwrite_changelog()</code>函数，并以一种良好的格式写入到创建的<code class="fe os ot ou ov b">CHANGELOG.md</code>文件中。</p><h2 id="32f7" class="of nj iu bd nk og oh dn no oi oj dp ns le ok ol nu li om on nw lm oo op ny oq bi translated">行动YAML描述</h2><p id="4fbb" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">现在我们已经有了<code class="fe os ot ou ov b">Dockerfile</code>和Python脚本设置，我们可以继续定义动作是什么和做什么。动作是在一个<code class="fe os ot ou ov b">action.yaml</code>文件中定义的——很容易记住——大概是这样的:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pn"><img src="../Images/4fdad8e96b542422f7a9fbbb51c09902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GIClYck4aSFprxxs2jo16g.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">继续根据您的需要更改名称和作者。</figcaption></figure><p id="d918" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">实际使用动作的关键在于<code class="fe os ot ou ov b">outputs</code>和<code class="fe os ot ou ov b">runs</code>。</p><p id="7cd3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe os ot ou ov b">outputs</code>是动作完成并通过后给用户的东西。它可以是多个输出，但是我们只有<code class="fe os ot ou ov b">changelog</code>并且它甚至没有被回传；它直接提交给工作流中的项目。</p><p id="5c98" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe os ot ou ov b">runs</code>定义如何运行操作。我们使用Docker，所以我们只需要这样说，并告诉它<code class="fe os ot ou ov b">Dockerfile</code>的位置——这个动作的根。</p><p id="0873" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe os ot ou ov b">action.yaml</code>文件到此为止。现在我们已经做好了一切准备，可以开始运行项目了。</p><h2 id="2b38" class="of nj iu bd nk og oh dn no oi oj dp ns le ok ol nu li om on nw lm oo op ny oq bi translated">运转</h2><p id="0696" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">回到需求，我们说过这个动作应该只在对master的pull请求上运行。既然是这样，让我们来看看一个新的分支:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qa"><img src="../Images/9c69bea35da3b7f2e51e1241a6a1342d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wF-gMe5pC5OzQv-wp7wOpw.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">创建要提交的新分支。然后，我们将从该分支向GitHub上的master发出一个pull请求。</figcaption></figure><p id="875e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在我们运行动作本身之前，我们必须将它添加到git并推送文件以创建一个pull请求。那时我们将看到行动开始。继续运行提交。类似“专长:初始动作”的东西</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pp"><img src="../Images/5b0acff43c242aa1c39e8a8161994b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91U7g_A53r2AdOPyrhzPbw.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">直截了当的承诺。</figcaption></figure><p id="d448" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">提交消息语法对项目非常重要。我们正在使用<a class="ae ma" href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#type" rel="noopener ugc nofollow" target="_blank">角度提交消息语法</a>，这就是我们稍后将如何生成我们的变更日志。</p><p id="1382" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">既然已经提交了变更，那么就推送变更(<code class="fe os ot ou ov b">git push origin feature/action</code>)。您可能会在终端中看到类似这样的内容:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qb"><img src="../Images/a652b571dab4580e37733ada9f80b7d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALP9byre0fpWlSJ155zzsQ.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">您可以点击项目的链接，或者通过GitHub web界面创建一个新的pull请求。</figcaption></figure><p id="a497" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">提交拉取请求并稍等片刻。既然请求已经发送，您应该在“合并拉取请求”之前看到一个黄色的运行圆圈。这是您在回购上运行的自定义操作！一切就绪后，您会看到一个绿色圆圈出现，“合并拉取请求”按钮也会变成绿色:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qc"><img src="../Images/4a2b8591d399ececc9d7f7ddeb62e19d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LYvhzY90eL5CUj7mAgwcOg.png"/></div></div><figcaption class="ne nf gk gi gj ng nh bd b be z dk translated">抱歉，我在运行测试时忘记了获取屏幕截图！</figcaption></figure><p id="d63b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">一旦您合并了项目，您将会看到，每当您在项目上创建一个新的Pull请求时，您的定制操作就会运行并收集所有对<code class="fe os ot ou ov b">CHANGELOG.md</code>的需求。您还可以从回购中的“Actions”选项卡检查正在运行的操作。</p><blockquote class="pa"><p id="0388" class="pb pc iu bd pd pe pq pr ps pt pu lq dk translated">恭喜你！</p></blockquote></div><div class="ab cl mw mx hy my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="in io ip iq ir"><h1 id="c58a" class="ni nj iu bd nk nl qd nn no np qe nr ns ka qf kb nu kd qg ke nw kg qh kh ny nz bi translated">结论</h1><p id="837a" class="pw-post-body-paragraph kv kw iu kx b ky oa jv la lb ob jy ld le oc lg lh li od lk ll lm oe lo lp lq in bi translated">在这篇文章中，我们讨论了GitHub的动作和一些用例。我们简要地讨论了理解动作和创建动作所必需的一些概念和关键主题。</p><p id="7b9b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们运行了文档中的例子，<code class="fe os ot ou ov b">greet-everyone</code>,这给了我们运行动作的体验，然后我们在另一个项目中创建和实现了我们自己的定制动作。</p><p id="f126" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我希望你仍然渴望更多。我希望你继续学习GitHub动作，使用市场上的一些动作，或者更好的是，创建你自己的动作并在市场上分享它们！这只是一瞥，但我希望它让你站起来，离开地面。</p><p id="7d13" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">看完这篇关于行动的帖子后，你现在有什么想法？也许你有一个想法已经有一段时间了，但不知道如何实施。为什么不在这里开始讨论呢？我很乐意帮助你创造更多，我相信其他参与讨论的人也会很乐意帮忙。</p></div><div class="ab cl mw mx hy my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="in io ip iq ir"><p id="4b89" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">感谢你花时间阅读这篇文章，让我对自己有了更多的了解。期待前方的路。</p><p id="56d1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">祝一切顺利，保持安全——斯潘塞</p></div></div>    
</body>
</html>