<html>
<head>
<title>The Integral Image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">整体图像</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-integral-image-4df3df5dce35?source=collection_archive---------0-----------------------#2021-02-12">https://levelup.gitconnected.com/the-integral-image-4df3df5dce35?source=collection_archive---------0-----------------------#2021-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c32f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">计算机视觉导论，第3部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/849deb0bdba340bfba6926797d3ee17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4UIjX20rXN5KfGXf7HCUUg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://venturebeat.com/2020/08/29/how-to-tell-if-computer-vision-can-transform-your-business/" rel="noopener ugc nofollow" target="_blank">VentureBeat.com</a></figcaption></figure><p id="ba75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/haar-like-features-seeing-in-black-and-white-1a240caaf1e3">上一次</a>，我们讨论了Haar-like特征，它们是什么，它们如何帮助Viola-Jones算法检测物体，以及它们如何确定它们是否找到了一个特征。我们涵盖了很多信息，如果你以前从未听说过Haar-like特性，我强烈推荐你阅读上一篇文章，因为我给出的任何总结都不足以给你理解我们今天的主题所需的基础:积分图像。</p><p id="f79b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了真正强调整体形象的重要性，我们来谈一点…</p><h1 id="2af3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">大O</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/1163ed4c17bfec5c978b6eed6bfe1ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*mmtscGVX5mjSmhdA0RvB-w.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:【Pinterest.com T4】</figcaption></figure><p id="7784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不，不是那个大O。这个大O:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/21be695408a600416bcae2e2e1927b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*k-acuFitTKegB5l5JTn0tA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://medium.com/journey-of-one-thousand-apps/complexity-and-big-o-notation-in-swift-478a67ba20e7" rel="noopener">克里斯托弗·韦伯</a></figcaption></figure><p id="6245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大O是一种计算完成一项任务所需时间和资源的方法。随着变量/元素/输入数量的增加，处理时间越长，资源(处理能力、内存等)越多。)用完了。不要在细节上陷得太深，记住这一点:</p><blockquote class="mm mn mo"><p id="c54e" class="kw kx mp ky b kz la jr lb lc ld ju le mq lg lh li mr lk ll lm ms lo lp lq lr ij bi translated">随着你增加任务的复杂性，所需的时间和资源也会成倍增加。</p></blockquote><p id="952e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这和积分图像有什么关系？</p><p id="6e76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以请记住，Haar-like特征是在代表灰度图像的阵列上“平移”的一系列帧。这些帧可以缩放到几乎任何大小，除了1x1像素。这是因为帧(和图像数组)的每个单元(或元素)代表一个像素，它只能包含一种颜色的值。另一个原因是因为这些帧的全部功能是比较与<em class="mp">相邻的</em>像素的“白色”和“黑色”,因此不能缩小到单个像素。</p><p id="4779" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自2001年Viola-Jones问世以来，已经开发了许多类似Haar的功能，我们将重点介绍当时可供他们使用的三种功能:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/4a1e5a5c84a6fdde2940270f7cd6fa58.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*hbFPsfsCqV8rf1MV8b8p5w.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://docs.opencv.org/master/d2/d99/tutorial_js_face_detection.html" rel="noopener ugc nofollow" target="_blank">OpenCV.org</a></figcaption></figure><ul class=""><li id="f20a" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated">边缘特征:检测对象的边缘。最小比例- 1x2或2x1。</li><li id="efe7" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">线条特征:检测对象中的线条和高光。最小刻度- 1x3或3x1。</li><li id="f003" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">四矩形特征:检测对角线和直线。最小比例- 2x2</li></ul><p id="29e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过计算帧的“较亮”和“较暗”侧的平均值并将它们彼此相减来对特征进行分类。如果差异落在某个阈值内，则该算法识别出该帧内的像素构成了类似Haar的特征。</p><p id="48cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是大O发挥作用的地方。由于这些帧是可缩放的，因此有数千种组合和位置，即使是一幅很小的图像也能容纳这些特征。正如在<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/haar-like-features-seeing-in-black-and-white-1a240caaf1e3">上一篇文章</a>中提到的，一张24x24像素的图像包含超过180，000个可能的特征。该图像中的帧可以介于1x2(或2x1)像素和24x24像素之间。</p><p id="7023" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地说明这个问题，考虑这个例子:</p><p id="89a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设计算机计算单个特征的平均值所需的时间为1毫秒(这可能会慢得令人难以置信，但让我们试试看)。由于在24x24像素的图像中有超过180，000个特征，因此计算其中的所有特征需要180，000毫秒(3分钟)。这还不包括处理能力和完成任务所需的内存。</p><p id="d1cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到现在你很可能会使用分辨率为1920x1080像素的图像，时间会变得更长。为了减少时间和资源的消耗，我们需要找到一种方法来降低任务的复杂性。Viola和Jones是如何做到这一点的，他们的算法可以在数码相机上实时检测人脸？</p><h1 id="fced" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">输入:积分图像</h1><p id="8697" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">究竟什么是整体形象？这是一个数组，它的值是一个图像值的和。然而，什么价值观呢？它是如何以有意义的方式安排的？我们就做一个吧。当你看到它的时候会更容易理解。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/74be3ffaf4a28c55433d39db43dd41b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/0*ZaFmHzlhp3VKniaH.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1</figcaption></figure><p id="9c70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设这个数组表示一个10×8像素的图像。正如我们所知，数字代表该通道上像素的亮度。为了简单起见，假设我们没有将这些值缩小到0到1之间。因此，这些值的原始范围是0到255，0表示没有亮度，255表示最亮(这意味着上面的图像几乎是一片漆黑)。</p><p id="1ac8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该算法采用该原始图像，并创建一个维数完全相同的和数组，称为积分图像。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/cd3d6c4d61db13897096535b0b7d5305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*js6X9RqBvnksPtfDGnGJ3A.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.02</figcaption></figure><p id="036a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，它开始按照特定的模式计算原始图像中值的总和，从而填充该表。再说一遍，当我们看到它在运行时，就更容易理解了。假设我们需要如下所示的值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/24cda1588f6669b2afc03ba814943346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/0*pqL1n-wp5H930w-0.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.03</figcaption></figure><p id="69f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，这个单元格不是像素，而是原始图像上相应区域所有值的总和。要计算它的值，请转到原始图像中与这个像素对应的像素。然后从右下角画一条直线向上，另一条向左。在这些线的上方和左侧的值上画阴影，您将得到以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/07a868eeb7e2c1d44164a333d1393eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*a15YWuoBaIx0KWFV.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.04</figcaption></figure><p id="c595" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<strong class="ky ir">积分图像</strong>中的单元格的值是<strong class="ky ir">阴影区域</strong>中所有数字的<strong class="ky ir">和</strong>。这些数字的和是51，所以让我们把它放到我们的积分图像中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d744c895188362d46a576c82af514148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/0*IvYh4uoYo6hwTPd8.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.05</figcaption></figure><p id="0b24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">厉害！让我们再试一次来掌握它的窍门。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9e3e005fa757360d7288efa3e7f85714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*Ukn-NREYjPaTwK2k.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.06</figcaption></figure><p id="6f60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的单元格代表原始图像的哪个区域？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e79fb0f49863c64348458b5f5f27599e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*hbN3q4dX846GV8Vl.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.07</figcaption></figure><p id="3e7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果这是你的答案，你就对了！现在把它放到我们的整体形象中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/258b6610d99b3d147d04915b45e65fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*EsAVpqLaPtZKw4aD.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.08</figcaption></figure><p id="d4e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，您可能已经注意到了一种模式。<em class="mp">积分</em>图像<strong class="ky ir">中的一个<strong class="ky ir">单元格</strong>对应于<em class="mp">原始</em>图像中的一个特定区域</strong>。该单元格的<strong class="ky ir">值</strong>是原始图像中相应区域中所有值的<strong class="ky ir">总和。现在我们已经对一个完整的法师是如何被制造和组织的有了一点直觉，让我们来完成剩下的部分。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b6a031ac4f6788071a2abbef13ed1e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*vBy_3EqGmRbCuvsav4ffVg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.09</figcaption></figure><p id="48eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，回到最初的图像。我们将选择图像中需要求和的部分，并用红色标出轮廓。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e82776a63c97bf3a8b7444d8e29ebfd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/0*YVYDq4wmHET3QAfP.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.10</figcaption></figure><p id="fa66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只有5x3像素大，所以我们可以把所有15个数字加起来，这并不难。然而，如果我们有一个100x100像素的帧会怎么样呢？还是1000x1000像素？那是一大堆数字加起来！这就是整体形象发光的地方。因为积分图像的每个单元对应于原始图像的一个<em class="mp">区域</em>，所以我们可以找到包含我们所描绘的所有值的区域的总和，然后减去多余的值。我们来试试吧！</p><p id="24f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，找到对应红框右下角像素的单元格。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/dfd80adfcbe4b61899e9ed665eaaa680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*5RBJ-bGTT2M504A4.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.11</figcaption></figure><p id="e7ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，同样，这个数字是位于原始图像的特定区域的值的总和。该单元格对应于<em class="mp">原始</em>图像的哪个区域？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/24f421948057c4b1fb16deeda99e35ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/0*_CoWSnq_xgx_PH_Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.12</figcaption></figure><p id="2b4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧！我们已经开始隔离盒子里的区域了！回头参考积分图像，我们知道阴影部分的总和是215。然而，这仍然包括红框之外的值，所以我们需要删除更多的值。</p><p id="0d8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，这些超额值可以分解成两种形状，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/cc7c7122431325de36c72e9614379ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/0*I7ZlDjRgrJRvAezi.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.13</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/a6707da718a53a5ba527dc7d4a46ce11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*4hLuDdFmo8sAVneU.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.14</figcaption></figure><p id="ea84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从移除最上面的两行开始(图1.13中的橙色阴影)。<em class="mp">积分</em>图像中的哪个单元格对应于该区域？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/eee916fe03211d2cfe31ff95666da750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/0*vZyh1UBs95YL7hYb.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.15</figcaption></figure><p id="8b39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">80!215减去80，得到135。让我们检查一下原始图像的进度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/09f2da67d902a0d3d7dd8563b9a47f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*PgBfCWSLYsuaSN3L.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.16</figcaption></figure><p id="2dbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以蓝色阴影部分的值之和是135。现在我们只需要移除图1.14中最后的绿色阴影部分。但是，有一个问题，我们需要首先解决！</p><p id="2bd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">花点时间比较一下图1.13和1.14。敏锐的眼睛会注意到它们重叠在一起！看下面的图1.17，你会看到重叠的区域。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1beba54056f8b459587140705b724dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/0*9YDFU1afVSJ1lsqC.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.17</figcaption></figure><p id="ea91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是，当我们移除上面两行的时候，我们已经减去了这个区域的总和。如果我们向前跳，从图1.14中减去绿色阴影区域，我们将减去这些值两次！不过，别担心！这很容易解决。我们只需要把这些值加回我们的计算中。所以回到积分图，找到粉色区域对应的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6db0d304bfb6980e77be6a59e4cc3257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*-BS1IgKZhAzKRSKH.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.18</figcaption></figure><p id="39f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没错！20!所以把这个加回我们的总数，我们有155。然而，更重要的是，我们已经解决了这个问题。看看吧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/ad1bb16b1d407790752f006db91a5bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/0*e6Ilvu0rLoPabEu6.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.19</figcaption></figure><p id="76a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩下的蓝色阴影区域现在与图1.14中的绿色区域完美地对齐了！现在我们减去这个面积！让我们找出积分图像上的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/cf271394595050832df06cd63b4023c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/0*-fGolxBu66Am12bz.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图1.20</figcaption></figure><p id="db4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完美！减去这个会得到我们的答案。155- 72 = 83.这是图1.10中原始图像上红框中所有值的总和！</p><p id="de47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这一切意味着什么？很简单，无论一帧中选择了多少像素，您只需要四个数字来计算这些值的总和。面积是24x24像素还是1000x1000像素，都无所谓。你只需要那四个数字。这一过程大大降低了任务的复杂性，从而减少了计算所需的时间和资源。</p><h1 id="e6f9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">应用于Haar类特征</h1><p id="fcea" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">那么Viola-Jones算法是如何工作的呢？我们再来看看原图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b6bfea3d915cfa47f5fd217fe01ec684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*-JkRaaUIQLJ-rq1PWx4nug.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图2</figcaption></figure><p id="bd7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此处的框架代表一个边缘特征。该算法需要计算较亮和较暗的一半的平均值，并将它们相减，以查看差值是否在阈值范围内。为了便于讨论，假设我们的阈值是10(请记住，我们解释数组中的值时，假设它们仍然在0到255的范围内)。所以它创造了完整的图像。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/dddd874322229c575ac0b3ef41d9115f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*NXV0wbZSRuqMBKvjjiKlgg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图2.01</figcaption></figure><p id="bee0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，它通过找到四个相关的数字来计算较轻的那一半的总和。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/11df221238dee2a9f3dbd76bf0ce512f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*KLgsyAzg_ewGjUtYd7Ly6Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图2.02</figcaption></figure><blockquote class="mm mn mo"><p id="ff22" class="kw kx mp ky b kz la jr lb lc ld ju le mq lg lh li mr lk ll lm ms lo lp lq lr ij bi">255 - 215 + 46 - 55 = 31</p></blockquote><p id="3ef7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">取此总和，算法通过将其除以框架中的列数来计算平均值。</p><blockquote class="mm mn mo"><p id="aab4" class="kw kx mp ky b kz la jr lb lc ld ju le mq lg lh li mr lk ll lm ms lo lp lq lr ij bi">31 / 6 = 5.167</p></blockquote><p id="8b68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，它遵循完全相同的步骤来寻找较暗的一半的平均值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/dd3da33e56bd48927b8e3836a4a2e5bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*USQA6BdGpi-92YOH1UARHg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图2.03</figcaption></figure><blockquote class="mm mn mo"><p id="e6c9" class="kw kx mp ky b kz la jr lb lc ld ju le mq lg lh li mr lk ll lm ms lo lp lq lr ij bi">302 - 255 + 55 - 69 = 33</p><p id="37e9" class="kw kx mp ky b kz la jr lb lc ld ju le mq lg lh li mr lk ll lm ms lo lp lq lr ij bi">33 / 6 = 5.5</p></blockquote><p id="64c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，它减去平均值，看它是否落在阈值内。</p><blockquote class="mm mn mo"><p id="6e5b" class="kw kx mp ky b kz la jr lb lc ld ju le mq lg lh li mr lk ll lm ms lo lp lq lr ij bi">5.5 - 5.167 = 0.333</p></blockquote><p id="e7e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这落在我们的阈值之外，并且算法确定在图像的这一部分中没有边缘特征，并且继续前进。</p><h1 id="5139" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="19f2" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">我们今天讨论了很多内容，但关键是积分图像在减少实时计算和评估数十万个特征所需的时间和处理能力方面起着重要作用。20年前，正是像这样聪明的快捷方式使得这种物体检测在硬件上成为可能。简直太有才了。</p></div></div>    
</body>
</html>