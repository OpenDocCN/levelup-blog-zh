<html>
<head>
<title>Reloading Single Page Applications after deploying</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部署后重新加载单页应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reloading-single-page-applications-after-deploying-ec96e78e7016?source=collection_archive---------3-----------------------#2020-11-23">https://levelup.gitconnected.com/reloading-single-page-applications-after-deploying-ec96e78e7016?source=collection_archive---------3-----------------------#2020-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ca1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当今的许多企业级应用程序都使用最先进的技术，如微服务、持续集成和持续部署(CI/CD)。这些技术通过自动化组织使用的构建/测试/部署周期，有助于加速变革或缩短上市时间。此外，应用程序通常打包在容器映像中，并使用容器编排工具(如Kubernetes)进行部署，这些工具允许将服务中的更改从源代码轻松部署到不同的环境，甚至使用更复杂的部署策略，如A/B测试或canary部署。</p><p id="2bda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于单页面应用程序(SPA)来说，情况并非总是如此，因为这种应用程序通常呈现在客户端，并且驻留在客户端的浏览器上。使用单页面应用程序有明显的优势，如可用性、网络速度和计算机资源的分配，但这项技术也有一些缺点。</p><p id="1c5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将回顾当前的解决方案，当部署的应用程序发生变化时，重新加载SPA。然后，我将提出一个基于Kubernetes控制器的解决方案，以检测部署中的变化，并使用WebSocket向客户端发送通知，以便采取行动。</p><h1 id="904b" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">解决方法</h1><p id="b2c6" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">本节回顾了当前在发生变化时重新加载SPA的解决方案。</p><h2 id="2267" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">强力</h2><p id="eebf" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这个解决方案不包括在客户端缓存应用程序和定期重新加载。</p><p id="4da7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点</strong>:易于实施，无需服务器端组件。</p><p id="b595" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong>:对用户体验没有好处，因为如果重新加载周期很短，用户在使用应用程序时可能会不必要地重新加载，或者如果重新加载周期太长，它不会获得新的更改。</p><h2 id="bc3f" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">在我们的js文件中包含散列</h2><p id="2589" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这种替代方法包括生成一个文件，该文件带有一个标识构建的哈希值，然后在一个众所周知的位置提供它。这种替代方案的一些例子如下:</p><ul class=""><li id="2184" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated"><a class="ae mj" href="https://medium.com/@codemonk/automatic-reload-of-client-after-deploying-in-vue-js-91c120f85f0e" rel="noopener">https://medium . com/@ code monk/automatic-reload-of-client-after-deployment-in-vue-js-91c 120 f 85 f 0e</a></li></ul><p id="c347" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点</strong>:简单快速的实现，我们只需要一些webpack配置来生成hash，以及在客户端存储当前hash并与服务器hash进行比较的一些代码。</p><p id="03e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong>:需要客户端主动监控，设置超时功能，用于检查一个众所周知的URL，并与当前URL进行比较。</p><h2 id="6e45" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">在HTTP头中包含应用程序版本</h2><p id="8b08" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">由于大多数SPA将使用后端API来对应用程序执行操作，因此请求HTTP标头和响应HTTP标头都可能包含一个额外的字段，用于指示应用程序的当前版本和服务器版本。与以前的解决方案类似，客户端将存储当前版本或哈希，并将其与收到的版本或哈希进行比较，以检测部署的SPA中的更改，以便它可以通知用户或强制重新加载页面以进行升级。</p><p id="7b96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点</strong>:在客户端和服务器端都相当容易实现。</p><p id="cc3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong>:这需要服务器端知道SPA版本以将其包含在HTTP头中，或者它们由相同的代码库提供服务。它还要求在客户端进行主动监控，将每个HTTP请求与当前存储的版本进行比较。</p><h2 id="32ee" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">WebSocket通知</h2><p id="8c13" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在这个解决方案中，将有一个websocket后端服务，它监视已部署的SPA中的机会，并通知所有订阅的客户端更改。SPA需要订阅此服务，并在收到通知时通知用户或重新加载页面进行升级。</p><p id="805f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点</strong>:这是一个事件驱动的解决方案，只有当服务器端发生需要SPA参与的变化时，客户端才会得到通知。</p><p id="740c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点:服务器端和客户端的实现都更加复杂。它需要服务器端的一个组件来监听或检查SPA的已部署代码的变化。</p><h1 id="17d1" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">Kubernetes控制器和WebSocket解决方案</h1><p id="31c8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated"><a class="ae mj" href="https://toucansoft.io" rel="noopener ugc nofollow" target="_blank"> Toucan Software </a>的SPA重载器由一个<a class="ae mj" href="https://github.com/ToucanSoftware/spa-reloader" rel="noopener ugc nofollow" target="_blank">服务器端</a>组件和一个<a class="ae mj" href="https://github.com/ToucanSoftware/spa-reloader" rel="noopener ugc nofollow" target="_blank">客户端</a>组件组成，用于检测部署的应用程序中的变化，通知客户端并向用户发送通知以采取行动。</p><h2 id="fe47" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">服务器端组件</h2><p id="4b58" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">SPA Reloader的服务器端组件实现了一个Kubernetes控制器，该控制器监视部署中的变化，并检测容器映像的SHA-256是否发生了变化。当这种情况发生时，它向客户端所有连接的用户发送一个WebSocket通知。</p><p id="bb83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SPA Reloader可以与您的应用程序一起部署，也可以作为独立组件单独部署。它将以下需要作为环境变量传递的参数作为环境变量，以便了解要监视哪些变化:</p><ul class=""><li id="a277" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated"><strong class="jp ir"> SPA_NAMESPACE </strong>:用于监视名称空间变化的环境变量的名称。</li><li id="6c80" class="ma mb iq jp b jq mk ju ml jy mm kc mn kg mo kk mf mg mh mi bi translated"><strong class="jp ir"> SPA_NAME </strong>:用于监视部署名称变化的环境变量的名称。</li></ul><h2 id="c5b3" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">客户端组件</h2><p id="5602" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在这种情况下，客户端组件是一个Vue插件，它将SPA的服务器端组件公开的WebSocket服务器的URL作为参数。您还可以注册一个回调函数，以便在检测到部署中的更改后立即执行。</p><p id="9f5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还需要在您的应用程序中注册一个回调函数，以便您可以在部署发生变化时接收通知。</p><h1 id="af8f" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">实际演示</h1><p id="45a4" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">为了演示SPA Reload的使用，我们将使用位于<a class="ae mj" href="https://github.com/ToucanSoftware/spa-reloader-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/ToucanSoftware/spa-reloader-demo</a>的演示项目。这是一个非常简单的VueJS应用程序，我们之前已经构建并发布了2个版本。所以它的第一个版本被标记为:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5e7e" class="lo km iq mu b gy my mz l na nb">toucansoftware/spa-reloader-demo:v1</span></pre><p id="8dbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序的第二个版本是</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6b06" class="lo km iq mu b gy my mz l na nb">toucansoftware/spa-reloader-demo:v2</span></pre><p id="4c98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该应用程序是使用vue-cli和标准设置创建的，之后我们添加了<strong class="jp ir"> <em class="nc"> spa-reloader-vue </em> </strong>组件，使用:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4e6d" class="lo km iq mu b gy my mz l na nb">npm i spa-reloader-vue</span></pre><p id="c914" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦添加了组件，我们必须注册插件，并提供WebSocker服务的URL，我们将在那里注册通知。</p><figure class="mp mq mr ms gt nd"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="500f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们需要使用原型函数<strong class="jp ir"> $spaSubscribe </strong>注册我们想要接收通知的回调函数</p><figure class="mp mq mr ms gt nd"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个演示，我使用的是Docker Desktop for Mac的Kubernetes，因此为了展示web应用程序和SPA Reloader WebSocket服务，我需要安装一个入口控制器，比如NGINX入口控制器</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="76a7" class="lo km iq mu b gy my mz l na nb">kubectl apply -f <a class="ae mj" href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.41.1/deploy/static/provider/cloud/deploy.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.41.1/deploy/static/provider/cloud/deploy.yaml</a></span></pre><p id="26ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署完成后，我们将使用以下脚本部署SPA加载程序</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1642" class="lo km iq mu b gy my mz l na nb">kubectl apply -f <a class="ae mj" href="https://raw.githubusercontent.com/ToucanSoftware/spa-reloader-demo/main/deploy/01-spa-reloader.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/ToucanSoftware/spa-reloader-demo/main/deploy/01-spa-reloader.yaml</a></span></pre><p id="9462" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将为SPA控制器创建命名空间、部署和服务。然后，我们将使用以下工具部署演示SPA应用程序:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="ccca" class="lo km iq mu b gy my mz l na nb">kubectl apply -f <a class="ae mj" href="https://raw.githubusercontent.com/ToucanSoftware/spa-reloader-demo/main/deploy/02-demo.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/ToucanSoftware/spa-reloader-demo/main/deploy/02-demo.yaml</a></span></pre><p id="e24b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，您可以检查您的入口外部IP地址以访问演示应用程序，您应该会看到类似下图的内容</p><figure class="mp mq mr ms gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/a13a4a310441cfced6865f76503cddf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwcbaDJUTG0vGraQYvcdxg.png"/></div></div></figure><p id="9147" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试演示，我们需要更改容器映像，以便SPA可以检测到更改并通知客户端。我们可以使用这样的命令:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8c09" class="lo km iq mu b gy my mz l na nb">kubectl set image deployment/spa-demo spa-demo=docker.io/toucansoftware/spa-reloader-demo:v2 -n spa-demo</span></pre><p id="b6e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这一更改，SPA Reloader将生成如下消息，并将其发送给连接的客户端:</p><figure class="mp mq mr ms gt nd"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d7a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦该消息被发送到客户端，<strong class="jp ir"><em class="nc">spa-reloader-vue</em></strong>将会收到一个回调调用，在本演示中，会显示一条弹出消息，提醒用户该情况。确认后，<strong class="jp ir"><em class="nc">window . location . reload(true)；发出</em> </strong>命令，使用当前修改强制重新加载页面。</p><figure class="mp mq mr ms gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nn"><img src="../Images/313f1e46eb901ed540af80b434fd3c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e6eYOHIqqELm8bqJyDMnvA.png"/></div></div></figure><h1 id="0558" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="1499" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">SPA Reloader使用Kubernetes控制器来检测应用程序容器映像的变化，并通过WebSocket发送通知。该解决方案可以有效地用于通知单页面应用程序部署中的变更，实现事件驱动方法。</p><p id="5d2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管没有具体的细节说明如何使用Kubernetes控制器来检测消息并将其传递给客户端，但后面的文章将讨论SPA实现的内部机制。</p></div></div>    
</body>
</html>