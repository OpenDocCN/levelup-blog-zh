# 线程、承诺、通道:异步编程的基础

> 原文：<https://levelup.gitconnected.com/threads-promises-channels-1c8e86595286>

![](img/9c0b7e69e2c288c66b25b52ea4081195.png)

照片由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的 [Jp Valery](https://unsplash.com/@jpvalery?utm_source=medium&utm_medium=referral)

# 介绍

编写后端和前端代码时，经常需要异步编程。然而，不同的编程语言公开了执行异步任务的不同范例。本文将讨论的三个范例是线索、承诺和渠道。作为演示，我使用 [PokéAPI](https://pokeapi.co/) 获取关于口袋妖怪的信息。示例代码发出一个初始请求来获取前 10 个 Pokemon 的 URL，然后发出 10 个并行请求来获取详细信息。

# 线

要理解线程，需要一些关于线程含义的背景知识。要理解什么是线程，我们必须首先理解进程。流程是一个程序。一个进程有自己的(虚拟)内存，独立于其他进程。一个进程有一个或多个线程。操作系统将在每个正在运行的进程之间公平地切换，以便所有进程都有公平的执行机会。现在，一个线程就像一个进程，有一个关键的区别，一个线程与进程中的其他线程共享内存。因此，借助线程的力量，单个进程(即程序)可以在相同的可用内存下同时执行多个任务。

在我们的例子中，我们使用线程来执行那些大部分时间都在网络上等待的任务。具体来说，示例中的每个线程调用函数“fetchPokemon ”,该函数将花费大部分时间等待网络请求完成。因此，通过并发运行这些 I/O 请求，我们的程序变得更加高效，因为我们可以在收到任何响应之前启动每个请求。

虽然线程是一个强大的工具，但也有一些困难需要警惕。首先，共享内存是众所周知的竞争条件错误的来源。为了避免这些错误，使用了互斥(即锁)。但是，如果程序员不小心的话，互斥可能会导致性能下降和死锁。因此，尽可能避免共享数据通常被认为是最佳实践。最后，重要的是要认识到不要过度使用线程。仅仅因为某个东西可以在一个单独的线程上并发运行，并不意味着这样做会提高性能。此外，由于操作系统必须执行上下文切换，因此在使用线程时还会有性能开销。俗话说，不要过早优化。

下面是一个在 C++中使用线程的例子。您可能会在 Java 和 Python 等语言中看到类似的代码。

# 承诺

承诺是一种在不直接使用线程和共享数据的情况下编排异步任务的方式。虽然 promise 语法出现在许多语言中，但我将从 JavaScript/Node 上下文中描述 promise。

在 Node 中，承诺通过事件循环工作。要理解这一点，重要的是要理解操作系统如何处理通常被承诺的任务。当你的程序执行 I/O 时，这被认为是一种特权操作，只有操作系统本身才能执行。因此，你的程序会要求操作系统代表你的程序进行 I/O。现代操作系统提供阻塞和非阻塞接口来执行这些特权操作。在过去，存在的只是阻塞接口。因此，当您的程序发出 I/O 请求时，您的线程将被阻塞，直到操作系统完成操作。阻塞接口就是上面的 C++例子中使用的接口。使用非阻塞接口，您的程序将请求排入操作系统，您的线程立即继续执行。稍后，操作系统会通知你的程序特权操作已经完成。在 Node 中，这些通知用于推动事件循环，并通过扩展来实现承诺。

promise 语法支持异步任务的迭代式编程。此外，在有 I/O 需求的环境中，promises 支持单线程环境，消除了共享数据错误的可能性。

下面是一个在 TypeScript 中使用 promises 的例子。

# 频道

我们异步编程的最后一个范例是通道。与线程和承诺不同，渠道是一个抽象的话题。使用通道，异步编程是以发布者/订阅者的方式对数据流进行的。虽然这个概念出现在许多语言和库中(比如 Kotlin 和 RxJava)，但我们将从 Go 的角度来探讨这个概念。

在 Go 中，有一个 goroutine 的概念，它是线程的抽象。要在 goroutines 之间进行通信，可以使用“共享数据”(带锁)或通道。一个 goroutine 可以写入一个通道，当另一个 goroutine 同时监听时，数据通过该通道在 go routine 之间传输。

对于异步任务的编排，通道是一个强大的概念。通道允许您建立一个管道，在事件到来时处理它们。这可能比线程或承诺更有效。例如，由于通道的原因，下面的 Go 代码比上面的 C++和 TypeScript 代码更有效。具体来说，返回的第一个 Pokemon 信息可以立即处理，而在 C++和 Typescript 中，处理只能在最慢的请求完成后进行。

下面的 Go 代码演示了如何使用通道。

# 摘要

对于任何程序来说，拥有一致且有效的模式来执行异步任务都是一个重要的考虑因素。存在许多异步编程的范例，但是我希望您在本文中了解了线程、承诺和通道。