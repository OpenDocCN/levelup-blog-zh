<html>
<head>
<title>Enhance Factory Pattern capabilities for DI in Swift within 3 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在3分钟内增强Swift中DI的工厂模式功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/enhance-factory-pattern-for-di-in-swift-b255008ba110?source=collection_archive---------10-----------------------#2021-02-11">https://levelup.gitconnected.com/enhance-factory-pattern-for-di-in-swift-b255008ba110?source=collection_archive---------10-----------------------#2021-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4f521c3b806f27c2491e197daadeb665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oNUJVWKTmCgCLNx38PaHNg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">工厂模式</figcaption></figure><div class=""/><p id="102e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">工厂模式是编程语言中常见的模式之一。它是一种创造性的设计模式，为您的代码提供了高度的灵活性。一个有趣的用例是<strong class="kh jj">依赖注入</strong>，它可以让工厂模式成为一个方便的工具。通常，每当我们想要注入一个接口作为对一个对象的依赖时，我们可以很容易地通过初始化器传递它或者从属性中设置它。参见下面的例子</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ld"><img src="../Images/0336af94a2c087dda4577133badf58b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jD4l9GSqMBmZie6HeEUJEw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">选项1</figcaption></figure><p id="9d00" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在上面的例子中，我们试图给<strong class="kh jj"> SampleViewModel </strong>注入网络和数据库管理器的依赖关系(记住，总是依赖于<strong class="kh jj">抽象</strong>)。在初始化式上做DI是最简单的方法，一旦我们有了多重依赖，需要注入太多参数，问题就开始出现了。当然，然后我们尝试下面的第二种方法。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi li"><img src="../Images/f8e260c7ad70b4be806e0c87092bf781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7sGC9xp-IufwOIdd5zCOg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">选项2</figcaption></figure><p id="9dd8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在第二种方法中，如果两个依赖项都封装到一个符合它们的对象中，我们简单地传递一个带有规则的<strong class="kh jj"> typealias </strong>，这被称为<strong class="kh jj">协议组合。这是一种非常快捷的方式，看起来非常整洁。在此之前不会有任何问题，我们需要将每一个依赖项传递给初始化器，否则我们可能会在我们的<strong class="kh jj"> typealias中加入多个&amp;操作符。</strong>如果我们使用一个可以轻松产生这种效果的物体会怎么样？是啊！那就是<strong class="kh jj">厂</strong>。参见下面的例子</strong></p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lk"><img src="../Images/831be23ece01b6f62ff3f94bd1323808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xzoW0_F2mkXkmm8gLWLhQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">选项3</figcaption></figure><p id="34bc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">参见<strong class="kh jj">选项3 </strong>，我们可以只拥有一个工厂实例，然后调用函数为我们创建依赖关系。我们<strong class="kh jj">厂</strong>班的大图见下图。它有为我们创建<strong class="kh jj">依赖关系</strong>的功能，或者提供创建某个<strong class="kh jj">依赖关系</strong>的单一对象的功能。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ll"><img src="../Images/6ddb453bf823f44db1fd43a06f793a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1unar6OKXltSdla0-8bMqw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">工厂级</figcaption></figure><h1 id="feb8" class="lm ln ji bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">小技巧&amp;小技巧</strong></h1><ol class=""><li id="60c4" class="mk ml ji kh b ki mm km mn kq mo ku mp ky mq lc mr ms mt mu bi translated">如果您想创建一个可以被任何对象轻松访问的工厂，您可以创建一个单例工厂。然而，请记住，为了让我们的<strong class="kh jj"> singleton </strong>不成为<strong class="kh jj">反模式，因为大多数人都试图避免它</strong>，让它保持无状态，只是为了创建一个必要的对象。通过创建我们的singleton <strong class="kh jj"> stateless </strong>并且只用于产生一个对象，那么就可以了，不需要担心测试。记住，DI中的单例问题居多，因为<strong class="kh jj">单例可以产生共享状态</strong>和<strong class="kh jj">提供有状态类</strong>。所以保持干净。</li><li id="3820" class="mk ml ji kh b ki mv km mw kq mx ku my ky mz lc mr ms mt mu bi translated">另一个技巧是我们可以创建一个<strong class="kh jj">容器，</strong>并且这个容器可以符合多个<strong class="kh jj">工厂，</strong>然后将这个容器存储到你的应用程序的顶层对象中，或者如果需要的话甚至使它成为一个单例，并且这个<strong class="kh jj">容器</strong>是唯一一个集合了大多数工厂协议的容器，可以产生它的访问器所需要的多个对象。</li><li id="ed82" class="mk ml ji kh b ki mv km mw kq mx ku my ky mz lc mr ms mt mu bi translated">探索更多关于<a class="ae na" href="https://quickbirdstudios.com/blog/swift-dependency-injection-service-locators/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh jj">解析器</strong> </a> <strong class="kh jj"> </strong>的模式。这种模式是一个很好的例子，说明<strong class="kh jj">工厂</strong>模式如何成为<strong class="kh jj"> DI的强大工具。</strong><a class="ae na" href="https://github.com/Swinject/Swinject" rel="noopener ugc nofollow" target="_blank"><strong class="kh jj">s winject</strong></a><strong class="kh jj"/>是<strong class="kh jj">解析器</strong>模式如何工作以及<strong class="kh jj">工厂</strong>模式如何在幕后工作的一个例子。</li></ol><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nb"><img src="../Images/42c29b42842cee9491dc1f13dde9fb9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivDnFpxElG91s7--iwguuA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">容器示例</figcaption></figure><p id="0478" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">今天关于工厂模式的知识到此为止。希望这是非常有帮助的，除了一个最强大的<strong class="kh jj">创造性的设计模式。</strong>敬请期待下一篇文章！</p><p id="2d69" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">参考:<br/> 1。<a class="ae na" href="https://refactoring.guru/design-patterns/factory-method/swift/example" rel="noopener ugc nofollow" target="_blank">https://refactoring . guru/design-patterns/factory-method/swift/example</a><br/>2 .<a class="ae na" href="https://www.swiftbysundell.com/articles/dependency-injection-using-factories-in-swift/" rel="noopener ugc nofollow" target="_blank">https://www . swiftbysundell . com/articles/dependency-injection-using-factories-in-swift/</a></p></div></div>    
</body>
</html>