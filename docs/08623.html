<html>
<head>
<title>A Look at the Prototype Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">看看原型设计模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-look-at-the-prototype-design-pattern-3e4032b072d2?source=collection_archive---------5-----------------------#2021-05-18">https://levelup.gitconnected.com/a-look-at-the-prototype-design-pattern-3e4032b072d2?source=collection_archive---------5-----------------------#2021-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e161" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将原始对象复制到新对象，然后根据需要进行修改。这里有一个Java实现。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b6dd323f903fbe901bcf9a7b7ce4565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nrawv9qiSlTMhxk4HLVXxQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图像信用—pexels.com</figcaption></figure><p id="88bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">原型模式</em>指的是在考虑性能的同时创建重复的对象。这种类型的设计模式属于创建模式，因为这种模式提供了创建对象的最佳方式之一。</p><p id="125a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原型模式提供了一种机制，将原始对象复制到新对象，然后根据我们的需要修改它。原型设计模式使用Java克隆来复制对象。</p><p id="7474" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将涵盖以下主题:</p><ul class=""><li id="2633" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">原型设计模式是什么？</li><li id="38ed" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">我们应该什么时候使用它？</li><li id="f919" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">它的Java实现带有适当的图像和Java编码</li><li id="5406" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">它的优点和缺点</li></ul><p id="3c2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以试试我下面其他的设计模式和原理的相关文章</p><ul class=""><li id="f6c1" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/overview-of-solid-principles-and-its-java-implementations-4ae37fa5bb1b">SOLID原理及其JAVA实现概述</a></li><li id="24ec" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae mj" href="https://blog.devgenius.io/the-factory-method-pattern-and-its-implementation-in-java-b51d307b8dd8" rel="noopener ugc nofollow" target="_blank">工厂方法模式及其在JAVA中的实现</a></li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="5a20" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">原型设计模式是什么？</h1><p id="efd6" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">根据<a class="ae mj" href="https://en.wikipedia.org/wiki/Prototype_pattern#:~:text=The%20prototype%20pattern%20is%20a,cloned%20to%20produce%20new%20objects.&amp;text=avoid%20subclasses%20of%20an%20object,the%20factory%20method%20pattern%20does" rel="noopener ugc nofollow" target="_blank">维基百科</a>，“原型模式是软件开发中一种创造性的设计模式。当要创建的对象类型由原型实例决定时，使用它，克隆原型实例以产生新对象。”</p><ul class=""><li id="3e39" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">原型模式是一种创造性的设计模式。当对象创建是一项耗时且成本高昂的操作时，原型模式是必需的，因此我们用现有的对象本身创建一个对象。</li><li id="ab56" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">对象克隆是实现原型模式的最佳方法。</li><li id="a03d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">该模式为所有支持克隆的对象声明了一个公共接口。</li><li id="25ea" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">支持克隆的对象称为原型。对象原型化是子类化的最佳替代方案，当一个对象有大量字段时，它会很有帮助。</li><li id="57eb" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">通过这个过程，您甚至可以复制私有字段。</li><li id="0aa4" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">但是，如何根据您的业务模型复制现有对象是您自己的事情。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="c47d" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">原型设计模式的实现</h2><p id="a2b6" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">让我们看看下面针对不同类型消费者的智能手机制造流程的著名例子。</p><p id="3415" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现这个模式，声明一个抽象基类，指定一个纯虚拟的<em class="lu"> clone() </em>方法。所有子类都可以扩展SmartPhone类，并实现<em class="lu"> clone() </em>操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/7594efb314cb9eb357f53a07b947a84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XN4cFriz1V4O2JXPzU8FHA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源—作者</figcaption></figure><p id="841e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，</p><ul class=""><li id="8f8f" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">SmartPhone抽象类具有型号、价格和附加价格等属性</li><li id="2d9e" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">它实现了可克隆的接口。所以所有的具体类都必须覆盖克隆方法</li></ul><p id="e3d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查智能手机类。这是一个抽象类，实现了一个可克隆的接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3e0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个类有一些名为model、price和additional price的成员变量。总价是价格和附加价格的总和</p><p id="3aba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在类Apple扩展了智能手机基类。下面给出了Apple的实现类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a2cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，</p><ul class=""><li id="3a64" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">它的价格设置为1200硬编码，模型名称通过构造函数传递</li><li id="9424" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">它实现了克隆方法，并在克隆后返回这个类</li></ul><p id="3cff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在类三星扩展了智能手机基类。Samsung的实现类如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5a54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，</p><ul class=""><li id="f668" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">它的价格设置为1000硬编码，模型名称通过构造函数传递</li><li id="7ac6" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">它实现了克隆方法，并在克隆后返回这个类</li></ul><p id="7cb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在调用类代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d946" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，</p><ul class=""><li id="f704" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">我们为三星制造note10，为苹果制造iPhoneX，并打印出来。它显示默认价格</li><li id="be72" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">在此之后，我们将从note10开始打造note10Golds，并为VIP提供更高的价格。还有，为价格更高的VIP打造iPhoneX128。</li><li id="bb13" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">这里没有构建或创建新的实例。我们只是克隆以前创建的实例，并根据我们的要求进行修改</li></ul><p id="537a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是执行这些任务后的输出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/85e6c8c0d33054a79e698bd3daed1e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*457UjzxHfbSY0UD8-8FMag.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源—作者</figcaption></figure><p id="1a54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，</p><ul class=""><li id="e171" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">首先，我们为普通市场制造产品。</li><li id="91af" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">第二，我们为贵宾修改那些产品，它的价格变得更高</li><li id="3eb3" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">第三，我们以较低的价格为学生定制原始产品</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="01ad" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">使用原型模式的利与弊</h2><p id="e681" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated"><strong class="la iu">优点</strong></p><ul class=""><li id="c5f2" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><strong class="la iu"> <em class="lu">复用性</em> </strong> <em class="lu"> : </em>如果我们想创建一个有很多默认值的类的实例，或者在同样复杂的流程中，<em class="lu">原型模式</em>很有用。我们可以专注于其他活动。</li><li id="71bb" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu"> <em class="lu">减少初始化</em> </strong> <em class="lu"> : </em>我们可以用更便宜的成本获得新的实例。客户端可以获得新的对象，而不知道它将是哪种类型的对象。</li><li id="7edf" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu"> <em class="lu">简单的复制过程</em> </strong> <em class="lu"> : </em>它隐藏了创建对象的复杂性。我们只需要调用<code class="fe oe of og oh b">clone()</code>方法，它简单易读。</li><li id="72da" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">它减少了分类的需要。它允许您在运行时添加或删除对象。</li></ul><p id="bcb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">缺点</strong></p><ul class=""><li id="3a2e" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">这种模式成本很高。确定迭代次数是有确定性的。</li><li id="99e0" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">每个子类都必须实现<code class="fe oe of og oh b">clone()</code>方法或可选的复制方法。</li><li id="5f9b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">为现有类构建克隆可能很复杂。</li><li id="2624" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">比如实现<code class="fe oe of og oh b">Cloneable</code>接口可以约束所有子类/实现实现<code class="fe oe of og oh b">clone()</code>方法(有些类可能不需要)。</li><li id="caed" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">如果类在循环引用中，以浅层复制的方式实现<code class="fe oe of og oh b">clone()</code>方法可能会导致问题。在具有原语字段的示例中，这是可以的，但是当一个类对象包含许多引用其他对象的字段时，我们需要实现深度复制。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="2779" class="no ms it bd mt np nq dn mx nr ns dp nb lh nt nu nd ll nv nw nf lp nx ny nh nz bi translated">结论</h2><p id="b60a" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">希望你喜欢这篇文章。快乐编码。</p><p id="ea42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">参考文献<br/>1</strong>。<a class="ae mj" href="https://sourcemaking.com/design_patterns/prototype/java/1" rel="noopener ugc nofollow" target="_blank">https://sourcemaking.com/design_patterns/prototype/java/1</a>T8】2。<a class="ae mj" href="https://www.geeksforgeeks.org/advantages-and-disadvantages-of-prototype-model/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/advantages-and-missions-of-prototype-model/</a><br/>3 .<a class="ae mj" href="https://www.bartleby.com/essay/Advantages-And-Disadvantages-Of-Prototype-Design-Pattern-FCJJWYAB6JU" rel="noopener ugc nofollow" target="_blank">https://www . Bartleby . com/essay/advantage-And-lessons-Of-Prototype-Design-Pattern-fcjjwyab 6 ju</a></p></div></div>    
</body>
</html>