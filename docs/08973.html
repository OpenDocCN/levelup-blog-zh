<html>
<head>
<title>Testing Compliance with Coding Standards Through SAST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过SAST测试是否符合编码标准</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-compliance-with-coding-standards-through-sast-ff4f39184503?source=collection_archive---------3-----------------------#2021-06-23">https://levelup.gitconnected.com/testing-compliance-with-coding-standards-through-sast-ff4f39184503?source=collection_archive---------3-----------------------#2021-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ac1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用静态应用程序安全测试提高代码质量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b1bfc911fefd550b506a027051641624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wyAEjCxvf36_A_BOJ-VTrA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图像由<a class="ae ky" href="https://www.pexels.com/photo/macbook-pro-on-brown-table-139387/" rel="noopener ugc nofollow" target="_blank">负空格</a></figcaption></figure><p id="4776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免产生漏洞，开发团队建立良好的实践(例如，结对编程、代码审查、单元测试等)。)供开发人员在编码时使用。但是，即使有一套好的实践，漏洞也可能被引入到代码库中，并且只有当代码到达生产环境并且最终客户报告错误时才被检测到。</p><p id="5ca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种有助于减少新漏洞出现的方法是使用静态应用程序安全测试(<a class="ae ky" href="https://www.perforce.com/blog/kw/what-is-sast" rel="noopener ugc nofollow" target="_blank"> SAST </a>)。可以使用扫描代码的工具来应用这种技术，在代码开发时或部署前的管道中搜索漏洞。</p><p id="bda7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这项技术带来的一些优势:</p><ul class=""><li id="d0dc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">允许漏洞检测成为一个自动化的过程。</li><li id="5bf7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在将更改推送到存储库或部署管道中之前，您可以将SAST集成到您的IDE中，这将在代码进入生产环境之前创建多种扫描可能性。</li><li id="98ff" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在团队中提供安全感，在开发代码库时带来更多的信心和速度。</li></ul><p id="ec2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看它是如何为开发团队工作的。</p><h2 id="1ef4" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">执行静态代码分析</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/94d099d606b336f5dbc5ded4a38b3cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eBWp2UKPeCgxAqFY"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.grammatech.com/products/source-code-analysis" rel="noopener ugc nofollow" target="_blank"> <em class="nd">图片来源</em> </a></figcaption></figure><p id="f821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设一个项目团队决定使用一个工具来执行静态代码分析。该团队选择了基于云的SAST工具，并选择将其集成到他们的部署管道中。通过这种方式，他们可以保证对代码库的每一个更改在进入生产之前都经过了扫描。</p><p id="25d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然已经对代码进行了漏洞扫描，他们希望为每次扫描的结果创建可见性。为此，他们为每次扫描生成一个HTML报告，并以网页的形式提供，显示关于漏洞的代码库的演变。</p><p id="e4ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了前面的步骤，团队现在可以进行迭代开发，并在前进的过程中检查代码库的质量。</p><p id="ba05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更详细地看看静态代码分析报告。</p><h2 id="7d1d" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">静态代码分析报告</h2><p id="a339" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当静态代码分析扫描发生时，它会生成一个报告来解决代码库的质量问题。根据所选的SAST工具，报告的各个部分可能会有所不同，但最常见的部分如下:</p><ul class=""><li id="bad9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">bug</strong>—需要修复的代码中的错误</li><li id="5d6e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">代码味道</strong>——代码中对其目的不够清楚的部分，当代码改变时，可能会导致误解和新的错误</li><li id="799c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">漏洞</strong> —允许攻击者利用系统的安全漏洞(如SQL注入或跨站脚本)</li><li id="9888" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">最终漏洞</strong>——可能的安全漏洞，必须通过人眼检查才能确认是真正的漏洞还是误报</li></ul><p id="0585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为每一部分浏览一些代码示例。</p><p id="179a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">bug</strong></p><p id="9ce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的<a class="ae ky" href="https://en.wikipedia.org/wiki/Software_bug" rel="noopener ugc nofollow" target="_blank"> bug </a>的例子就是死代码。在下面的示例中，变量值在return语句执行后递增，但增量永远不会执行。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f8d9" class="mj mk it nk b gy no np l nq nr">// function with bug<br/>function increment(int i) {<br/>  return i;<br/>  i++;<br/>}</span></pre><p id="6104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将增量行更改为与返回行相同的行，可以很容易地修复这个示例。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="5fd1" class="mj mk it nk b gy no np l nq nr">// corrected function<br/>function increment(int i) {<br/>  return i++;<br/>}</span></pre><p id="fbcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">代码气味</strong></p><p id="4f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个函数在其作用域内返回不同类型的值，那么我们就有了<a class="ae ky" href="https://martinfowler.com/bliki/CodeSmell.html" rel="noopener ugc nofollow" target="_blank">代码气味</a>。这种代码味道不允许开发人员容易地理解函数的行为，并可能导致错误。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="3138" class="mj mk it nk b gy no np l nq nr">// function with code smell<br/>function f(int i) {<br/>  if (i === 1) {<br/>    return true;<br/>  }<br/>  return 2;<br/>}</span></pre><p id="f8f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题的一个选择是理解函数的目的，并决定使用单一的返回类型，在本例中是一个布尔值。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0bf8" class="mj mk it nk b gy no np l nq nr">// corrected function<br/>function f(int i) {<br/>  if (i === 1) {<br/>    return true;<br/>  }<br/>  return false;<br/>}</span></pre><p id="18e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">漏洞</strong></p><p id="bc71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个非常众所周知的漏洞是<a class="ae ky" href="https://owasp.org/www-community/attacks/SQL_Injection" rel="noopener ugc nofollow" target="_blank"> SQL注入</a>，攻击者使用传递给特定SQL查询的参数来改变查询的含义并获得数据访问权限，或者通过删除或更改数据来直接攻击系统。当SQL查询和相应的参数通过串联手动组装时，可能会发生这种情况，如下例所示。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="dda4" class="mj mk it nk b gy no np l nq nr">var dbConnection = require('./dbConnection.js');<br/><br/>function queryUser(req, res) {<br/>  var name = req.query.name;<br/>  var password = crypto.createHash('sha256').update(req.query.password).digest('base64');<br/><br/>  var sql = "select * from user where name = '" + name + "' and password = '" + password + "'";</span><span id="d95a" class="mj mk it nk b gy ns np l nq nr">  dbConnection.query(sql, function(err, result) {<br/>    // execute some code here  <br/>  })<br/>}</span></pre><p id="a142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止SQL注入，请使用参数化查询的预准备语句，并确保用户提供的参数被正确转义。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="7f67" class="mj mk it nk b gy no np l nq nr">var dbConnection = require('./dbConnection.js');<br/><br/>function queryUser(req, res) {<br/>  var name = req.query.name;<br/>  var password = crypto.createHash('sha256').update(req.query.password).digest('base64');<br/><br/>  var sql = "select * from user where name = ? and password = ?";<br/><br/>  dbConnection.query(sql, [name, password], function(err, result) {<br/>    // execute some code here<br/>  })<br/>}</span></pre><p id="1246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">最终漏洞</strong></p><p id="d87c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">潜在漏洞的一个简单例子是在源代码的文件中硬编码凭证。以下示例显示了访问数据库的硬编码凭据。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f38a" class="mj mk it nk b gy no np l nq nr">let mysql = require('mysql');<br/><br/>let conn = mysql.createConnection({<br/>  host:'localhost',<br/>  user: "username",<br/>  password: "notsosecretpassword",<br/>  database: "db"<br/>});<br/><br/>conn.connect();</span></pre><p id="c3fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免硬编码凭证，它们应该存储在环境变量中，并在代码中使用，如下例所示。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="58f0" class="mj mk it nk b gy no np l nq nr">var mysql = require('mysql');<br/><br/>var conn = mysql.createConnection({<br/>  host: process.env.MYSQL_URL,<br/>  username: process.env.MYSQL_USERNAME,<br/>  password: process.env.MYSQL_PASSWORD,<br/>  database: process.env.MYSQL_DATABASE<br/>});</span><span id="2745" class="mj mk it nk b gy ns np l nq nr">conn.connect();</span></pre><h2 id="7dd6" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">包扎</h2><p id="adbd" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">使用SAST工具无疑是一个很好的选择，因为它允许开发团队在代码库的开发过程中对代码中可能引入的漏洞进行自动防护。</p><p id="3e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不应被视为通向100%无漏洞代码库的途径，因为它是基于扫描代码时检查的一组预定义的有限规则。尽管如此，它将为团队节省大量的时间和压力，因为它避免了漏洞被某些人(开发人员、质量保证人员，甚至最终客户)手动检测，然后被修复。</p><p id="0e54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反映代码库质量的报告创建了关于项目当前状态和将来需要进行的必要改进的可见性、透明度和意识。</p><p id="2089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>