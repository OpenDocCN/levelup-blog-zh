<html>
<head>
<title>Designing a Graph Data Structure in a Relational Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在关系数据库中设计图形数据结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/designing-a-graph-data-structure-in-a-relational-database-e13ffb857ce2?source=collection_archive---------2-----------------------#2020-03-28">https://levelup.gitconnected.com/designing-a-graph-data-structure-in-a-relational-database-e13ffb857ce2?source=collection_archive---------2-----------------------#2020-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5fd4b0b970d476042dc335340cfd805a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bILSz3ebx0-B01yf_VAUzQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">奥布里·达尔克在<a class="ae kf" href="https://unsplash.com/s/photos/vine?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4154" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你曾经想问我为什么要在关系数据库(如MySQL或Postgres)中设计图形数据结构，而不使用图形数据库或NoSQL，这可能是出于几个特定的原因:</p><ol class=""><li id="c731" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">SQL作为一种查询语言被广泛使用，大多数开发人员对它都很了解。</li><li id="25d6" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">RDSs扩展，有很多大公司已经扩展了关系数据库。(诚然，没有NoSQL多，但见第3点)</li><li id="2c2c" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">rds提供了许多有用的一致性保证，以及围绕特定数据访问和数据迁移的灵活性。</li></ol><h1 id="6806" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">问题是</h1><p id="95f7" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">图是具有节点和边的数据结构。边连接节点，大多数时候，表达两个节点之间的关系。节点是数据库中的“实体”，是那些关系的主体。</p><p id="e350" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个例子，</p><ul class=""><li id="a3c9" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld mv lk ll lm bi translated">菲利普拥有一辆吉普车</li><li id="3a14" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld mv lk ll lm bi translated">泰伦斯是菲利普的朋友</li><li id="b98d" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld mv lk ll lm bi translated">特伦斯还有另外两个朋友——盖伊和巴迪</li><li id="28cb" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld mv lk ll lm bi translated">巴迪目前出租菲利普的吉普车</li></ul><p id="95e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你试着想象这些关系，你可能会得到这样的结果:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/adde424cdc4b4e12bc4b4e9804b0cdf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*4vz4ArV4EEEUOJ6q5V7Nvg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">与http://www.webgraphviz.com<a class="ae kf" href="http://www.webgraphviz.com/" rel="noopener ugc nofollow" target="_blank">一起创作</a></figcaption></figure><p id="3873" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在表格中呈现这种结构有多种方式。一种方法是让表中的每一行都有一个到图中相邻行的“链接”。换句话说，每一行都有足够的信息来推断相邻关系。我们称之为邻接表。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/7a98fd4087d0fac18bf14e32a61d11a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLUrr67TMtOeEmkoDW64BA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图一</figcaption></figure><p id="9d0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，这个表格传达了和我们的视觉图一样多的信息。出于可读性的目的，我保留了表中的<em class="nc">实体</em>字段，但是当构建该表的最规范形式时，我们可以将其丢弃，因为它是可以使用<em class="nc"> id </em>字段从另一个表中解密的信息。</p><p id="ba9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们使用的是关系数据存储，因此规范化这些信息会使我们有两个表。对这些表执行连接将得到表的先前版本(图1)。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/2c5e3c4c01ab5e1f2631231b90a111fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZewrNLhBZNYv49XHyHQ2A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图2</figcaption></figure><h1 id="b509" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">稀疏表格</h1><p id="278f" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">实体表保存id和实体之间的映射。但事实是，实体可以是任何东西，不可避免地，我们将不得不存储某些特定实体特有的信息。</p><p id="9843" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，Jeep属于车辆类型，必须有牌照。菲利普、泰伦斯、盖伊、巴迪都是人，都有姓氏和出生日期。如果你不介意迁就我一下，我们可以把所有这些列放在一个表格里，就像这样:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/992a48890b4138c48fb3e32cfa2aa5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iKN-wEzPDvqqwcIEW35rzg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图3</figcaption></figure><p id="f3c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要我们的关系表来保存另一个表中的关系。</p><p id="be39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您可能怀疑的那样，某些列不适用于某些实体类型。对于这些列，它们用空值表示。实体越多，每行的空列就越多。我从现在开始把这个叫做稀疏表。因为随着实体数量的增加，包含空值的单元格数量也会增加。</p><h2 id="4f42" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">赞成:稀疏表实现起来很简单</h2><p id="0ec5" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">它是一张单人桌子。通过一个简单的SELECT语句，您可以访问您想要的所有信息。但不幸的是，这可能是这种设计唯一的好处。</p><h2 id="0d28" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">缺点:很难保证数据的一致性</h2><p id="25df" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">数据没有标准化，每个实体都可以访问其他实体的列。没有什么可以阻止Terrence在数据库设计中拥有一个license_no属性。</p><h2 id="3e15" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">缺点:它不能随着实体数量的增加而很好地扩展</h2><p id="8aee" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">关系数据存储能够很好地处理大表。但是一旦表中的列数开始增加，这种可伸缩性就会下降。你可以争辩说，如果这是真的，你必须有大量的列。但是，如果您支持的实体数量或每个实体支持的列数增加，这种情况很快就会发生。根据RDS分区的内部情况，您迟早会遇到这个问题。</p><h2 id="a6e5" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">反对意见:迁移可能会很痛苦</h2><p id="ddfe" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">因为所有数据都集中在一个表中，所以添加、删除或更改列的数据类型可能需要一些停机时间。这是因为rds是为强一致性而设计的，当数据库模式在后台很难改变时，它可以实现一定的一致性保证。</p><h2 id="ad87" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">缺点:单个表成为您的瓶颈</h2><p id="00cc" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">如果您有一个繁重的写入工作负载，那么您的所有应用程序节点都将开始向该表写入数据。如果您对一些数据库操作使用事务，您可能会发现一些操作被死锁或等待锁，这取决于您的<a class="ae kf" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)" rel="noopener ugc nofollow" target="_blank">隔离级别</a>。</p><h1 id="ba34" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">卫星表</h1><p id="d27f" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">另一个解决问题的方法是使用我称之为“卫星桌”的设计。您可以在一个表(id，parentId，type)中拥有节点的关系，并拥有<em class="nc"> n </em>个其他附属表，其中<em class="nc"> n </em>是您的“实体类型”的数量。</p><p id="62ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本质上，它是稀疏表设计的标准化版本。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/582e800c54d93702121b0ecfa47af8d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YKffuED88-Fgst1XQaLRdg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图4</figcaption></figure><p id="da17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为所有的实体都有自己的表，所以避免了稀疏性。然而，现在当您想要读取所有数据时，您将有n个连接要执行。要获得数据集的完整视图，您必须将关系表的id与人员表和车辆表的每个id连接起来。</p><p id="22c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您创建这个视图，那么它包含一个数据集，非常像我们前面看到的稀疏表。但是，由于数据存在于几个表中，而不是一个表中，所以它没有同样的缺点。</p><h2 id="fa91" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">赞成:数据集是正常的。</h2><p id="4eb2" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">这里不需要太多解释——一切都在<a class="ae kf" href="https://en.wikipedia.org/wiki/Third_normal_form" rel="noopener ugc nofollow" target="_blank">第三范式</a>中。</p><h2 id="ae00" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">赞成:数据访问是分布式的</h2><p id="7503" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">由于数据访问分布在多个表中，并且每种类型的实体都有自己的表，所以您的读写不会像稀疏表设计那样出现瓶颈。</p><h2 id="a004" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">教授:迁移更容易</h2><p id="6296" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">您的迁移现在影响更多的表，但是影响是分散的。如果您正在进行大型迁移，(比如完全删除一个实体类型或者添加一个新的实体类型)，可以分阶段进行，避免停机时间。例如，要更改大型实体表的模式，可以先用新模式创建一个新的实体表，将数据增量迁移到新表中，然后废弃旧表。这在稀疏表设计中是不太可能的。</p><h2 id="6a24" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">缺点:连接随着实体类型的增加而增加</h2><p id="ab24" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">就像稀疏表设计中的列随着实体类型的增加而增加一样，连接也随着实体类型的增加而增加。并且连接会稍微降低查询性能。</p><h2 id="b11e" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">缺点:数据访问逻辑很复杂</h2><p id="4f75" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">对于稀疏表设计的所有缺点，数据访问要简单得多。您可以在一个表上做一个简单的选择、更新、删除，然后就完成了。在卫星表设计中，你必须包含连接。如果您想要删除一个实体，这将导致在两个表中最少两次删除操作</p><h1 id="fd86" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">JSON列</h1><p id="4add" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">当我们试图在关系数据存储中设计图形数据结构时，看起来我们试图解决两个问题。</p><ol class=""><li id="07f8" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">设计一个邻接表，把代表一个图的行彼此连接起来。</li><li id="d272" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">设计可以在关系数据存储中表示n个模式的数据存储。</li></ol><p id="9054" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，1可以很容易地用引用<code class="fe ns nt nu nv b">id</code>列的<code class="fe ns nt nu nv b">parent_id</code>列来解决(用外键来确保一致性)。</p><p id="dd6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">№2是我们正在努力解决的问题。当您可以事先对表模式进行推理时，传统的关系数据存储规范化技术是有用的，但是当您使用不断变化和不断增长的模式列表时，它们就不够用了。</p><p id="61c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是NoSQL试图用“无模式”设计来解决的一个问题。但是正如一些大型的T2实现可能显示的那样，SQL可能是比NoSQL更好的NoSQL。</p><p id="23df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以这种方式设计表看起来很像稀疏表设计，但是您的数据在JSON列中。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/1f8929bb3a268f5477ee4538dc337c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivJqT6_6capgtWI4q9O1Ag.png"/></div></div></figure><h2 id="6a23" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">教授:鱼与熊掌不可兼得。</h2><p id="e465" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">您可以享受RDS世界的精华，享受它所提供的保证，以及一种让您将无模式数据视为无模式数据的查询语言。数据库中可以正常化的数据被正常化。</p><h2 id="95fc" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">利:减轻对可伸缩性的大部分担忧。</h2><p id="3b64" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">在上面的两种方法中，我们遇到了列和连接数量的可伸缩性问题。使用这种方法，随着表中行数的增加，您会遇到可伸缩性问题。谢天谢地，这个问题有很多解决方案。</p><h2 id="ba97" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">利:迁移可以利用JSON函数</h2><p id="3b41" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">如果需要对JSON列进行迁移，可以使用引擎的查询功能来进行更新，而不需要借助应用程序代码。换句话说，您将在数据库级别处理数据库迁移。</p><h2 id="a3f2" class="nf lt it bd lu ng nh dn ly ni nj dp mc kr nk nl mg kv nm nn mk kz no np mo nq bi translated">缺点:你必须在应用程序代码中实施JSON模式</h2><p id="83c7" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">关系数据库不能保证JSON列中使用的模式。这将是您必须在应用程序代码中强制执行的内容。除非您求助于在JSON列上进行数据库迁移，否则您将不可避免地实施<a class="ae kf" href="https://luminousmen.com/post/schema-on-read-vs-schema-on-write" rel="noopener ugc nofollow" target="_blank">模式读取</a>方法，就像您如何处理NoSQL用例一样。</p><h1 id="55c3" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">关于NoSQL解的一个注记</h1><p id="0ddb" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">现在，您可能会问，我们处理NoSQL数据库不是更好吗？毕竟，这是一个键值存储。嗯，你可能会。但是，不要把关系数据存储带来的好处一笔勾销。</p><p id="f6f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您将获得更多的一致性保证、<a class="ae kf" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"> ACID事务</a>，以及批量更新JSON数据的能力，其中<a class="ae kf" href="https://dev.mysql.com/doc/refman/8.0/en/json-functions.html" rel="noopener ugc nofollow" target="_blank"> MySQL </a>和<a class="ae kf" href="https://www.postgresql.org/docs/9.5/functions-json.html" rel="noopener ugc nofollow" target="_blank"> Postgres </a>都实现了JSON查询，并将语法更新为SQL的超集。</p><p id="282e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于NoSQL数据库的设计，它们往往比关系数据库更具可伸缩性，但这种优势仅在大型数据集上体现，为了获得这种优势，您必须做出许多正确的决策，包括预先选择正确的分区键。通常，当迭代一个项目时，由于不断变化的需求，很难确定正确的分区键。</p><p id="e4c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您认为自己犯了一个错误时，NoSQL数据库中的数据库迁移也不是一件小事。DynamoDB <a class="ae kf" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html" rel="noopener ugc nofollow" target="_blank">对批量更新吞吐量</a>有上限，MongoDB有<a class="ae kf" href="https://docs.mongodb.com/manual/core/map-reduce/" rel="noopener ugc nofollow" target="_blank">的数据库内map-reduce </a>功能，管理起来有点麻烦。</p><p id="c3a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而在RDS中，您可以将JSON数据作为数据迁移的一部分或作为读取模式机制进行迁移。换句话说，对于绝大多数用例(当然，这取决于数据集的大小)，为此目的使用rds有很大的好处，但坏处很少。</p></div></div>    
</body>
</html>