<html>
<head>
<title>Fully dynamic data-table component for Vue.JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue的全动态数据表组件。射流研究…</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fully-dynamic-data-table-component-for-vue-js-c72cdb6cff92?source=collection_archive---------3-----------------------#2020-05-04">https://levelup.gitconnected.com/fully-dynamic-data-table-component-for-vue-js-c72cdb6cff92?source=collection_archive---------3-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="7196" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="ef5e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面这篇文章是为入门级前端开发人员准备的，他们已经对反应式/渐进式javascript框架和SPA开发有所了解。您将能够看到一个完全动态的数据表是如何创建的，并且在这个过程中熟悉VueJS的语法、数据流和组件。</p><p id="7beb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果你不太熟悉水疗发展的概念，不用担心！您可以通过查看令人惊叹的Vue框架<a class="ae lr" href="https://vuejs.org/v2/guide/" rel="noopener ugc nofollow" target="_blank">文档</a>快速了解这些概念。</p><h1 id="68ea" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">入门指南</h1><p id="0607" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们需要做的第一件事是使用Vue CLI建立一个VueJS项目。在整个项目中，我们将依赖NPM包，所以请确保在您的机器中全局设置NodeJS。为了通过CLI创建您的应用程序，您首先需要通过您的终端进行全局安装:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="7fcb" class="mb jr it lx b gy mc md l me mf"><strong class="lx iu">npm install -g @vue/cli</strong></span></pre><p id="83d9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在我们已经有了Vue CLI，您可以使用下面的命令在我们想要的任何目录下创建项目:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="9e1b" class="mb jr it lx b gy mc md l me mf"><strong class="lx iu">vue create your-project-name</strong></span></pre><p id="874c" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">执行上述命令后，Vue CLI将为您提供项目的预定义配置选项，然后手动选择它们，这样您就可以亲眼看到它所提供的功能:</p><figure class="ls lt lu lv gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi gj"><img src="../Images/034bffba8941c134101cf236adcbbe18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JtdV92y1nJaAO5OXzvghVA.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图1.1 — Vue CLI功能依赖关系</figcaption></figure><p id="6876" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">还将有后续选项配置(即CSS处理器，如node-sass)以及这些配置文件在应用程序中的结构，我选择了node-sass进行CSS预处理，Jest进行测试，package.json文件作为主配置文件。</p><p id="f834" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">创建项目后，我们只需移动到新创建的文件夹，使用<strong class="kq iu"><em class="mr">NPM run serve</em></strong><em class="mr"/>，您会发现您新出炉的Vue应用程序正在被提供@ <strong class="kq iu"> localhost:8080 </strong>。</p><h1 id="af5b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">了解项目文件结构</strong></h1><figure class="ls lt lu lv gt mg gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/aa1e9b6163b5da97734cd5a2341275bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*140_TFm8hayH-AJEyNdyLg.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图1.2 —项目结构</figcaption></figure><p id="b3fa" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">所以你的项目结构应该是这样的，突出强调<strong class="kq iu"> <em class="mr"> src </em> </strong>目录，我们的源代码将在这个目录中开发和维护。Node_modules拥有关于我们的开发甚至产品依赖(第三方库)的黑盒魔法，或者稍后将被捆绑到javascript文件的大块中。</p><figure class="ls lt lu lv gt mg"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Vue路由器配置</figcaption></figure><p id="e941" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">正如您在左侧代码片段中看到的，您将从Vue CLI项目设置中找到预定义的路由，因此基本上您在这里有几个选项，要么创建一个具有不同路径和组件的新路由，要么修改第一个路由的组件，要么继续处理现有的Home组件。我将继续创建一个新视图(<strong class="kq iu"> Main.vue </strong>)，它将保存主数据表组件，并将替换指向我的新视图的home路径。</p><h1 id="d671" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">从主要组件开始</h1><p id="b59f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，我们要做的是保持一种健康和建设性的基于组件的思维模式。目前我们知道的是，我们将构建一个动态表。因此，从命名本身，我们知道必须有一个包装组件，即<strong class="kq iu"> <em class="mr"> Table.vue </em> </strong>。任何表格的组成部分都是它的表头和行，所以这些部分/组件应该单独定义和实现:<strong class="kq iu"> <em class="mr"> TableRow.vue </em>，TableHeader.vue </strong>。</p><p id="7ec8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">尽管这不是一个大项目，但最好的做法是知道将应用程序的组成部分放在哪里，这样组件将放在<em class="mr"> src下——组件</em>目录和视图将成为它自己的文件夹的一部分。</p><figure class="ls lt lu lv gt mg"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">为了您的方便，分享要点/片段</figcaption></figure><p id="6bd1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在上面的代码片段中，您会发现我们组件的主干以及我们在这里所做的事情，父表组件及其各自的标题和行子组件。从要点的第25行可以看出，我已经在组件的data属性中创建了一个数组，它显然是伪数据，所以我们可以继续在我们的<em class="mr"> Main.vue </em>视图中显示一个表。</p><blockquote class="mv mw mx"><p id="516d" class="ko kp mr kq b kr lm kt ku kv ln kx ky my lo lb lc mz lp lf lg na lq lj lk ll im bi translated">更简单地说，你可以把<strong class="kq iu">数据</strong>看作是变量/对象/数组的来源，它们是组件的一部分，可以在整个组件中使用。</p></blockquote><p id="0f9d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当然，这个组件不可或缺的一部分是某种数据，理想情况下，您会从后端服务中获取这些数据，然后从您自己的由Vuex提供支持的应用状态中检索这些数据……这就是为什么我将table headers()和table rows()作为计算属性写下来，这些属性将直接从我们集中的Vuex存储中的一个状态属性中派生出来。这些计算属性的值作为<strong class="kq iu"> <em class="mr">属性</em> </strong>传递给子表组件，并在这些组件中被期望和处理如下:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="8f3d" class="mb jr it lx b gy mc md l me mf">&lt;template&gt;<br/> &lt;div&gt;<br/>   {{propName}}<br/> &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="cd45" class="mb jr it lx b gy nb md l me mf">...<br/>props['propName']<br/>...</span></pre><p id="5b02" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">该组件的所有动态部分背后的主要思想是想出一种方法来获得每个对象的正确数量的键和相应的值，这就是为什么上面提到的计算属性中的两个操作都很方便。通过回调机制，<strong class="kq iu"> map </strong>迭代每个对象并返回一个新数组，这取决于我们如何根据自己的需要来管理自己的对象。在这里，我主要依赖于获取键及其索引，以及获取与每个特定行的键成对的值。</p><h1 id="f104" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">一瞥真空状态操作</h1><p id="a9f0" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在当今的SPA中，您很少会发现不通过HTTP与第三方服务进行通信的SPA，但通常它们都有某种状态管理，因此，无论何时开发此类应用程序，最好将通信和状态更改活动/事件分开。VueJS提供了<em class="mr">动作</em>和<em class="mr">突变</em>，在一个高层次的概念上，你可以认为它们都是涉及状态变化的操作。</p><blockquote class="mv mw mx"><p id="3951" class="ko kp mr kq b kr lm kt ku kv ln kx ky my lo lb lc mz lp lf lg na lq lj lk ll im bi translated">根据它的官方文档，Vuex告诉我们，改变我们的应用程序状态的唯一方法是<strong class="kq iu">向状态的特定部分提交</strong>突变，动作与突变的不同之处在于，前者只是启动/提交突变，并不直接改变状态，由于它们提供异步操作的兼容性，最佳实践是第三方API/后端服务调用由动作启动，无论结果如何，都将通过提交的突变反映到应用程序状态。</p></blockquote><figure class="ls lt lu lv gt mg"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">商店管理骨干</figcaption></figure><p id="3740" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在上面的要点中，你会看到我已经通过添加突变、动作和一个新的状态属性<em class="mr"> tableData </em>修改了我们的created-by-vuecli存储，正如你正确回忆的那样，它是我们的Table组件中的<em class="mr">数据属性</em>。您可以在主<em class="mr"> index.js </em>文件中“内联”定义您自己的动作和突变，但通常这不是首选，因为一旦代码库扩展并且新功能即将出现，在它们单独的文件中拥有单独的动作、突变甚至公共实用函数对于进一步的代码可维护性将是一个很大的优势。</p><figure class="ls lt lu lv gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nc"><img src="../Images/3acc707aca3b147cb0d4c43c9ff3eff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpNBA8NR82Yhv2RR_tPrng.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图1.3组件—商店反射</figcaption></figure><p id="2d27" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我还添加了一个已知的VueJS组件生命周期挂钩(在众多挂钩中)，如其名称所示，在组件被挂载和呈现之前，它会启动一个操作，为我们的表组件检索所需的表数据，正如您在上面的图片中所看到的(与VueJS开发工具一起)，计算的属性通过反映中央状态属性<em class="mr">表数据</em>的主vuex绑定来填充。</p><h1 id="b747" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">一些最后的润色</h1><p id="71b9" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在继续之前，如果您没有可以从中检索数据的第三方API或后端服务，您可以继续检查<a class="ae lr" href="https://github.com/marak/Faker.js/" rel="noopener ugc nofollow" target="_blank"> FakerJS </a>，并在Vuex Store上的<em class="mr">操作</em>中使用其方法，您可以使用您喜欢的任何键生成任意数量的对象。接下来，您可以查看我用来得出最终结果的CSS属性和实践，您可以查看本文中的图1.4。</p><figure class="ls lt lu lv gt mg"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">项目的最终CSS</figcaption></figure><h1 id="b75d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">开始</h1><p id="a5a3" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这篇文章结束时，如果你已经遵循了要点，你应该会有一个如下的表格。显然，这是一个简单的组成部分，而不是火箭科学，但这是一个有趣的任务。本文是这个项目的第一部分，下一部分将集中在部署和使这个表组件作为一个NPM包可访问，这样任何人都可以通过将其作为一个依赖项安装并作为一个组件集成到他们的应用程序中来使用它。与此同时，我打算实现一个全功能表所具有的所有特性，即过滤、排序、修改等等，所以可以放心地继续使用Github repo @ <a class="ae lr" href="https://github.com/ardianche/zippytable" rel="noopener ugc nofollow" target="_blank"> ZippyTable </a>。</p><p id="db4d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">感谢您花时间阅读本文，期待您在评论中的反馈！</p><figure class="ls lt lu lv gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nd"><img src="../Images/1e22e98f133cd8153a2db607d4ec4fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odzEMZ0AEL-jx85mh3dXiQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图1.4 —最终产品</figcaption></figure></div></div>    
</body>
</html>