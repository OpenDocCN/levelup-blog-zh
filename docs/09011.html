<html>
<head>
<title>Operating System — Memory Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">操作系统—内存管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/operating-system-memory-management-7f130d242e68?source=collection_archive---------1-----------------------#2021-06-28">https://levelup.gitconnected.com/operating-system-memory-management-7f130d242e68?source=collection_archive---------1-----------------------#2021-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b6a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">仅用5分钟了解内存管理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/db41b9d7aa1681aab65fc4b27cd29ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b8XBVHV6M7K4QnOk"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">杰瑞米·泽罗在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="bc03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">内存管理</strong>是管理计算机内存的过程，在主存和磁盘之间移动进程以提升系统的整体性能。它非常重要，因为它帮助操作系统跟踪每个内存位置，包括分配内存和释放内存。</p><p id="68b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将只关注用户空间内存，因为它直接影响应用软件的执行，每个软件工程师都应该了解它。</p><h1 id="dd33" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用户空间内存管理</h1><h2 id="5a25" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">地址空间</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/e3d26c1029a88403d3bbaf6e0d28ddf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Srd3CFvM3GkWvuG5hk7Y2A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">地址空间</figcaption></figure><p id="d01d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个地址映射到一个字节。在32位系统上，一个进程的最大内存量是2^32字节，这意味着<strong class="ky ir"> 4GB </strong>。这意味着64位系统上一个进程的内存可以是<strong class="ky ir"> 16EB </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/0ed22dd9c53712500511127004530f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*JjiUBGG3JPe1vl5MJhIlJA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">关于地址空间的更多细节</figcaption></figure><p id="1174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个进程都有自己的地址空间，并且应该有2^32字节(4GB)的内存。(我说的是32位系统)</p><p id="90f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">地址空间由4种主要的内存组成。它们是:</p><ol class=""><li id="d5c5" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">程序代码和程序段</li><li id="47b6" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">数据段</li><li id="d965" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">堆</li><li id="976c" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">许多</li></ol><h2 id="a7fd" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">程序代码和常量</h2><p id="e496" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">让我们来看一个代码段的例子:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="6cf0" class="mk lt iq ns b gy nw nx l ny nz">int main(void) {<br/>  <strong class="ns ir">char *string = "hello";</strong> //string constant<br/>  printf("\"hello\" = %p\n", <strong class="ns ir">"hello"</strong>); // "hello" is used<br/>  printf("String pointer = %p\n", <strong class="ns ir">string</strong>); // same constant is used<br/>  return 0;<br/>}</span></pre><p id="b8f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">电脑很聪明。在这个例子中，程序总是使用相同的字符串常量，只要它是唯一的。</p><p id="731c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数具有基本编程知识的开发人员或软件工程师肯定知道它。代码和常量都是只读的。</p><ul class=""><li id="ae2e" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr oa ne nf ng bi translated">我们不能在运行时改变代码或常量的值。</li><li id="2578" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr oa ne nf ng bi translated">常数存储在代码段中，并且只存储唯一的常数。</li></ul><h2 id="f8a2" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">数据段和BSS</h2><p id="3c83" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">全局和静态变量存储在数据段和BSS(以符号开始的块)中。数据段用于存储初始化的变量，而BSS用于存储未初始化的变量。</p><p id="1ec2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看下面的例子:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="6e3c" class="mk lt iq ns b gy nw nx l ny nz">int global_int = 1; // global</span><span id="4a15" class="mk lt iq ns b gy ob nx l ny nz">int main(void) {<br/>  int local_int = 1;<br/>  static int static_int = 1; // static</span><span id="d0f2" class="mk lt iq ns b gy ob nx l ny nz">  printf("local_int addr = %p\n", &amp;local_int ); // e.g. 0xbf8bb8ac<br/>  printf("static_int addr = %p\n", &amp;static_int ); // e.g. <strong class="ns ir">0xxxxxx18</strong><br/>  printf("global_int addr = %p\n", &amp;global_int ); // e.g. <strong class="ns ir">0xxxxxx14</strong><br/>  return 0;<br/>}</span></pre><p id="8eff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想在自己的机器上运行c程序。我们会发现全局变量和静态变量是紧挨着存储的。这意味着它们在同一个分段中。</p><p id="74e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看另一个例子:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="37ce" class="mk lt iq ns b gy nw nx l ny nz">int global_bss; // uninitialized<br/>int global_data = 1; // initialized</span><span id="4b70" class="mk lt iq ns b gy ob nx l ny nz">int main(void) {<br/>  static int static_bss; // uninitialized<br/>  static int static_data = 1; // uninitialized</span><span id="ed85" class="mk lt iq ns b gy ob nx l ny nz">  printf("global bss = %p\n", &amp;global_bss ); // e.g. <strong class="ns ir">0xxxxxx88</strong><br/>  printf("static bss = %p\n", &amp;static_bss ); // e.g. <strong class="ns ir">0xxxxxx84</strong><br/>  printf("global data = %p\n", &amp;global_data ); // e.g. <strong class="ns ir">0xxxxxx14</strong><br/>  printf("static data = %p\n", &amp;static_data ); // e.g. <strong class="ns ir">0xxxxxx18</strong><br/>}</span></pre><p id="0b9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这表明数据和BSS是分开存储的。</p><h2 id="2cec" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">堆</h2><p id="1568" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">堆栈是存储以下内容的区域:</p><ul class=""><li id="e106" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr oa ne nf ng bi translated"><strong class="ky ir">局部变量</strong>，</li><li id="2a7b" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr oa ne nf ng bi translated"><strong class="ky ir">功能参数</strong>，以及</li><li id="595f" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr oa ne nf ng bi translated"><strong class="ky ir">环境变量</strong></li></ul><p id="6a91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由函数创建。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/984bca17d2e4a1723be45a9fa27064ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wdYnOQTYEnHfxTnhRY3u2g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">堆栈示例</figcaption></figure><p id="ccf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个函数被调用时，一个堆栈框架将被压入。当函数返回时，堆栈帧将被弹出。这项工作不是由内核完成的，而是由编译器完成的。它将这种机制硬编码到我们的程序中。</p><p id="9b63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数可以在堆栈中的任何地方读写，而不局限于自己的堆栈框架。</p><p id="7151" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，编译器无法在编译时估计堆栈的大小。函数调用的次数取决于许多因素，如程序状态、用户输入等。内核只能为堆栈保留一定的空间。</p><p id="41fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再多考虑一点。<strong class="ky ir">如果栈中没有更多的空间了怎么办？</strong>操作系统会做什么？放大堆栈？如果是一串无休止的<br/>递归函数调用怎么办？</p><p id="e100" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">会发生什么？</p><ul class=""><li id="48c1" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr oa ne nf ng bi translated">CPU捕捉到异常</li><li id="bcb3" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr oa ne nf ng bi translated"><strong class="ky ir">堆栈溢出</strong>异常</li><li id="fd1f" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr oa ne nf ng bi translated">程序终止</li></ul><p id="ebc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解决方案</strong></p><ul class=""><li id="a295" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr oa ne nf ng bi translated">最小化参数的数量</li><li id="d578" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr oa ne nf ng bi translated">最小化局部变量的数量</li><li id="3544" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr oa ne nf ng bi translated">最大限度地减少通话次数</li><li id="5d42" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr oa ne nf ng bi translated">使用全局变量</li><li id="181c" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr oa ne nf ng bi translated">使用malloc</li></ul><h2 id="adb2" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">许多</h2><p id="f36b" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">当一个程序刚刚运行时，整个堆空间是未分配的或空的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/607c15e30601ccd89cd5f75ecec2c777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*wKzBNtyOtP-DcBDWjgEbpg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">调用malloc时，堆正在增长</figcaption></figure><p id="1a05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分配空间的增长或收缩取决于<strong class="ky ir"> malloc() </strong>和<strong class="ky ir"> free() </strong>系统调用。<strong class="ky ir"> malloc() </strong>增加堆空间，而<strong class="ky ir"> free() </strong>减少堆空间。</p><p id="b8da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当调用“<strong class="ky ir"> malloc() </strong>”或“<strong class="ky ir"> free() </strong>”时，可能会调用“brk()”系统调用。系统调用标记堆地址结束的地方。</p><div class="oe of gp gr og oh"><a href="https://man7.org/linux/man-pages/man3/malloc.3.html" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">malloc(3) - Linux手册页</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">MALLOC(3) Linux程序员手册MALLOC(3) malloc，free，calloc，realloc，reallocarray - allocate和free dynamic…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">man7.org</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kp oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="https://linux.die.net/man/3/free" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">免费(3) - Linux手册页</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">malloc()函数分配大小字节并返回…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">linux.die.net</p></div></div></div></a></div><div class="oe of gp gr og oh"><a href="https://man7.org/linux/man-pages/man2/brk.2.html" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">brk(2) - Linux手册页</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">include int brk(void * addr)；void * sbrk(int ptr _ t increment)；glibc的功能测试宏要求(参见…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">man7.org</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov kp oh"/></div></div></a></div><p id="1bcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">"<strong class="ky ir"> free() </strong>"取消分配任何已分配的内存。当一个程序调用“<strong class="ky ir"> free(ptr) </strong>”时，那么地址“ptr”一定是之前“<strong class="ky ir"> malloc() </strong>”调用获得的内存的开始。</p></div><div class="ab cl ox oy hu oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="ij ik il im in"><h2 id="1288" class="mk lt iq bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">后续步骤</h2><p id="05be" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">如果你正在读这一行，恭喜你！！！你做到了。您已经学习了用户空间内存管理的基础知识。当然，内存管理还有更复杂的问题，比如分段错误。希望我能在未来讨论其中的一些。</p><p id="9d12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请随意查看下面关于操作系统的其他文章:</p><div class="oe of gp gr og oh"><a href="https://mattchw.medium.com/overview-of-operating-system-cc3f6f6bb062" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">操作系统概述</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">操作系统一般是如何工作的？</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">mattchw.medium.com</p></div></div><div class="oq l"><div class="pe l os ot ou oq ov kp oh"/></div></div></a></div><p id="570a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解更多关于我的后端学习路径，请点击这里查看我的旅程:</p><div class="oe of gp gr og oh"><a href="https://mattchw.medium.com/my-backend-developer-learning-journey-%E6%88%91%E7%9A%84%E5%BE%8C%E7%AB%AF%E5%AD%B8%E7%BF%92%E4%B9%8B%E6%97%85-5315fe2fefc2" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi">My Backend Developer Learning Journey 我的後端學習之旅</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">毕业一年多了。拥有2年以上的前端和后端工作经验…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">mattchw.medium.com</p></div></div><div class="oq l"><div class="pf l os ot ou oq ov kp oh"/></div></div></a></div></div></div>    
</body>
</html>