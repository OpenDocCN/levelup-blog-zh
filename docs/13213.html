<html>
<head>
<title>What Can We Do With Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们能用Web组件做什么</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-can-we-do-with-web-components-997ed097aa4b?source=collection_archive---------1-----------------------#2022-08-17">https://levelup.gitconnected.com/what-can-we-do-with-web-components-997ed097aa4b?source=collection_archive---------1-----------------------#2022-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8d4d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不需要框架的本地web组件的优势是什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/32f0d5983bf84bc978bd071aa26b255b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MppT_kx4SKu3-cE1"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@_louisreed?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路易斯·里德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">近年来，Web开发的趋势是组件化。web前端架构最大的挑战是如何复用更多的组件。目前流行的JavaScript框架如React、Vue、Angular大多使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Domain-specific_language" rel="noopener ugc nofollow" target="_blank"> DSL(特定领域语言)</a>编写组件，并转换成框架内部的原生HTML元素。谷歌一直在推进新技术，即浏览器的原生网络组件。与这些框架相比，本机组件更简单，不需要额外的运行时，并且需要的代码更少。它仍在开发中，但可以在大多数浏览器中运行。</p><p id="b71e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将带您创建一个简单的web组件，并解释它的优点。让我们把手弄脏:</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="944c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们制作一个简单的自定义<code class="fe mc md me mf b">button</code>组件，只需将其插入HTML:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="d332" class="mk ml it mf b gy mm mn l mo mp">&lt;custom-button&gt;&lt;/custom-button&gt;</span></pre><p id="b4f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，这个定制HTML标记被称为定制元素。根据规范，自定义元素的名称必须包含一个连字符，以区别于本机HTML元素。因此，<code class="fe mc md me mf b">&lt;custom-button&gt;</code>不能写成<code class="fe mc md me mf b">&lt;customButton&gt;</code>。</p><p id="a404" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们来看看怎么定义。我们需要使用<code class="fe mc md me mf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define" rel="noopener ugc nofollow" target="_blank">window.customElements.define()</a></code> API。像下面这样:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="7008" class="mk ml it mf b gy mm mn l mo mp">window.customElements.define('custom-button', CustomButton);</span></pre><p id="956c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的效果是定义了一个<code class="fe mc md me mf b">custom-button</code>，当我们在HTML中使用它时，浏览器会使用我们写的<code class="fe mc md me mf b">CustomButton</code>:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="c4fa" class="mk ml it mf b gy mm mn l mo mp">class <!-- -->CustomButton<!-- --> extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>  }<br/>}</span></pre><p id="3328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要从<code class="fe mc md me mf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement" rel="noopener ugc nofollow" target="_blank">HTMLElement</a></code>扩展过来，也赋予了它很多HTML元素的属性。</p><p id="f7fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们给它添加内容，完整的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果有很多内部元素，我们都需要用JavaScript来创建，那就麻烦了，容易出错。所以Web组件API提供了<code class="fe mc md me mf b">&lt;template&gt;</code>标签，我们可以在这里定义DOM:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="e8a9" class="mk ml it mf b gy mm mn l mo mp">&lt;body&gt;<br/>  &lt;custom-button&gt;&lt;/custom-button&gt;<br/>  &lt;template id="template"&gt;<br/>    &lt;button class="button"&gt;Click&lt;/button&gt;<br/>  &lt;/template&gt;<br/>&lt;/body&gt;</span><span id="dac7" class="mk ml it mf b gy ms mn l mo mp">&lt;script&gt;<br/>  class CustomButton extends HTMLElement {<br/>    constructor() {<br/>      super();</span><span id="75e6" class="mk ml it mf b gy ms mn l mo mp">      const templateElem = document.getElementById('template');<br/>      const content = templateElem.content.cloneNode(true);<br/>      this.appendChild(content);<br/>    }<br/>  }</span><span id="e41c" class="mk ml it mf b gy ms mn l mo mp">  window.customElements.define('custom-button', CustomButton);<br/>&lt;/script&gt;</span></pre><p id="ddbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe mc md me mf b">document.getElementById</code>得到<code class="fe mc md me mf b">template</code>元素后，我们称之为<code class="fe mc md me mf b">cloneNode</code>。这是因为该模板可能被多个实例使用，因此需要克隆。</p><p id="5739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们来添加样式。我们可以直接在<code class="fe mc md me mf b">template</code>元素中编写样式，这样就不会影响外部样式:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="54fd" class="mk ml it mf b gy mm mn l mo mp">&lt;template id="template"&gt;<br/>  &lt;style&gt;<br/>    button {<br/>      background-color: blue;<br/>      color: #fff;<br/>    }<br/>  &lt;/style&gt;<br/>  &lt;button&gt;Click&lt;/button&gt;<br/>&lt;/template&gt;</span></pre><p id="3c60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么作为一个自定义组件，另外很重要的一点就是可以传递不同的参数来改变不同的状态。您可以像这样传递参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过类中的<code class="fe mc md me mf b">this.getAttribute(key)</code>得到<code class="fe mc md me mf b">key</code>的属性值。让我们来看看DOM结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/148514cd5f4c142cdaf299a58c07f2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nwSErltRUykhydAMddkpQ.png"/></div></div></figure><p id="01bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTML中的<code class="fe mc md me mf b">template</code>是<em class="mu">【丑】</em>，我们用JavaScript中的模板字符串来代替它吧:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mr l"/></div></figure><p id="748f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用<code class="fe mc md me mf b">str2DOM</code>将模板字符串转换成DOM元素，当然你也可以直接使用<code class="fe mc md me mf b">this.innerHTML = template</code>。这里我总结了4种实现<code class="fe mc md me mf b">str2DOM</code>的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="35f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，最重要的一步是封装。查看我们当前的DOM结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/eeff8cf3da8809e114621e936e70fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*UffhM3_upWUR8VOPlxTDCA.png"/></div></figure><p id="8391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将<code class="fe mc md me mf b">style</code>标签添加到最外层，您可以看到我们编写的组件与普通的DOM没有什么不同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/bab846e44fd8e10d66a0550c0832f5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*u20I8OqeFLCSAYxEnGkyYw.png"/></div></figure><p id="dda8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到它起作用了。所以我们需要一种机制来封装web组件— <code class="fe mc md me mf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">Shadow DOM</a></code>:它允许我们编写与其他代码隔离的web组件，这样就不会有冲突。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/e828e9b302c60e25a2d8ff08bfa006eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HhxUSAmKmwkPaB5hRP25qw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank"> MDN </a></figcaption></figure><p id="c6db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样如图所示，从一个阴影根开始，你可以在它下面附加任何元素。最后，将影子主机添加到DOM树。值得一提的是，浏览器中的<code class="fe mc md me mf b">video</code>元素可以看作是一个影子DOM，虽然你在DOM中看到的只是<code class="fe mc md me mf b">video</code>元素，但它包含了一系列按钮和其他控件。</p><p id="2396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的API是:<code class="fe mc md me mf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow" rel="noopener ugc nofollow" target="_blank">Element.attachShadow()</a></code>，我们来补充一下:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="5851" class="mk ml it mf b gy mm mn l mo mp">this.attachShadow({ mode: 'open' });</span><span id="5490" class="mk ml it mf b gy ms mn l mo mp">this.shadowRoot.appendChild(str2DOM(template));<br/>this.shadowRoot.querySelector('button').style.backgroundColor =<br/>this.getAttribute('backgroundColor');</span></pre><p id="6722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe mc md me mf b">mode: 'open'</code>时，我们可以访问实例上的<code class="fe mc md me mf b">shadowRoot</code>。而当<code class="fe mc md me mf b">mode: 'closed'</code>时，我们无法访问实例上的<code class="fe mc md me mf b">shadowRoot</code>:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="41da" class="mk ml it mf b gy mm mn l mo mp">this.attachShadow({ mode: 'closed' });<br/>// null<br/>console.log(this.shadowRoot);</span></pre><p id="17ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着如果访问最外层JavaScript中的实例，<code class="fe mc md me mf b">open</code>的<code class="fe mc md me mf b">mode</code>可以得到<code class="fe mc md me mf b">shadowRoot</code>，而<code class="fe mc md me mf b">closed</code>的<code class="fe mc md me mf b">mode</code>不能得到<code class="fe mc md me mf b">shadowRoot</code>。用<code class="fe mc md me mf b">shadowRoot</code>我们可以修改它的内部:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然当<code class="fe mc md me mf b">mode</code>为<code class="fe mc md me mf b">closed</code>时我们无法获取默认的<code class="fe mc md me mf b">shadowRoot</code>，但是实例上的公共属性是可访问的，也就是说如果你做了:<code class="fe mc md me mf b">this._shadowRoot = this .attachShadow({ mode: 'closed' });</code>，那么外部也可以通过<code class="fe mc md me mf b">this._shadowRoot</code>访问。</p><p id="056b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，如果页面提前注入脚本，改变原来的方法:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="a971" class="mk ml it mf b gy mm mn l mo mp">Element.prototype._attachShadow = Element.prototype.attachShadow;<br/>Element.prototype.attachShadow = function () {<br/>    return this._attachShadow( { mode: "open" } );<br/>};</span></pre><p id="f9d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后就一直“开着”。所以还是很容易破解，完全隐藏它们的努力通常是不值得的。</p><p id="4b9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到此为止，整个组件是完整的，它有很多高级用法，比如<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks" rel="noopener ugc nofollow" target="_blank">生命周期</a>、<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots" rel="noopener ugc nofollow" target="_blank">槽</a>、<code class="fe mc md me mf b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:host" rel="noopener ugc nofollow" target="_blank">:host</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:host" rel="noopener ugc nofollow" target="_blank"> CSS伪类</a>等。查看<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> MDN </a>来更详细地了解API。</p><h1 id="6f9c" class="mz ml it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">结论</h1><p id="e707" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">与DOM的直接操作相比，web组件具有一定的抽象性，并且具有允许我们封装灵活组件的基本能力。但是支持三方扩展库的很少，所以不能广泛使用。但是如果您正在编写轻量级的web应用程序，那么web组件是一个不错的选择。例如，它在<a class="ae ky" href="https://github.com/vitejs/vite" rel="noopener ugc nofollow" target="_blank"> Vite </a>中用于为客户端错误生成<code class="fe mc md me mf b"><a class="ae ky" href="https://github.com/vitejs/vite/blob/main/packages/vite/src/client/overlay.ts" rel="noopener ugc nofollow" target="_blank">ErrorOverlay</a></code>。</p><p id="f698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vue.js的语法参考了一些web组件规范，所以如果你是Vue开发者，可能会比较容易上手。</p><p id="c576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后是浏览器兼容性:</p><div class="nv nw gp gr nx ny"><a href="https://caniuse.com/?search=Web%20Components" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">“Web组件”|我可以使用吗...HTML5、CSS3等的支持表</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">建立和维护DOM树之间的功能边界的方法以及这些树如何相互作用…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">caniuse.com</p></div></div></div></a></div><p id="69d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看到很多浏览器已经开始支持了。期待它变好。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="6102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mu">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="mu">中等会员</em> </a> <em class="mu">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="mu">我的链接</em> </a> <em class="mu">报名，我会得到一点佣金。</em></p><p id="9e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的支持对我来说非常重要——谢谢。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6254" class="mz ml it bd na nb oh nd ne nf oi nh ni jz oj ka nk kc ok kd nm kf ol kg no np bi translated">分级编码</h1><p id="0dab" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="909c" class="om on it lb b lc ld lf lg li oo lm op lq oq lu or os ot ou bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="3e89" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">📰查看<a class="ae ky" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="ce16" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">🔔关注我们:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ky" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="2341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🚀👉<a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>