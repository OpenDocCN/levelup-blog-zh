<html>
<head>
<title>Binary Search with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法与围棋</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/binary-search-with-go-727b1943fd64?source=collection_archive---------7-----------------------#2020-07-25">https://levelup.gitconnected.com/binary-search-with-go-727b1943fd64?source=collection_archive---------7-----------------------#2020-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="1792" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">算法和数据结构</h2><div class=""/><p id="7e6a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">用Go编写高效搜索函数的快速简单指南</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/c25e2b424ae5a64ea0eeccbf29338f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tyh5EfBnl9_Vkkc66tVCeA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">简而言之二分搜索法</figcaption></figure><p id="e043" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">搜索算法被认为是软件工程师多年来的热门趋势之一。这些算法从计算机时代开始就已经被讨论过了，它们是计算机科学的基础。在这篇文章中，我试图描述一个最有效和最简单的搜索算法，<em class="lk">，</em>，并展示我们如何在不到5分钟的时间内制作自己的版本。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="16a0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">算法复杂性</h1><p id="cd57" class="pw-post-body-paragraph jw jx iq jy b jz mq kb kc kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt ij bi translated">在我开始描述算法之前，有必要熟悉一下<em class="lk">算法复杂度</em>的概念。变得<em class="lk">快</em>和<em class="lk">高效</em>大概是学习算法的主要目的。<em class="lk">算法复杂度</em>是描述一个算法如何针对不同的输入集执行的度量，如<a class="ae mv" href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Algorithmic%20Complexity/complexity.html" rel="noopener ugc nofollow" target="_blank">卡内基梅隆大学</a> : <strong class="jy ja"> <em class="lk">算法复杂度关注的是特定算法执行</em> </strong> <em class="lk">的快慢。</em></p><p id="1fe6" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">算法的复杂性可以用不同的符号来表示，但最常用的是<em class="lk">大O，</em>，它描述了算法在最差输入下的性能。换句话说，如果一个算法面对最差的可能输入集，它不会花费比<em class="lk">大O </em>步更长的时间来完成。由于性能取决于输入，因此用<strong class="jy ja"><em class="lk">O(n)</em></strong>表示，其中<em class="lk"> n </em>是输入大小。</p><p id="3737" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">话虽如此，算法按性能分为不同的类别:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi mw"><img src="../Images/a7d6e5eee9b92aa157b9f3de68abc59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pgf2YjoOQasfV7efIDLjmA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated"><a class="ae mv" href="https://www.freecodecamp.org/news/my-first-foray-into-technology-c5b6e83fe8f1/" rel="noopener ugc nofollow" target="_blank">freecodecamp.org</a></figcaption></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="59a5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">什么是二分搜索法</h1><p id="5d4c" class="pw-post-body-paragraph jw jx iq jy b jz mq kb kc kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt ij bi translated"><em class="lk">二分搜索法</em>是最有效的搜索实现之一，它处理一系列<strong class="jy ja">排序的整数。</strong> It <strong class="jy ja"> </strong>具有<strong class="jy ja"> <em class="lk"> O(n log n) </em> </strong>的复杂度，这在处理大型数据集时是很牛逼的，然而，它只有在数据事先排序的情况下才起作用。由于算法的性质，它也只对整数列表有效。</p><h2 id="2f14" class="mx lt iq bd lu my mz dn ly na nb dp mc kh nc nd mg kl ne nf mk kp ng nh mo iw bi translated">递归算法</h2><p id="6fda" class="pw-post-body-paragraph jw jx iq jy b jz mq kb kc kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt ij bi translated"><em class="lk">二分搜索法</em>是使用<em class="lk">递归</em>方法实现的，其中搜索函数是自己调用的。编写递归算法并不总是容易的，但它肯定不是一项可怕的任务。你需要记住的唯一一点是关于<em class="lk">基本情况</em>，它使算法在某一点停止，否则，函数将永远继续。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/21141c5c70b19667f09ec9ff03516773.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*HHFoWOqni4f8O7k17mNvTA.jpeg"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">递归算法</figcaption></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="b572" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">代码时间</h1><p id="8e99" class="pw-post-body-paragraph jw jx iq jy b jz mq kb kc kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt ij bi translated">现在，是时候写下你的二分搜索法了。虽然在这篇文章中我用的是Go，但是你可以得到这个想法，然后用你喜欢的语言写出来。此外，GitHub上有大量可用的实现，您可以从中受益。</p><p id="e3e5" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">让我们首先定义一个接受输入数组、目标数以及给定数组的第一个和最后一个索引的函数。它返回一个布尔值，该值指示是否找到了目标数字及其索引。如果没有找到该号码，则返回<em class="lk">假，-1 </em></p><pre class="kv kw kx ky gt nj nk nl nm aw nn bi"><span id="376b" class="mx lt iq nk b gy no np l nq nr">func search(number int, arr []int, start, end int) (bool, int) {}</span></pre><p id="80c8" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们首先编写第一个检查案例，根据给定的索引检查给定的数组是否有效</p><pre class="kv kw kx ky gt nj nk nl nm aw nn bi"><span id="6fee" class="mx lt iq nk b gy no np l nq nr">if end &lt; 0 || start &lt; 0 {<br/>  return false, -1<br/>}</span></pre><p id="ba0f" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">如果索引是好的，我们继续检查数组本身是否是有效的输入。如果数组只有一个元素，我们只需检查这个元素是否是我们要找的。<strong class="jy ja">这是<em class="lk">基础案例</em>，它永远阻止函数被调用。</strong></p><pre class="kv kw kx ky gt nj nk nl nm aw nn bi"><span id="d5bf" class="mx lt iq nk b gy no np l nq nr">if end — start == 0 {<br/>   if number == arr[end] { <br/>        return true, end <br/>   }<br/>   return false, -1<br/>}</span></pre><p id="5d83" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">如果上面的检查都不正确，我们必须开始搜索输入。关键是，因为输入数组已经排序，所以可以通过一种简单而巧妙的方法找到目标数字。</p><p id="b33f" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在这种方法中，我们首先从找到输入的中间开始，并将其命名为<em class="lk"> pivot </em>。其次，我们检查目标数字是等于、大于还是小于中枢。pivot将输入数组分成2个子数组，左边的数组包含所有小于pivot的输入，右边的数组是所有大于pivot的输入的子数组。</p><p id="f996" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">现在，我们必须简单地做以下检查。</p><ul class=""><li id="0196" class="ns nt iq jy b jz ka kd ke kh nu kl nv kp nw kt nx ny nz oa bi translated">如果目标数<strong class="jy ja">等于</strong>枢轴；只需返回<em class="lk">真</em></li><li id="318c" class="ns nt iq jy b jz ob kd oc kh od kl oe kp of kt nx ny nz oa bi translated">如果目标数比支点大<strong class="jy ja">或</strong>;则开始在右子阵列中搜索</li><li id="9cbe" class="ns nt iq jy b jz ob kd oc kh od kl oe kp of kt nx ny nz oa bi translated">如果目标数比枢轴数小<strong class="jy ja">;则开始在左侧子阵列中搜索</strong></li></ul><pre class="kv kw kx ky gt nj nk nl nm aw nn bi"><span id="8c08" class="mx lt iq nk b gy no np l nq nr">pivot := (end + start) / 2<br/>if number == arr[pivot] {<br/>   return true, pivot<br/>} else if number &gt; arr[middle] {<br/>   return search(number, arr, pivot+1, end)<br/>}<br/>return search(number, arr, start, pivot)</span></pre><h2 id="df08" class="mx lt iq bd lu my mz dn ly na nb dp mc kh nc nd mg kl ne nf mk kp ng nh mo iw bi translated">一个例子</h2><p id="79d6" class="pw-post-body-paragraph jw jx iq jy b jz mq kb kc kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt ij bi translated">现在让我们看看下面的例子中的<a class="ae mv" href="https://brilliant.org/wiki/binary-search/" rel="noopener ugc nofollow" target="_blank">，我们被要求在给定的数组中找到47。</a></p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi og"><img src="../Images/f8b93120f01fd983fbed0e41982f69b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fQBx0_j354hJSIkmsACUYw.gif"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">它是如何工作的</figcaption></figure><h2 id="e638" class="mx lt iq bd lu my mz dn ly na nb dp mc kh nc nd mg kl ne nf mk kp ng nh mo iw bi translated">最终代码</h2><p id="f441" class="pw-post-body-paragraph jw jx iq jy b jz mq kb kc kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt ij bi translated">最终代码如下所示</p><pre class="kv kw kx ky gt nj nk nl nm aw nn bi"><span id="4e89" class="mx lt iq nk b gy no np l nq nr">func search(number int, arr []int, start, end int) (bool, int) {<br/>   if end &lt; 0 || start &lt; 0 {<br/>     return false, -1<br/>   } if end — start == 0 {<br/>      if number == arr[end] { <br/>           return true, end <br/>      }<br/>      return false, -1<br/>   }</span><span id="dfd3" class="mx lt iq nk b gy oh np l nq nr">   pivot := (end + start) / 2<br/>   if number == arr[pivot] {<br/>      return true, pivot<br/>   } else if number &gt; arr[pivot] {<br/>      return search(number, arr, pivot+1, end)<br/>   }<br/>   return search(number, arr, start, pivot)<br/>}</span></pre></div></div>    
</body>
</html>