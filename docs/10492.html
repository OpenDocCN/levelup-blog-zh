<html>
<head>
<title>How to Implement OpenTelemetry and Propagate Trace Among Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现OpenTelemetry并在微服务间传播轨迹</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-implement-opentelemetry-and-propagate-trace-among-microservices-dfa1a1a14865?source=collection_archive---------7-----------------------#2021-12-14">https://levelup.gitconnected.com/how-to-implement-opentelemetry-and-propagate-trace-among-microservices-dfa1a1a14865?source=collection_archive---------7-----------------------#2021-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7f1a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用GoLang和微服务做基本的OpenTelemetry</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e0affeaf9fd60f8930a6276619d2543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Luoqdd5wmNu6EAf8j0lx4g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">OpenTelemetry和Go微服务</figcaption></figure><p id="ea7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原生云成为设计和开发应用程序的事实标准。根据<strong class="la iu"> CNCF的说法，</strong> cloud-native被定义为在“现代动态环境”中运行的“可扩展应用程序”，这些应用程序使用了诸如<em class="lu">容器、微服务和声明式API等技术。</em></p><p id="4f8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当遵循上述设计时，您倾向于将您的应用程序划分为多个微服务。通过遵循<em class="lu">单一责任原则，</em>每个微服务将只有一个责任。这些微服务中的每一个最终都会自己变成一个容器。这很棒，因为你可以根据需求增加每个微服务的实例数量；例如，如果您需要购物应用程序中更多的<em class="lu">结账服务</em>实例来处理需求/负载，您可以在不影响其他微服务的情况下这样做。这可以再次缩减以将资源归还给池。即CPU、存储器。</p><p id="f56f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但问题是。作为一名开发人员，如果应用程序是单一的，您可以有意地将请求流从一个模块指向另一个模块。但是在动态伸缩的微服务的情况下，我们如何确定哪些请求由哪些服务呢？</p><p id="0780" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是<strong class="la iu"><em class="lu">open telemetry</em></strong>发挥作用的地方。另一个<em class="lu"> CNCF </em>孵化项目(2021年12月撰写本文时的孵化状态)用于<em class="lu">仪器化、生成、收集和输出</em>遥测数据，即。、指标、日志和跟踪，帮助分析微服务架构。</p><p id="edf6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> OpenTelemetry </em>简称为<em class="lu"> otel </em>，是一个工具、API和SDK的集合，通过您选择的编程语言实现的微服务来执行上述任务。</p><blockquote class="lv lw lx"><p id="e6f2" class="ky kz lu la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated"><em class="it"> OpenTelemetry </em>拥有几乎所有语言的SDK。在本文中，我们将使用GoLang编程语言。尽管所有语言的实现方面几乎是相同的。</p></blockquote><p id="3860" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始创建微服务，并集成<em class="lu"> OpenTelemetry </em>以从中提取度量数据。</p><h1 id="530d" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">简单Web服务器</h1><p id="0a62" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在任何语言中，Web服务器都是相对容易建立和运行的。即使在围棋中，也没有什么不同。使用<code class="fe my mz na nb b">net/http</code>包，创建一个如下所示的包非常简单。但在此之前，让我们创建一个目录，并使用命令<code class="fe my mz na nb b">go mod init &lt;mod_name&gt;.</code>在其中初始化一个模块</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在Go中建立一个简单的web服务器</figcaption></figure><p id="67f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过运行上面的代码，您应该已经启动了简单的web服务器并监听端口号8080。点击浏览器中的URL <code class="fe my mz na nb b">http://localhost:8080/ping</code>,确保它的运行没有任何问题。您应该会看到来自服务器的响应文本<code class="fe my mz na nb b">pong</code>。</p><p id="f790" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们添加<em class="lu"> OpenTelemetry </em>的依赖项。由于Go使用模块作为管理依赖项的方式，让我们使用<code class="fe my mz na nb b">go get</code>命令将OpenTelemetry模块添加到项目中，如下所示。</p><pre class="kj kk kl km gt ne nb nf ng aw nh bi"><span id="c6e9" class="ni mc it nb b gy nj nk l nl nm">go get go.opentelemetry.io/otel/sdk/trace</span><span id="600d" class="ni mc it nb b gy nn nk l nl nm">go get go.opentelemetry.io/otel/exporters/stdout/stdouttrace</span><span id="c703" class="ni mc it nb b gy nn nk l nl nm">go get go.opentelemetry.io/otel/propagation</span><span id="e0ed" class="ni mc it nb b gy nn nk l nl nm">go get go.opentelemetry.io/otel/semconv</span></pre><p id="558c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">逐一查看我们添加到项目中的模块</p><ul class=""><li id="14a1" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><code class="fe my mz na nb b">trace</code>包包含对OpenTelemetry分布式跟踪的支持。</li><li id="185d" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe my mz na nb b">stdout</code>包包含一个OpenTelemetry导出器，用于跟踪要作为JSON写入输出目的地的遥测。仅为了本文/演示的目的，我们正在写入一个JSON文件。在现实世界中，数据被导出到Jager、Prometheus、Zipkin等工具中。</li><li id="15ff" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe my mz na nb b">propagation</code>包包含OpenTelemetry上下文传播器。这些传播器非常重要，因为这些传播器用于从应用程序交换的消息中注入和提取上下文数据。这就是OpenTelemetry如何支持任何数量的不同编程语言，用于为单个应用实现各种微服务。</li><li id="39ba" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe my mz na nb b">semconv</code>包实现OpenTelemetry语义约定。</li></ul><h1 id="95b3" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">创建追踪器</h1><p id="1cb5" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">现在我们已经将相关模块添加到项目中，让我们创建一个<em class="lu">跟踪程序。</em>要创建一个跟踪器，您需要为服务命名。姑且称之为<em class="lu"> service-1。</em>跟踪创建方法非常标准，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">创建导出器并向tracer注册</figcaption></figure><p id="c23e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码片段中，我们创建了一个导出器作为<em class="lu">标准输出</em>导出器和一个注册导出器的跟踪提供者。</p><p id="d3bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们使用<em class="lu"> trace </em>包中的函数<code class="fe my mz na nb b">WithResource</code>来配置额外的资源属性，比如这个代码片段中的模式URL和服务名。</p><p id="4e4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使导出器是附加到跟踪器上创建的，微服务仍然不能发出跟踪数据。这需要附加到web服务器的主要功能，只要web服务器在运行，就应该继续运行。因此，让我们稍微修改一下运行简单web服务器的主函数。</p><p id="dfc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们调用主函数中的<code class="fe my mz na nb b">initTracer</code>函数，并将返回的<code class="fe my mz na nb b">traceProvider</code>赋值给一个变量，如下所示:<code class="fe my mz na nb b">tp := initTracer()</code>。现在，追踪器必须拦截所有传入web服务器的请求，以便能够提取和/或注入遥测数据。因为对于服务器将要公开的所有端点来说，情况都是一样的，所以我们将创建<code class="fe my mz na nb b">otel handler</code>作为一个单独的函数。就像下面的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">打开遥测HTTP处理程序来拦截请求</figcaption></figure><p id="57b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们有了一个新的<code class="fe my mz na nb b">httphandler</code>，现在让我们将它添加到主函数中，并通过新的处理程序公开<code class="fe my mz na nb b">ping</code>端点。修改后的主函数如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">端点通过otel的HTTP处理程序来处理</figcaption></figure><p id="660d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了上面的设置，如果我们执行这个并点击URL <code class="fe my mz na nb b">http://localhost:8080/ping</code>，我们将得到类似下面的输出。这将加载所有细节，如<code class="fe my mz na nb b">TraceID, SpanID</code>等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/4c83336e8b1b790a35b793411c4a2f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5REkdNcN_Uen5sxLbbWHHw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">显示轨迹的终端输出</figcaption></figure><p id="50a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们给这个web服务器增加一点功能。让我们列出Kubernetes集群中部署的所有单元。为了与K8s集群交互，我们将使用<a class="ae od" href="https://pkg.go.dev/github.com/gkarthiks/k8s-discovery" rel="noopener ugc nofollow" target="_blank"> k8s-discovery </a>包。我已经在下面的帖子中解释了<em class="lu">为什么以及如何</em>使用这个包，请参考它以获得更多的细节。</p><div class="oe of gp gr og oh"><a href="https://medium.com/swlh/clientset-module-for-in-cluster-and-out-cluster-3f0d80af79ed" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">集群内和集群外的客户端集模块</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">大多数时候，当我们基于Kubernetes编写云原生GoLang代码时，我们最终会做一些事情…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div><p id="2f09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们使用<code class="fe my mz na nb b">go get</code>命令作为<code class="fe my mz na nb b">go get github.com/gkarthiks/k8s-discovery</code>将这个模块添加到项目中。在添加了pod清单函数并附加了端点之后，主文件将如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">所有补丁后的主函数文件</figcaption></figure><p id="a4d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行上述代码并点击URL <code class="fe my mz na nb b">http://localhost:8080/pods</code>后，将会给出与之前类似的跟踪数据，但名称为“list pods ”,作为<em class="lu">操作字符串</em>传递，当然会列出在本地<code class="fe my mz na nb b">kubeconfig</code>文件中配置的集群中运行的pods。</p><h1 id="c005" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">让我们创建一个子服务</h1><p id="2bf9" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">到目前为止，我们已经在单个服务中配置和创建了OpenTelemtry跟踪器。要看到跟踪程序遍历微服务和/或应用程序，我们至少还需要一个微服务。让我们为上面创建的service-1创建一个名为<code class="fe my mz na nb b">service-2</code>的父服务。</p><p id="ab09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将复制service-1中的所有内容，并将<code class="fe my mz na nb b">ServiceNameKey</code>更改为<code class="fe my mz na nb b">service-2</code>，并将监听端口更改为8091。对于<em class="lu"> service-1，</em>中的<code class="fe my mz na nb b">listPods</code>方法，让我们也稍微改变一下。我们不会点击Kubernetes集群来列出pod，而是要求<code class="fe my mz na nb b">service-2</code>列出pod。这意味着<code class="fe my mz na nb b">service-2</code>的反应有了变化。因此完成后的新<code class="fe my mz na nb b">service-2</code>文件将如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">儿童服务:服务-2</figcaption></figure><p id="9927" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们的父服务中的<code class="fe my mz na nb b">listPods</code>函数需要被修改以调用这个新服务的端点，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">修改了父服务中的<code class="fe my mz na nb b">listPods</code>函数</figcaption></figure><p id="0c45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本地运行这些服务时，首先启动service-2，然后启动service-1，并在本地配置Kubernetes集群。命中以下端点:<code class="fe my mz na nb b">http://localhost:8091/pods</code>。这将在浏览器中显示窗格列表。但是，如果您仔细观察终端中两个服务正在写入的跟踪数据，您将观察到父服务的<em class="lu"> TraceID </em>被传播到子服务的跟踪数据，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/186c85bce23c84a0c6503b00a1facfc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ll-ccRfZy-2b27XC81Y0Bw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">父服务的TraceID从服务1传播到服务2的子服务</figcaption></figure><p id="9ebd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个完整的示例项目可以在我的GitHub repo中找到，供您查看和学习。</p><div class="oe of gp gr og oh"><a href="https://github.com/gkarthiks/otel-demo-svc-1" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">GitHub-gkarthiks/otel-demo-SVC-1:开放式遥测演示服务1</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="ox l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="https://github.com/gkarthiks/otel-demo-svc-2" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">GitHub-gkarthiks/otel-demo-SVC-2:开放式遥测演示服务2</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="oy l os ot ou oq ov ks oh"/></div></div></a></div><p id="b366" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们通过OpenTelemetry为我们的微服务实现了分布式跟踪。在生产环境中，您将使用标准的OpenTelemetry导出器，这里的<a class="ae od" href="https://github.com/open-telemetry/opentelemetry-go/tree/main/exporters/" rel="noopener ugc nofollow" target="_blank">是可用的</a>。</p></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="c0da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章，请通过拍手帮助其他人找到它，并在这里和Twitter上关注我以获取更多更新。</p><h1 id="8db2" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">参考资料:</h1><ul class=""><li id="7af2" class="no np it la b lb mt le mu lh pg ll ph lp pi lt nt nu nv nw bi translated"><a class="ae od" href="https://opentelemetry.io/docs/" rel="noopener ugc nofollow" target="_blank">打开遥测文档</a></li><li id="cfda" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae od" href="https://pkg.go.dev/github.com/gkarthiks/k8s-discovery" rel="noopener ugc nofollow" target="_blank"> K8s发现</a></li></ul></div></div>    
</body>
</html>