<html>
<head>
<title>Interface segregation principle in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的接口分离原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/interface-segregation-principle-in-java-44f1c1a4eacd?source=collection_archive---------6-----------------------#2020-10-26">https://levelup.gitconnected.com/interface-segregation-principle-in-java-44f1c1a4eacd?source=collection_archive---------6-----------------------#2020-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a72a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">权威指南</h2><div class=""/><div class=""><h2 id="fe33" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">开发java时理解SOLID原理非常重要，因为…</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/70c4dd87c461bf8fab45a81fefce1104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0bxo4Al8SNkpKjEq"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@merlenegoulet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Merlene Goulet </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="8832" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">界面分离原理</h1><p id="fb87" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">接口在Java编程语言中起着重要的作用，它们被广泛用于抽象和支持多重继承。</p><p id="1c66" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">接口是通过使用关键字<strong class="mc jd">和接口</strong>在其中声明方法来实现的。类可以用<strong class="mc jd"> implements </strong>关键字实现接口，然后为声明的方法提供实现。编写接口时要记住的设计原则之一是接口分离原则。</p><p id="4c7d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在接口分离原则中，接口不应该有实现类不需要的方法。实现类毫无理由地被迫为那些它不需要的方法提供实现。向接口添加方法或更改方法签名需要更改该接口中实现的所有类。</p><p id="f5bf" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">接口分离原则建议将一个接口分离成更小的和<a class="ae lh" href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" rel="noopener ugc nofollow" target="_blank">高度内聚的</a>接口，称为“角色接口”,每个“角色接口”为特定的行为声明一个或多个方法。因此，客户端不是实现接口，而是只实现那些方法相关的“角色接口”。</p><h1 id="fa71" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">坏榜样</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nb"><img src="../Images/eb0f7f78fa421a044249c4a52e052d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8oLrWJuHLUZ1rdpY"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@mlivio800?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">毛里西奥·里维奥</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7ce9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">考虑构建不同类型运输工具的应用程序的需求。每辆车都有价格和颜色。车辆如<strong class="mc jd">汽车</strong>可以启动和停止移动，而有些车辆如<strong class="mc jd">飞机</strong>既可以移动又可以飞行。示例界面</p><h2 id="6d4a" class="nc lj it bd lk nd ne dn lo nf ng dp ls mj nh ni lu mn nj nk lw mr nl nm ly iz bi translated">Vehicle.java</h2><pre class="ks kt ku kv gt nn no np nq aw nr bi"><span id="0b18" class="nc lj it no b gy ns nt l nu nv">public interface Vehicle {<br/>    void setPrice(double price);<br/>    void setColor(String color);<br/>    void start();<br/>    void stop();<br/>    void fly();<br/>}</span></pre><p id="3ed0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">表示飞机的类可以实现车辆接口，并提供所有接口方法的实现。但是，想象一个代表汽车的类。这就是汽车类的外观。</p><h2 id="f8e7" class="nc lj it bd lk nd ne dn lo nf ng dp ls mj nh ni lu mn nj nk lw mr nl nm ly iz bi translated">Car.java</h2><pre class="ks kt ku kv gt nn no np nq aw nr bi"><span id="0179" class="nc lj it no b gy ns nt l nu nv">public class Car implements Vehicle {<br/>    double price;<br/>    String color;<br/>    @Override<br/>    public void setPrice(double price) {<br/>        this.price = price;<br/>    }<br/>    @Override<br/>    public void setColor(String color) {<br/>        this.color=color;<br/>    }<br/>    @Override<br/>    public void start(){}<br/>    @Override<br/>    public void stop(){}<br/>    @Override<br/>    public void fly(){}    <br/>}</span></pre><p id="1945" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">正如你在代码中看到的，Car需要提供一个实现<strong class="mc jd"> fly </strong>()的方法，尽管它并不需要它们。这违反了接口隔离原则。这些可能会影响代码的可读性</p><h1 id="caa7" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">好榜样</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/4840dc93d90905d32cc058b28feadf4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D0d4umWc7qCr_1Et"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">保罗·基亚布兰多在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a581" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">遵循接口分离原则，我们可以解决车辆接口的问题，解决方案是- <em class="nx">将车辆接口分离成多个角色接口，每个接口用于特定的行为</em>。在这种情况下，车辆接口可以分为三个接口:玩具，移动，和飞行。</p><h2 id="180c" class="nc lj it bd lk nd ne dn lo nf ng dp ls mj nh ni lu mn nj nk lw mr nl nm ly iz bi translated">Vehicle.java</h2><pre class="ks kt ku kv gt nn no np nq aw nr bi"><span id="ea05" class="nc lj it no b gy ns nt l nu nv">public interface Vehicle {<br/>     void setPrice(double price);<br/>     void setColor(String color);<br/>}</span></pre><h2 id="6241" class="nc lj it bd lk nd ne dn lo nf ng dp ls mj nh ni lu mn nj nk lw mr nl nm ly iz bi translated">Movable.java</h2><pre class="ks kt ku kv gt nn no np nq aw nr bi"><span id="c52f" class="nc lj it no b gy ns nt l nu nv">public interface Movable {<br/>    void start();<br/>    void stop();<br/>}</span></pre><h2 id="b6ba" class="nc lj it bd lk nd ne dn lo nf ng dp ls mj nh ni lu mn nj nk lw mr nl nm ly iz bi translated">Flyable.java</h2><pre class="ks kt ku kv gt nn no np nq aw nr bi"><span id="d39a" class="nc lj it no b gy ns nt l nu nv">public interface Flyable {<br/>    void fly();<br/>}</span></pre><p id="e0b4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在Vehicle与<strong class="mc jd"> setPrice </strong>()和<strong class="mc jd"> setColor </strong>()方法接口，因为所有的Vehicle都有价格和颜色，所以所有的Vehicle实现类都可以实现这个接口。然后，可移动和可飞行的界面来表示车辆中的移动和飞行行为。</p><h1 id="2e4e" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">履行</h1><h2 id="4ac2" class="nc lj it bd lk nd ne dn lo nf ng dp ls mj nh ni lu mn nj nk lw mr nl nm ly iz bi translated">Car.java</h2><pre class="ks kt ku kv gt nn no np nq aw nr bi"><span id="8c89" class="nc lj it no b gy ns nt l nu nv">public class Car implements Vehicle, Movable {<br/>    double price;<br/>    String color;<br/>​<br/>    @Override<br/>    public void setPrice(double price) {<br/>​<br/>        this.price = price;<br/>    }<br/>    @Override<br/>    public void setColor(String color) {<br/>​<br/>        this.color=color;<br/>    }<br/>    @Override<br/>    public void start(){<br/>        // Implementation<br/>    }<br/>    @Override<br/>    public void stop(){<br/>        // Implementation<br/>    }<br/>}</span></pre><h2 id="becc" class="nc lj it bd lk nd ne dn lo nf ng dp ls mj nh ni lu mn nj nk lw mr nl nm ly iz bi translated">Aeroplane.java</h2><pre class="ks kt ku kv gt nn no np nq aw nr bi"><span id="bc37" class="nc lj it no b gy ns nt l nu nv">public class Aeroplane implements Vehicle, Movable, Flyable {<br/>    double price;<br/>    String color;<br/>​<br/>    @Override<br/>    public void setPrice(double price) {<br/>​<br/>        this.price = price;<br/>    }<br/>​<br/>    @Override<br/>    public void setColor(String color) {<br/>     this.color=color;<br/>    }<br/>    @Override<br/>    public void start(){<br/>        // Implementation<br/>    }<br/>    @Override<br/>    public void stop(){<br/>        // Implementation<br/>    }<br/>    @Override<br/>    public void fly(){<br/>        // Implementation<br/>    }<br/>}</span></pre><p id="7398" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在实现类实现了他们感兴趣的接口，这有助于删除不必要的代码，可读性更好</p><p id="c0cf" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">接下来，让我们编写一个类来创建实现类的对象。</p><h2 id="944a" class="nc lj it bd lk nd ne dn lo nf ng dp ls mj nh ni lu mn nj nk lw mr nl nm ly iz bi translated">VehicleBuilder.java</h2><pre class="ks kt ku kv gt nn no np nq aw nr bi"><span id="ac74" class="nc lj it no b gy ns nt l nu nv">public class VehicleBuilder {<br/>    public static Car buildCar(){<br/>        ToyHouse toyHouse=new ToyHouse();<br/>        Car car = new Car();<br/>        car.setPrice(15.00);<br/>        car.setColor("green");<br/>        car.start();<br/>        return car;<br/>        }<br/>    public static Aeroplane buildAeroPlane(){<br/>        Aeroplane aeroplane = new Aeroplane();<br/>        aeroplane.setPrice(25.00);<br/>        aeroplane.setColor("red");<br/>        aeroplane.start();<br/>        aeroplane.fly();<br/>        return aeroplane;<br/>    }<br/>}</span></pre><h1 id="529b" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">总结(界面分离原则)</h1><p id="ab38" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">接口分离原则确保了小的、集中的和高度内聚的软件组件。界面分离原理易于理解和简单遵循。但是，识别不同的接口对于获得正确的角色分离来说是一个挑战。接口分离原则是开发Java应用程序时需要掌握的一个非常强大的概念。</p><p id="b0c1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果你喜欢这个概念并理解了这个故事，你可能会喜欢<a class="ae lh" href="https://medium.com/dev-genius/the-command-pattern-in-java-8a545a56d68a" rel="noopener"> <strong class="mc jd">命令模式</strong> </a> <strong class="mc jd"> </strong>，这是我过去写的另一个行为设计模式，是GoF正式设计模式列表的一部分。该模式旨在将执行给定动作(命令)所需的所有数据封装在一个对象中</p></div></div>    
</body>
</html>