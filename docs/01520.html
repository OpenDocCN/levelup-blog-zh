<html>
<head>
<title>Basic Usage of RxJS Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS运算符的基本用法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/basic-usage-of-rxjs-operators-b5fdd9feea1d?source=collection_archive---------4-----------------------#2020-01-09">https://levelup.gitconnected.com/basic-usage-of-rxjs-operators-b5fdd9feea1d?source=collection_archive---------4-----------------------#2020-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c27b326b7a02bf9b4379dd8f0bb106a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jL8uLHXa3iEoYZcq"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科学高清照片</a>上<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="13a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了运营商，我们可以做更多的RxJS可观。它们对于用异步代码进行复杂的操作很有用。</p><p id="45d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运算符是函数。有两种类型的运算符:</p><ul class=""><li id="b644" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">可管道化操作符——可以使用Observables中可用的<code class="fe ln lo lp lq b">pipe</code>方法将它们管道化到Observables。它们返回一个新的可观察对象，因此多个可管道化的操作符可以链接在一起</li><li id="d6d5" class="le lf it ki b kj lr kn ls kr lt kv lu kz lv ld lj lk ll lm bi translated">创建操作符——这些是创建新的可观察对象的独立函数。比如<code class="fe ln lo lp lq b">of(1,2,3)</code>会发出1，2，3。</li></ul><h1 id="ec43" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">使用运算符</h1><p id="dd75" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我们可以从RxJS导入操作符来操纵我们的可观察结果。</p><p id="4336" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用<code class="fe ln lo lp lq b">map</code>函数将观察值映射到另一个观察值:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="d41f" class="nh lx it lq b gy ni nj l nk nl">import { of } from "rxjs";<br/>import { map } from "rxjs/operators";</span><span id="7d97" class="nh lx it lq b gy nm nj l nk nl">map(x =&gt; x * 2)(of(1, 2, 3)).subscribe(val =&gt; console.log(val));</span></pre><p id="50a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe ln lo lp lq b">of</code>函数创建了一个发出1、2和3的可观察对象，然后用回调函数调用<code class="fe ln lo lp lq b">map</code>，让我们映射这些值，回调函数返回一个函数，我们可以传入我们创建的可观察对象，并返回一个新的可观察对象。</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="e996" class="nh lx it lq b gy ni nj l nk nl">map(x =&gt; x * 2)(of(1, 2, 3))</span></pre><p id="9769" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回一个我们可以订阅的新的可观察值。然后我们在<code class="fe ln lo lp lq b">subscribe</code>的回调函数中得到值2、4和6。</p><h1 id="f146" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">平静的</h1><p id="1c64" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我们可以使用Observable的<code class="fe ln lo lp lq b">pipe</code>方法将多个操作组合成一个。</p><p id="a405" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它以多个操作作为参数，这比嵌套它们要干净得多。</p><p id="4129" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以用它来重写上面的例子:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="6a24" class="nh lx it lq b gy ni nj l nk nl">import { of, pipe } from "rxjs";<br/>import { map } from "rxjs/operators";</span><span id="12e2" class="nh lx it lq b gy nm nj l nk nl">of(1, 2, 3)<br/>  .pipe(map(x =&gt; x * 2))<br/>  .subscribe(val =&gt; console.log(val));</span></pre><p id="0190" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到相同的结果，但它要干净得多。</p><p id="77bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以向<code class="fe ln lo lp lq b">pipe</code>方法传递多个操作:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="f85c" class="nh lx it lq b gy ni nj l nk nl">of(1, 2, 3)<br/>  .pipe(<br/>    map(x =&gt; x * 2),<br/>    map(x =&gt; x * 3)<br/>  )<br/>  .subscribe(val =&gt; console.log(val));</span></pre><p id="461c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们首先将可观察对象发出的每个值乘以2，然后将返回值再次乘以3。结果，我们在<code class="fe ln lo lp lq b">console.log</code>中得到6、12和18。</p><h1 id="5423" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">创建运算符</h1><p id="c05a" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">创建操作符是从零开始或通过将其他可观察对象连接在一起来创建可观察对象的函数。</p><p id="4934" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们让<code class="fe ln lo lp lq b">interval</code>函数在我们指定的时间间隔内发出一个从0开始的值:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="f2e7" class="nh lx it lq b gy ni nj l nk nl">import { interval } from "rxjs";</span><span id="7075" class="nh lx it lq b gy nm nj l nk nl">interval(5000).subscribe(val =&gt; console.log(val));</span></pre><p id="eef5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码将每5秒输出一个从0开始的整数。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/a1c41d836fa13d1676a8cbe368d1dee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y4lb6bIb_WOijmNK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科学高清照片</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</figcaption></figure><h1 id="09e9" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">高阶可观测量</h1><p id="3a8e" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">高阶可观测量是可观测量中的可观测量。我们可以用不同的观测值做一些事情。</p><p id="7bf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RxJS有一个<code class="fe ln lo lp lq b">concatAll()</code>操作符，它订阅每个内部可观察对象，并复制所有发出的值，直到外部可观察对象完成。</p><p id="0af6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="959f" class="nh lx it lq b gy ni nj l nk nl">import { of, pipe } from "rxjs";<br/>import { concatAll, map } from "rxjs/operators";</span><span id="2ca0" class="nh lx it lq b gy nm nj l nk nl">of(1, 2, 3)<br/>  .pipe(<br/>    map(outerVal =&gt; {<br/>      console.log(`outerVal ${outerVal}`);<br/>      return of(4, 5, 6);<br/>    }),<br/>    concatAll()<br/>  )<br/>  .subscribe(innerVal =&gt; console.log(`innerVal ${innerVal}`));</span></pre><p id="8330" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该得到输出:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="ee18" class="nh lx it lq b gy ni nj l nk nl">outerVal 1<br/>innerVal 4<br/>innerVal 5<br/>innerVal 6<br/>outerVal 2<br/>innerVal 4<br/>innerVal 5<br/>innerVal 6<br/>outerVal 3<br/>innerVal 4<br/>innerVal 5<br/>innerVal 6</span></pre><p id="5c18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，我们首先从<code class="fe ln lo lp lq b">of(1,2,3)</code>可观测值中获得第一个值，然后从第二个值中获得所有值。然后我们从<code class="fe ln lo lp lq b">of(1,2,3)</code>得到第二个值，然后从第二个得到所有的值，依此类推。</p><p id="00e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他操作员功能包括:</p><ul class=""><li id="cd5b" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><code class="fe ln lo lp lq b">mergeAll()</code> —订阅到达的每个内部可观察值，并在到达时发出每个值。</li><li id="c7e0" class="le lf it ki b kj lr kn ls kr lt kv lu kz lv ld lj lk ll lm bi translated"><code class="fe ln lo lp lq b">switchAll()</code> —在第一个内部可观察值到达时订阅它，然后在它到达时发出每个值。它取消订阅前一个，然后订阅新的。</li><li id="4e29" class="le lf it ki b kj lr kn ls kr lt kv lu kz lv ld lj lk ll lm bi translated"><code class="fe ln lo lp lq b">exhaust()</code> —在第一个内部可观察对象到达时订阅它，然后在它到达时发出每个值，在它完成时丢弃所有新到达的可观察对象，并等待下一个内部可观察对象。</li></ul><p id="e826" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都给出了与<code class="fe ln lo lp lq b">concatAll()</code>相同的结果，但区别就在下面。</p><p id="3ee1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过组合多个观察值或运算符来创建新的观察值。</p><p id="ecbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="1724" class="nh lx it lq b gy ni nj l nk nl">of(1, 2, 3)<br/>  .pipe(<br/>    map(x =&gt; x * 2),<br/>    map(x =&gt; x * 3)<br/>  )</span></pre><p id="d410" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是一个可观察值，将可观察值<code class="fe ln lo lp lq b">of(1, 2, 3)</code>的每个值乘以6。</p><p id="2618" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于RxJS，我们可以使用内置的运算符来创建和操作可观察值。此外，我们可以创造新的可观测量，并以不同的方式将它们组合在一起。</p><p id="edca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可观测量也可以嵌套，所有嵌套可观测量的值都可以用<code class="fe ln lo lp lq b">concatAll()</code>、<code class="fe ln lo lp lq b">mergeAll()</code>、<code class="fe ln lo lp lq b">switchAll()</code>或<code class="fe ln lo lp lq b">exhaust()</code>得到。</p></div></div>    
</body>
</html>