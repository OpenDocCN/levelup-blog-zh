<html>
<head>
<title>Filter Unique in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中唯一的过滤器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/filter-unique-in-javascript-226007247354?source=collection_archive---------0-----------------------#2019-06-25">https://levelup.gitconnected.com/filter-unique-in-javascript-226007247354?source=collection_archive---------0-----------------------#2019-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b37363c397cf454692d1394b3182711f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9MfB3_mghGuOlRHX5YAzw.jpeg"/></div></div></figure><p id="49b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一段时间我一直在思考一个简单的问题，为什么我们不能在Javascript中对array's使用<code class="fe kw kx ky kz b">.filter</code>来获取数组中所有唯一的值。简短的回答是，你可以！但是我沿着JavaScript这条路走了一小段路，寻找实现这一点的最佳方式。</p><h1 id="cbd9" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">概观</h1><p id="1971" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">对我来说，这样过滤感觉很自然。将<code class="fe kw kx ky kz b">.filter</code>应用于数组的目的是移除不需要的值，即重复值。不使用<code class="fe kw kx ky kz b">.filter</code>有很多方法可以实现这一点，但是这些方法看起来可读性差，也不优雅。使用<code class="fe kw kx ky kz b">.filter</code>的一个额外好处是，您还可以灵活地链接其他数组函数(例如，<code class="fe kw kx ky kz b">.map</code>、<code class="fe kw kx ky kz b">.reduce</code>和其他<code class="fe kw kx ky kz b">.filter</code>调用)。</p><p id="c418" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不喜欢使用<code class="fe kw kx ky kz b">.filter</code>，你可以用ES6 <code class="fe kw kx ky kz b">Set</code>类做一个巧妙的技巧。这实质上是将数组转换成一个只存储唯一值的集合<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">然后再将其转换回数组。干净优雅。</a></p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="eb75" class="mm lb iq kz b gy mn mo l mp mq">const unique = arr =&gt; [...new Set(arr)];</span><span id="b341" class="mm lb iq kz b gy mr mo l mp mq">unique(myArray)</span></pre><h1 id="7982" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">版本1</h1><p id="f3dc" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">经过一点修补，我想出的第一个版本是这样的...</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="d722" class="mm lb iq kz b gy mn mo l mp mq">const unique = (elem, index, array) =&gt; {<br/>  for (var i = 0; i &lt; index; i++) {<br/>    if (array[i] === elem) return false;<br/>  }<br/>  return true;<br/>};</span><span id="1134" class="mm lb iq kz b gy mr mo l mp mq">myArray.filter(unique);</span></pre><p id="fcc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae md" href="https://runkit.com/nizmox/5cef741585603a001c321ad7" rel="noopener ugc nofollow" target="_blank"> runkit </a>中试用。</p><p id="6f8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最初对这种方法相当满意。</p><ul class=""><li id="d10a" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">它适用于字符串和数字(原语)。我并没有试图让这种工作进行深入的平等比较。</li><li id="1b58" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">它只查看当前元素之前的数组元素，因此值的第一个实例将返回<code class="fe kw kx ky kz b">true</code>，任何后续实例都将返回<code class="fe kw kx ky kz b">false</code>。它不需要查看整个数组。</li><li id="1d9e" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">一旦找到重复项，它就返回false(它不会一直检查数组的其余部分)。</li></ul><h1 id="74c1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">还有比这更好的吗？</h1><p id="c1a6" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">过了一段时间，我意识到虽然版本1工作得很好，但它可以做得更好。考虑这个例子，一个有1000个元素的数组。</p><p id="0f66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">const myArray = [&lt;...998 items that aren't 1&gt;, 1, 1];</code></p><p id="12c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们到达最后一个项目时，它将开始查看它前面的项目(999个项目)以查看相同的元素是否已经存在。它从数组位置<code class="fe kw kx ky kz b">[0]</code>开始，将一直检查每一项，直到到达数组位置<code class="fe kw kx ky kz b">[998]</code>的倒数第二个<code class="fe kw kx ky kz b">1</code>。</p><p id="05e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这感觉没有必要，因为我们已经找到了一个<code class="fe kw kx ky kz b">1</code>，所以我们知道任何后续的<code class="fe kw kx ky kz b">1</code>都不可能是唯一的。如果我们能够以某种方式缓存我们找到的每个唯一值，以便不需要重新检查整个数组中的重复值，那就太好了。</p><p id="2650" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我开始考虑创建自己的缓存对象，在缓存中存储值并提供一个函数来检查它们是否已经存在并不难，但这感觉好像我在重新发明轮子，这听起来就像<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank"> Set </a>所做的一样。</p><h1 id="e0e1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">版本2</h1><p id="3030" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">这让我再次想到了<code class="fe kw kx ky kz b">Set()</code>和它的优雅，我开始想我是否能以某种方式将其应用于<code class="fe kw kx ky kz b">.filter</code>。</p><p id="5581" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编写与<code class="fe kw kx ky kz b">.filter</code>一起使用的函数的一个挑战是，您受限于过滤器提供的参数。它只为您提供当前元素、索引和初始数组。不幸的是，当你迭代时，它没有为你提供为结果构造的数组(就像你在<code class="fe kw kx ky kz b">.reduce</code>中访问的“累加器”)。如果是这样的话，这个问题就容易解决了。</p><p id="e7f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过一些黑客攻击，这是我想出的…</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="b0ea" class="mm lb iq kz b gy mn mo l mp mq">const unique = () =&gt; {<br/>  let cache;<br/><br/>  return (elem, index, array) =&gt; {<br/>    if (!cache) cache = new Set(array);<br/>    return cache.delete(elem);<br/>  };<br/>};</span><span id="022d" class="mm lb iq kz b gy mr mo l mp mq">myArray.filter(unique());</span></pre><p id="c20b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae md" href="https://runkit.com/nizmox/5d05fda03a90b1001a3f6188" rel="noopener ugc nofollow" target="_blank"> runkit </a>上试用。</p><p id="cacf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个解决方案首先使用<code class="fe kw kx ky kz b">Set</code>生成整个数组的缓存。然后，在迭代过程中，它使用<code class="fe kw kx ky kz b">.delete</code>方法对照缓存检查每个值。<code class="fe kw kx ky kz b">.delete</code>将从缓存中移除元素，如果可以找到则返回<code class="fe kw kx ky kz b">true</code>，如果不能找到则返回<code class="fe kw kx ky kz b">false</code>。</p><p id="ff32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着第一次找到一个值时，它将返回<code class="fe kw kx ky kz b">true</code>(对于成功的删除)，因为每个元素在缓存中都存在一次，因此将它包含在结果中。但是在随后对相同值(即重复值)的检查中，它将返回<code class="fe kw kx ky kz b">false</code>(删除失败)，因为该值已经被删除，因此将其从结果中排除。</p><p id="4c99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就性能而言，这个解决方案很棒，因为我们预先找到了所有的唯一值，然后每次迭代纯粹是对唯一值列表的一次检查。没有必要重复检查相同的值。</p><p id="2dd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个警告是，这个解决方案需要生成一个缓存并在每个调用之间共享，因此需要一个闭包<code class="fe kw kx ky kz b">.filter(unique()) </code>而不是<code class="fe kw kx ky kz b">.filter(unique)</code>。但是我认为这是一个高性能和干净的解决方案的公平权衡。</p><h1 id="13dd" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">互联网的解决方案</h1><p id="a684" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在我发表这篇文章后，我在互联网上发现了一个非常好的解决方案。这是一条使它更加美丽的线。</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="705a" class="mm lb iq kz b gy mn mo l mp mq">const unique = (x, i, a) =&gt; a.indexOf(x) == i;</span><span id="c86f" class="mm lb iq kz b gy mr mo l mp mq">myArray.filter(unique);</span></pre><p id="d677" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我开始想也许我浪费了时间？</p><h1 id="5637" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">表演</h1><p id="e901" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">谜题的最后一块是哪个解决方案是最有效的。<br/>你可以在<a class="ae md" href="http://jsben.ch/fgmWs" rel="noopener ugc nofollow" target="_blank"> JSBench </a>上看到自己的结果。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/e0b3fcbd88bb03885e6fc9f8e2a04d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sVZrvUxRnYlxl6vGIl02ug.png"/></div></div></figure><p id="9767" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">老实说，他们都很亲近。版本2比版本1更好，版本1比“互联网的解决方案”更好。也就是说，它们都非常接近，可能需要非常大的数据集才能使我的解决方案(版本2)有价值。所以如果这不是你需要的东西，我可能会选择一条线。</p><h1 id="85eb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">包裹</h1><p id="46b4" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">差不多就是这样了。您可以在runkit上试用我的解决方案，或者复制并粘贴到您的项目中。我也创建了一个npm包，如果你愿意的话，叫做<a class="ae md" href="https://www.npmjs.com/package/youneek" rel="noopener ugc nofollow" target="_blank"> youneek </a>。如果你喜欢这篇文章/解决方案，你能给我的最好的感谢就是在<a class="ae md" href="https://github.com/s-taylor/youneek" rel="noopener ugc nofollow" target="_blank"> github </a>上打一颗星。</p><h1 id="e1eb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">附录</h1><p id="9782" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">如果我确实想使用深度相等来过滤对象呢？这超出了我试图实现的范围，但是您可以使用第一个解决方案(版本1)和类似于<a class="ae md" href="https://www.npmjs.com/package/fast-deep-equal" rel="noopener ugc nofollow" target="_blank">快速深度相等</a>的东西来做比较。</p><pre class="me mf mg mh gt mi kz mj mk aw ml bi"><span id="5c3d" class="mm lb iq kz b gy mn mo l mp mq">const isEqual = require('fast-deep-equal');</span><span id="b0f2" class="mm lb iq kz b gy mr mo l mp mq">const deepUnique = (elem, index, array) =&gt; {<br/>  for (var i = 0; i &lt; index; i++) {<br/>    if (isEqual(array[i], elem)) return false;<br/>  }<br/>  return true;<br/>};</span><span id="1e2c" class="mm lb iq kz b gy mr mo l mp mq">myArray.filter(deepUnique);</span></pre></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><div class="me mf mg mh gt no"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">67大JavaScript教程-免费学习JavaScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">gitconnected.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jw no"/></div></div></a></div></div></div>    
</body>
</html>