<html>
<head>
<title>Removing Duplicates and Emptying Arrays: JavaScript Array Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">删除重复项和清空数组:JavaScript数组提示</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/more-javascript-array-tips-removing-duplicates-and-emptying-arrays-4bd56804f477?source=collection_archive---------2-----------------------#2020-01-07">https://levelup.gitconnected.com/more-javascript-array-tips-removing-duplicates-and-emptying-arrays-4bd56804f477?source=collection_archive---------2-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cb73af5548e842b6d3fcbdfe9be8641c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Slm9LRSDN9KvL5qU"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@zburival?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Zbynek Burival </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5e5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript和其他编程语言一样，有许多方便的技巧，让我们可以更容易地编写程序。在本文中，我们将看看如何做涉及数组的不同事情，比如删除数组中的重复项和清空数组。</p><h1 id="ca00" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">移除数组中的重复项</h1><h2 id="59fd" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">使用集合</h2><p id="5a6d" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">从数组中删除重复的条目是我们经常要解决的问题，有几种方法可以做到。对于ES6或更高版本，最简单的方法之一是将其转换为集合，然后再转换回数组。</p><p id="6cdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过使用<code class="fe mt mu mv mw b">Set</code>构造函数将数组转换成集合。构造函数接受一个参数，可以是任何可迭代的对象。这意味着我们可以传入一个数组，或其他类似数组的对象，如<code class="fe mt mu mv mw b">arguments</code>对象、字符串、节点列表、类型数组，如<code class="fe mt mu mv mw b">Uinit8Array</code>、<code class="fe mt mu mv mw b">Map</code>、其他<code class="fe mt mu mv mw b">Sets</code>和任何其他具有<code class="fe mt mu mv mw b">Symbol.iterator</code>方法的对象。</p><p id="e8e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以传入<code class="fe mt mu mv mw b">null</code>，做一个空集。然后，我们用spread操作符将集合转换回数组。例如，如果我们有一个数组，我们可以编写以下代码将它转换为一个集合，然后再转换回数组，以删除重复的条目:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="f85f" class="mc lf it mw b gy nf ng l nh ni">let arr = [1, 1, 2, 2, 3, 4, 5, 5, 6, 6];<br/>arr = [...new Set(arr)];<br/>console.log(arr);</span></pre><p id="2125" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们从拥有重复条目的<code class="fe mt mu mv mw b">arr</code>开始，到最后，我们应该记录了以下内容:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="c37c" class="mc lf it mw b gy nf ng l nh ni">[1, 2, 3, 4, 5, 6]</span></pre><p id="401a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们在数组声明中使用了<code class="fe mt mu mv mw b">let</code>。我们需要使用<code class="fe mt mu mv mw b">let</code>,这样我们就可以在第二秒把新数组赋回给我们的<code class="fe mt mu mv mw b">arr</code>变量。每个条目的第一次出现被保留，其他重复出现被丢弃。</p><p id="3729" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用<code class="fe mt mu mv mw b">Array.from</code>方法将<code class="fe mt mu mv mw b">Set</code>转换成一个数组。<code class="fe mt mu mv mw b">Array.from</code>方法的第一个参数是一个类似数组的对象，如<code class="fe mt mu mv mw b">arguments</code>对象、字符串、节点列表、类型数组如<code class="fe mt mu mv mw b">Uinit8Array</code>、<code class="fe mt mu mv mw b">Map</code>、其他<code class="fe mt mu mv mw b">Sets</code>和任何其他具有<code class="fe mt mu mv mw b">Symbol.iterator</code>方法的对象。这意味着我们可以在下面的代码中使用它来替代数组中的spread运算符:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="8afb" class="mc lf it mw b gy nf ng l nh ni">let arr = [1, 1, 2, 2, 3, 4, 5, 5, 6, 6];<br/>arr = Array.from(new Set(arr));<br/>console.log(arr);</span></pre><p id="abbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用上面的代码，我们应该得到与第一个例子相同的输出。</p><h2 id="2d84" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">使用Array.filter方法</h2><p id="9f8b" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">另一种从数组中删除重复项的方法是使用数组的<code class="fe mt mu mv mw b">filter</code>方法。<code class="fe mt mu mv mw b">filter</code>方法让我们过滤掉已经存在的数组条目。它采用一个有两个参数的回调函数，第一个是数组入口，第二个是被<code class="fe mt mu mv mw b">filter</code>方法迭代的数组的索引。</p><p id="df08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">filter</code>方法过滤器让我们定义我们想要保留的内容，并返回一个包含保留条目的新数组。我们可以将它与<code class="fe mt mu mv mw b">indexOf</code>方法一起使用，后者返回数组条目的第一次出现。</p><p id="b507" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">indexOf</code>方法接受我们想要查找索引的任何对象。我们可以使用它来过滤掉重复出现的数组条目，如下面的代码所示:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="a6f7" class="mc lf it mw b gy nf ng l nh ni">let arr = [1, 1, 2, 2, 3, 4, 5, 5, 6, 6];<br/>arr = arr.filter((entry, index) =&gt; arr.indexOf(entry) === index);<br/>console.log(arr);</span></pre><p id="8967" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">filter</code>中的回调函数返回我们想要保留的数组项的状态。在上面的代码中，我们想返回<code class="fe mt mu mv mw b">arr.indexOf(entry) === index</code>，因为我们只想返回每个条目的第一次出现。<code class="fe mt mu mv mw b">arr.indexOf(entry)</code>返回条目第一次出现的索引，<code class="fe mt mu mv mw b">index</code>是我们想要检查的数组条目，因为<code class="fe mt mu mv mw b">filter</code>方法正在遍历它。</p><p id="31bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">filter</code>方法的第一次迭代应该使<code class="fe mt mu mv mw b">entry</code>为1，而<code class="fe mt mu mv mw b">index</code>为0，因此我们得到:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="2dd7" class="mc lf it mw b gy nf ng l nh ni">arr.indexOf(1) === 0</span></pre><p id="4caa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<code class="fe mt mu mv mw b">indexOf</code>获得了第一个条目的索引，所以它返回0，所以<code class="fe mt mu mv mw b">filter</code>方法将保留它。在下一次迭代中，我们再次将<code class="fe mt mu mv mw b">entry</code>设为1，将<code class="fe mt mu mv mw b">index</code>设为1，因此我们得到:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="da35" class="mc lf it mw b gy nf ng l nh ni">arr.indexOf(1) === 1</span></pre><p id="bde0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经知道<code class="fe mt mu mv mw b">arr.indexOf(1)</code>是0但是右边是1。这意味着表达式将被求值为<code class="fe mt mu mv mw b">false</code>，因此<code class="fe mt mu mv mw b">filter</code>方法将丢弃它。对于第三个条目，我们有值为2的<code class="fe mt mu mv mw b">entry</code>和值为2的<code class="fe mt mu mv mw b">index</code>。然后我们得到:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="2caf" class="mc lf it mw b gy nf ng l nh ni">arr.indexOf(2) === 2</span></pre><p id="a7c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">arr.indexOf(2)</code>将返回2，因为2的第一次出现是2，并且我们在右侧有2，因为<code class="fe mt mu mv mw b">index</code>是2，所以表达式计算为<code class="fe mt mu mv mw b">true</code>，所以它将被保存在返回的数组中。这种情况会一直持续下去，直到所有的条目都被遍历并检查完毕。因此，我们应该得到与上面其他例子相同的条目。</p><h2 id="94b4" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">使用Array.reduce方法</h2><p id="8f1e" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">从数组中删除重复条目的第三种方法是使用<code class="fe mt mu mv mw b">reduce</code>方法。该方法根据我们在传入的回调函数中指定的内容，将数组的条目组合成一个实体，并返回组合后的实体。</p><p id="3243" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">reduce</code>方法接受一个有两个参数的函数，第一个参数包含一个数组，该数组包含到目前为止由<code class="fe mt mu mv mw b">reduce</code>方法合并的条目，第二个参数包含要合并到第一个参数的第一个值中的条目。</p><p id="55e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是回调函数的第一个参数的初始值。例如，我们可以使用它来过滤掉重复的数组，如下面的代码所示:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="71b5" class="mc lf it mw b gy nf ng l nh ni">let arr = [1, 1, 2, 2, 3, 4, 5, 5, 6, 6];<br/>arr = arr.reduce((noDupArr, entry) =&gt; {<br/>  if (noDupArr.includes(entry)) {<br/>    return noDupArr;<br/>  } else {<br/>    return [...noDupArr, entry];<br/>  }<br/>}, [])<br/>console.log(arr);</span></pre><p id="3038" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们传递了一个回调函数，该函数通过使用数组附带的<code class="fe mt mu mv mw b">includes</code>方法来检查没有任何重复值的数组<code class="fe mt mu mv mw b">noDupArr</code>是否在第二个参数中包含了<code class="fe mt mu mv mw b">entry</code>。<code class="fe mt mu mv mw b">includes</code>方法接受任何对象，并让我们检查它是否已经在<code class="fe mt mu mv mw b">noDupArr</code>中。因此，如果<code class="fe mt mu mv mw b">noDupArr.includes(entry)</code>是<code class="fe mt mu mv mw b">true</code>，那么我们返回到目前为止组合的所有内容。否则，如果该值还没有包含在数组中，那么我们可以添加<code class="fe mt mu mv mw b">entry</code>，通过使用spread操作符将<code class="fe mt mu mv mw b">noDupArr</code>的现有条目扩展到一个新的数组中，然后我们添加<code class="fe mt mu mv mw b">entry</code>作为数组的最后一个条目。</p><p id="418c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按照这种逻辑，第一个值之后的后续值不会包含在新组合的数组中。因此，我们不会在数组中包含重复的条目。最初，<code class="fe mt mu mv mw b">noDupArr</code>将是一个由<code class="fe mt mu mv mw b">reduce</code>方法的第二个参数指定的条目。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/3ad5e8e0c953d5675f97e001e428a2c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ojAdTaztvqD39eqn"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">freestocks.org</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="d0f3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">清空数组</h1><p id="44d4" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">有几种方法可以清空数组。我们可以将它设置为空数组，或者将数组的长度设置为0。例如，我们可以将其设置为一个空数组，如下面的代码所示:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="947f" class="mc lf it mw b gy nf ng l nh ni">let arr = [1, 1, 2, 2, 3, 4, 5, 5, 6, 6];<br/>arr = [];<br/>console.log(arr);</span></pre><p id="3f5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码是最明显的方法。一种不太为人所知的清空数组的方法是将其长度设置为0，如下所示:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="0c2b" class="mc lf it mw b gy nf ng l nh ni">let arr = [1, 1, 2, 2, 3, 4, 5, 5, 6, 6];<br/>arr.length = 0;<br/>console.log(arr);</span></pre><p id="0c2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们也应该为<code class="fe mt mu mv mw b">arr</code>得到一个空数组。</p><h1 id="b9af" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="0cec" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">有许多方法可以从数组中删除重复的条目，每种方法都保持第一次出现的值不变，并丢弃后续出现的值。我们可以用spread操作符将它转换成一个集合，然后再转换回一个数组。</p><p id="7c98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以使用<code class="fe mt mu mv mw b">filter</code>和<code class="fe mt mu mv mw b">indexOf</code>方法返回一个新数组，只保留第一次出现的值，因为<code class="fe mt mu mv mw b">indexOf</code>返回第一次出现的值和回调函数的第二个参数，如果我们可以检查原始数组的索引，我们会将该参数传递给<code class="fe mt mu mv mw b">filter</code>。</p><p id="0d04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以一起使用<code class="fe mt mu mv mw b">reduce</code>和<code class="fe mt mu mv mw b">includes</code>方法来做类似于<code class="fe mt mu mv mw b">filter</code>和<code class="fe mt mu mv mw b">indexOf</code>方法的事情。</p><p id="6a66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要清空数组，我们可以将其<code class="fe mt mu mv mw b">length</code>设置为0或者直接设置为空数组。</p></div></div>    
</body>
</html>