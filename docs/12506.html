<html>
<head>
<title>Simplifying How Garbage Collection Works in .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化垃圾收集的工作方式。网</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simplifying-how-garbage-collection-works-in-net-6c86d998328e?source=collection_archive---------8-----------------------#2022-06-15">https://levelup.gitconnected.com/simplifying-how-garbage-collection-works-in-net-6c86d998328e?source=collection_archive---------8-----------------------#2022-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4a9e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从内存分配到释放内存</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5860a391b7017a6683b98c52bb0cb9f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cK5Zo2IvM_A14vS1cPLGZA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/photos/d_3EKbSg1tg" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@hdbernd" rel="noopener ugc nofollow" target="_blank"> Bernd Dittrich </a>拍摄的照片</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="016d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">垃圾收集器是一个内存管理器，负责为我们的应用程序分配和释放内存。这意味着开发人员无需担心编写执行内存管理任务的代码，从而降低了开发人员忘记释放内存并可能导致内存泄漏的风险。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="d042" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">简而言之，垃圾收集器做什么</h2><ul class=""><li id="e4f5" class="mv mw it li b lj mx lm my lp mz lt na lx nb mb nc nd ne nf bi translated">我们已经提到过，它通过为开发人员进行内存管理来帮助他们。</li><li id="51ac" class="mv mw it li b lj ng lm nh lp ni lt nj lx nk mb nc nd ne nf bi translated">在托管堆上分配对象。</li><li id="02c1" class="mv mw it li b lj ng lm nh lp ni lt nj lx nk mb nc nd ne nf bi translated">识别不再使用的对象并清除内存，以便将来分配使用。</li><li id="fb71" class="mv mw it li b lj ng lm nh lp ni lt nj lx nk mb nc nd ne nf bi translated">确保对象不能使用已经分配给另一个对象的内存。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="0182" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">记忆是什么样子的</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/135e4f7d38956bb10611080e43247bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtzQFXhETi6qMsZGZzqvrw.png"/></div></div></figure><p id="5b79" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">实际上很简单，假设这些块是内存。每个进程都占用了一块内存，并有一个地址。块也可以是未使用的(空闲的)，或者它们可以被某个进程保留，但尚未使用(过渡阶段)。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="09e2" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">托管堆</h2><p id="d3dc" class="pw-post-body-paragraph lg lh it li b lj mx ju ll lm my jx lo lp nm lr ls lt nn lv lw lx no lz ma mb im bi translated">垃圾收集器由CLR(公共语言运行时)初始化，然后分配一些内存来存储和管理对象。这种内存称为托管堆。</p><p id="8d90" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以把托管堆看作两个不同的部分。第一部分存储较小的对象，而第二部分专门用于最小为85，000字节的较大对象。</p><p id="58e7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">记住这一点，让我们看看垃圾收集器是如何工作的。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="e3c6" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">世代</h2><p id="0dfc" class="pw-post-body-paragraph lg lh it li b lj mx ju ll lm my jx lo lp nm lr ls lt nn lv lw lx no lz ma mb im bi translated">简而言之，代是将托管堆分成3部分以提高垃圾收集器性能的组。这背后的主要思想是:</p><ul class=""><li id="d0ab" class="mv mw it li b lj lk lm ln lp np lt nq lx nr mb nc nd ne nf bi translated">压缩托管堆的一部分会更快。</li><li id="1e2e" class="mv mw it li b lj ng lm nh lp ni lt nj lx nk mb nc nd ne nf bi translated">较新的对象往往具有较短的生存期，而较旧的对象则相反，因为它们的生存期较长。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/74e69ac01024443a92258020a0f8fea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*mhfEDiPwU-BAE7-ed9fs7w.png"/></div></figure><p id="1453" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">第0代是运行最频繁的集合。这背后的逻辑是新对象通常没有很长的生命周期。如果他们确实有更长的寿命，他们将进入第一代。GC不经常尝试在第1代中释放内存，因为它知道其中的对象很有可能比第0代中的对象活得更长。如果GC在第1代上执行收集，并且一些对象幸存下来，它们将被提升到第2代，第2代是最不频繁收集的，因为在第2代中，生存期是最长的，从逻辑上讲，更频繁地检查它没有什么意义。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="0f45" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">结论</h2><p id="88c8" class="pw-post-body-paragraph lg lh it li b lj mx ju ll lm my jx lo lp nm lr ls lt nn lv lw lx no lz ma mb im bi translated">开发人员并不真的需要与垃圾收集器交互，因为它为我们完成了工作，但是知道底层的工作方式总是很好的。虽然C#足够好地为我们提供了内存管理，但有些语言却没有这种能力，深入了解内存分配和释放将会大有裨益。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><div class="kj kk kl km gt nt"><a href="https://medium.com/@ivan.zstoev/membership" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">通过我的推荐链接加入Medium-Ivan Stoev</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">medium.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div></div></div>    
</body>
</html>