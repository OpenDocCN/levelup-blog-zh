<html>
<head>
<title>4 Different Ways To Solve Trapping Rain Water Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决截留雨水问题的4种不同方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-different-ways-to-solve-trapping-rain-water-problem-c69c09e4f96b?source=collection_archive---------5-----------------------#2021-10-26">https://levelup.gitconnected.com/4-different-ways-to-solve-trapping-rain-water-problem-c69c09e4f96b?source=collection_archive---------5-----------------------#2021-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6cb7aa586ac3aeb3baba587b8b66636d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1CK2UX5_LcMaloz2"/></div></div></figure><p id="5e44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给定n个非负整数表示一个高程图，其中每个条形的宽度为1，计算下雨后它可以收集多少水。</p><p id="2856" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将查看4种不同的方法来解决上述问题，为此，我们将遵循给定的输入测试用例</p><p id="7c88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输入:a = [1，0，2，1，0，1，3，2，1，2，1]</p><p id="4730" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看下面的图片，了解有多少水将被困在酒吧之间。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/289f6a7def486740904ba1c52602c1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fu1MEoR-gBqTvBDh"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">了解水是如何在每个索引处被截留的|作者图片</figcaption></figure><h2 id="d87a" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">我们先来了解一下问题背后的直觉。</h2><ul class=""><li id="d83e" class="ly lz iq ka b kb ma kf mb kj mc kn md kr me kv mf mg mh mi bi translated">仔细观察上面的图片，你会注意到，为了让水在第I个栅栏处被捕获，它的左侧和右侧都应该有一个更高的栅栏。</li><li id="0300" class="ly lz iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">为了找到在第I个索引处被捕获的水量，我们需要找到其左侧的最大元素max(a[1]，…a[i])，以及其右侧的最大元素max(a[i]…a[n])。</li><li id="e399" class="ly lz iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">现在，如果在第I个指数处的棒的高度是a[i],那么在第I个指数处收集的水将是</li></ul><blockquote class="mo mp mq"><p id="48a1" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated"><strong class="ka ir"> min(leftmax，rightmax) — a[i] </strong></p><p id="496a" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated"><strong class="ka ir"> min(max(a[1]，…a[i])，max(a[I]…a[n])—a[I]</strong></p></blockquote><p id="260f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参考下图更好理解。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/9a083270e905323010fa6789066c8bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IlG4VE4rX8Dbuv8QaAGqWA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">作者图片</figcaption></figure><p id="bb07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以对每第I个指数下收集的水进行求和，并找出实际收集的水的总量。</p><p id="1981" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当你理解了问题陈述及其背后的直觉，让我们跳到第一个也是最天真的方法。</p><h1 id="4812" class="mw lg iq bd lh mx my mz lk na nb nc ln nd ne nf lq ng nh ni lt nj nk nl lw nm bi translated">蛮力:</h1><p id="640e" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">首先，对于每个第I个索引，我们将找到其左侧的最大元素以及其右侧的最大元素，然后找到在第I个索引处可以捕获的水。</p><p id="6637" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有关上述方法，请参考下面的代码。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e926" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">时间复杂度:O(N ) </strong></p><p id="e6d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">空间复杂度:O(1) </strong></p><p id="c084" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们能做得更好吗？让我们看看下面的方法:</p><h1 id="3580" class="mw lg iq bd lh mx my mz lk na nb nc ln nd ne nf lq ng nh ni lt nj nk nl lw nm bi translated"><strong class="ak">基于前缀和的优化方法:</strong></h1><p id="525e" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">我们可以预先计算每个索引I的leftmax和rightmax，而不是找到每个索引I的leftmax和rightmax。请看下面的步骤！</p><ul class=""><li id="0027" class="ly lz iq ka b kb kc kf kg kj ns kn nt kr nu kv mf mg mh mi bi translated">我们将创建大小为n的2个数组<strong class="ka ir"> <em class="mr">前缀</em> </strong>和<strong class="ka ir"> <em class="mr">后缀</em> </strong>。</li><li id="275a" class="ly lz iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><strong class="ka ir"><em class="mr">【I】</em></strong>前缀会存储<strong class="ka ir"> <em class="mr"> max(a[1]，…a[i]) </em>。</strong></li><li id="591c" class="ly lz iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><strong class="ka ir"> <em class="mr">后缀【I】</em></strong>会存储<strong class="ka ir"> <em class="mr"> max(a[i]，…a[n])。</em> </strong></li></ul><p id="f431" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以对输入数组进行迭代，找到条块之间的总水量。</p><p id="6580" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请参考上述方法的代码。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="46e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">时间复杂度:O(N) </strong></p><p id="7bdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">空间复杂度:O(N) </strong></p><p id="d067" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你能想出另一种同样复杂的方法吗！</p><h1 id="fa8e" class="mw lg iq bd lh mx my mz lk na nb nc ln nd ne nf lq ng nh ni lt nj nk nl lw nm bi translated">基于堆栈的方法:</h1><p id="bc2f" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">这种方法基于著名的面试问题<a class="ae nv" href="https://leetcode.com/problems/largest-rectangle-in-histogram/" rel="noopener ugc nofollow" target="_blank">直方图中的最大矩形。</a></p><p id="3203" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照下面的步骤来理解这种方法。</p><ul class=""><li id="8a9b" class="ly lz iq ka b kb kc kf kg kj ns kn nt kr nu kv mf mg mh mi bi translated">找到第I个元素左侧 最近的<strong class="ka ir"> <em class="mr">更大的元素和第I个元素右侧</em> </strong>最近的<strong class="ka ir"> <em class="mr">更大或相等的元素。</em></strong></li><li id="a417" class="ly lz iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">如果leftmax的指数是x，rightmax的指数是y，则将(min(leftmax，rightmax)-a[i])*(y-x-1)加到总截留水。没明白吗？参考下图。</li></ul><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/b3dffc0fb1355c4fd7483d0a3afba86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a14_gFUoJAsNN1puCJr-mQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">作者图片</figcaption></figure><p id="4451" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请参考上述方法的代码:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d506" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">时间复杂度:O(N) </strong></p><p id="d45f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">空间复杂度:O(N) </strong></p><p id="4b5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还不满意上面的复杂？让我们来看看一种更加优化空间的方法。</p><h1 id="bb6d" class="mw lg iq bd lh mx my mz lk na nb nc ln nd ne nf lq ng nh ni lt nj nk nl lw nm bi translated"><strong class="ak">双指针方法:</strong></h1><p id="b19d" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">在第二种方法中，我们使用了额外的空间来存储每个索引I的leftmax和rightmax的预计算值</p><p id="3ebb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，我们可以保留两个变量leftmax和rightmax。现在我们可以用low=1和high=n来定义我们的范围。</p><ul class=""><li id="84a4" class="ly lz iq ka b kb kc kf kg kj ns kn nt kr nu kv mf mg mh mi bi translated">如果<strong class="ka ir"><em class="mr">a[low]≤a[high]</em></strong>那么我们知道在它的右边有一个大于a[low]的元素，并且从公式<strong class="ka ir"> <em class="mr"> min(leftmax，right max)-a[I]</em></strong>我们将考虑<strong class="ka ir"><em class="mr">left max-a[low]</em></strong>进入trappedwater并且<strong class="ka ir"> <em class="mr">递增我们的低指针。</em> </strong></li><li id="8eea" class="ly lz iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">如果<strong class="ka ir"> <em class="mr"> a【低】&gt; a【高】</em> </strong>那么我们知道在其左侧有某个大于a【高】的元素，并且从公式<strong class="ka ir"> <em class="mr"> min(leftmax，right max)-a【I】</em></strong>我们将考虑<strong class="ka ir"> <em class="mr"> rightmax-a【高】</em> </strong>进入trappedwater并且<strong class="ka ir"> <em class="mr">递减我们的高指针</em> </strong>。</li></ul><p id="5576" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更好地理解，请参考上述方法的代码。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="643d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">时间复杂度:O(N) </strong></p><p id="76dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">空间复杂度:O(1) </strong></p><p id="776e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望现在你对截留雨水的问题有了清楚的了解。</p><p id="79f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读:)</p></div></div>    
</body>
</html>