<html>
<head>
<title>Handling Nested Objects in Firestore With Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Flutter处理Firestore中的嵌套对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-nested-objects-in-firestore-with-flutter-18fc1072143f?source=collection_archive---------5-----------------------#2020-07-05">https://levelup.gitconnected.com/handling-nested-objects-in-firestore-with-flutter-18fc1072143f?source=collection_archive---------5-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="bba6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谷歌的云Firestore是一个应该在每个移动应用开发者的工具带中的工具。它提供的灵活和可伸缩的数据库不同于任何一个编码员可以单独创建的东西，如果你的应用程序是为全球观众设计的，没有多少解决方案像它一样。另外，有一个Flutter包(<a class="ae ko" href="https://pub.dev/packages/cloud_firestore" rel="noopener ugc nofollow" target="_blank"> cloud_firestore </a>)旨在让Flutter和Flame很好地配合。</p><p id="553f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，有一个缺点。该工具不能免费使用，你的应用程序对Firestore数据库进行的每一次读/写交易都将计入你的<a class="ae ko" href="https://firebase.google.com/docs/firestore/quotas" rel="noopener ugc nofollow" target="_blank">每日配额</a>(免费层计划为每日50，000次读取和20，000次写入)。因此，你在设计数据库时必须考虑到这些使用限制……否则，你创建一个有利可图的移动应用的梦想就会像火焰一样被扑灭。</p><p id="03c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将讨论如何在Firestore数据库中使用嵌套对象来减少事务处理量。您不必从一个文档和两个不同的子集合中检索数据，而是能够查询单个文档并在客户端处理嵌套的数据。#资金动向。</p><h1 id="a5f5" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">写入嵌套数据</h1><h1 id="b6ac" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">地图—手动</h1><p id="cff5" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">将嵌套数据保存到Firestore文档的最简单方法是使用地图。在你的Flutter应用程序中设置Firestore并创建数据库后，你可以像这样保存嵌套的地图数据:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="92b0" class="mb kq it lx b gy mc md l me mf">void SaveNestedData() { Firestore.instance.collection("exercises").add(<br/>{ "name": "Dumbbell curl",<br/>  "muscle": "Biceps", <br/>  "sets": { <br/>     "reps": 10, <br/>     "weight": 40} <br/>}); <br/>}</span></pre><p id="7714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出将如下所示:</p><figure class="ls lt lu lv gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mg"><img src="../Images/0ca87681057cfcd3e7c51b13ad2afba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7t9OnJHDAH-KgXcy"/></div></div></figure><p id="c5fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在许多情况下，这种方法可能是完全令人满意的…在其他情况下，就不那么令人满意了。在我的例子中，一个“练习”应该有多个“集合”，每个集合都有一个权重和重复值。理想情况下，我会将一组地图存储在一个名为sets的字段中。</p><h1 id="3178" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">一系列地图—手动</h1><p id="389c" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">完成此任务的代码只比保存单个地图的代码稍微复杂一点。您所要做的就是添加括号来表明该值是一个列表:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1858" class="mb kq it lx b gy mc md l me mf">void SaveNestedData() { Firestore.instance.collection("exercises").add(<br/>{ "name": "Dumbbell curl", <br/>  "muscle": "Biceps", <br/>  "sets": [ {"reps": 10, "weight": 40}, <br/>            {"reps": 10, "weight": 40}, <br/>            {"reps": 10, "weight": 40}] <br/>}); <br/>}</span></pre><p id="eb4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此函数的结果如下所示:</p><figure class="ls lt lu lv gt mh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/fc7b7a268092f9f96c43190b04e77794.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/0*Dp_k6KpClgWXHzW5"/></div></figure><p id="732f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管如此，手动写出想要保存的数据是低效的，并且容易出现不一致。为了解决这个问题，您可以创建一个类来保存您想要保存的每个对象的值。</p><h1 id="3287" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">地图-使用对象</h1><p id="2fc2" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">将对象保存到Firestore的第一步是创建对象<a class="ae ko" href="https://api.flutter.dev/flutter/dart-core/Object-class.html" rel="noopener ugc nofollow" target="_blank">类</a>。这个类将保存定义对象的属性和方法。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="62f4" class="mb kq it lx b gy mc md l me mf">class Exercise { <br/>final String name; <br/>final String muscle; <br/>List&lt;dynamic&gt; sets = [ <br/>{"reps": 10, "weight": 40}, <br/>{"reps": 10, "weight": 40}, <br/>{"reps": 10, "weight": 40} ]; <br/>Exercise(this.name, this.muscle); <br/>}</span></pre><p id="7a2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可以创建新类的一个实例，并使用点符号赋值，而不是在映射中声明每个值。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="c606" class="mb kq it lx b gy mc md l me mf">Exercise exercise = Exercise("Dumbbell Curl", "Biceps");</span></pre><p id="8cbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在非Flutter语言中，将这个对象保存到Firestore很简单，但遗憾的是，没有与document()等价的东西。在颤动中设置(数据)。相反，我们拥有的是文档()。setData()，它接受一个映射&lt;字符串、动态&gt;参数和一个对象参数<em class="mp">而不是</em>。更糟糕的是，Dart(Flutter语言)没有<a class="ae ko" href="https://stackoverflow.com/questions/54949087/how-to-convert-class-object-to-data-structure-map-or-a-list-of-maps-in-dart" rel="noopener ugc nofollow" target="_blank">将对象转换成地图的方法。</a></p><p id="d11d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这给我们留下了一个选择:自己创建对象到映射函数。这听起来比实际情况更吓人。实际上，这意味着我们需要在我们的类中创建一个函数，将对象的值赋给一个映射并返回该映射。我的健身课应该是这样的:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="8f9d" class="mb kq it lx b gy mc md l me mf">class Exercise { <br/>final String name; <br/>final String muscle; <br/>List&lt;dynamic&gt; sets = [ <br/>{"reps": 10, "weight": 40}, <br/>{"reps": 10, "weight": 40}, <br/>{"reps": 10, "weight": 40} ]; </span><span id="70ae" class="mb kq it lx b gy mq md l me mf">Exercise(this.name, this.muscle); </span><span id="6797" class="mb kq it lx b gy mq md l me mf">Map&lt;String,dynamic&gt; toMap() =&gt; { <br/>"name": this.name, <br/>"muscle": this.muscle, <br/>"sets": this.sets }; <br/>}</span></pre><p id="6ccc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将数据保存到Firestore数据库就像这样简单:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="b494" class="mb kq it lx b gy mc md l me mf">void SaveNestedData() { <br/>Exercise exercise = Exercise("Tricep Extension", "Triceps"); Firestore.instance.collection("exercises") .document().setData(exercise.toMap()); }</span></pre><h1 id="9396" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">对象数组</h1><h2 id="5680" class="mb kq it bd kr mr ms dn kv mt mu dp kz kb mv mw ld kf mx my lh kj mz na ll nb bi translated">创建嵌套对象</h2><p id="f840" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在最后一个例子中，我仍然清楚地将“集合”列表写成一系列{maps}。我真正想做的是把每个“集合”也变成一个对象。这将使我对每组数据有更多的控制，并允许我在任何时候向练习中添加新的组。同样，第一步是创建类。这一次，我们还将添加toMap()函数，这样它就准备好保存到Firestore了。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="fcc8" class="mb kq it lx b gy mc md l me mf">class Set { <br/>final int reps; <br/>final int weight; </span><span id="1b07" class="mb kq it lx b gy mq md l me mf">Set(this.reps, this.weight); Map&lt;String,dynamic&gt; toMap() =&gt; { "reps": this.reps, "weight": this.weight <br/>}; <br/>}</span></pre><p id="a1af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，当我第一次保存练习对象时，我将用一个空白的Set对象数组保存它。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1eff" class="mb kq it lx b gy mc md l me mf">class Exercise { <br/>final String name; <br/>final String muscle; <br/>List&lt;dynamic&gt; sets = []; Exercise(this.name, this.muscle); </span><span id="427e" class="mb kq it lx b gy mq md l me mf">Map&lt;String,dynamic&gt; toMap() =&gt; { <br/>"name": this.name, <br/>"muscle": this.muscle, <br/>"sets": this.sets }; }</span><span id="99d4" class="mb kq it lx b gy mq md l me mf">void SaveNestedData() { <br/>Exercise exercise = Exercise("Tricep Extension", "Triceps"); Firestore.instance.collection("exercises").document("OWXsZjJRy3jjWmaM3Rup").setData(exercise.toMap());<br/>}</span></pre><h2 id="3248" class="mb kq it bd kr mr ms dn kv mt mu dp kz kb mv mw ld kf mx my lh kj mz na ll nb bi translated">向阵列中添加对象</h2><p id="8841" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">当您想要将对象添加到空数组时，请执行以下操作:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="f026" class="mb kq it lx b gy mc md l me mf">void AddObjectToArray() { <br/>Set set = Set(10,35); </span><span id="ca17" class="mb kq it lx b gy mq md l me mf">Firestore.instance.collection("exercises") .document("OWXsZjJRy3jjWmaM3Rup").updateData({ <br/>"sets": FieldValue.arrayUnion([set.toMap()]) }); <br/>}</span></pre><p id="bedf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于这个函数有几件重要的事情:</p><ul class=""><li id="1721" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn nh ni nj nk bi translated">我使用updateData()方法来更新文档中的单个字段。这要求您知道文档ID。</li><li id="5b1d" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">为了给数组添加一个值，我使用了FieldValue.arrayUnion()方法，该方法接受一个List <dynamic>参数。</dynamic></li><li id="a392" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">我正在为我的Set对象调用toMap()函数，这样它就变成了Map <string>格式。</string></li></ul><p id="246e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你再次触发这个函数，你会注意到一些奇怪的事情。数据库中的数组不会更新，在“集合”字段中仍然只有一个条目。</p><figure class="ls lt lu lv gt mh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/807e26ec6c3b0576e310c5edbac2e1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/0*C0o1Ku-Yb7Gdc3AN"/></div></figure><p id="b94e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为arrayUnion(method) only <a class="ae ko" href="https://firebase.google.com/docs/firestore/manage-data/add-data#update_elements_in_an_array" rel="noopener ugc nofollow" target="_blank">向一个不存在的数组添加一个值</a>。对于我的用例来说，这是行不通的。一项运动可以有多个组，这些组由相同的重复次数和重量定义。那现在怎么办？</p><figure class="ls lt lu lv gt mh gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/2f2c09d59a32e34f3c66f23c3c46dba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/0*TkFsMRoCZR7nUICv"/></div></figure><h2 id="a95e" class="mb kq it bd kr mr ms dn kv mt mu dp kz kb mv mw ld kf mx my lh kj mz na ll nb bi translated">向数组中添加多个对象</h2><p id="c742" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">这就是事情变得有点棘手的地方。在Firestore中向数组添加重复值的唯一方法是读取文档，用您的重复值更新数组，然后将其重写到数据库中。我们一会儿再来讨论这个问题。</p><h1 id="84c2" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">读取嵌套数据</h1><p id="8509" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">当您试图从数据库中的文档读取数据时，您将首先获得一个DocumentSnapshot。这个对象包含一个数据属性，它将文档的内容保存在一个巨大的Map <string>对象中。因此，如果我们想从以前创建的文档中获取“name”值，我们应该这样做:</string></p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="33d9" class="mb kq it lx b gy mc md l me mf">void ReadNestedData() { <br/>Firestore.instance.collection("exercises") .document("OWXsZjJRy3jjWmaM3Rup") <br/>.get().then((docSnapshot) =&gt; { <br/>log(docSnapshot.data["name"]) }); <br/>}</span></pre><p id="75fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们只是从地图中抓取其中一个键。这是现成的，因为“name”字段包含一个字符串值。但是如果我们想从“集合”字段中读取数据呢？混乱。开玩笑…除非混乱意味着可读性差，数据不可访问。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="17f0" class="mb kq it lx b gy mc md l me mf">void ReadNestedData() { <br/>Firestore.instance.collection("exercises") .document("OWXsZjJRy3jjWmaM3Rup") .get().then((docSnapshot) =&gt; { log("Sets: " + docSnapshot.data["sets"].toString()) }); <br/>}</span></pre><figure class="ls lt lu lv gt mh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/3377814469cdf2d2123edb2c07810ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/0*mVyY0d6UMrjjk257"/></div></figure><p id="eb9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，如果我想手动检索第一组练习的重复次数，我必须做这样的事情:</p><figure class="ls lt lu lv gt mh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3fbca6fcc420ed7baa0233595be9b718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/0*1uU3irg4Dyp7u17D"/></div></figure><p id="fe28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一个更简单的方法。</p><h1 id="506d" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">从Firestore文档创建对象</h1><p id="a3af" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">就像我们写数据一样，我们可以在类中创建一个从地图创建对象的函数。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6e32" class="mb kq it lx b gy mc md l me mf">class Set { <br/>final int reps; <br/>final int weight; <br/>Set(this.reps, this.weight); </span><span id="c2cc" class="mb kq it lx b gy mq md l me mf">Map&lt;String, dynamic&gt; toMap() =&gt; { <br/>"reps": this.reps, <br/>"weight": this.weight }; </span><span id="0709" class="mb kq it lx b gy mq md l me mf">Set.fromMap(Map&lt;dynamic, dynamic&gt; map) : <br/>reps = map["reps"].toInt(), <br/>weight = map["weight"].toInt(); }</span></pre><p id="5fc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以使用我们的新函数从DocumentSnapshot中的数据创建一个Set对象:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="ed41" class="mb kq it lx b gy mc md l me mf">void ReadNestedData() { </span><span id="2b7f" class="mb kq it lx b gy mq md l me mf">Set set; <br/>Firestore.instance.collection("exercises") .document("OWXsZjJRy3jjWmaM3Rup") .get().then((docSnapshot) =&gt; { <br/>set = Set.fromMap(docSnapshot.data["sets"][0]), <br/>log("Data :" + docSnapshot.data.toString()), <br/>log("Reps: " + set.reps.toString()) }); <br/>}</span></pre><p id="05bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管如此，这仍然不够完美，因为我们必须从要检索的数组中手动选择项目(参见上面的docSnapshot.data["sets"][0]部分)。</p><h1 id="6259" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">从Firestore文档创建嵌套对象</h1><p id="2c5e" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">理想情况下，我们想要做的是完整地阅读文档，并一次解析出所有的内容(当然，要注意文档的大小)。为此，您需要在fromMap()方法中手动创建嵌套对象列表。例如，要在我们的练习对象中创建一个集合对象列表，我们可以这样做:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="c45e" class="mb kq it lx b gy mc md l me mf">class Exercise { <br/>final String name; <br/>final String muscle; <br/>List&lt;dynamic&gt; sets = []; <br/>Exercise(this.name, this.muscle); </span><span id="e4a8" class="mb kq it lx b gy mq md l me mf">Map&lt;String, dynamic&gt; toMap() =&gt; { <br/>"name": this.name, <br/>"muscle": this.muscle, <br/>"sets": this.sets }; </span><span id="2113" class="mb kq it lx b gy mq md l me mf">Exercise.fromMap(Map&lt;dynamic, dynamic&gt; map) : <br/>name = map['name'], <br/>muscle = map['muscle'], <br/>sets = map['sets'].map((set) { <br/>return Set.fromMap(set); }).toList(); <br/>}</span></pre><p id="5fd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可以检索文档快照，将其转换为一个带有Set对象嵌套数组的练习对象，然后按照您喜欢的方式操纵这些集合。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="129a" class="mb kq it lx b gy mc md l me mf">void ReadNestedData() { <br/>Exercise exercise; Firestore.instance.collection("exercises").document("OWXsZjJRy3jjWmaM3Rup").get().then((docSnapshot) =&gt; { </span><span id="dd09" class="mb kq it lx b gy mq md l me mf">exercise = Exercise.fromMap(docSnapshot.data), exercise.sets.forEach((set) { <br/>Set setInst = set as Set; <br/>log("Reps :" + setInst.reps.toString()); }) }); <br/>}</span></pre><h1 id="cbfb" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">向数组中添加多个对象</h1><p id="28d4" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">回到上面的问题，我们如何在Firestore中将重复的对象保存到一个数组中？</p><ol class=""><li id="c53e" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn nu ni nj nk bi translated">首先，阅读您想要更新的文档，并从中创建一个对象。</li><li id="e8d5" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nu ni nj nk bi translated">然后，创建一个新对象，并将其添加到已经存在的对象列表中</li><li id="ad7b" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nu ni nj nk bi translated">最后，将文档重写到Firestore</li></ol><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="5cde" class="mb kq it lx b gy mc md l me mf">void AddObjectToArray() { <br/>Exercise exercise; <br/>Set newSet; </span><span id="cb01" class="mb kq it lx b gy mq md l me mf">Firestore.instance .collection("exercises") .document("OWXsZjJRy3jjWmaM3Rup") .get() .then((docSnapshot) =&gt; { newSet = Set(10, 30), <br/>exercise = Exercise.fromMap(docSnapshot.data), exercise.sets.add(newSet), </span><span id="5528" class="mb kq it lx b gy mq md l me mf">Firestore.instance.collection("exercises") .document("OWXsZjJRy3jjWmaM3Rup") .setData(exercise.toMap())}); <br/>}</span></pre><p id="cf53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有用吗？没有。如果您照原样运行这个函数，您可能会得到如下错误:</p><blockquote class="nv nw nx"><p id="6733" class="jq jr mp js b jt ju jv jw jx jy jz ka ny kc kd ke nz kg kh ki oa kk kl km kn im bi translated"><em class="it">【错误:flutter/lib/ui/ui _ dart _ state . cc(157)】未处理的异常:无效参数:【Set】的实例</em></p></blockquote><p id="a49c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为我们当前的Exercise.toMap()函数没有为Firestore准备嵌套的Set对象。我们需要更新我们的练习类，如下所示:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="924a" class="mb kq it lx b gy mc md l me mf">class Exercise { <br/>final String name; <br/>final String muscle; <br/>List&lt;dynamic&gt; sets = []; <br/>Exercise(this.name, this.muscle); <br/>Map&lt;String, dynamic&gt; toMap() =&gt; {<br/>"name": this.name, <br/>"muscle": this.muscle, <br/>"sets": firestoreSets()}; </span><span id="4d48" class="mb kq it lx b gy mq md l me mf">List&lt;Map&lt;String,dynamic&gt;&gt; firestoreSets() {<br/>    List&lt;Map&lt;String,dynamic&gt;&gt; convertedSets = [];<br/>    this.sets.forEach((set) { <br/>    Set thisSet = set as Set; <br/>    convertedSets.add(thisSet.toMap()); <br/>    }); <br/>return convertedSets; } </span><span id="3369" class="mb kq it lx b gy mq md l me mf">Exercise.fromMap(Map&lt;dynamic, dynamic&gt; map) : <br/>name = map['name'], <br/>muscle = map['muscle'], <br/>sets = map['sets'].map((set) { <br/>return Set.fromMap(set); }).toList(); <br/>}</span></pre><p id="7edc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我添加了一个名为firestoreSets的新函数，它遍历“Sets”变量中的所有Set对象，并将它们转换为地图。如果您再次运行代码，它应该可以工作，甚至更好——您可以向数组中添加任意多个相同的Set对象。</p><figure class="ls lt lu lv gt mh gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/7823987b361038dd08334631c71a3315.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/0*A3TfDp1iApxPK2rE"/></div></figure><h1 id="fc4e" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">最后</h1><p id="4c38" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">这是一篇很长的文章，但是一旦你有了Firestore的基础知识，你可以用云数据库做什么就没有什么限制了(除了使用配额)。随着我了解更多，我会更新这篇文章，所以请定期查看。继续编码！</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="94a4" class="kp kq it bd kr ks oj ku kv kw ok ky kz la ol lc ld le om lg lh li on lk ll lm bi translated">我的设置</h1><p id="af89" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我是一名自学成才的开发人员，我相信适销对路的软件解决方案可以由专注的独狼(或非常小的团队)来创建。我写博客是为了介绍像Flutter、Google Firestore和RevenueCat这样的开发工具，因为我相信在不久的将来，这些工具将会成为每一个成功的移动应用初创企业的必备工具。有了这些，你可以在极短的时间内完成4到5个人的工作。我也写关于计算机知识和效率的博客，因为这两件事都有指数回报。</p><h1 id="bc53" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">五金器具</h1><ul class=""><li id="fe2d" class="nc nd it js b jt ln jx lo kb oo kf op kj oq kn nh ni nj nk bi translated"><a class="ae ko" href="https://amzn.to/3ms7tHA" rel="noopener ugc nofollow" target="_blank">惠普方尖碑台式电脑的预兆</a></li><li id="529f" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated"><a class="ae ko" href="https://amzn.to/2EdH0wc" rel="noopener ugc nofollow" target="_blank">采用英特尔酷睿i9的MacBook Pro</a></li><li id="ffe0" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated"><a class="ae ko" href="https://amzn.to/3mzyfxY" rel="noopener ugc nofollow" target="_blank"> LG 27UL500显示器</a></li><li id="6f84" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated"><a class="ae ko" href="https://amzn.to/33DGQqp" rel="noopener ugc nofollow" target="_blank">两台惠普27英寸LED显示器</a></li><li id="f423" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated"><a class="ae ko" href="https://amzn.to/2FHrxVw" rel="noopener ugc nofollow" target="_blank">海盗船弯刀游戏鼠标</a></li></ul><p id="e17d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mp">原载于2020年7月5日http://lonercoder.wordpress.com</em><a class="ae ko" href="https://lonercoder.wordpress.com/2020/07/05/handling-nested-objects-in-firestore-with-flutter/" rel="noopener ugc nofollow" target="_blank"><em class="mp"/></a><em class="mp">。</em></p></div></div>    
</body>
</html>