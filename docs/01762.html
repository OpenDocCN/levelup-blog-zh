<html>
<head>
<title>How to Create a Perfect Repository Using Kotlin Exclusive Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Kotlin独有的特性创建一个完美的存储库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-perfect-repository-using-kotlin-exclusive-features-61c3121f22df?source=collection_archive---------2-----------------------#2020-01-28">https://levelup.gitconnected.com/how-to-create-a-perfect-repository-using-kotlin-exclusive-features-61c3121f22df?source=collection_archive---------2-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ab1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">组织您的数据和属性域图层</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1743285a8e6a340dfdd2964b455bb129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x198mvOJ1QTIpyTe"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@youxventures?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> You X Ventures </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ff3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一切都始于谷歌为Android引入架构开发。首先，让我们看看为什么移动应用程序开发需要架构。移动开发是过去十年中增长最快的技术之一，每天有数十亿活跃用户来自世界各地。</p><p id="3da5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们拥有如此可观的用户规模时，我们必须放眼全球。将会有来自互联网可能很慢的地方的用户，或者他们无法理解像英语这样的标准语言和许多我们无法想象的用例。</p><p id="c14f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为这样的用户群开发应用并不是一件简单的事情。我们不是为一次性发布创建应用程序；会有更新，所以我们正在编写的代码应该有一个模式，帮助我们重用代码，并使事情尽可能简单。</p><p id="6d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">架构的主要目的之一是提供一个代码库，当需求改变时，它可以快速适应，这意味着需要改变的代码量应该总是最小的。</p><p id="8ea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看谷歌推荐的架构是什么样子的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/d7e611f4de07844a77e0492e2d282196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-yY0l4XD3kLcZz0rO1sfRA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Google推荐设计应用程序架构的方法</figcaption></figure><p id="84d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们讨论一下这个架构的基本内容，然后深入到存储库。</p><p id="ac1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">活动/片段与UI相关，ViewModel负责通过LiveData向UI组件提供数据。ViewModel从存储库中获取数据。最后，我们到了存储库部分。存储库是该架构中唯一依赖于两个因素的组件:远程服务器和本地数据库。这是我们现在需要处理的部分。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f20e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">存储库概述</h1><p id="ba57" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">存储库不应该依赖于远程服务器和本地存储，所以我们需要创建数据源逻辑，存储库从数据源逻辑获取数据，而数据源逻辑将从本地存储获取数据。如果本地数据库中没有数据，它将从远程服务器获取并保存在数据库中，然后发送到存储库。通过这种方式，存储库从单一来源获取数据。</p><p id="4e02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在架构级别进行开发是一件复杂的事情，您应该了解许多概念，并且知道如何在通用格式中使用它们。因此，我将推荐一些文章来帮助你理解高级概念，如果你不熟悉相应的概念，可以先浏览一下。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5d5c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">局部存储器</h1><p id="33a1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">数据的总体来源来自本地存储，所以让我们从那里开始。对于本地存储，Google推荐Room library，这是一个来自jetpack家族的库，充当SQLite上的抽象层。</p><p id="e46d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对房间不熟悉，看看下面这篇文章。</p><div class="na nb gp gr nc nd"><a href="https://medium.com/@sgkantamani/android-room-persistence-library-kotlin-coroutines-26d53a09d384" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">Android Room持久性库🔗科特林协程</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">制造悬念😉数据库ˌ资料库</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ks nd"/></div></div></a></div><p id="d9aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要实现房间数据库，我们需要Dao和实体。看看《道》和《实体》就能得到电影列表</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">获取电影的实体</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">电影岛</figcaption></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="527a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">网络</h1><p id="e840" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">那么下一个数据源来自远程服务器。同样，我们使用谷歌推荐的，也是最著名的图书馆改造。retrieval是一个基于注释的网络库，它使用okhttp进行套接字通信。</p><p id="027a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉翻新，看看下面的文章</p><div class="na nb gp gr nc nd"><a href="https://medium.com/mindorks/understand-how-does-retrofit-work-c9e264131f4a" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">了解改造是如何工作的</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">要成为一名优秀的开发人员，就要知道幕后发生了什么</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="nu l no np nq nm nr ks nd"/></div></div></a></div><p id="2030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们使用Kotlin协程的改型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用协程程序翻新</figcaption></figure><p id="12b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们必须处理全局的错误处理，否则将会出现各种类型的错误，如改造错误或来自服务器的错误。为了首先实现系统的错误处理，我们需要创建一个密封的类来保存所有的状态和数据，比如错误、响应和加载，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要对密封类有一个正确的认识，请参考下面的文章</p><div class="na nb gp gr nc nd"><a href="https://medium.com/@sgkantamani/sealed-classes-in-kotlin-e48e072daca8" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">科特林的密封课堂</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">了解如何在Android中使用密封类</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div></div></a></div><p id="804b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在该用Basedatasource处理错误了。在这里，我们使用高阶函数livedata等来尽可能简化错误处理。看看basedatasource类。</p><p id="3fc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解高阶函数，请参考下面的文章。</p><div class="na nb gp gr nc nd"><a href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">使用Kotlin进行高级Android编程</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">kot Lin-您应该使用的独有功能</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="nv l no np nq nm nr ks nd"/></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="78ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是实现远程服务调用的时候了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6c31" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">数据加载技术</h1><p id="888e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">既然我们已经完成了本地存储和远程服务。是时候处理如何把它们结合起来了。首先，我们需要从本地存储中检索数据，并发出这些数据来更新UI。然后发起远程服务器调用，获取最新数据并保存在本地存储器中；与此同时，我们也必须向UI发出最新的数据。</p><p id="78de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须创建一个策略，在一个地方操作所有这些任务，这样，如果我们将来想要对核心模式进行任何更改，都将很容易。在这里，我们使用Kotlin扩展使它变得简单而全面。看一看</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8bee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先探索一下这个扩展，它声明了两个通用数据类<code class="fe nw nx ny nz b">&lt;T, L&gt;</code>。<code class="fe nw nx ny nz b">T</code>是我们从本地数据库获得的模型，而<code class="fe nw nx ny nz b">L</code>是我们从远程服务器获得的模型。</p><p id="1e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里你会得到一个问题，为什么不用同样的模型？<br/>现在，使用相同的模型似乎是正确和直接的，但我强烈建议保持两种不同的模型。</p><p id="84d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">维护不同类型的优势</p><ol class=""><li id="de1d" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">您不需要为服务器中的更改更新数据库。</li><li id="77f2" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">您不需要遵循服务器命名约定或模式。</li></ol><p id="b278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，扩展有三个参数，我们在这里传递高阶函数。通过名字本身，你就会明白每个功能的用途。</p><p id="0710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在进入实际功能，从<code class="fe nw nx ny nz b">androidx.lifecycle:lifecycle-livedata-ktx</code>的livedata扩展开始。我们使用它是因为它可以接受Dispatcher类型，这有助于我们在带有<code class="fe nw nx ny nz b">Dispatcher.IO</code>的后台线程中运行数据库和网络相关的任务</p><p id="0ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考下面的文章来了解关于Kotlin协程的一切。</p><div class="na nb gp gr nc nd"><a href="https://medium.com/better-programming/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">科特林协程，从基础到高级</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">是时候了:协程在这里</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="oo l no np nq nm nr ks nd"/></div></div></a></div><p id="89fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始探索身体之前，你应该知道什么是发射和发射源。</p><p id="a458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">emit用于将数据发布到livedata中，例如，<code class="fe nw nx ny nz b">emit(data)</code>类似于<code class="fe nw nx ny nz b">livedata.postValue(data)</code>，而emit source用于分配另一个LiveData值，例如，<code class="fe nw nx ny nz b">emitSource(someLiveValue)</code>类似于<code class="fe nw nx ny nz b">data = someLiveData</code></p><p id="2772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在回到函数体，首先我们发布加载类型，这样在UI组件中你可以显示加载，然后在下一步我们执行<code class="fe nw nx ny nz b">roomQueryToRetriveData</code>高阶函数，从本地数据库获取数据，并用<code class="fe nw nx ny nz b">emitSource</code>发布到UI</p><p id="cf3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，UI将使用本地数据库中的数据进行更新。现在是从服务器获取最新数据的时候了，所以我们执行第二个高阶函数<code class="fe nw nx ny nz b">networkRequest</code>，然后我们开始验证请求是否成功。如果网络请求成功，我们必须调用第三个函数<code class="fe nw nx ny nz b">roomQueryToSaveData</code>将数据保存在本地数据库中。</p><p id="0f36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是全部，您已经成功地完成了所有棘手的部分，现在让我们从存储库开始实现它们。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b2a3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">贮藏室ˌ仓库</h1><p id="39dc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">因为我们已经完成了数据加载部分中的所有复杂任务，所以非常简单。看一看</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前一节中的改造网络处理和房间默认支持LiveData，我们在这里的工作非常简单。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d430" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">用例</h1><p id="0193" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">很长一段时间，我认为用例是架构工作的额外负担。显然，我是愚蠢的想法，让我们看看为什么。例如，如果您从五到六个视图模型中访问存储库中的某个功能。那么在将来，如果该功能中有任何需要更改的地方，您需要更改所有这些视图模型中的代码。</p><p id="5cfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，如果您为存储库中的每个功能创建一个用例，并访问这个用例，那么将这些更改应用到代码中就很容易了。这里看一下我从存储库中获取电影的用例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b5c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，如果服务器上的电影有任何变化，我们可以在一个地方处理。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ac9a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">数据映射器</h1><p id="6e7b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">DataMapper是一个简单的Kotlin类，我们在其中发送类型为<code class="fe nw nx ny nz b">T</code>的数据并获取类型为<code class="fe nw nx ny nz b">L</code>的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，我说过对服务器响应和本地存储使用不同的数据类，DataMappers是您根据需要转换类型的地方。如果您有相同的数据库和网络模型，但是您想要使用不同的模型来更新UI，那么您可以在用例中使用这种映射。</p><p id="3ef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，您可以在我们编写的Kotlin扩展中使用数据映射器，转换来自服务器的响应，然后直接将它们保存在本地存储中。通过这种方式，您不需要在每个用例中进行转换，而是选择适合您情况的转换。</p><p id="1dc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据映射器在服务器向您发送服务器时间戳的情况下非常方便，但是您必须显示用户的本地时间戳。这只是一个简单的场景，但是映射器会以一种通用的方式处理这种情况，这样你就不需要在整个项目中编写代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="57a6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">视图模型</h1><p id="181b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">剩下的唯一事情就是从ViewModel发起调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a9b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你能从你的活动/片段中观察到的livedata来更新UI。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="6d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://medium.com/@sgkantamani" rel="noopener">中</a>、<a class="ae ky" href="https://twitter.com/SG5202" rel="noopener ugc nofollow" target="_blank">推特</a>和<a class="ae ky" href="https://www.linkedin.com/in/siva-kantamani-bb59309b/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。</p><p id="616a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>