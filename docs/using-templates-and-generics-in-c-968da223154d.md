# 在 C #中使用模板和泛型

> 原文：<https://levelup.gitconnected.com/using-templates-and-generics-in-c-968da223154d>

![](img/444ac886822a4f50caab2a1bc0086610.png)

学分:PamperedChef

泛型是编程语言的语法组件，可以重复用于不同类型的对象。通常，泛型采用类或函数的形式，它们将类型作为参数。泛型通常也被称为`templates`，在 C++中被正式称为模板。通常，缺乏泛型或模板的编程语言会受到批评。能够在类型之间共享过程代码极大地提高了质量和开发。本文描述了在 pure `C`中实现类似模板功能的一些技术和方法。

# 什么是类型？

泛型和模板允许类型使用相同的代码。但是，在像 C 这样的语言中，真正构成“类型”的是什么呢？与其他面向对象的编程语言不同，C 没有构造和销毁对象的固有概念。语言中也没有固有的继承概念。c 将类型视为内存中具有特定已知数据格式的部分。正式来说，类型分为两类，*标量*和*聚集*类型。

标量类型只保存一个数据项，如`int`或`char*`。这些通常是整数或指针类型。聚合类型保存一个或多个数据值，如任何数组或结构。类型`void*`代表一种特殊的指针类型，它可以指向任何类型，标量或聚集。事实上，`void*`有时可以作为通用代码的一种形式。`string.h`中相当多的函数使用`void*`来读写不同大小的内存块。

因此，C #中的类型必须具有:

*   已知大小
*   一种已知的格式

两种类型可能大小相同，但格式不同。比如，在大多数平台上，`float`和`int`。它们通常具有相同的大小，因此，`sizeof(int) == sizeof(float)`也是如此。然而，它们有完全不同的格式，因此当用特定的函数调用时会有不同的行为。

# 静态模板

可以在 C 中实现的主要模板类型是静态模板。静态模板是在编译时创建的，并且不执行运行时大小检查，因为它们将这一责任转移给了编译器。C 中使用的静态模板类似于 C++语言中的模板，因为它们依赖于实际的类型成员，例如在`struct`的情况下。在 C #中，创建静态模板的唯一本地方法是使用宏。

*注意:使用“静态”一词仅表示“在编译时”。与 C 关键字* `*static*` *无关，表示一个函数有内部联动*

首先，让我们观察静态模板的最简单形式，定义宏:

```
#define DEF(type, name, val) type name = val 
DEF(int, foo, 5); 
// Then used as normal 
printf("%d", foo);
```

上述的`DEF`宏可以使用任何类型的宏，这些宏可以通过`=`操作符初始化。它还可以通过以下方式发挥作用:

```
DEF(const char*, txt, "foo");
```

该模板允许定义基本类型变量所需的代码被*一般化*和*抽象化*。目标是使代码在不同类型之间是可共享的和相似的。然而，这个例子是琐碎的，因为它只提供了很少的简化。真正的力量来自执行更复杂任务的代码。

# 为每一个

在 C 语言中，`for`循环会导致大量的代码非常类型化，导致冗余代码和巨大的源文件。在宏形式的静态模板的帮助下，我们可以使 c 语言中的循环更加流畅。

```
for (int i = 0; i < 10; i++) { 
    printf("%d", i); // ... // 
}
```

有四种不同的语法成分。变量的初始化、终止条件、增量步骤，最后是循环中每次增量执行的实际代码块。给定这四个元素，我们可以构造一个宏，作为一个`foreach`循环。

```
#define FOREACH(type, start, end, fn) \ 
        for (type _foreach_var = start; _foreach_var != end; _foreach_var++) { \ 
        fn(_foreach_var); \ 
                 }
```

该模板适用于原始类型*范围*，其中有一个已知类型、一个起始值、一个结束值和一个适用于该范围每个成员的期望函数。选择名称`_foreach_var`是为了有目的地减少与宏参数之一冲突的可能性。请注意，`fn` *不一定是函数。在这种情况下，您可以为`fn`传递一个宏，它也被称为高阶宏:*

```
#define PRINT_INT(n) printf("%d", n) 
// use FOREACH 
FOREACH(int, 0, 5, PRINT_INT)
```

For 循环模板也可以用在*在一个集合类型的内容上迭代*的循环上，比如一个数组。对于宏来说，使用聚合类型有时甚至更直接，因为我们可以从聚合类型中获得比标量类型更多的信息。使用`sizeof`操作符，我们可以确定一个数组中元素的数量。

```
long nums[4]; 
const size_t nums_count = sizeof(nums) / sizeof(nums[0]); printf("%zu\n", nums_count); 
// 4
```

`sizeof`操作符总是以字节为单位获取`value`的大小。这意味着传递数组将计算该数组的总大小。这不适用于指针类型，因为任何指针的大小总是与`sizeof(void*)`相同。可以从数组中推断出的这些信息可以用来制作一个强大的“foreach”模板:

```
#define FOREACH(arr, fn) \ 
         for (size_t _ind = 0; 
              _ind < sizeof(arr) / sizeof(arr[0]); 
              _ind++) { \ 
       fn(arr[_ind]); \ 
}
```

在上面的`FOREACH`宏中，唯一需要的两个参数是数组本身、`arr`和一些应用于`arr`中每个元素的可调用参数。类型可以用来访问任何数组元素。我们不需要也传入`arr`的类型，因为我们不需要它，我们可以让`fn`处理它。

# 功能

静态模板也可以在 C 中实现，以体现整个功能。当期望的行为比面向循环的模板所能捕获的更复杂时，就需要这种泛型和模板化的方法。通常在 C 中，采用多种不同类型形式的参数将被赋予类型`void*`，另一个`size_t`参数表示`void*`指向的内存大小。这种类型的函数定义用于标准库中，例如函数`memcpy`和`memset`。

使用`void*`的一个问题是缺少类型检查。C 语言中任何类型的地址都可以存储在`void*`中，比如

```
int s = 3; 
char mes[50]; 
long b = 6754333; void* ps = &s; 
void* pmes = mes; 
void* pb = &b;
```

这些都是有效的定义。编译器没有办法解释一个不正确的类型被传递给一个不同类型的`void*`。因此，函数模板提供了一种限制泛型函数接受的类型范围的方法。首先，让我们看一个通过特定字段的值来比较两种聚合类型是否相等的示例:

上面的模板是一个宏，每次被调用时都会产生一个函数定义。该函数接受两个指定类型的`const`指针，并返回比较`field`的结果。所产生的函数名称的末尾附加了类型的名称。我们需要这个等式模板函数的每个定义都有自己的名字，因为 C 不允许函数有相同的名字和冲突的类型。这意味着，使用这个模板

```
FIELD_EQ(point_t, x)
FIELD_EQ(foo_t, x)
```

实际上会分别产生`FIELD_EQ_point_t`和`FIELD_EQ_foo_t`。这里的优点是，我们可以为多种类型创建相同的函数，而无需多次显式写出这些函数。下面是一个既使用函数模板又调用生成函数的示例:

```
typedef struct { 
     int x;
     int y; 
} point_t; FIELD_EQ(point_t, x) int main(void) { 
     point_t f1 = {3, 5}; 
     point_t f2 = {3, 3}; 
     printf("result is %d\n", FIELD_EQ_point_t(&f1, &f2)); 
     return 0; 
}
```

这种函数产生模式可用于在不同类型之间创建相同的 C APIs。

# 结构

在 C 语言中，结构，简称为“结构”，是可以包含不同种类的命名数据字段的集合类型。与其他语言相比，`struct`就像一个没有方法、构造函数和析构函数的对象。结构是由多种标量类型组成的格式化数据块。结构不同于其他语言中的对象，因为没有实现多态性的内置方法。也没有实现继承的本机方法，例如在父结构和子结构的理想情况下。

解释编程语言，特别是 Python，使用对象“头”方法。这意味着，任何被认为是语言的“对象”的结构，在其定义的开头都有一个特殊的字段集合，保存与结构标识相关的信息。这允许所有的结构被转换成一个公共的基本类型`struct`，只要它们在定义任何其他特定字段之前携带这些字段。Python C API 通过一个叫做`PyObject_HEAD`的宏来完成这个任务。这个宏带有标识结构类型、大小等等的字段。

一个更基本的示例如下所示:

在上面的例子中，`obj_t`是所有其他`obj_*_t`相关结构的基础`struct`。它纯粹是用宏`OBJECT_HEAD`定义的，保存了关于结构的类型信息。这个宏是一个模板，任何其他包含`OBJECT_HEAD`的结构都可以被转换成`obj_t`。这可以在`struct`型`obj_int_t`中看到。可转换为`obj_t`的结构类型的创建可通过更高阶的宏模板简单实现:

```
#define OBJECT_START(name) \ 
            struct name { \ 
                  OBJECT_HEAD; #define OBJECT_END(name) }; \ 
           typedef struct name name
```

这两个宏，`OBJECT_START`和`OBJECT_END`允许模板结构的更多标准类型定义。它们保证开始和结束宏之间的任何定义语句将形成一个`obj_t`兼容类型。更重要的是，它确保了类型的名称将存在于`struct <name>`和`<name>`名称空间下。

# 结论

总的来说，用 C 实现模板可以使 C 代码可读性更好，冗余更少，更不容易出错。如果需要的话，它允许有效的开发，而不需要合并或切换到 C++或具有内置模板系统的语言。在 C 中使用泛型和模板还可以使程序更加类型安全，并防止对内存的不当访问。