<html>
<head>
<title>Functional Programming vs OOP in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的函数式编程与面向对象编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-programming-vs-oop-in-javascript-539202768406?source=collection_archive---------9-----------------------#2020-09-07">https://levelup.gitconnected.com/functional-programming-vs-oop-in-javascript-539202768406?source=collection_archive---------9-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="43f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这两种范式有什么区别？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/650a4755a98b6073bec998191de9c36e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZk0Zee2kLp0fis1eoF_Hg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">琼·加梅尔在<a class="ae ky" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="fb86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OOP和函数式编程有什么区别？为了解决这个问题，我们将编写一个小型的网站阶乘计算器。第一种方法使用函数式编程，第二种方法使用OOP。</p><h2 id="115a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">介绍</h2><p id="f125" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我们开始编码之前，我想给你一个面向对象和函数式编程的快速介绍。</p><p id="3027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者都是<a class="ae ky" href="https://en.wikipedia.org/wiki/Programming_paradigm" rel="noopener ugc nofollow" target="_blank">编程范例</a>，不同之处在于它们允许和禁止的技术。</p><p id="7403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些编程语言只支持一种范式，例如<a class="ae ky" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> Haskell </a>(纯函数式)。</p><p id="4bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了支持多种范例的语言(如<a class="ae ky" href="https://en.wikipedia.org/wiki/JavaScript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>)之外，您还可以使用JavaScript来编写面向对象或函数式代码，甚至是两者的混合。</p><h2 id="4798" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">设置</h2><p id="5ab1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我们深入研究这两个范例之间的差异之前，我们需要设置这个项目。</p><p id="9648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们首先创建所有需要的文件和文件夹，如下所示:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5eeb" class="lv lw it mu b gy my mz l na nb">$ mkdir func-vs-oop<br/>$ cd ./func-vs-oop<br/>$ cat index.html<br/>$ cat functional.js<br/>$ cat oop.js</span></pre><p id="d038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用的是<em class="nc"> cat </em>命令，因为它可以在Linux系统和Windows Powershell上运行。</p><p id="4b13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要在<em class="nc">index.html</em>中为阶乘计算器创建一个简单的表单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">index.html</figcaption></figure><p id="6762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了给这个表单一个更好的外观和感觉，我们使用<a class="ae ky" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> bootstrap </a>作为<em class="nc"> CSS框架</em>。如果您在浏览器中显示这个HTML，它应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/68af519c11b5e1e02b5db1a642d45044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFEomeIr5t83vsKwsD72-A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">阶乘计算器</figcaption></figure><p id="bc7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，这个表单不会做任何事情。</p><p id="b1c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是实现一个逻辑，您可以输入一个高达100的数字。点击“计算”按钮后，应在<em class="nc">结果分区</em>中显示结果。我们将以面向对象的方式和函数的方式来实现这一点。</p><h2 id="799e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">功能实现</h2><p id="b2bd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，我们将为函数式编程方法创建一个文件。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="cfcb" class="lv lw it mu b gy my mz l na nb">$ cat functional.js</span></pre><p id="b1a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要一个函数，在将这个文件加载到浏览器中时会调用这个函数。这个函数应该获取表单，然后将我们需要的功能添加到表单的submit-event中。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c15a" class="lv lw it mu b gy my mz l na nb">function addSubmitHandler(tag, handler) {<br/>  const form = getElement(tag);<br/>  form.addEventListener('submit', handler);<br/>}</span><span id="c852" class="lv lw it mu b gy ng mz l na nb">addSubmitHandler('#factorial-form', factorialHandler);</span></pre><p id="abdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们声明名为<em class="nc"> addSubmitHandler </em>的函数。</p><p id="ae5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数接受两个参数，第一个是我们希望在HTML中查找的标签，第二个是我们希望绑定到元素的submit-event的函数。</p><p id="cb8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们通过传入<em class="nc"> #factorial-form </em>和函数名<em class="nc"> factorialHandler </em>来调用这个函数。标签前面的hashtag表示我们正在HTML中寻找id属性。</p><p id="076f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您现在尝试运行它，这段代码将会抛出一个错误，因为无论是函数<em class="nc"> getElement </em>还是<em class="nc"> factorialHandler </em>都没有在任何地方定义。</p><p id="53de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们首先在我们的<em class="nc"> addSubmitHandler </em>函数上面定义<em class="nc"> getElement </em>，如下所示:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2808" class="lv lw it mu b gy my mz l na nb">function getElement(tag) {<br/>  return document.querySelector(tag);<br/>}</span></pre><p id="4b5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数非常简单，只返回我们通过传入的标签找到的HTML元素。</p><p id="6a24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们稍后会重用这个函数。</p><p id="7e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们开始创建核心逻辑，在<em class="nc"> addSubmitHandler </em>之上添加<em class="nc"> factorialHandler </em>函数。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2354" class="lv lw it mu b gy my mz l na nb">function factorialHandler(event) {<br/>  event.preventDefault();<br/>  const inputNumber = getValueFromElement('#factorial');<br/>  try {<br/>    const result = calculateFactorial(inputNumber);<br/>    displayResult(result);<br/>  } catch (error) {<br/>    alert(error.message);<br/>  }<br/>}</span></pre><p id="fe5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们传入事件并立即调用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault" rel="noopener ugc nofollow" target="_blank"><em class="nc">prevent default</em></a>。这将阻止提交事件的默认行为，你可以在不调用<em class="nc"> preventDefault </em>的情况下尝试一下点击按钮会发生什么。</p><p id="9fad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们通过调用函数<em class="nc">getvaluefrommelement</em>从输入字段获取用户输入的值。得到数字后，我们尝试使用函数<em class="nc"> calculateFactorial </em>计算阶乘，然后通过将结果传递给函数<em class="nc"> displayResult </em>将结果呈现到页面。</p><p id="aac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果值的格式不正确，或者数字大于100，我们将抛出一个错误，并显示为警报。这就是在这种特殊情况下使用try-catch块的原因。</p><p id="787e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步，我们再创建两个助手函数，<em class="nc">getvaluefrommelement，</em>和<em class="nc"> displayResult </em>。让我们将它们添加到<em class="nc"> getElement </em>函数的下面。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="bad9" class="lv lw it mu b gy my mz l na nb">function getValueFromElement(tag) {<br/>  return getElement(tag).value;<br/>}</span><span id="09f1" class="lv lw it mu b gy ng mz l na nb">function displayResult(result) {<br/>  getElement('#factorial-result').innerHTML = result;<br/>}</span></pre><p id="08a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个函数都使用我们的<em class="nc"> getElement </em>函数。这种可重用性是函数式编程如此有效的原因之一。</p><p id="eb41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使其更加可重用，我们可以潜在地为<em class="nc"> displayResult </em>添加第二个参数，称为tag。以便我们可以动态地设置应该显示结果的元素。但是在这个例子中，我采用了硬编码的方式。</p><p id="1b6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们在<em class="nc">阶乘处理程序</em>的正上方创建<em class="nc">计算阶乘</em>函数。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="16e9" class="lv lw it mu b gy my mz l na nb">function calculateFactorial(number) {<br/>  if (validate(number, REQUIRED) &amp;&amp; validate(number, MAX_LENGTH, 100) &amp;&amp; validate(number, IS_TYPE, 'number')) {<br/>    return factorial(number);<br/>  } else {<br/>    throw new Error('Invalid input — either the number is to big or it is not a number');<br/>  }<br/>}</span></pre><p id="7a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们验证参数“number”是否不为空，不超过100，并且属于number类型。为此，我们使用一个名为<em class="nc"> validate </em>的函数，我们接下来需要创建这个函数。如果检查通过，我们调用函数<em class="nc">阶乘</em>并返回其结果。如果这些检查没有通过，我们将抛出在<em class="nc">阶乘处理程序</em>函数中捕获的错误。</p><p id="0d25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们在<em class="nc"> displayResult </em>下面创建<em class="nc"> validate </em>函数和三个常量MAX_LENGTH、IS_TYPE和REQUIRED。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="52c8" class="lv lw it mu b gy my mz l na nb">const MAX_LENGTH = 'MAX_LENGTH';<br/>const IS_TYPE = 'IS_TYPE';<br/>const REQUIRED = 'REQUIRED';</span><span id="2e4b" class="lv lw it mu b gy ng mz l na nb">function validate(value, flag, compareValue) {<br/>  switch (flag) {<br/>    case REQUIRED:<br/>      return value.trim().length &gt; 0;<br/>    case MAX_LENGTH:<br/>      return value &lt;= compareValue;<br/>    case IS_TYPE:<br/>      if (compareValue === 'number') {<br/>        return !isNaN(value);<br/>      } else if (compareValue === 'string') {<br/>        return isNaN(value);<br/>      }<br/>    default:<br/>      break;<br/>  }<br/>}</span></pre><p id="a5a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个函数中，我们使用一个开关来决定我们将要执行哪种验证。确定之后，就是简单的值验证了。</p><p id="2007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将在<em class="nc"> calculateFactorial </em>声明的正上方添加实际的<em class="nc"> factorial </em>函数。这将是这种方法的最后一个功能。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="d2ee" class="lv lw it mu b gy my mz l na nb">function factorial(number) {<br/>  let returnValue = 1;<br/>  for (let i = 2; i &lt;= number; i++) {<br/>    returnValue = returnValue * i;<br/>  }<br/>  return returnValue;<br/>}</span></pre><p id="3a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多不同的方法来执行阶乘计算，我用的是迭代法。</p><p id="51a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于不同方法的信息，我推荐你查看GeeksForGeeks上的这篇文章:<a class="ae ky" href="https://www.geeksforgeeks.org/program-for-factorial-of-a-number/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/program-for-factorial-of-a-number/</a></p><p id="8420" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的<strong class="lb iu"> functional.js </strong>文件应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">functional.js</figcaption></figure><p id="879a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种方法中，我们专门处理函数。每个功能都有一个单一的目的，其中大部分可以在应用程序的其他部分重用。</p><p id="cc41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个简单的web应用程序，函数式方法有点矫枉过正。接下来，我们将编写相同功能的代码，但这次是面向对象的。</p><h2 id="940a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">面向对象的实现</h2><p id="8be4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，我们需要将我们的<em class="nc">index.html</em>文件的script-tag中的src修改如下。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="35c2" class="lv lw it mu b gy my mz l na nb">&lt;script src=”oop.js” defer&gt;&lt;/script&gt;</span></pre><p id="dcc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们创建了<em class="nc"> oop.js </em>文件。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6ed5" class="lv lw it mu b gy my mz l na nb">$ cat oop.js</span></pre><p id="c88f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于OOP方法，我们想要创建三个不同的类，一个用于验证，一个用于阶乘计算，一个用于处理表单。</p><p id="2904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从创建处理表单的类开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">输入形式</figcaption></figure><p id="b36e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构造函数中，我们获取表单元素和输入元素，并将其存储在类变量中，也称为属性。之后，我们将方法<em class="nc"> factorialHandler </em>添加到提交事件中。在这种情况下，我们需要将类的“this”绑定到方法上。</p><p id="91f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们不这样做，我们将得到引用错误，例如调用<em class="nc"> this.numberInput.value </em>将是未定义的。之后，我们创建类方法<em class="nc"> factorialHandler </em>，将事件作为参数。</p><p id="af39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法的代码应该看起来有些熟悉，例如，if语句检查输入值是否有效，就像我们在<em class="nc"> calculateFactorial </em>函数中所做的那样。</p><p id="d892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nc"> Validator.validate </em>是对我们仍然需要创建的类<em class="nc"> Validator </em>内部的静态方法的调用。如果我们使用静态方法，我们不需要初始化一个对象的新实例。验证通过后，我们创建一个新的<em class="nc">阶乘类</em>实例，传入输入值，然后向用户显示计算结果。</p><p id="e675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将在<em class="nc"> InputForm类</em>的正上方创建<em class="nc">验证器类</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">验证器</figcaption></figure><p id="3a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，这个类中的所有东西都是静态的，方法<em class="nc">验证了</em>以及三个属性。因此我们不需要任何构造函数。这样做的好处是，我们不需要每次想使用这个类时都初始化它。</p><p id="a462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nc"> validate </em>与<em class="nc"> validate </em>基本相同，validate 函数是我们的<em class="nc"> functional.js </em>，除了我们这样做<em class="nc">。必修</em>，<em class="nc">本。MAX_LENGTH </em>和<em class="nc"> this。IS_TYPE* </em>而不仅仅是变量名。</p><p id="c3b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们在<em class="nc">验证器类</em>的正下方创建我们的<em class="nc">阶乘类</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">阶乘</figcaption></figure><p id="adb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在初始化这个类的一个实例时，我们得到了<em class="nc"> resultElement </em>，并把它作为一个属性和我们传入的数字存储起来。之后，我们调用方法<em class="nc">计算</em>并将它的返回值存储在一个属性中。<em class="nc">计算</em>方法包含与<em class="nc"> functional.js </em>中的<em class="nc">阶乘</em>函数相同的代码。最后但同样重要的是，我们得到了<em class="nc"> display </em>方法，该方法将<em class="nc"> resultElement </em>的<em class="nc"> innerHTML </em>设置为计算出的阶乘数。</p><p id="0b91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的<em class="nc"> oop.js </em>文件应该是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">oop.js</figcaption></figure><p id="79b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了三个不同的类来处理应用程序的三个不同方面:</p><p id="6b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">-验证:<strong class="lb iu">验证类</strong></p><p id="4ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">-阶乘处理:<strong class="lb iu">阶乘类</strong></p><p id="3338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">-表单处理:<strong class="lb iu">输入表单类</strong></p><h2 id="c5e4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="9294" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这两种方法都是构建代码的有效方式。我喜欢尝试在我从事的不同项目中最有效的方法。大多数时候，甚至不可能如此清晰地区分两种范式。</p><p id="61cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这个小小的比较能让您对不同的方法有一个基本的了解。</p><p id="3fa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，你可以在我的<a class="ae ky" href="https://github.com/JakobKIT/func-vs-oop" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到该项目的代码。</p></div></div>    
</body>
</html>