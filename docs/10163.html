<html>
<head>
<title>Review: Rigetti’s quilc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回顾:里盖蒂的quilc</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/review-rigettis-quilc-579aa434815?source=collection_archive---------1-----------------------#2021-11-01">https://levelup.gitconnected.com/review-rigettis-quilc-579aa434815?source=collection_archive---------1-----------------------#2021-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/1291775dc1d90b717c3abd78d0deaafb.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*a5fFMuJjpjuwDCtXRL8t_g.png"/></div></figure><div class=""/><h1 id="9210" class="jx jy ja bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">quil语言编译器</h1><p id="29f0" class="pw-post-body-paragraph kv kw ja kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我被要求回顾Rigetti的quilc，所以显而易见的第一个问题是:quilc是什么？你可能听说过Rigetti的quil语言；quilc是这种语言的编译器。你可能会问，什么是编译器？让我们一起虚拟漫步吧，年轻的学徒…</p><h2 id="754a" class="lt jy ja bd jz lu lv dn kd lw lx dp kh lg ly lz kl lk ma mb kp lo mc md kt me bi translated">quilc是给程序员用的</h2><p id="a1ed" class="pw-post-body-paragraph kv kw ja kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">Python是量子计算的语言，因为它又快又容易学。你不必成为一个铁杆程序员来使用它，因为Python抽象出了细节。你可以专注于物理和化学等等，而不用担心你的经典计算机硬件在做什么。这类似于对量子位应用哈达玛门；你可以在没有任何微波脉冲知识的情况下进行量子计算。</p><p id="0005" class="pw-post-body-paragraph kv kw ja kx b ky mf la lb lc mg le lf lg mh li lj lk mi lm ln lo mj lq lr ls im bi translated">在命令行界面、对Linux的强调、文档中的一些参考等等之间，quilc显然是面向程序员的。所以，如果你不是程序员，也不想成为程序员，让我们先确定quilc是为程序员准备的。</p><h2 id="8198" class="lt jy ja bd jz lu lv dn kd lw lx dp kh lg ly lz kl lk ma mb kp lo mc md kt me bi translated">汇编</h2><p id="0b2f" class="pw-post-body-paragraph kv kw ja kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当你运行Python代码时，你只是运行它。你的电脑会在运行过程中计算出它在做什么。但是，你的电脑不懂Python。就此而言，它不理解任何其他语言。所以，这意味着你首选的编程语言必须首先被翻译成你的计算机能够理解的代码。这需要时间。</p><p id="d54c" class="pw-post-body-paragraph kv kw ja kx b ky mf la lb lc mg le lf lg mh li lj lk mi lm ln lo mj lq lr ls im bi translated">所以很多编程语言都是编译的。我的源代码在执行之前被优化并翻译成机器码，因此运行我的应用程序比其他情况下更快。当在你的屏幕上显示“你好，世界”时，这有关系吗？不能。但是，对于要求高性能的应用程序，绝对可以。</p><h2 id="b9c0" class="lt jy ja bd jz lu lv dn kd lw lx dp kh lg ly lz kl lk ma mb kp lo mc md kt me bi translated">减速</h2><p id="111d" class="pw-post-body-paragraph kv kw ja kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">使用Python，您只需点击“运行”按钮。没有比这更简单的了。编译会减慢速度，这取决于需要编译多少代码。这里不需要太多的技术，你可以把它看作一个额外的步骤:编译然后运行，而不仅仅是运行。在所有其他条件相同的情况下，两步比一步耗时更长，尤其是当第一步可能需要一段时间的时候。</p><p id="26f5" class="pw-post-body-paragraph kv kw ja kx b ky mf la lb lc mg le lf lg mh li lj lk mi lm ln lo mj lq lr ls im bi translated">但是，等等，我刚才不是提到了性能吗？是的，但那是运行时间。Python之所以吸引人，是因为开发生命周期很快。不断的重新编译减缓了开发生命周期，但最终换来的是卓越的性能。例如，这就是为什么Tesla快速开发Python应用程序，然后将其翻译成C++以提高性能的原因。</p><h2 id="dac9" class="lt jy ja bd jz lu lv dn kd lw lx dp kh lg ly lz kl lk ma mb kp lo mc md kt me bi translated">最佳化</h2><p id="5de3" class="pw-post-body-paragraph kv kw ja kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">除了缩短经典运行时间(不是量子处理器的排队时间，那是不同的)之外，quilc声称提供了多种优化功能:</p><ol class=""><li id="7cce" class="mk ml ja kx b ky mf lc mg lg mm lk mn lo mo ls mp mq mr ms bi translated">Rigetti处理器的门优化</li><li id="536e" class="mk ml ja kx b ky mt lc mu lg mv lk mw lo mx ls mp mq mr ms bi translated">量子位重新布线，这是一件大事:你可以专注于让你的算法工作，而编译器根据最佳连接分配物理量子位，从而最小化CNOT门数量和电路深度</li></ol><figure class="mz na nb nc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi my"><img src="../Images/b33001b8e463776e1f818df1422b85bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ld4acBShFzWI5QMWSCxWJA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">IBM量子传输电路最初有一个交换门(三个CNOT门)</figcaption></figure><p id="211c" class="pw-post-body-paragraph kv kw ja kx b ky mf la lb lc mg le lf lg mh li lj lk mi lm ln lo mj lq lr ls im bi translated">3.量子位重新布线以防止早期交换门；上面的IBM量子传输电路显示了量子位1和量子位3之间的交换，quilc承诺通过重新布线来消除这种交换</p><p id="8000" class="pw-post-body-paragraph kv kw ja kx b ky mf la lb lc mg le lf lg mh li lj lk mi lm ln lo mj lq lr ls im bi translated">4.可移植性，也就是说你可以在不同的设备上运行你的电路，量子位重新布线将为你优化量子位分配</p><h2 id="e732" class="lt jy ja bd jz lu lv dn kd lw lx dp kh lg ly lz kl lk ma mb kp lo mc md kt me bi translated">多线程操作</h2><p id="70cd" class="pw-post-body-paragraph kv kw ja kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这又是一个关于经典代码的性能问题。想象一下，你可以同时对你所有的量子位进行操作，而不是一次一个量子位地顺序操作。经典计算通常被认为是顺序的，事实也的确如此，但是也有可能同时并行执行代码。因此，除了通过编译加速经典代码之外，quilc还允许您最大限度地利用经典硬件。</p><h2 id="7005" class="lt jy ja bd jz lu lv dn kd lw lx dp kh lg ly lz kl lk ma mb kp lo mc md kt me bi translated">术语</h2><p id="4ec9" class="pw-post-body-paragraph kv kw ja kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我对quilc的主要问题是Rigetti似乎对所有事情都使用专有术语。不要误解我:一切都是显而易见的。但是，量子计算已经被拥有多个名字的事物所困扰；我们需要的是缓解，而不是加剧。我希望所有与会者能在某个时候努力实现术语的标准化。</p><p id="a00c" class="pw-post-body-paragraph kv kw ja kx b ky mf la lb lc mg le lf lg mh li lj lk mi lm ln lo mj lq lr ls im bi translated">因为除了熟悉Rigetti的术语之外，别忘了在使用他们的quilc编译器之前，你还必须学习他们的quil语言。而且，如果你不是程序员，可能有些编程概念对你来说是新的。其中至少有两个似乎是不必要的使用障碍。</p><h2 id="5264" class="lt jy ja bd jz lu lv dn kd lw lx dp kh lg ly lz kl lk ma mb kp lo mc md kt me bi translated">结论</h2><p id="0074" class="pw-post-body-paragraph kv kw ja kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">你以前编译过代码吗？在NISQ时代很难证明这一点，尽管目前还没有量子应用。但是，如果我有大量的量子位和一个真实世界的应用程序，我至少要运行一个基准测试实验。现在，您可以开始使用quilc为这种可能性做准备，但是只要我们处于探索模式——这是来自一个C程序员——就很难证明与Python相比更长的开发时间是合理的。也就是说，这只是一种可能性；Rigetti为后NISQ时代做了很好的定位。</p></div></div>    
</body>
</html>