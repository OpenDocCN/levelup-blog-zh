<html>
<head>
<title>Learning JavaScript: The Queue Data Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习JavaScript:队列数据结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-javascript-the-queue-data-structure-152dd0f2fde?source=collection_archive---------13-----------------------#2021-01-28">https://levelup.gitconnected.com/learning-javascript-the-queue-data-structure-152dd0f2fde?source=collection_archive---------13-----------------------#2021-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a9e969f4fe9010d5a9c355f2c610a2cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l54vnNl6BiMYWN1Y"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@macauphotoagency?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">澳门图片社</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c667" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上一篇文章中，我讨论了堆栈数据结构。栈是数据结构的一个例子，其中最后进入栈的数据是第一个从栈中出来的数据。我用的一个例子是自助餐厅里的一堆托盘，顾客只能从上面拿走一个托盘，洗碗机也只能把一个干净的托盘放在上面。换句话说，一切都发生在栈顶。</p><p id="676f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，队列数据结构就像你在杂货店排队一样。排队时，你从后面排队，从前面排队。因此，进入队列的第一个数据就是离开队列的第一个数据。这是队列和堆栈的主要区别。</p><p id="671a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像堆栈一样，队列只有一些操作。队列实现对这些操作使用相似的名称。向队列中添加新数据是一种推送操作，从队列中删除数据是一种弹出操作。与只能查看堆栈顶部的堆栈不同，使用队列可以查看队列的前面和后面。</p><p id="5874" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">了解了这些背景知识之后，让我们来看看JavaScript队列实现。</p><h1 id="c2c6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设计队列类</h1><p id="da16" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我已经定义了四个<code class="fe mh mi mj mk b">Queue</code>类行为:<code class="fe mh mi mj mk b">push</code>、<code class="fe mh mi mj mk b">pop</code>、<code class="fe mh mi mj mk b">front</code>和<code class="fe mh mi mj mk b">back</code>。我需要一个方法来告诉我队列中有多少元素——<code class="fe mh mi mj mk b">size</code>方法。我需要一个方法来测试队列是否为空——<code class="fe mh mi mj mk b">empty</code>方法，并且我需要一个方法来从队列中移除所有元素(当然你已经在杂货店排队并且在轮到你之前关闭了收银机)—<code class="fe mh mi mj mk b">clear</code>方法。</p><p id="b828" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还需要决定使用什么数据结构来存储我的队列元素。对于这个实现，我将使用一个数组。</p><p id="2f4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我的<code class="fe mh mi mj mk b">Queue</code>类定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0519" class="mt lf it mk b gy mu mv l mw mx">class Queue {<br/>  constructor() {<br/>    this.dataStore = [];<br/>  }</span><span id="1187" class="mt lf it mk b gy my mv l mw mx">  push(element) {<br/>    this.dataStore.push(element);<br/>  }</span><span id="fe4c" class="mt lf it mk b gy my mv l mw mx">  pop() {<br/>    this.dataStore.shift();<br/>  }</span><span id="9d4f" class="mt lf it mk b gy my mv l mw mx">  front() {<br/>    return this.dataStore[0];<br/>  }</span><span id="7f4c" class="mt lf it mk b gy my mv l mw mx">  back() {<br/>    return this.dataStore[this.dataStore.length-1];<br/>  }</span><span id="2731" class="mt lf it mk b gy my mv l mw mx">  empty() {<br/>    return this.dataStore.length == 0;<br/>  }</span><span id="ec5c" class="mt lf it mk b gy my mv l mw mx">  size() {<br/>    return this.dataStore.length;<br/>  }</span><span id="3f00" class="mt lf it mk b gy my mv l mw mx">  clear() {<br/>    while (this.dataStore.length != 0) {<br/>      this.dataStore.pop();<br/>    }<br/>  }<br/>}</span></pre><p id="a1f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试这个定义的简短程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a2f5" class="mt lf it mk b gy mu mv l mw mx">let line = new Queue()<br/>line.push("Mike");<br/>line.push("Cynthia");<br/>putstr("Front of line: ");<br/>print(line.front());<br/>putstr("Back of line: ");<br/>print(line.back());<br/>line.push("Jonathan");<br/>putstr("Number of people in line: ");<br/>print(line.size());<br/>putstr("Back of line is now: ");<br/>print(line.back());<br/>line.pop();<br/>putstr("Front of line: ");<br/>print(line.front());<br/>putstr("Back of line: ");<br/>print(line.back());<br/>print("Closing line.");<br/>line.clear();<br/>if (line.empty()) {<br/>  print("Line is now empty.");<br/>}<br/>else {<br/>  putstr("Number of people in line: ");<br/>  print(line.size());<br/>}</span></pre><p id="dfee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="14d5" class="mt lf it mk b gy mu mv l mw mx">Front of line: Mike<br/>Back of line: Cynthia<br/>Number of people in line: 3<br/>Back of line is now: Jonathan<br/>Front of line: Cynthia<br/>Back of line: Jonathan<br/>Closing line.<br/>Line is now empty.</span></pre><h1 id="889c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">一些队列应用程序</h1><p id="f8fe" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">队列有几个有用的应用。队列通常用于模拟研究，其中研究顾客流。例如，一家杂货店需要多少个自助检查岛来防止顾客队伍在购物高峰期间积压过多？模拟程序将使用队列数据结构来表示商店中的每一行。</p><p id="9799" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于第一个例子，我将编写一个小程序，实现一个队列调度程序来跟踪一个主管的日常约会。行政助理收集第二天的新约会，并将它们存储在约会队列中。</p><p id="b742" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二天开始时，访问约会队列并显示第一个约会。完成后，它将被删除，并显示下一个预约时间。这一直持续到队列为空。</p><p id="513b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还创建了一个新的类来存储时间。程序是这样的:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9323" class="mt lf it mk b gy mu mv l mw mx">class Time {<br/>  constructor(hour, minute) {<br/>    this.hour = hour;<br/>    this.minute = minute;<br/>  }</span><span id="2172" class="mt lf it mk b gy my mv l mw mx">  show() {<br/>    return this.hour + ":" + this.minute;<br/>  }<br/>}</span><span id="f8b9" class="mt lf it mk b gy my mv l mw mx">let appts = new Queue();<br/>for (let i = 1; i &lt;= 6; i++) {<br/>  putstr("Enter appointment hour: ");<br/>  let hour = parseInt(readline());<br/>  putstr("Enter appointment minute: ");<br/>  let minute = parseInt(readline());<br/>  let theTime = new Time(hour, minute);<br/>  appts.push(theTime);<br/>}<br/>print("Appointments for the day: ");<br/>let nextAppt = "n";<br/>while (!appts.empty()) {<br/>  putstr("Time: ");<br/>  print(appts.front().show());<br/>  appts.pop();<br/>}</span></pre><p id="51b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序运行一次的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cec7" class="mt lf it mk b gy mu mv l mw mx">C:\js&gt;js queue.js<br/>Enter appointment hour: 8<br/>Enter appointment minute: 15<br/>Enter appointment hour: 9<br/>Enter appointment minute: 20<br/>Enter appointment hour: 10<br/>Enter appointment minute: 25<br/>Enter appointment hour: 11<br/>Enter appointment minute: 25<br/>Enter appointment hour: 12<br/>Enter appointment minute: 30<br/>Enter appointment hour: 1<br/>Enter appointment minute: 15<br/>Appointments for the day:<br/>Time: 8:15<br/>Time: 9:20<br/>Time: 10:25<br/>Time: 11:25<br/>Time: 12:30<br/>Time: 1:15</span></pre><p id="2257" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了进行第二次演示，我将借用Timothy Budd所著的《C++ 中的<em class="mz">数据结构》一书中的一个模拟示例。这个模拟是一个银行出纳员模拟，可以帮助银行确定在任何一个时间应该开放多少个出纳员柜台，以最大限度地减少客户等待帮助的时间。</em></p><p id="1b62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该程序创建了两个类——一个<code class="fe mh mi mj mk b">Customer</code>类和一个<code class="fe mh mi mj mk b">Teller</code>类。<code class="fe mh mi mj mk b">Customer</code>类跟踪两条数据:顾客排队到达的时间和他们与出纳员相处的时间。<code class="fe mh mi mj mk b">Teller</code>类还必须跟踪两条数据:他们是否在帮助客户，以及他们开始帮助客户的时间。</p><p id="7117" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是这两个类别的定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="57e0" class="mt lf it mk b gy mu mv l mw mx">class Customer {<br/>  constructor(arrival) {<br/>    this.arrivalTime = arrival;<br/>    this.processTime = 2 + parseInt(Math.random() * (6-1) + 1);<br/>  }</span><span id="ac3d" class="mt lf it mk b gy my mv l mw mx">  done() {<br/>    return --this.processTime &lt; 0;<br/>  }</span><span id="f454" class="mt lf it mk b gy my mv l mw mx">  arrival() {<br/>    return this.arrivalTime;<br/>  }<br/>}</span><span id="b1cb" class="mt lf it mk b gy my mv l mw mx">class Teller {<br/>  constructor() {<br/>    this.free = true;<br/>  }</span><span id="a382" class="mt lf it mk b gy my mv l mw mx">  isFree() {<br/>    if (this.free) { return true };<br/>    if (this.customer.done()) {<br/>      this.free = true;<br/>      return this.free;<br/>    }<br/>  }</span><span id="9e11" class="mt lf it mk b gy my mv l mw mx">  addCustomer(c) {<br/>    this.customer = c;<br/>    this.free = false;<br/>  }<br/>}</span></pre><p id="1a9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Customer</code>物体排成一行，然后离开。<code class="fe mh mi mj mk b">Teller</code>对象要么有空见新客户，要么正忙着帮助客户。</p><p id="c4cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个程序，使用这些类来执行一个简单的银行出纳员模拟。您可以通过更改柜员数量来改变平均等待时间，从而决定您的银行应该有多少柜员队伍。</p><p id="75a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="54d3" class="mt lf it mk b gy mu mv l mw mx">let tellers = 2;<br/>let minutes = 60;<br/>let totalWait = 0;<br/>let customers = 0;<br/>let line = new Queue();<br/>let teller = new Array(tellers);<br/>for (let i = 0; i &lt; tellers; i++) {<br/>  teller[i] = new Teller();<br/>}<br/>for (let time = 0; time &lt; minutes; time++) {<br/>  if (parseInt(Math.random() * (10-1) + 1) &lt; 9) {<br/>    let newCustomer = new Customer(time);<br/>    line.push(newCustomer);<br/>  }<br/>  for (let i = 0; i &lt; tellers; i++) {<br/>    if (teller[i].isFree() &amp;&amp; !line.empty()) {<br/>      let frontCustomer = line.front();<br/>      customers++;<br/>      totalWait += (time - frontCustomer.arrival());<br/>      teller[i].addCustomer(frontCustomer);<br/>      line.pop();<br/>    }<br/>  }<br/>}<br/>print("Average wait: " + (totalWait / customers));</span></pre><p id="68b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是将出纳员数量设置为2的程序的一次运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7da9" class="mt lf it mk b gy mu mv l mw mx">Average wait: 16.571428571428573</span></pre><p id="8b75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是当我将出纳员的数量增加到5时，平均等待时间的变化情况:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="54a9" class="mt lf it mk b gy mu mv l mw mx">Average wait: 2</span></pre><p id="e3a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">队列可以用于其他应用，但模拟是它们最受欢迎的用途。</p><p id="3393" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种类型的队列是优先级队列，其中存储在队列中的元素具有优先级权重，并且那些具有较高优先级的元素比具有较低优先级的元素更快地从队列中弹出。优先排队的一个很好的例子是医院急诊部的候诊室。断腿比发烧更重要，会更快得到医生的治疗。我将在以后的文章中详细介绍优先级队列的实现。</p><p id="a2a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请回复本文或给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>