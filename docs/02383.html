<html>
<head>
<title>5 beautiful android animation libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个漂亮的android动画库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-beautiful-android-animation-libraries-2020-470e01875e66?source=collection_archive---------4-----------------------#2020-03-10">https://levelup.gitconnected.com/5-beautiful-android-animation-libraries-2020-470e01875e66?source=collection_archive---------4-----------------------#2020-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/53cbce2d0658948c589590a59b9d7e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*UL_OGNvmyflM5tguQYYBsA.gif"/></div></figure><p id="d9eb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在现代技术世界中，每个人都试图通过他们的应用程序/网站为他们的用户提供流畅而美丽的体验。公司希望抓住用户的注意力，让他们的应用程序尽可能具有交互性</p><p id="22af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">动画在这方面起着至关重要的作用。他们有两个目的:<br/> <strong class="jw ir"> 1) </strong>设计中的动画可以通过给应用程序带来生命来改善用户体验。</p><p id="9889" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 2) </strong>它们是意义、功能性的，并给予用户流畅的交互。</p><p id="981d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，设计中的动画只有在正确的地方和正确的时间被结合才能增强用户体验。你可以查看UI动画的详细指南，并在这篇由<a class="ae ks" href="https://uxdesign.cc/@skytskyi?source=post_page-----10bd98614fa9----------------------" rel="noopener" target="_blank"> Taras Skytskyi </a>撰写的文章<a class="ae ks" href="https://uxdesign.cc/the-ultimate-guide-to-proper-use-of-animation-in-ux-10bd98614fa9" rel="noopener" target="_blank"> here </a> <strong class="jw ir"> </strong>中了解好的和坏的动画背后的物理原理。</p><p id="84c0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在今天的文章中，我将展示几个漂亮的动画开源库，并逐一实现它们。让我们从我们的第一个动画开始。</p><h1 id="6c9e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">ShimmerLayout —</h1><p id="272d" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">脸书首先引入了闪烁布局效果来显示加载状态，而不是默认的进度条。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/215efd4495c2e593c052f99b19a2da05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*_xlUphZ5h1NaC0VKb8wXdA.gif"/></div></figure><h2 id="11ed" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">步骤1 —添加依赖关系</h2><p id="66b1" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">你可以在这里找到这个库的最新版本<a class="ae ks" href="https://github.com/team-supercharge/ShimmerLayout" rel="noopener ugc nofollow" target="_blank"/></p><pre class="lw lx ly lz gt mm mn mo mp aw mq bi"><span id="8931" class="ma ku iq mn b gy mr ms l mt mu">implementation 'io.supercharge:shimmerlayout:2.1.0'</span></pre><h2 id="d006" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">第2步—编辑布局</h2><p id="0992" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">要使用这种效果，我们必须修改我们的布局并用特定的标签包装我们的组件:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">布局— activity_main.xml</figcaption></figure><h2 id="10ec" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">最后一步—开始动画</h2><p id="72be" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在，我们可以通过一行代码简单地启动和停止布局上的动画。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">activity-main activity . XML</figcaption></figure><p id="0db5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更多细节可以访问这个库的GitHub repo..<a class="ae ks" href="https://github.com/team-supercharge/ShimmerLayout" rel="noopener ugc nofollow" target="_blank"> @ </a></p><h1 id="bfed" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">空间选项卡布局—</h1><p id="6c35" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">这是一个RelativeLayout的自定义实现，可以与ViewPager一起使用，在片段之间导航。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/85b9642054e0cd5f98caae9e64da486d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*5x-6p2ZpMi9dOrB-pPiPWg.gif"/></div></figure><h2 id="0819" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">步骤1 —添加依赖关系</h2><p id="6716" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">你可以在这里找到这个库的最新版本<a class="ae ks" href="https://github.com/long1eu/SpaceTabLayout" rel="noopener ugc nofollow" target="_blank"/></p><pre class="lw lx ly lz gt mm mn mo mp aw mq bi"><span id="0f01" class="ma ku iq mn b gy mr ms l mt mu">implementation 'eu.long1:spacetablayout:1.0.4'</span></pre><h2 id="a1c4" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">第2步—编辑布局</h2><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="73f0" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">步骤3 —创建片段</h2><p id="0621" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">根据需要创建新的片段类。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/cf0a73c532464d0e5998e00586f419e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ti_o-hLh1zhq_gzFX7JnZw.png"/></div></div></figure><h2 id="7e4b" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">最后一步—设置活动分类</h2><ul class=""><li id="f47d" class="ng nh iq jw b jx lr kb ls kf ni kj nj kn nk kr nl nm nn no bi translated">初始化视图。</li><li id="dd4e" class="ng nh iq jw b jx np kb nq kf nr kj ns kn nt kr nl nm nn no bi translated">创建一个包含片段的列表</li><li id="e2cb" class="ng nh iq jw b jx np kb nq kf nr kj ns kn nt kr nl nm nn no bi translated">用视图页和片段列表初始化选项卡布局</li></ul><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5184" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更多细节可以访问这个库的GitHub repo..<a class="ae ks" href="https://github.com/long1eu/SpaceTabLayout" rel="noopener ugc nofollow" target="_blank"> @ </a></p><h1 id="90b8" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">折叠细胞—</h1><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c7579966c688c461f3bca5008d883fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*WCZ7C4EhglLK6ybCs_MadA.gif"/></div></figure><p id="77b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">步骤1 —添加依赖关系</p><pre class="lw lx ly lz gt mm mn mo mp aw mq bi"><span id="9f33" class="ma ku iq mn b gy mr ms l mt mu">implementation 'com.ramotion.foldingcell:folding-cell:1.2.3'</span></pre><p id="c807" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第2步—编辑布局</p><p id="fd6c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将<code class="fe nu nv nw mn b">com.ramotion.foldingcell.FoldingCell</code>添加到布局</p><pre class="lw lx ly lz gt mm mn mo mp aw mq bi"><span id="ed70" class="ma ku iq mn b gy mr ms l mt mu">&lt;com.ramotion.foldingcell.FoldingCell<br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:id="@+id/folding_cell"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"&gt;<br/>​<br/>&lt;/com.ramotion.foldingcell.FoldingCell&gt;</span></pre><p id="9a7d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在folding cell标记中添加两个项目，默认情况下，第一个项目表示展开状态，第二个项目表示折叠状态。两种布局都可以包含任意数量的项目，并且可以很复杂。下面分享了一个工作示例:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><em class="nx">activity _ folding _ cell _ a ctivity . XML</em></figcaption></figure><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">单元格_内容_布局. xml</figcaption></figure><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">cell _ title _布局. xml</figcaption></figure><h2 id="2c49" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">步骤3-在活动中设置点击监听器</h2><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">FoldingCellAcivity.kt</figcaption></figure><p id="87bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">嘣！！欣赏这个美丽的动画。你可以找到完整的细节..<a class="ae ks" href="https://github.com/Ramotion/folding-cell-android" rel="noopener ugc nofollow" target="_blank"> @ </a></p><h1 id="b5fb" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">纸上入职—</h1><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d3509d854d6ad9ebd1d310a2171adbf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ggO165WgMhZMVnq4dTsebQ.gif"/></div></figure><p id="bb0a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你想在你的应用程序中加入入职界面。在这里，我将分享一个简单而美丽的图书馆给你。这让我们的生活变得简单，我们只需要几行代码就可以拥有这个特性。所以让我们从它的实现开始。</p><p id="ac94" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">步骤1 —添加依赖关系</p><pre class="lw lx ly lz gt mm mn mo mp aw mq bi"><span id="1948" class="ma ku iq mn b gy mr ms l mt mu">implementation 'com.ramotion.paperonboarding:paper-onboarding:1.1.3'</span></pre><h2 id="e17b" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">第2步—编辑布局</h2><p id="1038" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在我们的活动中，我们将有一个框架布局来保存片段和事务。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><em class="nx">activity _ paper _ on boarding . XML</em></figcaption></figure><h2 id="4827" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">第三步—</h2><p id="779b" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们现在将使用<code class="fe nu nv nw mn b">PaperOnboardingPage</code>为我们的入职滑块准备数据:</p><pre class="lw lx ly lz gt mm mn mo mp aw mq bi"><span id="7f08" class="ma ku iq mn b gy mr ms l mt mu">private fun getDataForOnboarding(): ArrayList&lt;PaperOnboardingPage&gt;? { // prepare data<br/>    val scr1 = PaperOnboardingPage("Hotels", "All hotels and hostels are sorted by hospitality rating", Color.parseColor("#678FB4"), R.drawable.<em class="ny">hotels</em>, R.drawable.<em class="ny">key</em>)<br/>    val scr2 = PaperOnboardingPage("Banks", "We carefully verify all banks before add them into the app", Color.parseColor("#65B0B4"), R.drawable.<em class="ny">banks</em>, R.drawable.<em class="ny">wallet</em>)<br/>    val scr3 = PaperOnboardingPage("Stores", "All local stores are categorized for your convenience", Color.parseColor("#9B90BC"), R.drawable.<em class="ny">stores</em>, R.drawable.<em class="ny">shopping_cart</em>)<br/>    val elements: ArrayList&lt;PaperOnboardingPage&gt; = ArrayList()<br/>    elements.add(scr1)<br/>    elements.add(scr2)<br/>    elements.add(scr3)<br/>    return elements<br/>}</span></pre><h2 id="7e71" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">第四步—</h2><p id="a0f3" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在我们将从<code class="fe nu nv nw mn b">PaperOnboardingFragment</code>创建一个片段并提供数据。</p><pre class="lw lx ly lz gt mm mn mo mp aw mq bi"><span id="ccf0" class="ma ku iq mn b gy mr ms l mt mu">val onBoardingFragment = PaperOnboardingFragment.newInstance(getDataForOnboarding())</span></pre><h2 id="6fb7" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">第五步—</h2><p id="f75e" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们将在活动中根据需要使用这个片段:</p><pre class="lw lx ly lz gt mm mn mo mp aw mq bi"><span id="28d3" class="ma ku iq mn b gy mr ms l mt mu">val fragmentTransaction: FragmentTransaction = fragmentManager!!.beginTransaction()<br/>fragmentTransaction.add(R.id.<em class="ny">fragment_container</em>, onBoardingFragment)<br/>fragmentTransaction.commit()</span></pre><h2 id="9001" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">最后一步—设置触摸监听器</h2><p id="16d6" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们将用我们的逻辑将监听器设置为片段，并将片段替换为另一个片段。</p><pre class="lw lx ly lz gt mm mn mo mp aw mq bi"><span id="fc1a" class="ma ku iq mn b gy mr ms l mt mu">onBoardingFragment.setOnRightOutListener <strong class="mn ir">{<br/>    </strong>val fragmentTransaction: FragmentTransaction = fragmentManager!!.beginTransaction()<br/>    val bf: Fragment = BlankFragment()<br/>    fragmentTransaction.replace(R.id.<em class="ny">fragment_container</em>, bf)<br/>    fragmentTransaction.commit()<br/><strong class="mn ir">}</strong></span></pre><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">完全实现</figcaption></figure><p id="d892" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更多详情请查看官方GitHub回购..<a class="ae ks" href="https://github.com/Ramotion/paper-onboarding-android" rel="noopener ugc nofollow" target="_blank"> @ </a></p><h1 id="dc4f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">扩大收藏——</h1><p id="2edf" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">这是我为你选择的最后一个动画库。让我们从它的实现开始，看看它是如何工作的。完整的文档可以在官方<a class="ae ks" href="https://github.com/Ramotion/expanding-collection-android" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> Github repo </strong> </a>找到</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/4d8b6067012519835bf8ba5c7223a7ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/1*mZgwRrlBBe5VX-yM1AhfqQ.gif"/></div></figure><h2 id="0679" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">步骤1 —创建布局</h2><p id="3029" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">首先，我们将创建所有需要的布局文件并修改它们。我们将在主要布局中使用<code class="fe nu nv nw mn b">ECBackgroundSwitcherView</code>和<code class="fe nu nv nw mn b">ECPagerView</code>:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6eec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我们将为名为<strong class="jw ir"> list_element.xml </strong>的适配器创建一个项目布局:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7011" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的最后一个布局将是一个标题布局，它将被放大到屏幕中央的卡片上:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="066c" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">步骤2-创建适配器类</h2><p id="0666" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们已经完成了布局，现在让我们创建一个适配器来保存每个项目的详细列表:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="a8ea" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">步骤3-静态数据模型</h2><p id="5f52" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在，我们将创建模型类，并用静态数据填充列表，以显示在应用程序中:</p><p id="b0b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们将为卡片创建一个模型类:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6600" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我们将创建一个名为Comment.java的模型类，它将保存适配器类的数据:</p><p id="f5f9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://gist.github.com/aasif1297/86d19cdd942bf3c8272168c3909835b0" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/aasif 1297/86d 19 cdd 942 BF 3c 8272168 c 3909835 b 0</a></p><p id="ff80" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们将创建一个名为ExampleDataset.java的数据集类，并用模拟数据填充我们的列表。您可以从API或firebase或任何后端服务器获取实际数据。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="7216" class="ma ku iq bd kv mb mc dn kz md me dp ld kf mf mg lh kj mh mi ll kn mj mk lp ml bi translated">最后一步—组合所有组件</h2><p id="34e5" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在，我们将在主类中设置ECBackgroundSwitcherView和ECPagerView及其适配器:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c2ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文到此为止。您可以在这里查看GitHub资源库中的资源或所有这些动画的完整项目<a class="ae ks" href="https://github.com/asifjawaid/AndroidAnimations" rel="noopener ugc nofollow" target="_blank"> @ </a></p></div></div>    
</body>
</html>