<html>
<head>
<title>Create your own ‘CamScanner’ using Python &amp; OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和OpenCV创建自己的“摄像机”</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-your-own-camscanner-using-python-opencv-2dd8355432de?source=collection_archive---------1-----------------------#2021-01-22">https://levelup.gitconnected.com/create-your-own-camscanner-using-python-opencv-2dd8355432de?source=collection_archive---------1-----------------------#2021-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c3e2660f3cf551f547da2a1bea651d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ce3rfUDjGYhWy3_sWHjLcg.jpeg"/></div></div></figure><p id="36d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们几乎都在生活中使用过CamScanner(或者类似的app)。这是一个非常有效的应用程序，允许用户从你的手机扫描文件，并将其作为图像分享。该应用程序的最大优势是它“清理”(去噪，旋转，锐化等)了一个相机点击图像到一个非常精致的输出。但是你知道吗，计算机视觉是其背后的科学，我们可以使用Python中OpenCV的基础知识来创建我们自己的CamScanner。</p><h1 id="3d03" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">导入库</h1><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0ff0" class="mg la it mc b gy mh mi l mj mk">import numpy as np<br/>import cv2<br/>import re<br/>from matplotlib import pyplot as plt</span></pre><h1 id="6ecb" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">图像路径</h1><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d14b" class="mg la it mc b gy mh mi l mj mk">path = "/Users/Harshil/Downloads/"<br/>image = cv2.imread("/Users/Harshil/Downloads/billtest2.jpg")</span></pre><h2 id="a6dc" class="mg la it bd lb ml mm dn lf mn mo dp lj km mp mq ln kq mr ms lr ku mt mu lv mv bi translated">模糊</h2><p id="a3a5" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">模糊的目的是减少图像中的噪声。它从图像中移除高频内容(例如:噪声、边缘)，从而导致边缘模糊。OpenCV中有多种模糊技术(滤镜)，最常见的有:</p><p id="c6a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">平均</strong> —它只是取内核区域下所有像素的平均值，并用这个平均值替换中心元素</p><p id="c6e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">高斯滤波器</strong>——使用高斯内核，而不是由相等滤波器系数组成的箱式滤波器</p><p id="825d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">中值滤波器</strong> —计算内核窗口下所有像素的中值，中心像素用该中值替换</p><p id="8862" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">双边滤镜</strong> —高级版高斯模糊。它不仅可以消除噪声，还可以平滑边缘。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1523" class="mg la it mc b gy mh mi l mj mk">def blur_and_threshold(gray):<br/>    gray = cv2.GaussianBlur(gray, (3, 3), 2)<br/>    threshold = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)<br/>    threshold = cv2.fastNlMeansDenoising(threshold, 11, 31, 9)<br/>    return threshold</span></pre><h1 id="7626" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">阈值处理</h1><p id="e913" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">在图像处理中，阈值化是分割图像的最简单的方法。从灰度图像，阈值可以用来创建二进制图像。这通常是为了清楚地区分不同色调的像素强度。OpenCV中最常见的阈值技术有:</p><p id="0d93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">简单阈值</strong> —如果像素值大于阈值，则为其分配一个值(可能是白色)，否则为其分配另一个值(可能是黑色)</p><p id="145c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">自适应阈值</strong> —算法计算图像小区域的阈值。因此，对于同一幅图像的不同区域，我们得到不同的阈值，并且对于具有变化的图像，它给我们更好的结果</p><p id="51db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Canny边缘检测与最大轮廓提取</p><p id="00a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在图像模糊和阈值处理之后，下一步是找到最大的轮廓(最大的边界框)并裁剪出图像。这是通过使用Canny边缘检测，然后使用四点变换提取最大轮廓来完成的。</p><h1 id="42ca" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">锐利的边缘</h1><p id="f2a2" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">Canny边缘检测是一种可以检测边缘的多步算法。我们应该向该算法发送去噪声的图像，以便它能够只检测相关的边缘。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/123e945edf24d5330e060d60446f3cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*GUmcGG61xO3c-sGO8V0Tbw.jpeg"/></div></figure><h1 id="81ff" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">查找轮廓</h1><p id="ec98" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">找到边缘后，将图像通过<code class="fe nc nd ne mc b">cv2.findcontours()</code>。它连接所有连续的点(沿着边缘)，具有相同的颜色或强度。在这之后，我们将得到所有的轮廓——矩形、球形等</p><p id="46d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe nc nd ne mc b">cv2.convexHull()</code>和<code class="fe nc nd ne mc b">cv2.approxPolyDP</code>找到照片中最大的矩形轮廓(大约)。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fd53" class="mg la it mc b gy mh mi l mj mk">def biggest_contour(contours, min_area):<br/>    biggest = None<br/>    max_area = 0<br/>    biggest_n = 0<br/>    approx_contour = None<br/>    for n, i in enumerate(contours):<br/>        area = cv2.contourArea(i)<br/><br/>        if area &gt; min_area / 10:<br/>            peri = cv2.arcLength(i, True)<br/>            approx = cv2.approxPolyDP(i, 0.02 * peri, True)<br/>            if area &gt; max_area and len(approx) == 4:<br/>                biggest = approx<br/>                max_area = area<br/>                biggest_n = n<br/>                approx_contour = approx<br/><br/>    return biggest_n, approx_contour<br/><br/><br/>def order_points(pts):<br/>    # initialzie a list of coordinates that will be ordered<br/>    # such that the first entry in the list is the top-left,<br/>    # the second entry is the top-right, the third is the<br/>    # bottom-right, and the fourth is the bottom-left<br/>    pts = pts.reshape(4, 2)<br/>    rect = np.zeros((4, 2), dtype="float32")<br/><br/>    # the top-left point will have the smallest sum, whereas<br/>    # the bottom-right point will have the largest sum<br/>    s = pts.sum(axis=1)<br/>    rect[0] = pts[np.argmin(s)]<br/>    rect[2] = pts[np.argmax(s)]<br/><br/>    # now, compute the difference between the points, the<br/>    # top-right point will have the smallest difference,<br/>    # whereas the bottom-left will have the largest difference<br/>    diff = np.diff(pts, axis=1)<br/>    rect[1] = pts[np.argmin(diff)]<br/>    rect[3] = pts[np.argmax(diff)]<br/><br/>    # return the ordered coordinates<br/>    return rect<br/></span></pre><h1 id="ddba" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">最后—锐化和亮度校正</h1><p id="522d" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">现在我们已经从图像中裁剪出了相关的信息(最大的轮廓)，最后一步是锐化图片，这样我们就可以得到清晰易读的文档。</p><p id="9882" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">—为此，我们使用<em class="nf">色调、饱和度、值(h，s，v) </em>概念，其中<em class="nf">值</em>代表<em class="nf">亮度。</em>可以用这个值来增加文档的亮度</p><p id="505a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">— <strong class="kd iu"> <em class="nf">内核锐化— </em>一个内核</strong>、<strong class="kd iu">卷积矩阵</strong>，或者<strong class="kd iu">遮罩</strong>就是一个小矩阵。它用于模糊、锐化、浮雕、边缘检测等。这是通过在内核和图像之间进行卷积来实现的</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8a46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完整代码—<a class="ae ni" href="https://github.com/its-harshil/document_scanner_python/blob/main/scan" rel="noopener ugc nofollow" target="_blank">https://github . com/its-har shil/document _ scanner _ python/blob/main/scan</a></p><p id="8712" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢Adrian Rosebrock在<a class="ae ni" href="http://www.pyimagesearch.com/" rel="noopener ugc nofollow" target="_blank"> PyImageSearch </a>上的所有有用的博客。有用的博客— <br/> 1。<a class="ae ni" href="https://www.pyimagesearch.com/2014/09/01/build-kick-ass-mobile-document-scanner-just-5-minutes/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2014/09/01/build-kick-ass-mobile-document-scanner-just-5-minutes/</a></p><p id="bca3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.<a class="ae ni" href="https://www.pyimagesearch.com/2014/08/25/4-point-opencv-getperspective-transform-example/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2014/08/25/4-point-opencv-get perspective-transform-example/</a></p><p id="84a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.<a class="ae ni" href="https://www.pyimagesearch.com/2016/03/21/ordering-coordinates-clockwise-with-python-and-opencv/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2016/03/21/ordering-coordinates-顺时针-with-python-and-opencv/ </a></p></div></div>    
</body>
</html>