<html>
<head>
<title>6 tradeoffs between monolithic and microservices architecture you need to keep in mind</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6您需要记住的单片和微服务架构之间的权衡</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/6-tradeoffs-between-monolithic-and-microservices-architecture-you-need-to-keep-in-mind-f7dd5c5cda4?source=collection_archive---------7-----------------------#2021-12-10">https://levelup.gitconnected.com/6-tradeoffs-between-monolithic-and-microservices-architecture-you-need-to-keep-in-mind-f7dd5c5cda4?source=collection_archive---------7-----------------------#2021-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/83843bf9e0ab3ece121084e5f0ee8e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3rlWCItJsmYN97fQ2a3HQ.png"/></div></div></figure><div class=""/><p id="abad" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎回到我们的应用架构系列。在<a class="ae kw" href="https://medium.com/codex/monoliths-or-microservices-the-critical-differences-between-approaches-to-application-architecture-adb6a8e93aa" rel="noopener">上一篇文章</a>中，我们介绍了单片和微服务架构，以及功能需求和可用资源如何塑造应用程序的结构。然而，每种架构都包括一系列的权衡，在确定应用程序的最终结构之前，必须仔细考虑这些权衡。</p><p id="f4e5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开发复杂性、可伸缩性、部署时间、灵活性、运营成本和可靠性都是需要考虑的因素。让我们仔细看看每一个权衡。</p><p id="991c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">开发复杂性</strong> <br/>安装和管理应用程序所需的工作被称为开发复杂性。</p><p id="1396" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">monolith——一种编程语言；一个存储库；支持顺序开发。</p><p id="47b0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微服务——多种编程语言；多个存储库；支持并行开发(也就是说，编码过程是独立的，或者完全与简单挂钩或端点之外的更广泛的微服务生态系统解耦，单个交互要简单得多)。</p><p id="c154" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微服务中有一些关于开发复杂性的概念——它们使网络变得复杂，使it更加关注事务和数据一致性。使用微服务时，您必须确定每个服务如何在宏观层面上与其他服务进行交互。虽然单个单元的创建相当简单，但整个系统变得越来越复杂。</p><p id="0112" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为一切都有千丝万缕的联系，一个整体可能会更新。在微服务设计中，整个系统的更新(例如采用所选语言或协议的新版本)可能更昂贵，因为它是分散的。您正在升级微服务和使其协同工作的组件。在企业规模中，解决这些挑战肯定需要使用管理层。例如，集装箱化和服务网格使分散的环境成为可能，同时又有一个统一的控制平面。</p><p id="d62c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">可伸缩性</strong> <br/>应用程序响应传入流量的能力称为可伸缩性。</p><p id="c654" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整体——整个堆栈的复制；因此，它对资源消耗很大。</p><p id="da36" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微服务—单个单元的复制，提供资源的按需消耗。</p><p id="29bf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">部署时间<br/> </strong>用于交付特性的交付管道的构造被称为部署时间。</p><p id="e924" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">monolith——部署整个烟囱的一条输送管道；每次部署的风险越大，导致速度越慢。</p><p id="5075" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微服务——部署独立单元的多条输送管道；每次部署的风险更低，导致更高的特性开发率</p><p id="5892" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">柔性</strong> <br/>适应新技术和提供新功能的能力称为柔性。</p><p id="baf3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">monolith——低速率，因为整个应用程序堆栈可能需要重新构建以包含新的功能。</p><p id="adaa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微服务—高速率，因为更换独立单元非常简单。</p><p id="765e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，灵活性实际上取决于微服务是否正确划分，这实际上是最大的挑战之一。换句话说，结构良好的单一回购协议比设计错误的微服务更灵活。</p><p id="8ccb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">运营成本</strong> <br/>发布一款产品所需要的必要资源成本被称为运营成本。</p><p id="34bf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Monolith —初始成本低，因为只需管理一个代码库和一个管道。然而，当应用程序需要大规模运行时，成本会呈指数级增长。</p><p id="8801" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微服务—初始成本高，因为需要管理多个存储库和管道。然而，在规模上，成本仍然与受影响的微服务在该时间点消耗的资源成比例。</p><p id="fbf5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">可靠性</strong> <br/>可靠性是指应用程序如何从故障中恢复，以及用来监控它的工具。</p><p id="ddb8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整体式—在发生故障的情况下，需要恢复整个堆栈。此外，每个功能的可见性很低，因为所有的日志和指标都聚集在一起。</p><p id="9f48" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微服务—在发生故障的情况下，只需要恢复发生故障的单元。此外，每个单元的日志和指标都有很高的可视性。</p><p id="6533" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这两种情况下，您通常希望将所有日志聚集在一个地方，并选择过滤掉所需的组件，这种方法允许您查看高级和详细的透视图。在独石的情况下，在单个单元的范围内收集日志，并且日志收集过程是更连续的过程。但是在微服务的情况下，每个服务都有自己的日志处理流程，可以作为一个解耦的流程进行分析，而不需要额外的过滤。</p><p id="090e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">总结</strong> <br/>每个应用架构都有一套在项目开始时必须考虑的权衡。但是更重要的是要知道这个程序在未来将如何维护——在规模上，在压力下，维持每天几个版本，等等。产品设计没有唯一的方法，但是对权衡取舍的透彻了解将有助于你规划你的项目。</p><p id="4dba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论选择整体架构还是微服务架构，如果项目与快速交付渠道、拥抱新技术的灵活性以及轻松添加功能的能力相关联，则云原生部署的路线是有保证的。</p><p id="cd44" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">寻求更多信息。<br/> <a class="ae kw" href="https://www.linkedin.com/in/artyom-koshko-87629985/" rel="noopener ugc nofollow" target="_blank"> Artyom </a>，高级软件工程师</p><p id="160c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参考资料:<br/>-【www.udacity.com】<br/>-<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/architecture/microservices/migrate-monolith" rel="noopener ugc nofollow" target="_blank">docs.microsoft.com</a><br/><a class="ae kw" href="https://www.youtube.com/watch?v=t7iVCIYQbgk" rel="noopener ugc nofollow" target="_blank">-YT—1500微服务中的现代银行</a></p></div></div>    
</body>
</html>