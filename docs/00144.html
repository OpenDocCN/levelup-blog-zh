<html>
<head>
<title>Demystifying State Management and Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘状态管理和冗余</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/demystifying-state-management-and-redux-4ccbb1a1167a?source=collection_archive---------0-----------------------#2018-05-28">https://levelup.gitconnected.com/demystifying-state-management-and-redux-4ccbb1a1167a?source=collection_archive---------0-----------------------#2018-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b84ef8bd3d8f10d26e520c427c592e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfzDKX7sSN6XcRUGBAfP8A.jpeg"/></div></div></figure><p id="4cda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何应用程序的基本组成部分都是它的用户界面和应用程序状态。应用程序状态的神圣性和可预测性对于任何应用程序来说都是至关重要的。为了使这个任务更简单，我们有状态管理库。在这篇文章中，我将深入探讨状态管理的需求，并深入了解redux是如何工作的。</p><h2 id="5dbb" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">状态管理需求</strong></h2><p id="3a81" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">通常我们有UI，状态通常分布在应用程序中。在基于react的应用程序中，状态跨组件和DOM本身传播。</p><p id="3a3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种分散的状态带来了许多挑战，其中不止一个组件需要访问同一个状态——通常我们将状态移动到父组件，并将其作为道具传递给需要它的组件。如果需要它的组件比父组件低6-7层，该怎么办？这种做法虽然没有错，但相当麻烦和乏味。如果我们所有的状态都在Redux状态树中，我们就不需要担心这一切，需要它的组件可以直接从状态树中获得它。</p><p id="80d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，与其将状态分散在应用程序中，不如将它放在一个位置。这就是我们所说的<em class="lu">状态树。</em></p><h2 id="0a71" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">与状态树交互并理解Redux如何工作</h2><p id="cea8" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">现在我们已经理解了状态树的本质和存在的必要性，让我们更深入地理解redux是如何帮助处理状态树和应用程序状态的。</p><p id="96ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了构建状态管理库，这些是<code class="fe lv lw lx ly b">building-blocks</code>。</p><ul class=""><li id="48bd" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">首先，我们需要将我们所有的州放在一个位置</li><li id="b0a0" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">然后我们需要从状态树中“获取”状态</li><li id="4249" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">倾听国家的变化</li><li id="e382" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">更新状态树</li></ul><p id="ae73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些共同组成了我们的<em class="lu">商店。</em></p><h2 id="d004" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><em class="mn">建设商场并与商场互动</em></h2><p id="fd33" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">基于上面提到的4个<code class="fe lv lw lx ly b">building-blocks</code>,让我们创建我们的<code class="fe lv lw lx ly b">createStore()</code>函数</p><pre class="mo mp mq mr gt ms ly mt mu aw mv bi"><span id="d051" class="kw kx iq ly b gy mw mx l my mz">function createStore(){</span><span id="f095" class="kw kx iq ly b gy na mx l my mz">// Create the state tree</span><span id="de0c" class="kw kx iq ly b gy na mx l my mz">// GET the state tree - getState()</span><span id="b0eb" class="kw kx iq ly b gy na mx l my mz">// LISTEN for changes - subscribe()</span><span id="c1d0" class="kw kx iq ly b gy na mx l my mz">// UPDATE the state tree - dispatch()</span><span id="61d0" class="kw kx iq ly b gy na mx l my mz">}</span></pre><p id="6725" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论何时调用<code class="fe lv lw lx ly b">createStore()</code>函数，用户都可以访问<code class="fe lv lw lx ly b">getState()</code> <code class="fe lv lw lx ly b">subscribe()</code>和<code class="fe lv lw lx ly b">dispatch()</code>方法。</p><h2 id="456b" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">初始化<code class="fe lv lw lx ly b">state </code>和<code class="fe lv lw lx ly b">getState</code>功能</h2><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/5a46da0547f1d73e2b75beb61ebbf0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DtXwtFQ7hYoDYA90mbycyg.png"/></div></div></figure><p id="24ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的<code class="fe lv lw lx ly b">createStore()</code>函数中，我们初始化状态，还有<code class="fe lv lw lx ly b">getState()</code>函数，它的任务仅仅是返回当前状态。此外，<code class="fe lv lw lx ly b">getState()</code>从主函数返回，这样当<code class="fe lv lw lx ly b">createStore</code>被调用时，它可以作为一个方法被访问。</p><pre class="mo mp mq mr gt ms ly mt mu aw mv bi"><span id="0fba" class="kw kx iq ly b gy mw mx l my mz">const myStore = createStore();</span><span id="1f3e" class="kw kx iq ly b gy na mx l my mz">myStore.getState()// returns the current state </span></pre><h2 id="7371" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">使用subscribe监听更改</h2><p id="f0d5" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">既然状态是可访问的，我们需要监听对存储的更改。我们定义了一个subscribe方法，作为一个观察器。这个方法接受一个函数作为参数。因为subscribe方法可以被多次调用，所以我们使用一个数组来推送所有被监视的函数。</p><p id="eab9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户调用subscribe并传递函数，该函数被推送到watchers数组上。为了取消订阅，我们返回一个回调函数，它只是过滤器数组助手检查当前传递的函数是否已经存在于观察器数组中。然后返回一个数组，其中包含除传递给它的函数之外的所有其他函数。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/dc17790f01116a23c8acaaa029cb436b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84gllP92b3z6wppZ69nztA.png"/></div></div></figure><h2 id="119b" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">更新状态树</h2><p id="ff06" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">可预测性是我们试图实现的状态管理库的本质。因此，一旦我们听取了要对商店做出的改变，我们就该实施这些改变了。</p><p id="805d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个事件集合，这些事件应该在我们的存储中强制执行这些状态更新</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/136ac95fc904197e2bfd394db9e71436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjN48zRSJLWqLLyTK6eanQ.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">一个简单的动作</figcaption></figure><p id="e7d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这是一个对象，我们可以添加任何我们想要的额外信息，这将帮助我们基于被调用的类型改变存储的状态。这被称为<code class="fe lv lw lx ly b">ACTION</code>——它是一个表示改变我们商店状态的事件的对象</p><p id="0479" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了我们的状态和行动，我们需要以某种方式将它们连接在一起。动作必须有一个类型属性来指定正在发生的动作的“类型”。除了“类型”，动作的结构相当灵活</p><h2 id="90a9" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">减速器功能</h2><p id="1902" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Reducer函数应该是纯函数，它接受当前状态和动作，并返回状态的更新版本，而不改变它。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/791ce91fc7d501fa0238887e72f3b91b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9vRCq1OnBEjyJxjtmnJW1g.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">减速器功能</figcaption></figure><p id="f0ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">reducers观察被分派的动作的<code class="fe lv lw lx ly b">type</code>,然后更新状态。如果你在上面的代码中观察到我们使用了<code class="fe lv lw lx ly b">.concat()</code>而不是<code class="fe lv lw lx ly b">.push</code>，那么现有的状态不会发生变化</p><h2 id="80ac" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">分派行动</h2><p id="ced2" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">一旦定义了归约器，我们所需要的就是能够“分派”一个动作，这样归约器就可以得到关于修改什么以及更重要的是如何修改状态的指令。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/d4bc5db867507769a6771b8e57acd89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PiB4IS8ZKtUEdYLJwpCZFA.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">一种分派动作的方法</figcaption></figure><p id="17b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，<code class="fe lv lw lx ly b">createStore()</code>现在接受一个reducer作为参数，这样在<code class="fe lv lw lx ly b">dispatch()</code>中我们可以动态地访问reducer并传递动作以获得当前状态。一旦我们有了状态，我们就调用我们的观察器数组中的所有函数。</p><p id="220f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这上面，是我们的全功能状态管理库。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/9fa2dfa961aa64097b680700edacb20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbwJWo2UckzC2aR1uFuJdg.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">访问存储区中声明的状态和方法</figcaption></figure><h2 id="cf52" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结论</h2><p id="5621" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在这篇文章中，我试图让读者深入了解redux是如何工作的。对内部工作的更好理解可能会对在哪里以及如何使用它们给出更清晰的描述。我还强调了状态的神圣性是至高无上的，以及redux如何帮助我们维护它，尤其是在大型应用程序中。</p></div></div>    
</body>
</html>