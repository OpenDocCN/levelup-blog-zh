<html>
<head>
<title>DI from Hell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自地狱的迪</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/di-from-hell-b1f43e122a4c?source=collection_archive---------28-----------------------#2020-06-29">https://levelup.gitconnected.com/di-from-hell-b1f43e122a4c?source=collection_archive---------28-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="2eda" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">这篇文章主要基于<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/stop-using-setters-785670f4bf8?source=friends_link&amp;sk=a020d40e49eb5ed450171c3b0cc8e780">停止使用setter</a>和<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/stop-using-postconstruct-in-your-java-applications-2a66fb202cb8">停止在你的Java应用程序中使用@ post construct</a>的故事。如果你还没有读过它们，最好在读这本书之前读一读。但是这对于理解故事的信息来说是不必要的。</p><p id="b02b" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">进一步的论证不仅适用于Java语言和Spring框架，也适用于所有类似的技术。</p></blockquote><p id="7b6b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">我们都喜欢Spring框架。或许不是我们所有人。但是至少大多数Java开发人员都熟悉它。春天是一个巨大的生态系统，为我们提供了几十种有用的工具。反正最根本的就是<a class="ae ks" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>和<a class="ae ks" href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank">反转控制</a>。这些巨人已经交付，使我们的代码不那么脆弱，更易于维护。但是我认为，实施有一些问题，这些可能会导致完全相反的事情。所以，我们来讨论一下。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/1921ccb52b2b5331cabe274cf537f53f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Su6mCyfh2aJVtJzotFVlCA.jpeg"/></div></div></figure><p id="7fa9" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated"><a class="ae ks" href="https://stackoverflow.com/questions/38068303/spring-autowiring-order-and-postconstruct" rel="noopener ugc nofollow" target="_blank">这个StackOverflow问题</a>引发了我写这个故事。作者想了解beans的实例化和<code class="fe li lj lk ll b">@PostConstruct</code>调用的顺序。目标是预测控制台中应该打印的内容。我们将在文章的最后回到这个任务。首先，让我们检查代码。我对它做了一点点改动，只是为了让它更具可读性，但重点是一样的。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ks" href="https://gist.github.com/085cc8fc76cdfa7b00632d15ff6a2145.git" rel="noopener ugc nofollow" target="_blank">来自StackOverflow的代码</a></figcaption></figure><p id="92e7" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">人们对春豆的执行顺序留下了相当详细的评论。但我认为重点应该转移。我认为这段代码包含一些架构错误。如果我们解决了这些问题，初始化顺序的模糊性将会自行消失。那么，我们开始吧。</p><h1 id="1054" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">邪恶的起源</h1><p id="3435" class="pw-post-body-paragraph jt ju it jw b jx mq jz ka kb mr kd ke kt ms kh ki ku mt kl km kv mu kp kq kr im bi translated">开头是字，字是<code class="fe li lj lk ll b">@Autowired</code>。这个注解告诉了春迪如何表演魔术。让我们看看它的声明。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ks" href="https://gist.github.com/908567d4e360b4eb62b8e4be93d28dd3.git" rel="noopener ugc nofollow" target="_blank">自动连线</a></figcaption></figure><p id="0087" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated"><code class="fe li lj lk ll b">@Target</code>定义了<code class="fe li lj lk ll b">@Autowired</code>用法的可能变化。我们今天不讨论<code class="fe li lj lk ll b">ElementType.ANNOTATION_TYPE</code>和<code class="fe li lj lk ll b">ElementType.PARAMETER</code>。因为第一个是用来实现Spring中棘手的注释继承的。第二种类型用于测试环境，尽管我个人从未见过这样的例子。</p><p id="27a0" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">因此，我们对三种类型的注射感兴趣。</p><ul class=""><li id="a798" class="mv mw it jw b jx jy kb kc kt mx ku my kv mz kr na nb nc nd bi translated">现场注射</li><li id="e3c7" class="mv mw it jw b jx ne kb nf kt ng ku nh kv ni kr na nb nc nd bi translated">定型剂注射</li><li id="f206" class="mv mw it jw b jx ne kb nf kt ng ku nh kv ni kr na nb nc nd bi translated">构造函数注入</li></ul><p id="ddd4" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">让我们逐一讨论。</p><h1 id="5aea" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">现场注射</h1><p id="5b2a" class="pw-post-body-paragraph jt ju it jw b jx mq jz ka kb mr kd ke kt ms kh ki ku mt kl km kv mu kp kq kr im bi translated">在我个人看来，这是列表中最差的选项。没有构造函数或设置函数，但是依赖关系会凭空出现在一个对象中。Spring使用<code class="fe li lj lk ll b">Reflection API</code>来执行DI。所以，它不在乎可见性的范围。但是我们作为开发者确实关心它。</p><p id="6575" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">首先，没有办法为这样的案例编写一个好的单元测试。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ks" href="https://gist.github.com/b068a2ca8c8ceba4e61a90100af985a6.git" rel="noopener ugc nofollow" target="_blank">测试将失败</a></figcaption></figure><p id="7c96" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">如果我们运行这个测试，我们显然会得到<code class="fe li lj lk ll b">NullPointerException</code>，因为<code class="fe li lj lk ll b">child</code>依赖项丢失了。但是我们不会放弃。是时候叫上<code class="fe li lj lk ll b">Reflection API</code>了！</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ks" href="https://gist.github.com/a63c553c7eb27702b8eefa3d3f8c03d4.git" rel="noopener ugc nofollow" target="_blank">恐怖的测试</a></figcaption></figure><p id="bdb9" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">现在它像我们预期的那样工作了。这个测试有多脆弱？我会说10个中有10个水晶花瓶。如果有人改变了变量的名称或类型，测试将停止工作。但是我们要等到它发射后才能知道。这可能会更糟。想象一下，您的构建在等待15分钟后在Jenkins上失败了。而你所做的只是变量名的一个小改动。这可不是开发人员生活中最美好的一天。</p><blockquote class="nj"><p id="fa56" class="nk nl it bd nm nn no np nq nr ns kr dk translated">有人可能会说，我们可以在测试中开始<a class="ae ks" href="https://docs.spring.io/spring/docs/1.2.9/reference/beans.html" rel="noopener ugc nofollow" target="_blank"> Spring应用程序上下文</a>。因此，没有必要直接传递依赖关系。这真的很有效，我不否认。但是它不是一个单元，而是一个集成测试。我认为集成测试应该扩展现有的测试覆盖范围，而不是取代它。我认为不可能写出一个合适的单元是一个危险信号，表明你的代码应该被重构。</p></blockquote><p id="b994" class="pw-post-body-paragraph jt ju it jw b jx nu jz ka kb nv kd ke kt nw kh ki ku nx kl km kv ny kp kq kr im bi translated">但是问题不仅仅在于测试(老实说，我们并不总是写测试)。假设我们需要用<code class="fe li lj lk ll b">BeanFactory</code>实例化我们的对象。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ks" href="https://gist.github.com/46c0bdef18175292537fa1fa81e09f12.git" rel="noopener ugc nofollow" target="_blank">不工作的豆制品厂</a></figcaption></figure><p id="2983" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">可悲的是<code class="fe li lj lk ll b">child</code>仍然是<code class="fe li lj lk ll b">null</code>。因为没有合法的方式来传递<code class="fe li lj lk ll b">Parent</code>内部的依赖关系。技术上我们可以再次使用索伦之眼。但是如果有什么比测试中的反射更糟糕的话，那就是产品代码中不必要的反射。</p><p id="b1f3" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">正如我们所看到的，除了减少几行代码长度之外，使用字段注入没有任何好处。</p><h1 id="fbe7" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">定型剂注射</h1><p id="bbf1" class="pw-post-body-paragraph jt ju it jw b jx mq jz ka kb mr kd ke kt ms kh ki ku mt kl km kv mu kp kq kr im bi translated">让我们用setter注入重写我们的代码。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ks" href="https://gist.github.com/f43f8bf89d5a4aa0f6a16ecce7e6bc7a.git" rel="noopener ugc nofollow" target="_blank">二传手注射</a></figcaption></figure><p id="7682" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">现在已经变得好多了。不仅如此，我们可以很容易地添加适当的单元测试以及<code class="fe li lj lk ll b">BeanFactory</code>实例化。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ks" href="https://gist.github.com/3e976ef68293b738864a4c89fd605f86.git" rel="noopener ugc nofollow" target="_blank">测试和BeanFactory </a></figcaption></figure><p id="d58e" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">问题解决了吗？不完全是。Public setter的存在允许我们对业务逻辑进行一些棘手的操作。像这样。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ks" href="https://gist.github.com/c2df9a414de1ec2c17e7763e625b9b65.git" rel="noopener ugc nofollow" target="_blank">恶作剧</a></figcaption></figure><p id="92c4" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">我们很快就会面临不愉快的后果。也可能不是。实际上我们并没有意识到这一点。也许这个地雷会在5分钟或5年内爆炸。这取决于功能需求。</p><p id="646b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">有人可能会说这个代码没有意义。从来没有人写过这个。目的是什么？我认为你是对的。如果我在代码审查中得到类似的东西，我不会批准它。但是这里有一个例子说明这种方法是有用的。</p><p id="02e4" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">假设用<code class="fe li lj lk ll b">@Scope(SCOPE_PROTOTYPE)</code>注释声明了<code class="fe li lj lk ll b">Parent</code>。这意味着每次调用<code class="fe li lj lk ll b">applicationContext.getBean(Parent.class)</code>都返回一个新的<code class="fe li lj lk ll b">Parent</code>实例。我们面临着在一个地方改变<code class="fe li lj lk ll b">child</code>行为的需求。所以，我们用<code class="fe li lj lk ll b">parent.setChild</code>注入了另一个实现。效果非常好。我们更改了刚刚创建的对象中的一个字段。哪里出了问题？</p><p id="1c31" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">时间已过，<code class="fe li lj lk ll b">@Scope</code>标注已离开<code class="fe li lj lk ll b">Parent</code>。这意味着<code class="fe li lj lk ll b">applicationContext.getBean(Parent.class)</code>每次都返回相同的实例(singleton)。这个设置者改变了整个应用程序中<code class="fe li lj lk ll b">Child</code>的行为。</p><p id="1857" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">此外，字段和setter注入打开了循环依赖的闸门。我会把它们分成两类。均匀和不均匀。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi nz"><img src="../Images/16f3d481c7f862a5b2a764e4db5d8b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4MPZdYGcby2uEJ1kH6XYGQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">均匀和不均匀循环依赖</figcaption></figure><p id="85c7" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">构造函数注入无法做到这一点。在beans实例化期间，我们会得到一个异常。我们的例子是一个完美的循环依赖的例子。</p><p id="a8c7" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">为什么不好？我认为它打破了抽象交互的流程。Bob叔叔曾经说过，数据应该从最高的抽象层运行到最低的抽象层。最低层必须对最高层一无所知。我认为这是有道理的。想象一下，您的打印机驱动程序可以通过Skype给某人打电话。那会很奇怪。但是实现循环依赖的能力很容易打破这个规则。最令人不快的是，识别这种情况并不总是容易的。</p><p id="ec66" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">我认为setters是绝对邪恶的吗？不完全是。我认为我们应该避免他们，但有时没有其他选择。例如，假设我们有一个服务，它有一个决定函数分析状态的标志。如果为真，那么所有的函数执行都被测量和记录。如果我们想在运行时改变这个标志呢？在我看来，除了添加一个改变标志值的setter之外，别无他法。</p><p id="9124" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">我在故事<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/stop-using-setters-785670f4bf8?source=friends_link&amp;sk=a020d40e49eb5ed450171c3b0cc8e780">中向setters描述了我的观点</a>停止使用Setters。你可以去看看。</p><h1 id="f591" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">构造函数注入</h1><p id="0640" class="pw-post-body-paragraph jt ju it jw b jx mq jz ka kb mr kd ke kt ms kh ki ku mt kl km kv mu kp kq kr im bi translated">让我们用构造函数代替setters。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ks" href="https://gist.github.com/df334bff4c30c76b32674e39a88ec6c6.git" rel="noopener ugc nofollow" target="_blank">构造函数注入</a></figcaption></figure><p id="519a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">为了启动我们的应用程序，我们必须消除<code class="fe li lj lk ll b">Parent → Child → Parent</code>循环依赖。谢天谢地，在这种情况下很容易。</p><p id="88b3" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">我认为这种方法是最好的。首先，所有的类都可以被测试。其次，我们可以更改bean实例化类型。第三，所有的依赖对于外部作用域是不可见的。最后，由于<code class="fe li lj lk ll b">final</code>关键字，它们甚至不能在类内部被更改。</p><p id="5172" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">但这还没有结束。有一件事不合时宜。<code class="fe li lj lk ll b">@PostConstruct</code>。我为此写了一篇相当大的文章(<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/stop-using-postconstruct-in-your-java-applications-2a66fb202cb8?source=friends_link&amp;sk=5ee161f2cce91a824123d750c9331992">停止在Java应用程序中使用@ post construct</a>)。但是现在我只想说<code class="fe li lj lk ll b">@PostConstruct</code>可以很容易的省略，用一个普通的构造函数代替。此外，还有一个不错的奖金。因为Spring 4.3 <code class="fe li lj lk ll b">@Autowired</code>是多余的，如果一个类有一个接受所有必需依赖的构造函数。</p><p id="5243" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">让我们制作代码的最终版本。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ks" href="https://gist.github.com/cfaa43aa982a723729b2d9639027e1e3.git" rel="noopener ugc nofollow" target="_blank">不带@PostConstruct的构造函数注入</a></figcaption></figure><p id="55d0" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke kt kg kh ki ku kk kl km kv ko kp kq kr im bi translated">现在让我们回到StackOverflow的问题。bean实例化的顺序是什么，消息打印的顺序是什么？解决方案现在很清楚了。<code class="fe li lj lk ll b">Parent</code>取决于<code class="fe li lj lk ll b">Child</code>。不能先创建它。所以，构造函数调用的顺序是<code class="fe li lj lk ll b">Child → Parent</code>。事实上，消息顺序是<code class="fe li lj lk ll b">"Child is called" → "Parent is called" → 9</code>。行为是确定的。我们想运行多少次就运行多少次。结果应该是一样的。</p><h1 id="5553" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="9383" class="pw-post-body-paragraph jt ju it jw b jx mq jz ka kb mr kd ke kt ms kh ki ku mt kl km kv mu kp kq kr im bi translated">虽然Spring允许我们使用field或setter注入，但我认为应该避免使用。我认为很多开发人员会同意我的观点，认为最后一段代码是最清晰的。不像使用<code class="fe li lj lk ll b">@PostConstruct</code>和<code class="fe li lj lk ll b">@Autowired</code>的复杂方法，它不会在你的代码中产生任何歧义或误解。如果您有任何问题或建议，请在下面留下您的评论。感谢阅读！</p></div></div>    
</body>
</html>