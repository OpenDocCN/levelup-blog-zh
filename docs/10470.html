<html>
<head>
<title>Declaring a gRPC Service Definition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">声明gRPC服务定义</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/grpc-part-2-declaring-a-grpc-service-definition-df9ae0847e4c?source=collection_archive---------8-----------------------#2021-12-10">https://levelup.gitconnected.com/grpc-part-2-declaring-a-grpc-service-definition-df9ae0847e4c?source=collection_archive---------8-----------------------#2021-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/de22580be509bd0b258d9c7c2f928879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tn1AOANb6RWmfeb3.jpg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图片由Renee French提供</figcaption></figure><h2 id="84bf" class="jg jh ji bd b dl jj jk jl jm jn jo dk jp translated" aria-label="kicker paragraph">GRPC:第二部分</h2><div class=""/><div class=""><h2 id="741b" class="pw-subtitle-paragraph ko jr ji bd b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dk translated">服务定义是gRPC开发的基础部分，所以让我们从正确的方面开始。</h2></div><p id="c70f" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">对于gRPC的简要介绍，请在继续之前检查第1部分，尽管这不是继续的必要条件。</p><div class="is it gp gr iu mc"><a rel="noopener  ugc nofollow" target="_blank" href="/grpc-part-1-a-case-for-grpc-69592155cfbd"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd js gy z fp mh fr fs mi fu fw jr bi translated">gRPC的一个案例</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">gRPC将继续存在，这就是原因。</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ja mc"/></div></div></a></div></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="463c" class="my mz ji bd na nb nc nd ne nf ng nh ni kx nj ky nk la nl lb nm ld nn le no np bi translated">服务定义</h1><p id="2c32" class="pw-post-body-paragraph lg lh ji li b lj nq ks ll lm nr kv lo lp ns lr ls lt nt lv lw lx nu lz ma mb im bi translated">gRPC基于定义服务和客户可以用来操作服务的方法的思想。gRPC的<em class="nv">服务定义</em>使用<em class="nv">协议缓冲区</em>作为其接口定义语言来描述服务。在本系列中，我们将创建一个有用的服务来安全地存储用户名和密码。在我们开始尝试这样做的逻辑之前，我们必须创建我们的服务定义。这被称为接口优先编程，是gRPC所要求的。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="d019" class="my mz ji bd na nb nc nd ne nf ng nh ni kx nj ky nk la nl lb nm ld nn le no np bi translated">开始之前</h1><p id="0138" class="pw-post-body-paragraph lg lh ji li b lj nq ks ll lm nr kv lo lp ns lr ls lt nt lv lw lx nu lz ma mb im bi translated"><strong class="li js"> 1。protocol buffer compiler protocol<br/></strong>protocol是一个编译工具，可以将服务定义编译成目标语言的客户机和服务器代码。您可以将相同的服务定义编译到Node或Java或Golang或任何其他具有协议插件的流行语言中。这就是gRPC polygot的特点。</p><p id="e521" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">您可以通过<a class="ae oa" href="https://github.com/protocolbuffers/protobuf/releases" rel="noopener ugc nofollow" target="_blank">下载</a>并将文件解压到您的路径中来手动安装protobuf二进制文件<code class="fe nw nx ny nz b">protoc</code>。</p><p id="021f" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">或者，您可以使用<strong class="li js">自制软件</strong>来安装protobuf二进制文件<code class="fe nw nx ny nz b">protoc</code>。</p><pre class="ob oc od oe gt of nz og oh aw oi bi"><span id="1d5c" class="oj mz ji nz b gy ok ol l om on">$ brew install protobuf@3.17</span></pre><p id="04fc" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li js"> 2。安装golang插件</strong></p><pre class="ob oc od oe gt of nz og oh aw oi bi"><span id="a2d0" class="oj mz ji nz b gy ok ol l om on">$ go get -u google.golang.org/grpc@v1.40.0<br/>$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.27.1<br/>$ <!-- -->go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1.0</span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="2c54" class="my mz ji bd na nb nc nd ne nf ng nh ni kx nj ky nk la nl lb nm ld nn le no np bi translated">关于目录结构的一个注记</h1><p id="97c3" class="pw-post-body-paragraph lg lh ji li b lj nq ks ll lm nr kv lo lp ns lr ls lt nt lv lw lx nu lz ma mb im bi translated">gRPC服务定义与消息传递协议和客户端代码紧密结合。我们可以依靠gRPC的这个构造来显著地改进向客户分发服务定义的过程。在实践中，我发现维护服务定义的整体项目是有效的。</p><p id="ffa0" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li js"> 1。<br/>新建一个目录</strong>创建下面的目录结构和<code class="fe nw nx ny nz b">salt_hash.proto</code>文件。随着你作为服务提供商的成长，你会发现在这个项目中添加其他服务是有价值的，因为客户已经熟悉了导入。</p><p id="30e2" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe nw nx ny nz b">proto</code>目录应该位于<code class="fe nw nx ny nz b">$GOPATH/src/proto</code>。</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">整体服务定义项目的初始目录</figcaption></figure><p id="7f0e" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">用下面的命令创建上面的目录结构。</p><pre class="ob oc od oe gt of nz og oh aw oi bi"><span id="d3d9" class="oj mz ji nz b gy ok ol l om on">$ mkdir -p $GOPATH/src/proto/security/salt_hash/datastore/v1</span></pre><p id="47e0" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li js"> 2。创建SaltHash服务定义<br/> </strong>通过添加以下代码在<code class="fe nw nx ny nz b">salt_hash.proto</code>内创建一个空服务定义。</p><pre class="ob oc od oe gt of nz og oh aw oi bi"><span id="6f5f" class="oj mz ji nz b gy ok ol l om on">$ touch $GOPATH/src/proto/security/salt_hash/datastore/v1/salt_hash.proto</span></pre><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure><ul class=""><li id="fb0b" class="oq or ji li b lj lk lm ln lp os lt ot lx ou mb ov ow ox oy bi translated"><code class="fe nw nx ny nz b">syntax</code>字段(1)声明该服务定义使用协议缓冲版本<code class="fe nw nx ny nz b">proto3</code>。</li><li id="9a87" class="oq or ji li b lj oz lm pa lp pb lt pc lx pd mb ov ow ox oy bi translated"><code class="fe nw nx ny nz b">go_package</code>字段(2)向代码生成工具提供关于生成的代码应该放在哪里的指令。</li><li id="6e2c" class="oq or ji li b lj oz lm pa lp pb lt pc lx pd mb ov ow ox oy bi translated"><code class="fe nw nx ny nz b">package</code>字段(3)防止协议消息类型之间的名称冲突，并用于生成代码。</li><li id="4c3d" class="oq or ji li b lj oz lm pa lp pb lt pc lx pd mb ov ow ox oy bi translated">(5)是服务定义接口。现在这是空的，但是很快将描述客户可以用来操作这个服务的方法。</li></ul><p id="c65d" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li js"> 3。将RPC方法添加到服务定义<br/> </strong>将<code class="fe nw nx ny nz b">Credentials</code>类型和方法添加到<code class="fe nw nx ny nz b">salt_hash.proto</code>文件。</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure><ul class=""><li id="46b4" class="oq or ji li b lj lk lm ln lp os lt ot lx ou mb ov ow ox oy bi translated">import语句(1)导入google提供的一组常见类型，例如StringValue和BoolValue。避免在这里重新创建轮子是很方便的。</li><li id="5b1b" class="oq or ji li b lj oz lm pa lp pb lt pc lx pd mb ov ow ox oy bi translated">(2)向数据存储区添加凭据的远程方法。</li><li id="529a" class="oq or ji li b lj oz lm pa lp pb lt pc lx pd mb ov ow ox oy bi translated">(3)从数据存储中删除凭证的远程方法。</li><li id="a7dc" class="oq or ji li b lj oz lm pa lp pb lt pc lx pd mb ov ow ox oy bi translated">(4)消息类型凭证的定义。</li><li id="7397" class="oq or ji li b lj oz lm pa lp pb lt pc lx pd mb ov ow ox oy bi translated">(5)保存用户名值的字段。</li><li id="e6bb" class="oq or ji li b lj oz lm pa lp pb lt pc lx pd mb ov ow ox oy bi translated">(6)保存密码值的字段。</li></ul><p id="efee" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一旦服务定义完成，您就可以自动生成gRPC代码，并为其实现客户机和服务器。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="f994" class="my mz ji bd na nb nc nd ne nf ng nh ni kx nj ky nk la nl lb nm ld nn le no np bi translated">汤姆·范·弗利克的一课</h1><blockquote class="pe pf pg"><p id="9ff3" class="lg lh nv li b lj lk ks ll lm ln kv lo ph lq lr ls pi lu lv lw pj ly lz ma mb im bi translated">如果某件事值得做一次，那就值得打造一个工具去做。汤姆·范·弗利克</p></blockquote><p id="b006" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">…并且您将大量编译服务定义，所以让我们创建一个Makefile来尊重我们未来的自己。</p><p id="8b95" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li js"> 1。在下面的位置创建一个Makefile文件。</strong></p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure><pre class="ob oc od oe gt of nz og oh aw oi bi"><span id="1e94" class="oj mz ji nz b gy ok ol l om on">$ touch $GOPATH/src/proto/Makefile</span></pre><p id="e4fa" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li js"> 2。将以下内容添加到Makefile中。</strong></p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="07ff" class="my mz ji bd na nb nc nd ne nf ng nh ni kx nj ky nk la nl lb nm ld nn le no np bi translated">编译服务定义</h1><p id="4909" class="pw-post-body-paragraph lg lh ji li b lj nq ks ll lm nr kv lo lp ns lr ls lt nt lv lw lx nu lz ma mb im bi translated">编译服务定义将允许您实现服务的业务逻辑。</p><p id="1636" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li js">从</strong> <code class="fe nw nx ny nz b"><strong class="li js">proto</strong></code> <strong class="li js">目录运行下面的</strong></p><pre class="ob oc od oe gt of nz og oh aw oi bi"><span id="c52a" class="oj mz ji nz b gy ok ol l om on">$ make compile</span></pre><p id="2f8c" class="pw-post-body-paragraph lg lh ji li b lj lk ks ll lm ln kv lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果没有出错，那么您将拥有以下目录结构和文件。</p><figure class="ob oc od oe gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="afd7" class="my mz ji bd na nb nc nd ne nf ng nh ni kx nj ky nk la nl lb nm ld nn le no np bi translated">创建Go模块</h1><p id="7ab7" class="pw-post-body-paragraph lg lh ji li b lj nq ks ll lm nr kv lo lp ns lr ls lt nt lv lw lx nu lz ma mb im bi translated">从<code class="fe nw nx ny nz b">proto</code>项目中创建一个Go模块，以便于客户端导入。</p><pre class="ob oc od oe gt of nz og oh aw oi bi"><span id="95cf" class="oj mz ji nz b gy ok ol l om on">$ go mod init proto<br/>$ go mod tidy</span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="fa48" class="my mz ji bd na nb nc nd ne nf ng nh ni kx nj ky nk la nl lb nm ld nn le no np bi translated">摘要</h1><ul class=""><li id="abb4" class="oq or ji li b lj nq lm nr lp pk lt pl lx pm mb ov ow ox oy bi translated">gRPC及其固有的接口优先需求可以用来改进向客户分发代码的过程。</li><li id="d634" class="oq or ji li b lj oz lm pa lp pb lt pc lx pd mb ov ow ox oy bi translated">gRPC使用协议缓冲区作为其接口定义语言来编写服务定义。</li><li id="0a3c" class="oq or ji li b lj oz lm pa lp pb lt pc lx pd mb ov ow ox oy bi translated">通过使用<code class="fe nw nx ny nz b">protoc</code>二进制和语言插件，服务定义被编译成目标语言的文件。</li><li id="8faf" class="oq or ji li b lj oz lm pa lp pb lt pc lx pd mb ov ow ox oy bi translated">必须先创建和编译服务定义，然后才能实现它们。</li></ul></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="c1e3" class="my mz ji bd na nb nc nd ne nf ng nh ni kx nj ky nk la nl lb nm ld nn le no np bi translated">延伸阅读…</h1><p id="3b74" class="pw-post-body-paragraph lg lh ji li b lj nq ks ll lm nr kv lo lp ns lr ls lt nt lv lw lx nu lz ma mb im bi translated">本文是四篇系列文章中的第二篇，将带您步入gRPC的正轨。点击下面的链接查看本系列的下一篇文章。</p><div class="is it gp gr iu mc"><a rel="noopener  ugc nofollow" target="_blank" href="/grpc-part-3-implementing-a-grpc-service-definition-cac5404c5c1b"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd js gy z fp mh fr fs mi fu fw jr bi translated">实施gRPC服务定义</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">gRPC构建生命周期有一个陡峭的学习曲线，但是您会看到我们可以自动完成这个过程。</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ml l"><div class="pn l mn mo mp ml mq ja mc"/></div></div></a></div></div></div>    
</body>
</html>