<html>
<head>
<title>Binary Tree Implementation in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中二叉树的实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/binary-tree-implementation-in-java-7d7b0b0f090b?source=collection_archive---------15-----------------------#2020-01-27">https://levelup.gitconnected.com/binary-tree-implementation-in-java-7d7b0b0f090b?source=collection_archive---------15-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="357d" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">最初发表于2020年1月27日我的<a class="ae ks" href="https://blog.contactsunny.com/tech/binary-tree-implementation-in-java" rel="noopener ugc nofollow" target="_blank">个人博客</a>。</p></blockquote><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/b4a9fcc39b572fb5eeb1095b28b66a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ma-RIJdPvYxemaK8"/></div></div></figure><p id="1d4e" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">更多在<a class="ae ks" href="https://blog.contactsunny.com/tag/data-structure-implementation-in-java" rel="noopener ugc nofollow" target="_blank"> <strong class="jw iu">《数据结构系列》</strong> </a>。</p><p id="c67b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">在学习了如何用Java实现一个<a class="ae ks" href="https://blog.contactsunny.com/tech/stack-implementation-in-java-using-linked-lists" rel="noopener ugc nofollow" target="_blank">栈</a>，各种类型的<a class="ae ks" href="https://blog.contactsunny.com/tag/linked-list-in-java" rel="noopener ugc nofollow" target="_blank">链表</a>，甚至一个<a class="ae ks" href="https://blog.contactsunny.com/tech/hashmap-implementation-in-java" rel="noopener ugc nofollow" target="_blank">哈希映射</a>之后，今天我们就来看看如何用Java构建自己的二叉树。类似于我们讨论过的其他数据结构，这里也有一个节点。它非常类似于<a class="ae ks" href="https://blog.contactsunny.com/tech/double-linked-list-implementation-in-java" rel="noopener ugc nofollow" target="_blank">双向链表</a> (DLL)中的节点，但是在DLL中没有前一个和下一个指针，我们在二叉树中有一个左指针和一个右指针。这是因为二叉树最多有两个子节点，一个在节点的左边，另一个在节点的右边。同样，与我写过的其他数据结构文章类似，我不打算解释什么是二叉树以及它是如何工作的。我们将直接进入实施阶段。所以让我们开始吧。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="e555" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">二叉树</h1><p id="42f3" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke lf mp kh ki lg mq kl km lh mr kp kq kr im bi translated">在开始编写代码之前，我们需要有一个参考树，以理解代码并验证代码的输出。如果我们有一个例子，理解树的功能也容易得多。所以，这就是我们要做的。我做了一项痛苦的工作，为这篇文章设计了一个图解，如下所示:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/b00200c2d1cdd239ee242681bd2b4763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*OSdyUWkJuLtKAkiAJ_LHhg.png"/></div></figure><p id="9947" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">到目前为止，这是我能为这个示例代码想到的最简单的二叉树。我们的根节点是1，它的左子节点是2，右子节点是3。然后，这两个节点都有几个子节点。在这篇文章中，我们将看看如何在代码中构建这棵树，然后进行三个流行的遍历:</p><ol class=""><li id="ac87" class="mt mu it jw b jx jy kb kc lf mv lg mw lh mx kr my mz na nb bi translated">前序遍历</li><li id="8cd2" class="mt mu it jw b jx nc kb nd lf ne lg nf lh ng kr my mz na nb bi translated">按顺序遍历</li><li id="9de5" class="mt mu it jw b jx nc kb nd lf ne lg nf lh ng kr my mz na nb bi translated">后置顺序遍历</li></ol></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="d32b" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">前序遍历</h1><p id="aad6" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke lf mp kh ki lg mq kl km lh mr kp kq kr im bi translated">在前序遍历中，我们在访问其子节点之前先“访问”节点。所以顺序应该是这样的:</p><p id="8249" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated"><em class="jv">节点- &gt;左子节点- &gt;右子节点</em></p><p id="a504" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">在我们的例子中，前序遍历的结果如下:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="2db4" class="nm lq it ni b gy nn no l np nq">1 2 4 5 3 6 7</span></pre><h1 id="2cec" class="lp lq it bd lr ls nr lu lv lw ns ly lz ma nt mc md me nu mg mh mi nv mk ml mm bi translated">按顺序遍历</h1><p id="31e2" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke lf mp kh ki lg mq kl km lh mr kp kq kr im bi translated">顾名思义，顺序遍历就是我们保持自然的遍历顺序，从左到右。所以顺序是这样的:</p><p id="381f" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated"><em class="jv">左子- &gt;节点- &gt;右子</em></p><p id="13ab" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">在我们的例子中，有序遍历的结果是这样的:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="b836" class="nm lq it ni b gy nn no l np nq">4 2 5 1 6 3 7</span></pre><h1 id="b33f" class="lp lq it bd lr ls nr lu lv lw ns ly lz ma nt mc md me nu mg mh mi nv mk ml mm bi translated">后置顺序遍历</h1><p id="e38d" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke lf mp kh ki lg mq kl km lh mr kp kq kr im bi translated">在后序遍历中，节点在子节点之后。因此，我们首先访问左边的子节点，然后是右边的子节点，如下所示:</p><p id="1dea" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated"><em class="jv">左子- &gt;右子</em> - &gt; <em class="jv">节点</em></p><p id="a1d1" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">在我们的例子中，后序遍历的结果是这样的:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="7bae" class="nm lq it ni b gy nn no l np nq">4 5 2 6 7 3 1</span></pre><p id="d6a4" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">在我们的代码中，我们将尝试实现这三种类型的遍历。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="8f54" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">代码</h1><p id="0ba8" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke lf mp kh ki lg mq kl km lh mr kp kq kr im bi translated">像往常一样，我们先看<em class="jv">节点</em>类。</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="e43c" class="nm lq it ni b gy nn no l np nq">public class Node&lt;T&gt; {<br/><br/>    private T data;<br/>    private Node&lt;T&gt; left;<br/>    private Node&lt;T&gt; right;<br/><br/>    public Node() {}<br/><br/>    public Node(T value) { this.data = value; }<br/><br/>    public T getData() {<br/>        return data;<br/>    }<br/><br/>    public void setData(T data) {<br/>        this.data = data;<br/>    }<br/><br/>    public Node&lt;T&gt; getLeft() {<br/>        return left;<br/>    }<br/><br/>    public void setLeft(Node&lt;T&gt; left) {<br/>        this.left = left;<br/>    }<br/><br/>    public Node&lt;T&gt; getRight() {<br/>        return right;<br/>    }<br/><br/>    public void setRight(Node&lt;T&gt; right) {<br/>        this.right = right;<br/>    }<br/>}</span></pre><p id="dbf6" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">正如我前面提到的，这里有左右指针，分别指向左边和右边的孩子。我们使用这个节点类作为我们的<em class="jv"> BinaryTree </em>类的基础。二叉树类的定义如下:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="ecd2" class="nm lq it ni b gy nn no l np nq">public class BinaryTree&lt;T&gt; {<br/>    <br/>    private Node&lt;T&gt; rootNode;<br/><br/>    public Node&lt;T&gt; getRootNode() {<br/>        return rootNode;<br/>    }<br/><br/>    public void setRootNode(Node&lt;T&gt; rootNode) {<br/>        this.rootNode = rootNode;<br/>    }<br/><br/>}</span></pre><p id="fc12" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">我们现在添加遍历方法。确保您记住了每个遍历是如何工作的。对于这些遍历方法，我们将使用递归，也就是说，我们将从方法本身内部调用一个方法。我们这样做是因为我们必须按照树的表示顺序遍历树的底部。首先，让我们来看看前序遍历。</p><h1 id="48b1" class="lp lq it bd lr ls nr lu lv lw ns ly lz ma nt mc md me nu mg mh mi nv mk ml mm bi translated">前序遍历</h1><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="da6f" class="nm lq it ni b gy nn no l np nq">public static void traversePreOrder(Node node) {<br/><br/>    System.out.print(node.getData() + " ");<br/><br/>    if (node.getLeft() != null) {<br/>        traversePreOrder(node.getLeft());<br/>    }<br/><br/>    if (node.getRight() != null) {<br/>        traversePreOrder(node.getRight());<br/>    }<br/>}</span></pre><p id="cd90" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">如你所见，我们首先打印节点的值，然后到左边的节点，最后到右边。这样，当前节点排在第一位，因此在前置顺序遍历中是<em class="jv">前置</em>。在这个函数调用的第一次迭代中，我们将把根节点作为参数传递。所以根节点首先被“访问”,然后根节点的所有左子节点按前序被访问。该函数的输出如下:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="36a6" class="nm lq it ni b gy nn no l np nq">1 2 4 5 3 6 7</span></pre><h1 id="b642" class="lp lq it bd lr ls nr lu lv lw ns ly lz ma nt mc md me nu mg mh mi nv mk ml mm bi translated">按顺序遍历</h1><p id="d249" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke lf mp kh ki lg mq kl km lh mr kp kq kr im bi translated">按照顺序遍历，正如我已经解释过的，将按照自然的从左到右的顺序。以下是这方面的代码:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="3ddc" class="nm lq it ni b gy nn no l np nq">public static void traverseInOrder(Node node) {<br/><br/>    if (node.getLeft() != null) {<br/>        traverseInOrder(node.getLeft());<br/>    }<br/><br/>    System.out.print(node.getData() + " ");<br/><br/>    if (node.getRight() != null) {<br/>        traverseInOrder(node.getRight());<br/>    }<br/>}</span></pre><p id="bee4" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">从代码片段中可以看出，首先访问左边的子节点，然后是右边的子节点。其输出如下所示:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="4bd5" class="nm lq it ni b gy nn no l np nq">4 2 5 1 6 3 7</span></pre><h1 id="010a" class="lp lq it bd lr ls nr lu lv lw ns ly lz ma nt mc md me nu mg mh mi nv mk ml mm bi translated">后置顺序遍历</h1><p id="0314" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke lf mp kh ki lg mq kl km lh mr kp kq kr im bi translated">最后，我们有后期订单遍历。在这种情况下，首先访问左边的子节点，然后是右边的子节点，最后是节点。所以名字<em class="jv">贴</em>顺序。下面是相应的代码片段:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="4fc4" class="nm lq it ni b gy nn no l np nq">public static void traversePostOrder(Node node) {<br/><br/>    if (node.getLeft() != null) {<br/>        traversePostOrder(node.getLeft());<br/>    }<br/><br/>    if (node.getRight() != null) {<br/>        traversePostOrder(node.getRight());<br/>    }<br/><br/>    System.out.print(node.getData() + " ");<br/>}</span></pre><p id="02b7" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">对于后期订单遍历，我们将获得以下输出:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="dd1d" class="nm lq it ni b gy nn no l np nq">4 5 2 6 7 3 1</span></pre><p id="7a8d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">完整的BinaryTree类如下所示:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="b157" class="nm lq it ni b gy nn no l np nq">public class BinaryTree&lt;T&gt; {<br/>    <br/>    private Node&lt;T&gt; rootNode;<br/><br/>    public Node&lt;T&gt; getRootNode() {<br/>        return rootNode;<br/>    }<br/><br/>    public void setRootNode(Node&lt;T&gt; rootNode) {<br/>        this.rootNode = rootNode;<br/>    }<br/>    <br/>    public static void traverseInOrder(Node node) {<br/><br/>        if (node.getLeft() != null) {<br/>            traverseInOrder(node.getLeft());<br/>        }<br/><br/>        System.out.print(node.getData() + " ");<br/><br/>        if (node.getRight() != null) {<br/>            traverseInOrder(node.getRight());<br/>        }<br/>    }<br/><br/>    public static void traversePreOrder(Node node) {<br/><br/>        System.out.print(node.getData() + " ");<br/><br/>        if (node.getLeft() != null) {<br/>            traversePreOrder(node.getLeft());<br/>        }<br/><br/>        if (node.getRight() != null) {<br/>            traversePreOrder(node.getRight());<br/>        }<br/>    }<br/><br/>    public static void traversePostOrder(Node node) {<br/><br/>        if (node.getLeft() != null) {<br/>            traversePostOrder(node.getLeft());<br/>        }<br/><br/>        if (node.getRight() != null) {<br/>            traversePostOrder(node.getRight());<br/>        }<br/><br/>        System.out.print(node.getData() + " ");<br/>    }<br/>}</span></pre><p id="273a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">这是一个相当简单的二叉树例子。随着我们向树中添加更多级别，这变得更加有趣。你可以自己试试。但是我们如何测试我们刚刚写的代码呢？我们将在下一节看到这一点。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="b0eb" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">测试</h1><p id="9111" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke lf mp kh ki lg mq kl km lh mr kp kq kr im bi translated">在我们的主类中，我们将创建一个Integer类型的二叉树，并用下面给出的代码片段添加根节点:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="19da" class="nm lq it ni b gy nn no l np nq">BinaryTree&lt;Integer&gt; binaryTree = new BinaryTree&lt;&gt;();<br/>Node&lt;Integer&gt; rootNode = new Node&lt;&gt;(1);<br/>binaryTree.setRootNode(rootNode);</span></pre><p id="15b8" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">一旦我们设置了根节点，我们就可以开始向根节点添加子节点，如下所示:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="99db" class="nm lq it ni b gy nn no l np nq">binaryTree.getRootNode().setLeft(new Node&lt;&gt;(2)); binaryTree.getRootNode().setRight(new Node&lt;&gt;(3));</span></pre><p id="5db5" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">接下来，我们将开始向这两个节点添加更多节点，如下所示:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="8c15" class="nm lq it ni b gy nn no l np nq">binaryTree.getRootNode().getLeft().setLeft(new Node&lt;&gt;(4));<br/>binaryTree.getRootNode().getLeft().setRight(new Node&lt;&gt;(5));<br/><br/>binaryTree.getRootNode().getRight().setLeft(new Node&lt;&gt;(6));<br/>binaryTree.getRootNode().getRight().setRight(new Node&lt;&gt;(7));</span></pre><p id="cc3f" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">这是创建二叉树的完整代码，我已经在本文开始的插图中展示过了。现在，让我们看看如何遍历这棵树:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="a567" class="nm lq it ni b gy nn no l np nq">System.out.println("Pre order traversing:");<br/>BinaryTree.traversePreOrder(binaryTree.getRootNode());<br/>System.out.println();<br/><br/>System.out.println("In order traversing:");<br/>BinaryTree.traverseInOrder(binaryTree.getRootNode());<br/>System.out.println();<br/><br/>System.out.println("Post order traversing:");<br/>BinaryTree.traversePostOrder(binaryTree.getRootNode());<br/>System.out.println();</span></pre><p id="625a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">那是非常直接的。这段代码的输出如下:</p><pre class="ku kv kw kx gt nh ni nj nk aw nl bi"><span id="4dd5" class="nm lq it ni b gy nn no l np nq">Pre order traversing:<br/>1 2 4 5 3 6 7 <br/>In order traversing:<br/>4 2 5 1 6 3 7 <br/>Post order traversing:<br/>4 5 2 6 7 3 1</span></pre><p id="a90c" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">遍历如我们预期的那样工作。所以我们到此为止。</p><p id="d8a2" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lf kg kh ki lg kk kl km lh ko kp kq kr im bi translated">像往常一样，我已经为这个实现设置了一个完整的maven项目。你可以从<a class="ae ks" href="https://github.com/contactsunny/binarytree_implementation_java_poc" rel="noopener ugc nofollow" target="_blank">我的Github repo </a>中查看或获取。</p></div></div>    
</body>
</html>