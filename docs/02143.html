<html>
<head>
<title>C/C++ pointer vs C++ reference vs Java reference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C/C++指针与C++参考和Java参考</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/c-c-pointer-vs-c-reference-vs-java-reference-facc037eb2a5?source=collection_archive---------2-----------------------#2020-02-21">https://levelup.gitconnected.com/c-c-pointer-vs-c-reference-vs-java-reference-facc037eb2a5?source=collection_archive---------2-----------------------#2020-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/edda0336c2ca2de4ea6c39312827adac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osLDToSqxHZzTERZw5Et8g.jpeg"/></div></div></figure><p id="87e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要在C++中声明一个指针，你可以在指针名旁边使用一个星号。为了说明这一点，在声明常规int标量变量时，可以输入以下内容:</p><p id="272d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">int a；</strong></p><p id="89e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当声明一个指针“b”时，你可以输入:</p><p id="51e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">int * b；</strong></p><p id="f69c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，指针变量包含星号。</p><p id="7a72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看内存，看看刚刚发生了什么。对于标量变量int“a”，保留了4个字节的内存。如果你看下面的表示，你会看到int“a”实际上被分配了4个字节的内存，位于内存地址0x34(只是一个随机的内存地址)。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/61520ec6e11966f481b0a0a0b106094a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Bklq7SqRcbTWwPFl3daG_Q.png"/></div></figure><p id="4f87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们要给标量变量“a”赋值，保留空间将被修改以直接包含该值。这可以从下面看出:</p><p id="09df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">int a = 5；</strong> // 5二进制是00000101</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/b9fa84fb386f813aaa04812129384b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*gz2l7OKb_UenTOCPtsuekA.png"/></div></figure><p id="4d9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其余字节用零填充。为什么？接下来，您可能想要修改整数值。它必须确保支持预定义的整数范围，对于有符号位，该范围恰好是-2，147，483，648到2，147，483，647，对于无符号位，该范围是0到4，294，967，295。</p><p id="bf83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于指针变量，根据体系结构，在32位机器上，将为指针变量分配4个字节的内存；在64位机器上，将分配8个字节。</p><p id="ed18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了简单起见，我们将使用一个抽象表示，其中指针只占用1个字节。因此，当指针“b”在上面声明时，它将像标量变量一样与内存地址相关联，但不能像标量变量“a”那样直接存储值，它只能存储内存地址。下面你可以看到内存地址0x11是指针“b”所在的位置。很多时候，在声明时会分配一个0，所以我们将把存储器地址0输入到0x11存储器地址中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/fea9784d00541924ff1fb2297c1bdb0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*BZQWBh2Cfk6rCsnyzkj0wQ.png"/></div></figure><p id="388e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个指针“b”目前不指向任何东西。因此，让我们改变它，将“b”指针指向位于0x34的“a”标量变量。我们不能简单地进入</p><p id="2d30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">b = a；</strong></p><p id="34ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为“a”提供存储在0x34中的值，而“b”仅存储存储器地址。要将“a”的地址存储到指针“b”中，我们必须在“a”前面使用&amp;符号:</p><p id="f53a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">b =&amp;a；</strong></p><p id="0417" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，“a”的内存地址存储在指针“b”中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/92142c67641052786bdd61297a0011bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*vbCkAMqjky40ykbfe_weFg.png"/></div></figure><p id="3bfd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“b”现在指向“a”的内存地址。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/4f526536db6708b707c1eba5bd8faab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*lqA10cj6bvqdH4mrL5dd3g.png"/></div></figure><p id="a041" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们要打印出指针“b”，我们将得到十六进制值0x34，这是存储在指针“b”中的地址。要打印出“a”的值，我们必须首先取消对指针“b”的引用，方法是再次在它前面加上星号。为了进一步解释解引用，我们将看几个例子。</p><p id="dca0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前b是一个声明的指针(int* b ),它指向“a”的内存地址。</p><p id="4340" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了打印出“a”的值，我们将使用C的printf语句:</p><p id="3453" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> printf("%d "，* b)；</strong> //打印5张</p><p id="ea41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，*b是解引用指针，将产生存储在a中的值，即5。</p><p id="7f50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们如何更新存储在“a”中的值我们可以通过两种不同的方式来实现。第一种方法是将新值直接赋给“a ”:</p><p id="1db2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">a = 10；</strong></p><p id="a47d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一种方法是取消引用表达式左侧的指针:</p><p id="9ee5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">* b = 10；</strong> // *b与“a”相同，因为“b”指向“a”</p><p id="e484" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们要创建其他变量，我们可以通过给指针分配新的内存地址来保持指针指向不同的东西。例如，假设我们创建了一个新的int c标量变量。要将指针“b”赋给标量“c”，我们将执行与之前相同的过程:</p><p id="dae0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">b =&amp;c；</strong></p><p id="c959" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我们没有取消对指针“b”的引用。因为我们没有取消对指针“b”的引用，“b”被直接修改，现在指向内存地址“c”</p><p id="2d4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么在C++中什么是引用呢？你可以把它看作一个别名(也就是同一个内存地址的另一个名字)。在这个例子中，我们已经声明了两个标量变量“a”和“c”。为了给每个变量取一个替换名，我们可以使用一个引用。要添加对“a”的引用，我们可以执行以下操作:</p><p id="53e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">int&amp;ref = a；</strong></p><p id="2e1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，出现在左侧的&amp;符号表示变量“ref”应该是一个引用，本质上与“a”是相同的。我们知道“a”位于0x34。新的引用“ref”也将位于存储器地址0x34。如果我们要打印“a”或“ref”，我们会看到值10(我们之前指定a = 10)。</p><p id="cb83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然现在存在一个引用，要将我们的指针“b”指向“a ”,我们可以用两种不同的方法来实现:</p><p id="33a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">b =&amp;a；</strong></p><p id="9975" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者</p><p id="db07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">b =&amp;ref；</p><p id="02f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">C++中的引用类型不同于Java中的引用类型。在Java中，我们有两种不同的类型:值类型和引用类型。值类型由原始数据类型组成，在Java中是:</p><p id="1d1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">字节、短整型、整型、长整型、浮点型、双精度型、布尔型和字符型</strong></p><p id="0855" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有其他变量类型都是引用类型(即String是引用类型，但请记住Java中的String是不可变的，因此当试图修改String时，将在堆中创建一个新对象)。Java中的引用行为更像C或C++指针，而不像C++引用类型。最大的区别是Java引用总是指向对象，而C和C++指针可以指向任何东西。要在Java中创建int类型的值类型，可以执行以下操作:</p><p id="566e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">int var _ name = 10；</strong></p><p id="7485" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该语句将一个内存位置与var_name相关联，并为其赋值10。与上面C++例子中的int a = 5的过程相同。</p><p id="b172" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们创建car类型的引用类型(我自己创建的类)时，如下例所示，dinos_car被分配一个内存位置，Car对象被分配一个堆中的位置。Car对象在堆中的位置(内存地址)存储在引用变量dinos_car中。</p><p id="e0a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Car dinos_car =新车(“蓝宝”)；</strong></p><p id="0fe8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">new操作符在堆中创建Car对象。那么，上面的语句是做什么的呢？在堆中创建一个位置。获取Car对象在堆中的内存地址，并将其分配给dinos_car。</p><p id="7449" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们为什么需要推荐信？内存管理。让我们看一个例子。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/ee930fa8deb11e6ff2f4453847fb5e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LiM6g-2n78I0Xw-MUqY4eQ.png"/></div></div></figure><p id="f7ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，“a”有一个原始数据类型int。它被赋值为10，并将该值直接存储在分配给它的内存地址中。我们打印出" a ",正如所料，它打印出10。接下来，我们调用一个方法，该方法将一个整数作为参数并递增它。一旦我们再次打印出“a ”,我们期望打印出的是11，但在本例中是10。为什么？当向increment提供参数“a”时，increment方法会复制它，并且范围仅限于increment方法。increment方法中的局部变量“a”是一个堆栈动态变量，它的生存期大约是该方法的长度。方法完成后，局部变量“a”(在increment方法中)被丢弃，不再可见。</p><p id="bc5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当引用变量作为参数传递时，对象在堆中的内存地址被传递，修改直接在对象本身上完成。例如:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/3ad4ddce4d40636f66cdeca93c7e641b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f2VkvFEMNbzmCFpyLQGZdA.png"/></div></div></figure><p id="8c80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，changeCar()方法有两个参数:Car a和字符串newCar。引用变量“a”只包含位于堆中某处的对象Car的内存地址。该堆对象被直接修改。该对象不会复制到changeCar()方法中。为什么？物体可能是巨大的。我们不希望每次调用一个方法就复制这么大的对象，因为我们可能会很快耗尽内存，我们的程序会明显变慢。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lm"><img src="../Images/fe85e745256b3a85900707d2e976c0b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5eUrYmxE_VTljtpd.jpeg"/></div></div></figure><p id="ffaf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">迪诺·卡伊奇目前是<a class="ae ln" href="https://www.lsbio.com/" rel="noopener ugc nofollow" target="_blank"> LSBio(生命周期生物科学公司)</a>、<a class="ae ln" href="https://absoluteantibody.com/" rel="noopener ugc nofollow" target="_blank">绝对抗体</a>、<a class="ae ln" href="https://www.kerafast.com/" rel="noopener ugc nofollow" target="_blank"> Kerafast </a>、<a class="ae ln" href="https://everestbiotech.com/" rel="noopener ugc nofollow" target="_blank">珠穆朗玛生物</a>、<a class="ae ln" href="https://www.nordicmubio.com/" rel="noopener ugc nofollow" target="_blank">北欧MUbio </a>和<a class="ae ln" href="https://www.exalpha.com/" rel="noopener ugc nofollow" target="_blank"> Exalpha </a>的IT主管。他还担任我的自动系统的首席执行官。他有十多年的软件工程经验。他拥有计算机科学学士学位，辅修生物学。他的背景包括创建企业级电子商务应用程序、执行基于研究的软件开发，以及通过写作促进知识的传播。</p><p id="5aff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在<a class="ae ln" href="https://www.linkedin.com/in/dinocajic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系他，在<a class="ae ln" href="https://instagram.com/think.dino" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注他，或者<a class="ae ln" href="https://dinocajic.medium.com/subscribe" rel="noopener">订阅他的媒体出版物</a>。</p><p id="f8c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae ln" href="https://dinocajic.medium.com/membership" rel="noopener"> <em class="lo">阅读迪诺·卡吉克(以及媒体上成千上万其他作家)的每一个故事。你的会员费直接支持迪诺·卡吉克和你阅读的其他作家。你也可以在媒体上看到所有的故事。</em> </a></p></div></div>    
</body>
</html>