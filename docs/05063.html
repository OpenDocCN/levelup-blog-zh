<html>
<head>
<title>Kotlin Scope Functions: The God-Sent Guide.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林示波器功能:天赐指南。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kotlin-scope-functions-the-god-sent-guide-4930533874de?source=collection_archive---------4-----------------------#2020-08-01">https://levelup.gitconnected.com/kotlin-scope-functions-the-god-sent-guide-4930533874de?source=collection_archive---------4-----------------------#2020-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/15422f08eed72d6c416ff42d25749fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J6_bregKfuE8hvAB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@davidpisnoy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·皮斯诺伊</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><blockquote class="kd ke kf"><p id="be6d" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kj ir">TL；DR；备忘单在这一页的末尾。</strong></p></blockquote><blockquote class="lf"><p id="7c24" class="lg lh iq bd li lj lk ll lm ln lo le dk translated">“我想，如果你唯一的工具是一把锤子，那么把一切都当成钉子是很有诱惑力的。”</p></blockquote><p id="5360" class="pw-post-body-paragraph kg kh iq kj b kk lp km kn ko lq kq kr lr ls ku kv lt lu ky kz lv lw lc ld le ij bi translated">正式名称为<a class="ae kc" href="https://en.wikipedia.org/wiki/Law_of_the_instrument" rel="noopener ugc nofollow" target="_blank">金锤</a>法则的美国心理学家亚伯拉罕·马斯洛创造了这个简单而真实的原则，它贬低了在解决问题的过程中对单一工具的过度依赖，支持一个人使用更多的工具来优雅而精确地解决问题。</p><p id="0213" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">JetBrains在开发Kotlin的过程中发挥了最大的作用，为开发人员提供了几十把精密的瑞士刀，以正确而严格地处理各种情况。</p><p id="8607" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">一个很好的例子是语言标准库提供的广泛的<a class="ae kc" href="https://kotlinlang.org/docs/reference/scope-functions.html#:~:text=OSGi-,Scope%20Functions,it%20forms%20a%20temporary%20scope." rel="noopener ugc nofollow" target="_blank">作用域函数</a>。很少有语言能够展示这一整套工具以及对动态范围和对象操作的控制。</p><p id="93de" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">但是，特别是，开发人员被提供了一堆不同的锐利工具，用于非常相似的用例。虽然你是一个强有力的盟友，但你需要负责任，确保正确理解范围函数并正确使用它们。</p><p id="bd0e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">关于这个主题，网上有很多文档和代码。然而，对于选择哪一个函数最好，并没有官方明确的指导方针，这取决于你所处的环境。事实上，在语法语义正确性的范围内，一个作用域函数对另一个作用域函数的使用有点武断。因此，您必须了解如何充分利用它们，并根据您/您的团队的偏好来决定您的项目编码风格。</p><h1 id="e82c" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">从什么开始作用域函数？</h1><p id="12f2" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated">我们将暂时搁置严格的定义，我将这样说:使用范围函数实际上是一种强大、干净和简洁的编码方式。他们的能力是把重复的、多余的代码变成诗歌。</p><p id="32ec" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">Kotlin中的那些函数是<code class="fe na nb nc nd b">run</code>、<code class="fe na nb nc nd b">let</code>、<code class="fe na nb nc nd b">apply</code>、&amp;、<code class="fe na nb nc nd b">also</code>。</p><p id="63b2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">他们允许你用物品变魔术。你可以在任何你喜欢的对象上调用<em class="ki">作用域函数，因为它们都是<a class="ae kc" href="https://kotlinlang.org/docs/reference/extensions.html" rel="noopener ugc nofollow" target="_blank">扩展函数</a>和<a class="ae kc" href="https://kotlinlang.org/docs/reference/generics.html" rel="noopener ugc nofollow" target="_blank">通用函数</a>。因为在科特林，一切都是物体，所以他们是完美的一对。</em></p><p id="f3d1" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">另一个关键概念是，有时你可以用多种方式做同一件事。我们当然可以争辩说，run、<code class="fe na nb nc nd b">let</code>、<code class="fe na nb nc nd b">also</code>、&amp;、<code class="fe na nb nc nd b">apply</code>都将在技术上为你完成这项工作，因为它们都解决了一个类似的问题，但方式略有不同。</p><h1 id="d1d7" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">代码示例。</h1><p id="2b5a" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated">考虑下面的语法，它应该创建一个窗口并用它做一些琐碎的操作。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3bbb" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">让我们感到特别不安的是，我们有很多重复的代码。数一数<code class="fe na nb nc nd b">window</code>出现的次数。我们甚至不得不把<code class="fe na nb nc nd b">window.header.buttons</code>写了三遍。</p><p id="8e90" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">那是令人难以忍受的多余和重复。让我们用范围函数来增加趣味。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b640" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">这是一个很大的进步。我们现在可以开始看到作用域函数的影响:由于我们的<code class="fe na nb nc nd b">apply</code>块，<code class="fe na nb nc nd b">this</code>指向一个不同的作用域。我们现在有了一个主编辑块来<em class="ki">应用<code class="fe na nb nc nd b">window</code>对象内部的</em>变化。为了使<code class="fe na nb nc nd b">add</code>函数循环三次，我们还使用了<code class="fe na nb nc nd b">run</code>(我们使用了<code class="fe na nb nc nd b">run</code>而不是<code class="fe na nb nc nd b">apply</code>，因为我们不关心结果)。</p><p id="cd91" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">仍有一些需要改进的地方:</p><ul class=""><li id="0618" class="nk nl iq kj b kk kl ko kp lr nm lt nn lv no le np nq nr ns bi translated">在创建了<code class="fe na nb nc nd b">ApplicationWindow</code>之后，可以内联<code class="fe na nb nc nd b">apply</code>调用。</li><li id="d195" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le np nq nr ns bi translated">前缀<code class="fe na nb nc nd b">this</code>是多余的。</li><li id="a12f" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le np nq nr ns bi translated">为了更好的语法，我们可以将<code class="fe na nb nc nd b">show()</code>函数移到<code class="fe na nb nc nd b">also</code>块中。</li></ul><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d147" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">瞧。完全相同的结果，但代码结构却大不相同。</p><p id="4e8f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">这是一个例子，通过将这些工具添加到您的腰带上，您可以为您的代码带来实质性的变化。</p><h1 id="c706" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">引擎盖下:让&amp;申请。</h1><p id="d817" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated">我们现在将直接通过查看它们的源代码来分解<code class="fe na nb nc nd b">let</code>和<code class="fe na nb nc nd b">apply</code>(它们是最不同的扩展函数，就像<code class="fe na nb nc nd b">run</code>对于<code class="fe na nb nc nd b">also</code>)的行为，以充分理解使它们工作的机制和部件。然后我们可以整合<code class="fe na nb nc nd b">run</code>和<code class="fe na nb nc nd b">also</code>来区分基于那些变化部分的作用域功能，并找出哪一个应该用于什么。</p><h2 id="ddad" class="ny ly iq bd lz nz oa dn md ob oc dp mh lr od oe ml lt of og mp lv oh oi mt oj bi translated">让</h2><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">(请注意，我删除了一些不感兴趣的代码，以便专注于let的内容)</figcaption></figure><ol class=""><li id="2d30" class="nk nl iq kj b kk kl ko kp lr nm lt nn lv no le ok nq nr ns bi translated">泛型类型声明<code class="fe na nb nc nd b">&lt;T, R&gt;</code>意味着<code class="fe na nb nc nd b">let</code>扩展的类型<code class="fe na nb nc nd b">T</code>可以不同于返回的类型<code class="fe na nb nc nd b">R</code>。</li><li id="8972" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le ok nq nr ns bi translated"><code class="fe na nb nc nd b">let</code>是一个扩展函数，适用于任何类型<code class="fe na nb nc nd b">T</code>。的确，<code class="fe na nb nc nd b">T.let</code>的意思是“<code class="fe na nb nc nd b">let</code>可以在任何类型上调用，我们就把你的whatever类型叫做<code class="fe na nb nc nd b">T</code>”。</li><li id="3794" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le ok nq nr ns bi translated">当<code class="fe na nb nc nd b">let</code>被调用时，一个lambda被传递给<code class="fe na nb nc nd b">let</code>，命名为<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>。的确，<code class="fe na nb nc nd b">let(<strong class="kj ir">block</strong>: (T) -&gt; R)</code>。</li><li id="4eaa" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le ok nq nr ns bi translated"><code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>是一个lambda，因此接受一个类型为<code class="fe na nb nc nd b">T</code>的参数，并返回一个类型为<code class="fe na nb nc nd b">R</code>的值。(<code class="fe na nb nc nd b">T</code>代表<em class="ki">参数-</em><strong class="kj ir"><em class="ki">T</em></strong><em class="ki">类型</em>，<code class="fe na nb nc nd b">R</code>代表<strong class="kj ir"><em class="ki">R</em></strong><em class="ki">eturn-类型</em>)。的确，<code class="fe na nb nc nd b">let(<strong class="kj ir">block</strong>: (T) -&gt; R)</code>。</li><li id="b987" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le ok nq nr ns bi translated">然后在<code class="fe na nb nc nd b">let</code>内部执行<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>，由<code class="fe na nb nc nd b">let</code>返回<code class="fe na nb nc nd b"><em class="ki">R</em></code> <em class="ki"> -Type </em>结果。的确，<code class="fe na nb nc nd b">return <strong class="kj ir">block</strong>(this)</code>。</li></ol><p id="3ae0" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">超级重要:<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>接受一个<code class="fe na nb nc nd b"><em class="ki">T</em></code> <em class="ki"> -Type </em>作为它的参数。的确，<code class="fe na nb nc nd b">this</code>被送入<code class="fe na nb nc nd b"><strong class="kj ir">block</strong>()</code>，因为<code class="fe na nb nc nd b">let</code>内的<code class="fe na nb nc nd b">this</code>引用了被调用的对象<code class="fe na nb nc nd b">let</code>(因为<code class="fe na nb nc nd b">let</code>是一个扩展函数)。并且根据<code class="fe na nb nc nd b">let</code>的定义，该对象必须是一个<code class="fe na nb nc nd b"><em class="ki">T</em></code><em class="ki">-类型</em>。另外，由于<code class="fe na nb nc nd b"><strong class="kj ir">block()</strong> -&gt; R</code>和<code class="fe na nb nc nd b">let</code>返回<code class="fe na nb nc nd b"><strong class="kj ir">block</strong>()</code>，所以<code class="fe na nb nc nd b">let -&gt; R</code>是有意义的。</p><p id="eb0b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">📌:<code class="fe na nb nc nd b">let</code>的lambda签名是<code class="fe na nb nc nd b">(T) -&gt; R</code>，这意味着它接受一个类型为<code class="fe na nb nc nd b">T</code>、<em class="ki"> it </em>的参数。</p><p id="5066" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">📌:<code class="fe na nb nc nd b">let</code>返回其<code class="fe na nb nc nd b"><strong class="kj ir">block</strong>()</code>函数返回的任何内容，作为一个<code class="fe na nb nc nd b"><em class="ki">R</em></code><em class="ki">-类型</em>，这可能与被调用的<code class="fe na nb nc nd b"><em class="ki">T</em></code><em class="ki">-类型</em> <code class="fe na nb nc nd b">T.let</code>不同。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="940f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated"><code class="fe na nb nc nd b">T</code>是<code class="fe na nb nc nd b">Person</code>,<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>是花括号之间的函数，它接受<code class="fe na nb nc nd b">it</code>并返回最后一条语句；准确地说，<code class="fe na nb nc nd b">R</code>，也就是<code class="fe na nb nc nd b">Unit</code>，因为<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>的最后一行没有返回任何东西(<code class="fe na nb nc nd b">println(it)</code>)</p><h2 id="231a" class="ny ly iq bd lz nz oa dn md ob oc dp mh lr od oe ml lt of og mp lv oh oi mt oj bi translated">应用</h2><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">(注意，我删除了一些不感兴趣的代码，以专注于apply的内容)</figcaption></figure><ol class=""><li id="3f94" class="nk nl iq kj b kk kl ko kp lr nm lt nn lv no le ok nq nr ns bi translated">泛型类型声明<code class="fe na nb nc nd b">&lt;T&gt;</code>意味着<code class="fe na nb nc nd b">apply</code>扩展的类型<code class="fe na nb nc nd b">T</code>在返回时必须匹配自身。</li><li id="3d8f" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le ok nq nr ns bi translated"><code class="fe na nb nc nd b">apply</code>是一个扩展函数，适用于任何<code class="fe na nb nc nd b">T</code>。的确，<code class="fe na nb nc nd b">T.apply</code>的意思是“<code class="fe na nb nc nd b">apply</code>可以在任何类型上调用，我们就把你的whatever类型叫做<code class="fe na nb nc nd b">T</code>”。</li><li id="cdf3" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le ok nq nr ns bi translated">当<code class="fe na nb nc nd b">apply</code>被调用时，一个λ被传递给<code class="fe na nb nc nd b">apply</code>，命名为<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>。的确，<code class="fe na nb nc nd b">apply(<strong class="kj ir">block</strong>: T.() -&gt; Unit)</code>。</li><li id="41e9" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le ok nq nr ns bi translated"><code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>为无参数lambda，扩展<code class="fe na nb nc nd b">T</code>并返回<code class="fe na nb nc nd b">Unit</code>。(而在<code class="fe na nb nc nd b">let</code>中我们有<code class="fe na nb nc nd b">(T)</code>，这意味着<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>是一个接受一个T类型参数的lambda，带有<code class="fe na nb nc nd b">apply</code>，<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>的签名是<code class="fe na nb nc nd b">T.()</code>。这意味着<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>的作用域是<code class="fe na nb nc nd b">T</code>，因此我们将不再有<code class="fe na nb nc nd b">it</code>作为<code class="fe na nb nc nd b"><em class="ki">T</em></code> <em class="ki"> -Type </em>对象。这次会是<code class="fe na nb nc nd b">this</code>。以下方法的巧妙之处在于，我们不需要在<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>函数中直接引用变量，因为我们的代码是在<code class="fe na nb nc nd b">T</code>之上执行的。</li><li id="9568" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le ok nq nr ns bi translated"><code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>然后在<code class="fe na nb nc nd b">apply</code>里面执行。事实上，我们看到<code class="fe na nb nc nd b"><strong class="kj ir">block()</strong></code>单独在一条线上。</li><li id="20ee" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le ok nq nr ns bi translated"><code class="fe na nb nc nd b"><em class="ki">T</em></code> <em class="ki"> -Type </em>结果由<code class="fe na nb nc nd b">apply</code>返回。的确，<code class="fe na nb nc nd b">return this</code>。</li></ol><p id="db20" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">超级重要:在<code class="fe na nb nc nd b"><strong class="kj ir">block()</strong></code>运行后，它的返回值被忽略。<code class="fe na nb nc nd b">this</code>被退回。如果<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>以某种方式改变了<code class="fe na nb nc nd b">this</code>，那么这些变化将反映功能输出。</p><p id="ac88" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">📌:<code class="fe na nb nc nd b">apply</code>的lambda签名为<code class="fe na nb nc nd b">T.() -&gt; Unit</code>，其<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>函数的作用域为<code class="fe na nb nc nd b">T</code>，由<em class="ki">引用此</em>。</p><p id="3b7c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">📌:<code class="fe na nb nc nd b">apply</code>返回它被调用的对象。无论<code class="fe na nb nc nd b"><strong class="kj ir">block</strong>()</code>函数返回什么，都将被丢弃。<code class="fe na nb nc nd b">apply</code>不关心lambda返回什么。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7afa" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated"><code class="fe na nb nc nd b">T</code>是<code class="fe na nb nc nd b">Person</code>，而<code class="fe na nb nc nd b"><strong class="kj ir">block</strong></code>是花括号之间的函数，它在<code class="fe na nb nc nd b">T</code>之上执行并返回现在更新的基础对象(<code class="fe na nb nc nd b">alice</code>，也就是<code class="fe na nb nc nd b">Person</code>)。</p><h1 id="6a11" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">差异分析。</h1><p id="adc4" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated">也许作用域函数最令人沮丧的一点是，对于如何选择其中之一，没有一张魔表。当然，您可以描绘出它们的属性，但是选择归结于上下文，以及您认为适合您的代码的内容。你必须慢慢培养直觉和直觉，才能自信地从众多选择中选出一个，这需要练习和创造力。把它们混在一起，玩，测试，弄乱它们。这将帮助你变得舒适。阅读代码以获取模式，编写示例测试代码以学习。它会值<code class="fe na nb nc nd b">it</code>。</p><h2 id="d4de" class="ny ly iq bd lz nz oa dn md ob oc dp mh lr od oe ml lt of og mp lv oh oi mt oj bi translated">🟢让</h2><blockquote class="kd ke kf"><p id="fa06" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">你有麻烦了？让我来处理这件事。</p></blockquote><p id="bbda" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">当与安全调用<code class="fe na nb nc nd b">?.</code>操作符结合使用来处理可空性时，非常方便。更多关于它的<a class="ae kc" href="https://medium.com/mobile-app-development-publication/kotlin-dont-just-use-let-7e91f544e27f" rel="noopener">这里</a>。</p><p id="13ff" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">返回lambda块的最后一条语句。</p><h2 id="3e05" class="ny ly iq bd lz nz oa dn md ob oc dp mh lr od oe ml lt of og mp lv oh oi mt oj bi translated">🔴奔跑</h2><blockquote class="kd ke kf"><p id="1c54" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们要一起运行这一堆函数。</p></blockquote><p id="352e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">在一个对象内部执行一个特定的动作(可能涉及到访问对象内部深处)并返回其结果，或者<em class="ki">在基础对象上运行</em>一组通用的函数，特别是在大量重复的情况下，而不关心结果。其主要目的是削减冗余。</p><p id="e3fa" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">返回lambda块的最后一条语句。</p><h2 id="a542" class="ny ly iq bd lz nz oa dn md ob oc dp mh lr od oe ml lt of og mp lv oh oi mt oj bi translated">🟠申请</h2><blockquote class="kd ke kf"><p id="c06b" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我将把这个变化应用到这个对象上。yw。</p></blockquote><p id="0abf" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">这可以说是最有用的一个。总的来说，当您必须更改属性和调用某个对象的函数时，这是一个非常惯用的函数。它很酷，因为它让你可以直接在作用域中做任何你想做的事情，然后它返回对象的更新版本，从而使它在一连串的调用中也能很好地工作。它广泛应用于对象初始化。</p><p id="0ad5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">执行lambda块后返回基对象。</p><h2 id="76f1" class="ny ly iq bd lz nz oa dn md ob oc dp mh lr od oe ml lt of og mp lv oh oi mt oj bi translated">🔵也</h2><blockquote class="kd ke kf"><p id="10d1" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">哦，我差点忘了，<strong class="kj ir">还有</strong>让我把<strong class="kj ir">它</strong>加到单子上。</p></blockquote><p id="4ec8" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">深深被忽视，但珍贵而独特，当然是我最喜欢的范围函数。它被用来做你通常会写得很糟糕的事情，因为，顾名思义，它非常适合添加最后的润色和完成一项操作。这是做不相关的动作的完美地方，这些动作远离当前的环境:在你需要评论的地方，它会自己说话。</p><p id="fb6a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">执行lambda块后返回基对象。</p><h1 id="55e6" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">画沙线。</h1><p id="37cf" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated">有些功能之间的界限很窄，为了做出正确的选择，尽可能清晰地划分界限非常重要。</p><h2 id="c45b" class="ny ly iq bd lz nz oa dn md ob oc dp mh lr od oe ml lt of og mp lv oh oi mt oj bi translated">🔴运行与🟠应用</h2><p id="4bcd" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated"><code class="fe na nb nc nd b">apply</code>在对象初始化&amp;配置中广泛使用，因为我们关心函数的结果(更新的对象本身)，而<code class="fe na nb nc nd b">run</code>主要用于(因为没有更好的词)<em class="ki">运行</em>或者一个非常具体的任务并将其结果作为最后一条语句来评估，或者在同一对象上运行一堆函数，以减少冗余，因为我们不关心我们得到什么。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="5bda" class="ny ly iq bd lz nz oa dn md ob oc dp mh lr od oe ml lt of og mp lv oh oi mt oj bi translated">🟢让<strong class="ak"> vs </strong>🔵也</h2><p id="3992" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated"><code class="fe na nb nc nd b">let</code>和<code class="fe na nb nc nd b">also</code>没有在对象初始化中使用，因为每次你想引用当前对象时键入<code class="fe na nb nc nd b">it</code>是多余的，而你可以用<code class="fe na nb nc nd b">this</code>将它用作当前上下文对象。</p><p id="6cce" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">相反，它们在其他场景中很有用。众所周知，它们分别用于空检查和额外的操作，但是只要它们适合您的代码并且语法清晰易读，您就可以使用它们。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="155d" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">道具小抄。</h1><p id="0395" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated">最左边的符号行代表<em class="ki">返回值:</em></p><ul class=""><li id="8bc1" class="nk nl iq kj b kk kl ko kp lr nm lt nn lv no le np nq nr ns bi translated">圆圈象征着被返回给调用者的基础对象。这意味着具有这种属性的函数将有一个lambda返回<code class="fe na nb nc nd b">Unit</code>，因为它们的返回值将被忽略。</li><li id="b233" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le np nq nr ns bi translated">λ代表返回给调用者的lambda块的最后一条语句。因此，具有这种属性的函数的返回类型将是它们被传递的lambda的最后一个语句，并且可能不同于它们的基本调用类型。</li></ul><p id="3eb3" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">最上面一行代表<em class="ki">上下文对象</em>:</p><ul class=""><li id="c1d1" class="nk nl iq kj b kk kl ko kp lr nm lt nn lv no le np nq nr ns bi translated"><code class="fe na nb nc nd b"><strong class="kj ir">it</strong></code>表示lambda用<code class="fe na nb nc nd b">T</code>参数化。</li><li id="77e7" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le np nq nr ns bi translated"><code class="fe na nb nc nd b"><strong class="kj ir">this</strong></code>表示lambda是无参数的，范围在<code class="fe na nb nc nd b">T</code>内。</li></ul><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/b62f4a5b1ea6e7bd97ab8c5b2fcda456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqXZZzsny5MhGfwsux8hvg.jpeg"/></div></div></figure><p id="c6ed" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">📌:<code class="fe na nb nc nd b"><strong class="kj ir">a</strong>lso</code>和<code class="fe na nb nc nd b"><strong class="kj ir">a</strong>pply</code>都以<code class="fe na nb nc nd b">a</code>开头，都返回基对象。<code class="fe na nb nc nd b">let</code>和<code class="fe na nb nc nd b">run</code>不以相同的字符开头，它们返回lambda的最后一个语句。</p><h1 id="d274" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">不要。</h1><p id="a09c" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated">在使用范围函数时，有一些非常精确的模式是出错的明显迹象。你必须能够捡起它们。</p><h2 id="2058" class="ny ly iq bd lz nz oa dn md ob oc dp mh lr od oe ml lt of og mp lv oh oi mt oj bi translated">上下文对象返回。</h2><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d5bc" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">那是一个大大的红色别。如果您选择使用<code class="fe na nb nc nd b">run</code>或<code class="fe na nb nc nd b">let</code>，那么您的返回值将始终是您传入的lambda的最后一个语句的<em class="ki">，并且强制它成为作用域对象以便它返回自身是完全错误的，因为对于这个唯一的目的，分别有<code class="fe na nb nc nd b">apply</code>和<code class="fe na nb nc nd b">also</code>。</em></p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="ca9e" class="ny ly iq bd lz nz oa dn md ob oc dp mh lr od oe ml lt of og mp lv oh oi mt oj bi translated">上下文冗余。</h2><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4768" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">使用<code class="fe na nb nc nd b">let</code>(或<code class="fe na nb nc nd b">also</code>)是错误的选择。你一直重复<code class="fe na nb nc nd b">it</code>。与使用<code class="fe na nb nc nd b">run</code>(或<code class="fe na nb nc nd b">apply</code>)的情况相比。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c6ec" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">如果您确定您将在目标对象上只调用函数<em class="ki">和</em>，那么在该对象范围内应用更改是有意义的，而不是通过参数。如果没有范围函数，看起来会更好。</p><h2 id="513b" class="ny ly iq bd lz nz oa dn md ob oc dp mh lr od oe ml lt of og mp lv oh oi mt oj bi translated">跟踪。</h2><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6b28" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">在<code class="fe na nb nc nd b">paint.run</code>块内，<code class="fe na nb nc nd b">this</code>指向<code class="fe na nb nc nd b">wall.paint</code>(从外块<code class="fe na nb nc nd b">wall.run</code>引用)</p><p id="df9f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated"><code class="fe na nb nc nd b">println(color)</code>将打印出<code class="fe na nb nc nd b">paint.color</code>，(因为我们在<code class="fe na nb nc nd b">paint</code>的范围内运行)，而不是外部lambda内的<code class="fe na nb nc nd b">color</code>变量。这是因为<a class="ae kc" href="https://stackoverflow.com/questions/53734399/what-is-variable-shadowing" rel="noopener ugc nofollow" target="_blank">变量遮蔽</a>。</p><p id="d4f5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">你可能是无意中或故意这样做的。不管是哪种情况，都要纠正这个问题，因为这是一种偷偷摸摸且容易出错的代码。这肯定会从你的雷达上消失，尤其是在几个月或几年后你不再主动阅读这段代码。要明确，不要怀疑你在做什么。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="cc51" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">双跑。</h1><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">(请注意，我删除了一些不感兴趣的代码，以专注于run的内容)</figcaption></figure><p id="b823" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">运行实际上有<a class="ae kc" href="https://kotlinlang.org/docs/reference/scope-functions.html#run" rel="noopener ugc nofollow" target="_blank"> 2个版本:<code class="fe na nb nc nd b">run</code>和<code class="fe na nb nc nd b">T.run</code></a></p><p id="6e1f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">第一个不是扩展函数，而是可以用来动态创建作用域，而不需要使用任何对象的上下文。这在一些场景中很方便，特别是像<code class="fe na nb nc nd b">T.run</code>一样，只有最后一条语句被作为块结果。</p><p id="fda2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">第二个是实际的<code class="fe na nb nc nd b">run</code>范围&amp;扩展函数，可以在任何<code class="fe na nb nc nd b"><em class="ki">T</em></code> <em class="ki">类型</em>对象上调用。</p><h1 id="fd23" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">与。</h1><p id="c9f6" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated">我完全放弃了<code class="fe na nb nc nd b">with</code>，因为它是最没意思的一部。<a class="ae kc" href="https://kotlinlang.org/docs/reference/scope-functions.html#with" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe na nb nc nd b"><a class="ae kc" href="https://kotlinlang.org/docs/reference/scope-functions.html#with" rel="noopener ugc nofollow" target="_blank">run</a></code>做的一样，只是把基础对象作为参数，而不是作为扩展函数。</p><p id="6f87" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">尽管我会说，<code class="fe na nb nc nd b">with</code>比<code class="fe na nb nc nd b">run</code>更吸引人，至少从句法上来说是这样。</p><p id="da0f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">您可能应该避免在代码中混淆它们。</p><h1 id="2c89" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">取如果&amp;取除非。</h1><p id="6e57" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated">除了我们在<a class="ae kc" href="https://github.com/JetBrains/kotlin/blob/1f17ff5d38bd1ceb8c30d641f09dbde2d9a7ffbd/libraries/stdlib/src/kotlin/util/Standard.kt" rel="noopener ugc nofollow" target="_blank"> Standard.kt </a>中看到的，我们还可以找到<code class="fe na nb nc nd b"><a class="ae kc" href="https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless" rel="noopener ugc nofollow" target="_blank">takeIf</a></code> <a class="ae kc" href="https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe na nb nc nd b"><a class="ae kc" href="https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless" rel="noopener ugc nofollow" target="_blank">takeUnless</a></code>，它们在调用链中起到了很好的粘合作用，并且与作用域函数和安全调用操作符配合得很好。</p><h1 id="06a8" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">作用域函数的形式性质。</h1><p id="d1f4" class="pw-post-body-paragraph kg kh iq kj b kk mv km kn ko mw kq kr lr mx ku kv lt my ky kz lv mz lc ld le ij bi translated">范围函数行为由两个属性设置:<em class="ki">返回值</em>和<em class="ki">上下文对象</em>。第一个定义了作用域函数<code class="fe na nb nc nd b">f</code>是返回它被调用的对象(<code class="fe na nb nc nd b">&lt;T&gt; T.f(): T</code>)还是返回块lambda产生的结果(<code class="fe na nb nc nd b">&lt;T, R&gt; T.f(): R</code>)。后者定义了作用域函数<code class="fe na nb nc nd b">f</code>的lambda块是参数化的(<code class="fe na nb nc nd b">block: (T)</code>，从而使用<code class="fe na nb nc nd b">it</code>指向<code class="fe na nb nc nd b">f</code>的调用对象，还是动态作用域(<code class="fe na nb nc nd b">block: T.()</code>，从而在<code class="fe na nb nc nd b">this</code>内执行。</p><h1 id="18bc" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">科特林中lambda符号的旁注。</h1><ul class=""><li id="9953" class="nk nl iq kj b kk mv ko mw lr om lt on lv oo le np nq nr ns bi translated"><code class="fe na nb nc nd b">() -&gt; R</code>:不带参数，返回一个类型为<code class="fe na nb nc nd b">R</code>的对象。</li><li id="36a1" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le np nq nr ns bi translated"><code class="fe na nb nc nd b">(T) -&gt; R</code>:接受1个T类型的参数，返回一个<code class="fe na nb nc nd b">R</code>类型的对象。</li><li id="3a41" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le np nq nr ns bi translated"><code class="fe na nb nc nd b">(T, U, V) -&gt; R</code>:带3个参数，返回一个<code class="fe na nb nc nd b">R</code>类型的对象。</li><li id="3e99" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le np nq nr ns bi translated"><code class="fe na nb nc nd b">T.() -&gt; R</code>:不带参数，作用域在<code class="fe na nb nc nd b">T</code>内，返回<code class="fe na nb nc nd b">R</code>。</li><li id="4f60" class="nk nl iq kj b kk nt ko nu lr nv lt nw lv nx le np nq nr ns bi translated"><code class="fe na nb nc nd b">T.(U, V) -&gt; X&lt;Y&gt;</code>:接受两个类型为<code class="fe na nb nc nd b">U</code>和<code class="fe na nb nc nd b">V</code>的参数，作用域在<code class="fe na nb nc nd b">T</code>内部，返回一个类型为<code class="fe na nb nc nd b">X&lt;Y&gt;</code>的对象。</li></ul><p id="e149" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lr kt ku kv lt kx ky kz lv lb lc ld le ij bi translated">官方文档<a class="ae kc" href="https://kotlinlang.org/docs/reference/lambdas.html" rel="noopener ugc nofollow" target="_blank">中的更多细节请点击</a>。</p></div></div>    
</body>
</html>