# 如何消除注射 ILogger <t>无处不在？网络</t>

> 原文：<https://levelup.gitconnected.com/how-to-eliminate-injecting-ilogger-t-everywhere-in-net-301be7b367a8>

## 将您的所有服务从这个显式注入中解放出来

![](img/4befa7839e691ceb90113333ee4f8fed.png)

扎克·杜兰特在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

依赖注入是很棒的，它为你节省了大量的连接和创建实例的手动设置，这些实例可以在你的整个应用程序中使用。然而，这也带来了一个问题。我们越来越习惯于简单地向另一个服务添加一个新的依赖项，以至于我们可能做得有点过头了。对服务的依赖太多是不干净的，应该重构。尽管如此，总有这样一种依赖性，它存在于如此多的构造函数中，存在于如此多的项目中——`ILogger<T>`。

在这篇文章中，我将向您展示一种至少可以从您的构造函数中消除这个`ILogger<T>`的方法。这不会明显地消除依赖性，但它会从构造函数中移除一个参数，从而使测试期间模仿您的类更容易，并且为每个类节省一行代码。

## 咨询通知

下面的方法当然有它的缺点，并且**不**符合传统的干净代码/干净架构模式。通过从构造函数中移除`ILogger`，你实际上**隐藏了**一个依赖。当将类移动或复制到另一个不能访问静态记录器工厂的存储库时，这个隐藏的依赖项可能需要更多的工作来调整。此外，您可能不得不在测试期间做额外的工作，并且可能会使不熟悉这种方法的其他程序员感到困惑。只有当你确信它的好处大于它的缺点时，才使用这个解决方案。

在我看来，与在构造函数中注入`ILogger`的“干净”方式相比，这种方法有几个好处，前提是你有一个单一的解决方案，即**而不是**像微服务那样是分布式环境的一部分。

*   您可以使用日志记录器，否则它只能作为参数传递，例如静态类、方法和扩展方法。
*   测试只是比 DI 更难。您没有将 ILoggerFactory-Mock 传递给 DI 容器，而是将其传递给静态记录器工厂，这花费了您一行代码。
*   如果`ILogger`接口保持不变，那么改变记录器实现只需要改变静态记录器工厂。
*   当一个类不能被 DI 实例化时，你不必考虑如何为这个类获得一个日志记录器。例如一个工厂，在这里注入 ILoggerFactory。
*   消除日志依赖的“干净”方法，如装饰模式、动态代理或中间件，只允许在方法之前和之后记录日志，而不是在方法之间。

## 静态记录器工厂

消除任何类型的注入的第一步可能是将它作为`static`保存在任何地方。对于`ILogger`来说，这可以通过保持一个`ILoggerFactory`静态可访问来实现。为此，我创建了一个名为`StaticLoggerFactory`的静态类。这个类拥有一个静态的`ConcurrentDictionary<Type, ILogger>`，它保存所有的`ILogger`实例，并使它们可以并发访问。我还为方便的方法`GetOrAdd()`选择了这个类，它给了我们一个创建实例的 liner，如果它不在字典中，如果在，就返回一个。

这个类必须用一个`ILoggerFactory`来初始化。在您将日志添加到您的`IServiceCollection`之后，您可以从`IServiceProvider`中获得一个这样的实例。

## 使用 StaticLoggerFactory

这就是设置，现在我们将看看如何在其他课程中使用它:

只需调用我们的静态日志工厂的`GetStaticLogger<T>`函数，就可以了。顺便说一下，如果您将下面一行添加到全局 usings(.NET 6 及以上):

`global using static <YourNameSpace>.StaticLoggerFactory;`

这一行使您能够简单地调用静态方法，而不用提及类名`StaticLoggerFactory`，正如您在上面的例子中所看到的。

最后，让我们将它与之前注射`ILogger<T>`的方式进行比较。

注入和空检查使用了`92`个额外的字符，而静态方法只使用了`35`个字符(计算在属性名之后)。因此，通过使用这种方法，您可以保护多几行代码，并且不必再担心在您的测试中创建多个`ILogger`模拟。

请在评论中告诉我你对这种方法的看法。是干净了，还是把事情搞复杂了？你是愿意把字典放在一边还是留着它？

如果你想查看代码，你可以在我的 github 上找到它:

[](https://github.com/TobiStr/LoggerElimination) [## GitHub-TobiStr/logger elimination:如何消除在。网

### 只需创建一个静态类，它包含一个字典，并从启动逻辑中初始化一个静态 LoggerFactory

github.com](https://github.com/TobiStr/LoggerElimination) 

感谢您花时间阅读这篇文章。我希望，你会觉得它有知识性、教育性和趣味性。非常感谢您的支持和参与。

如果您有兴趣了解干净架构、干净编码和最新技术栈的最新趋势、技巧和诀窍，尤其是在 C#环境中。净和有棱角——如果你考虑跟踪我，我会很感激。

祝你有美好的一天！

![](img/429378e6a7aee01df92851fb0e90e385.png)

如果你还没有每天使用媒体来增长你的知识，现在是开始的最佳时机！借助 Medium，您可以轻松获得更多关于高度专业的主题的知识，发布高质量的内容，并接触到更广泛的受众。要开始，只需使用以下链接创建一个中型帐户:

[*现在加入中等*](https://medium.com/@tobias.streng/membership)

通过这样做，你将获得一个强大的平台，可以帮助你联系新的作者和读者，每天学习新的东西。