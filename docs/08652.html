<html>
<head>
<title>Structural Directives in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度中的结构指令</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/structural-directives-in-angular-58f1054b674?source=collection_archive---------3-----------------------#2021-05-21">https://levelup.gitconnected.com/structural-directives-in-angular-58f1054b674?source=collection_archive---------3-----------------------#2021-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3a06" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">角度结构指令简明指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dd1c9b8c67353c07b6f93b6d18cf3019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WusdXY7f0JeMIX9Z"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@heftiba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托阿·海夫蒂巴</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0aee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能对Angular内置结构指令比较熟悉:<a class="ae kv" href="https://angular.io/api/common/NgForOf" rel="noopener ugc nofollow" target="_blank"> ngFor </a>、<a class="ae kv" href="https://angular.io/api/common/NgIf" rel="noopener ugc nofollow" target="_blank"> NgIf </a>、<a class="ae kv" href="https://angular.io/api/common/NgSwitch" rel="noopener ugc nofollow" target="_blank"> NgSwitch </a>。但是它们是如何工作的，它们有什么性质，幕后发生了什么？</p><p id="291c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我想做一个关于结构指令的小指南，展示当你使用指令时模板中发生了什么，以及在结构指令中使用装饰属性<code class="fe ls lt lu lv b">exportAs</code>的情况。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="6df9" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated"><strong class="ak">角度指令简短指南</strong></h2><p id="6d2f" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">角度指令用于改变DOM元素的外观或行为。有三种类型的指令:</p><ol class=""><li id="7b5c" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><em class="nk">组件</em>(自带模板)；</li><li id="9202" class="nb nc iq ky b kz nl lc nm lf nn lj no ln np lr ng nh ni nj bi translated"><em class="nk">结构化</em>，改变DOM树的结构；</li><li id="a934" class="nb nc iq ky b kz nl lc nm lf nn lj no ln np lr ng nh ni nj bi translated"><em class="nk">属性</em>改变DOM元素的外观或默认行为。</li></ol><p id="aab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">属性指令和结构指令有什么区别？结构化指令不仅可以改变元素的属性，还可以在DOM中删除或添加元素。另外，都是以*符号开头的(*ngFor，*ngIf等)。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="e4ad" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated"><strong class="ak">创建我们自己的结构指令</strong></h2><p id="1ee4" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">例如，让我们创建自己的简单结构化指令<em class="nk"> addElement </em>，它将向页面添加一个元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/d9258d9b56e54a6265f1625d4f6c0863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhErB1IH-htpVA8GQBc0gg.png"/></div></div></figure><p id="19e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个指令看起来就像是使用<em class="nk"> @Directive </em>属性的一个类，其中我们有一个选择器来描述我们的指令添加到任何元素时的样子。</p><p id="d300" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将我们的指令添加到一些元素中。非常简单:将我们的新指令添加到组件模块中的声明对象，并将我们的指令挂在模板中的元素上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/ac9971a56ad25791aac92eb7f02c0a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4IeiviPK2SjhSieVBH_zQ.png"/></div></div></figure><p id="8acc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在回到指令的类本身，因为它是一个结构化指令，那么我们可以将以下服务注入到构造函数中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/a8d4dc38aa669617dfffbe1f34234b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYPUGrATuUQnW2Lj7mxDeQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们的带有注入服务的指令类</figcaption></figure><p id="e0e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> TemplateRef </strong>是一个用特殊的&lt; ng-template / &gt;标签包装的视图。对我们来说，这是我们悬挂指令的&lt;分区&gt;。稍后我会解释&lt; ng-template / &gt;与此有何关联。</p><p id="01e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ViewContainerRef是我们指令的包装器。</p><p id="700d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们决定在浏览器中用<em class="nk"> appAddElement </em>指令检查我们的元素。那么我们将什么也看不到，因为我们创建了一个结构化的指令，它会立即将我们的元素抛出DOM。</p><p id="b6b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，让我们通过OnInit方法中的容器来添加模板。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/3e5cd291179861771f740ba6adb16a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3K0bhwErA0TQ8hSOuTp0_A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在ngOnInit中添加模板的指令类</figcaption></figure><p id="c730" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以在浏览器中看到包含内容的div。但是到目前为止看起来并不有趣。让我们考虑一些可以用指令实现的特性。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="f284" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated"><strong class="ak">指令中的输入</strong></h2><p id="6e96" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">您可以向指令传递输入参数，就像在组件中一样。此外，为了简单起见，您可以将指令的名称作为输入。让我们在指令中添加逻辑，通过超时显示元素，并通过输入参数传递超时时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/d6124216bc259ab501f8c32dc99207a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRKsitRegCVcnaeT6kHrgA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们的带有输入参数的指令类</figcaption></figure><p id="2ad7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，当我们调用我们的指令时，我们将延迟秒数作为输入参数传递:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/e37c9e3ec6e091118b7f1543248ad2dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXxlEfJNJazto-Ggc6Azzw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">结构指令通过传递输入参数进行调用</figcaption></figure><p id="1aad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如预期的那样，在浏览器中，我们将看到我们的div在3秒钟后出现。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="0ef6" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated"><strong class="ak">快速看一下在Angular的引擎盖下结构指令是如何工作的</strong></h2><p id="15e2" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">当有角度时看到下面的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/e37c9e3ec6e091118b7f1543248ad2dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXxlEfJNJazto-Ggc6Azzw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">结构指令正常调用</figcaption></figure><p id="f293" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它把一切都包装在<ng-template>标签中</ng-template></p><p id="e641" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<ng-template>本身上，Angular用这个名字放了一个简单的指示属性:</ng-template></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/7883cd1e37e1c6368572525a4609c704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0eycsfbGYz2NKIJD3zqYw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">结构指令调用时不使用*</figcaption></figure><p id="ae2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的符号与使用*的结构化指令的常用符号完全相同。</p><p id="9917" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是现在您可以看到先前在构造函数代码行中声明的到底是做什么的了:</p><p id="4422" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">私有模板:TemplateRef &lt; any &gt; </strong></p><p id="6fd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我之前写的ng-template标签的内容。</p><p id="9f90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构造函数中声明的<strong class="ky ir"> ViewContainerRef </strong>是&lt; ng-template &gt;标签本身作为我们指令的包装器。</p><p id="dafb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我想很明显，在结构指令中使用*只是一种语法糖，帮助我们有一个更短的指令符号。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="3764" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated"><strong class="ak"> ExportAs decorator属性并与结构指令一起使用</strong></h2><p id="eef3" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">最后，我想指出一个非常有用的属性<strong class="ky ir"> exportAs </strong>，它允许我们在附加指令的元素之外使用指令的类。在这种情况下，我们可以在使用该指令的组件模板中直接调用该指令的方法。</p><p id="fa1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应该注意的是，<strong class="ky ir"> exportAs </strong>属性更常用于属性指令，但是现在我们将使用我们的结构指令的例子来看它的操作。</p><p id="1721" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有一些限制。为了能够使用带有结构指令的<strong class="ky ir"> exportAs </strong>属性，我们需要在<strong class="ky ir">的</strong>表单<em class="nk"> </em>中使用不带<strong class="ky ir"> * </strong>符号的结构指令</p><p id="1136" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们稍微改变一下指令的逻辑——让我们将显示内容的逻辑从ngOnInit移到一个单独的方法中。并且还将<strong class="ky ir"> exportAs </strong>属性添加到@Directive decorator中，也就是说，我们将导出一个名为“addElement”的指令类。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/94ebc91e3bf7fd6e3a5c5c41e104a515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mb2jLx4fTb8ldoEo_FjKwg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们的带有新方法switchElement()的指令类</figcaption></figure><p id="85c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们继续调用我们的指令，正如我前面说过的，为了能够使用exportAs，我们必须以<strong class="ky ir">去糖</strong>形式应用指令——没有*符号。现在，通过点击按钮，我们将从我们的指令类中直接调用<strong class="ky ir"> switchElement() </strong>方法，切换div内容的可见性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/c79224e5a9adcb0955c3aab648316b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lDk88SOCrMKjFTX1uKHgw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">结构指令调用时不使用*</figcaption></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="0cbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！我希望这篇文章是有用的，并且揭开了Angular中结构指令如何工作的神秘面纱。在我的下一篇文章中再见！</p></div></div>    
</body>
</html>