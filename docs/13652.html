<html>
<head>
<title>C++ Object Oriented Programming: An In-Depth Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++面向对象编程:深入指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cpp-object-oriented-programming-an-in-depth-guide-f56a597091d8?source=collection_archive---------5-----------------------#2022-09-26">https://levelup.gitconnected.com/cpp-object-oriented-programming-an-in-depth-guide-f56a597091d8?source=collection_archive---------5-----------------------#2022-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="98f0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">C++ OOP的详细解释以及你应该如何在你的代码中使用它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2eb6eeb8b835331894b74bd5fcdc8d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TSqiowTzxo-_BOw3hLpSQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ffstop" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><blockquote class="kw kx ky"><p id="468b" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们切入正题:OOP是什么？</p></blockquote><p id="f34e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">面向对象编程(OOP)是一种计算机编程模型<strong class="lc ir">,几乎每个开发人员都在他们编码生涯的某个阶段使用它。它是占主导地位的编程范例之一，自20世纪90年代以来已经成为主流。</strong></p><p id="c24a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">OOP被认为是在教育程序中编写代码的标准方法，<a class="ae kv" href="https://www.johndcook.com/blog/2011/07/19/you-wanted-banana/" rel="noopener ugc nofollow" target="_blank">尽管它并不是最好的方法</a>。但我认为这是为初学者编写有效程序的最佳方式。这主要是因为OOP概念对大多数人来说是天生的。</p><p id="0a99" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">大多数流行的编程语言都支持OOP，包括C++。这也是C++语言的主要特征。而且你大部分时间都会用OOP来编写一个优秀的C++程序。</p><h1 id="dd72" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">C++程序设计中面向对象的定义</h1><p id="d375" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">顾名思义——OOP使用对象的概念来设计软件。它将一个软件程序打包成一个更加简单的和<strong class="lc ir">模块化的</strong>代码，使得<strong class="lc ir">更容易操作和维护</strong>。</p><h2 id="c71f" class="mw ma iq bd mb mx my dn mf mz na dp mj lw nb nc ml lx nd ne mn ly nf ng mp nh bi translated">班级</h2><p id="8e1d" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">为了创建一个模块化的对象，我们需要一个叫做<strong class="lc ir">类</strong>的可重用蓝图。类是C++中用户定义的数据类型。它不同于其他原始数据类型(int、bool、char等。)因为我们可以定制它。</p><p id="156e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">那么，我们如何定制类呢？我们可以在一个类中构造属性(变量数据)和方法(函数)，形成一种新的数据类型。变量定义类属性，而方法用于执行一些通常操作类属性的操作。</p><blockquote class="kw kx ky"><p id="b63c" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ir">属性</strong> —假设我们想要创建一个名为<code class="fe ni nj nk nl b">Fruit</code>的类，它包含类似于<code class="fe ni nj nk nl b">price</code>的属性。我们可以简单地在<code class="fe ni nj nk nl b">Fruit</code>中声明一个float数据类型的变量。</p><p id="cfdd" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果我们想有一种方法来确定水果的价格。我们可以在类内部定义一个名为<code class="fe ni nj nk nl b">setPrice</code>的方法。</p></blockquote><p id="838b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们的蓝图是怎样的:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="8add" class="mw ma iq nl b gy nq nr l ns nt">class Fruit{<br/>public:<br/>   void setPrice(float new_price){price = new_price;}</span><span id="1761" class="mw ma iq nl b gy nu nr l ns nt">private:<br/>   float price;<br/>};</span></pre><p id="ac59" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">到目前为止，我们只创建了一个名为<code class="fe ni nj nk nl b">Fruit</code>的蓝图(类)。<strong class="lc ir">要创建一个对象</strong>，我们需要像其他原始数据类型一样用对象名调用类<code class="fe ni nj nk nl b">Fruit</code>。</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="af0b" class="mw ma iq nl b gy nq nr l ns nt">int main(){<br/>   Fruit banana;<br/>   Fruit apple;<br/>}</span></pre><p id="a4c2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">上面的例子只通过调用C++编译器生成的默认构造函数创建了<strong class="lc ir">对象实例</strong>。因为我们从不指定构造函数。</p><h2 id="a010" class="mw ma iq bd mb mx my dn mf mz na dp mj lw nb nc ml lx nd ne mn ly nf ng mp nh bi translated">构造器</h2><p id="e473" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">那么什么是构造函数呢？构造函数是在对象创建时调用的方法。</p><p id="7495" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">通常，我们希望在创建新对象时执行一些类方法或定义类变量成员。这就是构造函数派上用场的地方。你可以查看本页了解更多关于构造函数的信息。</p><p id="b1b1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们可以如下声明构造函数:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="cd65" class="mw ma iq nl b gy nq nr l ns nt">class Fruit{<br/>public:<br/>   Fruit(float _price, std::string _color){<br/>      price = _price;<br/>      color = _color;<br/>   }  <br/>   void setPrice(float new_price){price = new_price;}</span><span id="7e82" class="mw ma iq nl b gy nu nr l ns nt">private:<br/>   float price;<br/>   std::string color;  <br/>};</span></pre><p id="32b9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如您所见，上面的构造函数(<code class="fe ni nj nk nl b">Fruit()</code>)需要两个参数:<code class="fe ni nj nk nl b">_price</code>和<code class="fe ni nj nk nl b">_color</code>。构造函数帮助我们在对象创建期间在对象内部创建有意义的数据:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="1e09" class="mw ma iq nl b gy nq nr l ns nt">int main(){<br/>   Fruit banana(1.25, "yellow");<br/>   Fruit apple(1.60, "red");<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b37b126b43d502dffae5e89d9ca56485.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*2uBfQfPJDwv3LviCVFqwhw.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">类(水果)及其两个对象实例，香蕉和苹果</figcaption></figure><h1 id="8631" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">OOP的4个主要概念</h1><p id="93e5" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">四个基本概念让C++变得过于强大(OOP):</p><h2 id="c2e6" class="mw ma iq bd mb mx my dn mf mz na dp mj lw nb nc ml lx nd ne mn ly nf ng mp nh bi translated">1.包装</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/3493011f6a67cdae3e8af810f847afde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0KR7Z2Rp58MoumozptZ3A.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@daniloalvesd" rel="noopener ugc nofollow" target="_blank"> danilo.alvesd </a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="54e7" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">封装是将重要信息 <strong class="lc ir">包装在一个对象内。</strong>换句话说，变量和方法在创建时就存储在对象内部。</p><p id="bdea" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">封装可以防止不必要的类外访问。这个概念有利于保护程序的使用。你可能不希望你的客户对你的软件做一些灾难性的改变。</p><p id="22d1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为了实现这种限制，我们需要某种东西来指定“安全级别”这就是<strong class="lc ir">访问修饰符</strong>发挥作用的地方。</p><p id="0866" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir">访问修饰符</strong></p><p id="6195" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">访问修饰符是<code class="fe ni nj nk nl b">public</code>和<code class="fe ni nj nk nl b">private</code>，正如你在上面的例子中看到的。(还有一个叫<code class="fe ni nj nk nl b">protected</code>，后面会详细介绍)</p><p id="b014" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们可以将类成员指定为<code class="fe ni nj nk nl b">public</code>或<code class="fe ni nj nk nl b">private</code>。默认情况下，一个类的所有成员都是<code class="fe ni nj nk nl b">private</code>，除非他们被特别标记为<code class="fe ni nj nk nl b">public</code>。</p><p id="492f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">任何对象用户都可以直接访问公共成员，但是私有成员只能由对象本身访问。</p><p id="1875" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">以上面的例子为例，我们将<code class="fe ni nj nk nl b">price</code>声明为私有成员，因为我们不希望用户直接访问它。我们将方法<code class="fe ni nj nk nl b">setPrice</code>定义为公共成员，以允许其他用户仅通过显式调用该方法来设置<code class="fe ni nj nk nl b">price</code>。</p><p id="e751" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">示例:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="8b7c" class="mw ma iq nl b gy nq nr l ns nt">int main(){<br/>   Fruit banana(1.25, "yellow");<br/>   <br/>   // error   <br/>   std::cout &lt;&lt; banana.color &lt;&lt; std::endl;<br/>   }</span></pre><p id="fe04" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">对象<code class="fe ni nj nk nl b">banana</code>不能直接访问<code class="fe ni nj nk nl b">main()</code>中的类变量<code class="fe ni nj nk nl b">color</code>。</p><p id="734d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">访问修饰符有助于限制某些类成员的使用。你可以参考<a class="ae kv" href="https://www.programiz.com/cpp-programming/access-modifiers" rel="noopener ugc nofollow" target="_blank">这本完整的指南</a>来学习更多关于访问修饰符的知识。</p><h2 id="fbcb" class="mw ma iq bd mb mx my dn mf mz na dp mj lw nb nc ml lx nd ne mn ly nf ng mp nh bi translated">2.抽象</h2><p id="b0b7" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">OOP中的数据抽象意味着<strong class="lc ir">只显示基本信息</strong>，而<strong class="lc ir">对最终用户隐藏细节</strong>。这个概念是封装的扩展。</p><p id="2222" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在类中，抽象是指将类的接口从实现细节中分离出来。</p><blockquote class="kw kx ky"><p id="effb" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果你还是得不到，你可以理解为——“你只看到我选择给你看的东西”</p></blockquote><p id="3217" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">抽象允许我们使用简单的类来表达复杂的细节。</p><p id="b786" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">让我们举一个开车的例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/ba13b7f9b90608422fb13d884cfcca60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zhgf1F-SKyvGUTl_boat4g.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@lance_asper" rel="noopener ugc nofollow" target="_blank">兰斯·阿斯伯</a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1d56" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">你不需要知道发动机是如何工作的来驾驶一辆汽车。你不需要了解其中涉及的工程:动力传输是如何完成的，冷却系统是如何工作的，或者底盘是如何设计来承受汽车的重量bla bla bla…</p><p id="5443" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">你只需要知道加速或刹车该踩哪个踏板，以及如何操控汽车转弯。所有的细节都隐藏在里面，以保护用户和它的制造商。</p><p id="dc1d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这类似于C++面向对象。让我们看看如何在C++中实现抽象:</p><p id="832b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><em class="lb"> fruit.h </em></p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="38f1" class="mw ma iq nl b gy nq nr l ns nt">class Fruit{<br/>public:<br/>   void increasePrice(float percentage);</span><span id="56cd" class="mw ma iq nl b gy nu nr l ns nt">private:<br/>   float price;<br/>};</span></pre><p id="9497" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><em class="lb"> fruit.cpp </em></p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="07b6" class="mw ma iq nl b gy nq nr l ns nt">void Fruit::increasePrice(float percentage)<br/>{<br/>   price *= 1.0 + (percentage / 100);<br/>}</span></pre><p id="2b58" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">通常情况下，用户只能看到头文件<em class="lb">、</em>、<em class="lb"> fruit.h </em>，而看不到源文件<em class="lb"> fruit.cpp </em>。</p><p id="ad7e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">用户可以通过<code class="fe ni nj nk nl b">increasePrice()</code>函数与<code class="fe ni nj nk nl b">Fruit</code>类进行交互。但是，他们不需要知道<code class="fe ni nj nk nl b">increasePrice()</code>(隐藏在<em class="lb"> fruit.cpp </em>里面)的实现细节。</p><h2 id="10b1" class="mw ma iq bd mb mx my dn mf mz na dp mj lw nb nc ml lx nd ne mn ly nf ng mp nh bi translated">3.遗产</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/d02553ceda17cd099d2b32051875fe95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yein3D99sZOK7LaY_hGNQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">胡安·巴勃罗·塞拉诺·阿里纳斯在<a class="ae kv" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片</figcaption></figure><p id="59ca" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">继承允许类从另一个类派生属性和特征。</p><p id="e410" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这是OOP最重要的特性之一，因为它支持可重用性。您不需要重新定义与您之前定义的类具有相似特征的另一个类。</p><p id="02f3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">例如，让我们使用我们之前定义的<code class="fe ni nj nk nl b">Fruit</code>:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="2605" class="mw ma iq nl b gy nq nr l ns nt">class Fruit{<br/>public:<br/>   void setPrice(float new_price){price = new_price;}</span><span id="a2b6" class="mw ma iq nl b gy nu nr l ns nt">protected:<br/>   float price;<br/>   std::string color;  <br/>};</span></pre><p id="0238" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们可以从<code class="fe ni nj nk nl b">Fruit</code>派生出其他类，比如<code class="fe ni nj nk nl b">Durian</code>和<code class="fe ni nj nk nl b">Strawberry</code>。因此，我们不需要再次定义成员变量— <code class="fe ni nj nk nl b">price</code>和<code class="fe ni nj nk nl b">color</code>。</p><p id="9c22" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">继承的另一个好处是派生类可以有不同的成员变量，比如<code class="fe ni nj nk nl b">thorns</code>和<code class="fe ni nj nk nl b">is_berry</code>:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="5061" class="mw ma iq nl b gy nq nr l ns nt">class Durian : public Fruit {<br/>private:<br/>   bool thorns = true;<br/>};</span><span id="a7d1" class="mw ma iq nl b gy nu nr l ns nt">class Strawberry : public Fruit {<br/>private: <br/>   bool is_berry = false;<br/>};</span></pre><p id="c0b5" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe ni nj nk nl b">Durian</code>和<code class="fe ni nj nk nl b">Strawberry</code>被称为派生类。相反，由其他类继承的<code class="fe ni nj nk nl b">Fruit</code>被称为基类。</p><p id="698b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">你们中的一些人可能已经发现了另一个访问说明符—<code class="fe ni nj nk nl b">Fruit</code>中的<code class="fe ni nj nk nl b">protected</code>。<code class="fe ni nj nk nl b">protected</code>是用于类继承的<strong class="lc ir">。</strong></p><p id="895d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">派生类不继承对其基类的私有数据成员的访问。为了防止其他用户直接访问<code class="fe ni nj nk nl b">price</code>和<code class="fe ni nj nk nl b">color</code>，同时允许<code class="fe ni nj nk nl b">Durian</code>和<code class="fe ni nj nk nl b">Strawberry</code>继承两个成员变量，使用了<code class="fe ni nj nk nl b">protected</code>。</p><p id="f3e8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">定义派生类时，访问说明符也用在继承中。对于这个例子，我们使用公共继承。</p><p id="2875" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">虽然我们<strong class="lc ir">通常在C++中使用公共继承</strong>，但你可能想检查一下什么时候在<a class="ae kv" href="https://www.programiz.com/cpp-programming/public-protected-private-inheritance" rel="noopener ugc nofollow" target="_blank">这个链接</a>中应用另外两个，私有和受保护继承。</p><h2 id="5fb5" class="mw ma iq bd mb mx my dn mf mz na dp mj lw nb nc ml lx nd ne mn ly nf ng mp nh bi translated">4.多态性</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/16710c216d0dc789422084c105193493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*19odowQUPcPgAOVLUkm6Jg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@cmzw" rel="noopener ugc nofollow" target="_blank">魏明·林</a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="39b9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><a class="ae kv" href="https://www.mygreatlearning.com/blog/polymorphism-in-cpp/#:~:text=Polymorphism%20in%20C%2B%2B%20means%2C%20the,in%20numbers%2C%20it%20performs%20addition." rel="noopener ugc nofollow" target="_blank">多态性</a>在希腊语中是“有多种形式”的意思。在面向对象程序设计中，它意味着一个函数的<strong class="lc ir">根据它被调用的方式不同而执行</strong>的能力。</p><p id="dd05" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir">过载</strong></p><p id="5969" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在C++中，多态性通常是通过<strong class="lc ir">重载、</strong>实现的，也称为<strong class="lc ir">编译时多态性</strong>。而重载又有两种:<a class="ae kv" href="https://www.geeksforgeeks.org/operator-overloading-c/" rel="noopener ugc nofollow" target="_blank">运算符重载</a>和函数重载。操作符重载更难理解，所以为了本文的简单起见，我们不在这里讨论它。</p><p id="ba56" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">函数重载非常简单。通过阅读下面的例子，你会明白我的意思:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="3762" class="mw ma iq nl b gy nq nr l ns nt">class Fruit{<br/>public:<br/>   Fruit(float _price){price = _price;}</span><span id="0965" class="mw ma iq nl b gy nu nr l ns nt">   void increasePrice(double percentage)<br/>   {<br/>      price *= 1.0 + (percentage / 100);<br/>   }<br/>   void increasePrice(int cents)<br/>   {<br/>      price += cents/100.0;<br/>   }</span><span id="cbbd" class="mw ma iq nl b gy nu nr l ns nt">private:<br/>   float price;<br/>};</span><span id="8295" class="mw ma iq nl b gy nu nr l ns nt">int main()<br/>{<br/>   Fruit orange;<br/>   Fruit apple;<br/>   Orange.setPrice(0.60);<br/>   Apple.setPrice(0.80);</span><span id="1091" class="mw ma iq nl b gy nu nr l ns nt">   orange.increasePrice(0.20);<br/>   apple.increasePrice(10);</span></pre><p id="61a1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">结果:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="a682" class="mw ma iq nl b gy nq nr l ns nt">Price of orange: 0.72<br/>Price of apple: 0.90</span></pre><p id="e596" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们定义了两个名称完全相同但参数数据类型不同的函数，一个是<code class="fe ni nj nk nl b">double</code>，另一个是<code class="fe ni nj nk nl b">int</code>。程序将根据输入执行任一功能。</p><p id="2447" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">因此，当您传递一个<code class="fe ni nj nk nl b">double</code>参数时，<code class="fe ni nj nk nl b">increasePrice(0.20)</code>将orange的价格提高了20%。但是如果你传递一个<code class="fe ni nj nk nl b">int</code>参数，那么<code class="fe ni nj nk nl b">increasePrice(10)</code>会将苹果的价格提高10美分。</p><p id="9c39" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir">超越</strong></p><p id="b748" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">多态性也可以用另一种方式实现:<a class="ae kv" href="https://www.programiz.com/cpp-programming/function-overriding" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">覆盖</strong> </a> <strong class="lc ir">。</strong>这种方法被称为运行时多态性。</p><p id="bc03" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">要实现覆盖，您必须在基类中声明一个<code class="fe ni nj nk nl b">virtual</code>函数，同时在派生类中定义另一个具有相同函数名和参数类型的函数。</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="5f03" class="mw ma iq nl b gy nq nr l ns nt">class Fruit{<br/>public:<br/>   virtual void printSkinColor() <br/>   { <br/>      std::cout &lt;&lt; "The skin colour of fruit is " &lt;&lt; color &lt;&lt; "\n";<br/>   }</span><span id="512e" class="mw ma iq nl b gy nu nr l ns nt">protected:<br/>   std::string color;  <br/>};</span><span id="ec15" class="mw ma iq nl b gy nu nr l ns nt">class Durian : public Fruit {<br/>public:<br/>   void printSkinColor()<br/>   {<br/>      std::cout &lt;&lt; "The skin colour of durian is " &lt;&lt; color &lt;&lt; "\n";<br/>   }<br/>};</span></pre><p id="5139" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">最终，调用不同的类会得到不同的结果。</p><p id="4708" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">使用重载和重写的多态性保持了一致性，并提高了代码的可读性。它还促进了代码的可重用性。</p><h1 id="60d9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="d986" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">这就结束了对C++面向对象编程的介绍。</p><p id="0779" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">学习C++通常很有挑战性，但是OOP总是一个很好的开始选择。你会在学习<a class="ae kv" href="https://cplusplus.com/doc/tutorial/pointers/" rel="noopener ugc nofollow" target="_blank">指针</a>的同时发现更多的乐趣(嗯，几十个人退出了，但是我相信你会乐在其中的！).</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="5e83" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如果你喜欢这个博客，用“鼓掌”来表示你的支持。记住，你最多可以鼓掌50次。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><h1 id="e305" class="lz ma iq bd mb mc oh me mf mg oi mi mj jw oj jx ml jz ok ka mn kc ol kd mp mq bi translated">分级编码</h1><p id="3dce" class="pw-post-body-paragraph kz la iq lc b ld mr jr lf lg ms ju li lw mt ll lm lx mu lp lq ly mv lt lu lv ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="c797" class="om on iq lc b ld le lg lh lw oo lx op ly oq lv or os ot ou bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="8b19" class="om on iq lc b ld ov lg ow lw ox lx oy ly oz lv or os ot ou bi translated">📰查看<a class="ae kv" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="f8ea" class="om on iq lc b ld ov lg ow lw ox lx oy ly oz lv or os ot ou bi translated">🔔关注我们:<a class="ae kv" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kv" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kv" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="ee9e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">🚀👉<a class="ae kv" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">将像你这样的开发人员安置在顶级创业公司和科技公司</strong> </a></p></div></div>    
</body>
</html>