<html>
<head>
<title>One Year of Learning React in One Article: 5 Tips for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一年的学习反应在一篇文章中:给初学者的5个提示</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/five-tips-from-one-year-of-learning-react-3e2d4c9c5379?source=collection_archive---------4-----------------------#2020-11-22">https://levelup.gitconnected.com/five-tips-from-one-year-of-learning-react-3e2d4c9c5379?source=collection_archive---------4-----------------------#2020-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e294f68131d2012fbe1696201f826a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7V4Kv9IKpf_UQfxsMsmEA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">反应</figcaption></figure><p id="3a85" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在过去的一年里，我专注于为我的PWA学习React。这是12个月前的事了——今天，我要告诉你我在过去12个月里学到的五个技巧，它们帮助我快速发展。</p><h1 id="a740" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">1.用Typescript！</h1><p id="95cf" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">我第一次涉足React是使用JS。虽然JS已经从它开始的地方走了很远，但是它的动态类型本质带来了许多问题，这些问题永远无法通过cool ES特性来解决。一次又一次，我传入一个属性或变量是<code class="fe mg mh mi mj b">undefined</code>并得到运行时属性访问错误——不可能期望一个人每次都能发现变量可能是未定义的。</p><p id="acda" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">切换到Typescript使我的工作效率提高了10倍——我不再需要在编程会话中花费数小时进行调试。Typescript编译器会捕捉我的大多数运行时错误，这些错误在编译时会在JS中显露出来。对于那些刚刚开始学习React的人来说，跳过一个半月令人毛骨悚然的调试和<code class="fe mg mh mi mj b">console.log('is' + var + ' undefined?')</code>的——直接进入类型检查的天堂，即Typescript。</p><p id="0870" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">有人认为Typescript只是原型化速度较慢。输入变量比写一个简单的<code class="fe mg mh mi mj b">let t = MyObj()</code>要花更长的时间。我发现，在学习Typescript的一个非常短的学习曲线之后，你实际上比使用JS更快地原型化<em class="mk">——这是因为你可以确信你的对象上有你需要的属性，并且当你需要它们时它们实际上就在那里，而不是未定义的或绑定到对象的原型。</em></p><p id="e226" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你要听听这个列表中的一个提示，那么编写TypeScript将会使你领先10步。</p><h1 id="6767" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">2.使用功能组件实现高效、可读的代码</h1><p id="70c5" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">从Flutter开始，类组件的学习曲线要比函数快得多。起初，我避免使用函数组件——钩子很难学，将参数传递给函数组件令人困惑，每个状态变量都有<code class="fe mg mh mi mj b">setState</code>变量也令人困惑。</p><p id="beb9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不过，我确实在Reddit上花了一些时间，100%的r/React都是在功能组件上售出的。由于对它们的一致喜爱，我决定硬着头皮把我的下一个组件写成一个功能组件。</p><p id="a95c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我再也没有写过一个类组件。</p><p id="dbf3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以下面的组件为例:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="4aca" class="mt le it mj b gy mu mv l mw mx">IMyComponentProps {<br/>    prop1: string<br/>    prop2: string<br/>    prop3: string<br/>}<br/><br/>interface IMyComponentState {<br/>    state1: number<br/>    state2: number<br/>    state3: number<br/>}<br/><br/>export class MyComponent&lt;IMyComponentState, IMyComponentProps&gt; {<br/>    this.timer: NodeJs.Interval<br/><br/>    componentDidMount() {<br/>        this.timer = setInterval(() =&gt; this.onRefresh, 200)<br/>        fetchApi().then((data) =&gt; this.setState({ state3: data }))<br/>    }<br/>    <br/>    componentDidUnmount() {<br/>        clearInterval(this.timer)<br/>    }<br/><br/>    onRefresh = () =&gt; {<br/>        fetchApi().then((data) =&gt; this.setState({ state3: data }))<br/>    }<br/><br/>    build(): JSX.Element {<br/>        return &lt;OtherComponent onClick={this.onRefresh.bind(this)} /&gt;<br/>    }<br/>}</span></pre><p id="35b4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们看看这里出了什么问题:</p><ul class=""><li id="bd65" class="my mz it kh b ki kj km kn kq na ku nb ky nc lc nd ne nf ng bi translated">每30秒进行一次API调用需要很多代码。</li><li id="1a3d" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated"><code class="fe mg mh mi mj b">.bind()</code>调用很难看，但对代码正常运行是必要的。</li><li id="3d49" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated">一个简单的类组件大约30行代码。</li><li id="c4e0" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated">一大堆<code class="fe mg mh mi mj b">this</code>，在TS/JS中是出了名的混乱。(虽然TS会让你免去<code class="fe mg mh mi mj b">this</code>的一些困难)</li></ul><p id="e8ba" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个功能组件可以让一切变得更好:</p><pre class="ml mm mn mo gt mp mj mq mr aw ms bi"><span id="d096" class="mt le it mj b gy mu mv l mw mx">IMyComponentProps {<br/>    prop1: string<br/>    prop2: string<br/>    prop3: string<br/>}<br/><br/>export const MyComponent = ({ prop1, prop2, prop3 }: IMyComponentProps): JSX.Element =&gt; {<br/>    const [state1, setState1] = useState(0)<br/>    const [state2, setState3] = useState(0)<br/>    const [state2, setState3] = useState(0)<br/><br/>    let timer: NodeJS.Interval<br/><br/>    const onRefresh = () =&gt; fetchApi().then(setState3)<br/><br/>    useEffect(() =&gt; {<br/>        timer = setInterval(onRefresh, 200)<br/>        return () =&gt; clearInterval(timer)<br/>    })<br/><br/>    return &lt;OtherComponent onClick={onRefresh} /&gt;    <br/>}</span></pre><ul class=""><li id="23b9" class="my mz it kh b ki kj km kn kq na ku nb ky nc lc nd ne nf ng bi translated">三分之一的代码</li><li id="cf65" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated">更容易理解</li><li id="980a" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated">可以适应更灵活的ES6功能</li><li id="8fd1" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated">不用担心<code class="fe mg mh mi mj b">this</code></li></ul><p id="6b65" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所有围绕一个更好的交易，老实说，没有那么高的学习曲线。也许更高级的钩子需要更多的学习，比如<code class="fe mg mh mi mj b">useRef</code>，但是这些不是必需的，只是有帮助——并且没有等价的类组件。</p><p id="56c7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">尽快学习功能组件——这会让你成为更好的开发者。</p><h1 id="46d6" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">3.最佳状态管理解决方案:未陈述-下一个</h1><p id="903e" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">这一点是争议较大的问题之一。如果你不知道什么是状态管理解决方案，这里是我的一句话介绍:有时，你需要在组件之间共享状态(例如，登录用户的用户名或者他们是否登录)，将用户名传递给数百个组件是不实际的，相反，你有某种更高范围的存储来存储数据，以便许多组件可以访问它。</p><p id="6fed" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我见过很多很多Redux粉丝——他们喜欢刚性，如果那是你，那很好！但我喜欢在一个地方做出改变，并让它发挥作用。使用Redux，我发现自己在一个Redux存储中填充了一堆状态变量，这样我就不必重写所有的样板文件。</p><p id="47e0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Next是迄今为止最简单的状态管理解决方案。我不打算写一个完整的未说明的下一个教程，但不会有太多的教程。《T2》是你需要阅读的全部，你知道你需要知道的一切。</p><p id="caac" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">未说明的Next是有史以来最简单的状态管理解决方案，它做了redux做的所有事情。</p><h1 id="ca42" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">4.Snowpack &gt;创建React应用程序</h1><p id="18af" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">无论如何，Create React App并不坏——它实际上做得很好。但我确实认为还有其他更好的选择。例如，我最近一直在使用的是Create Snowpack应用程序。创建Snowpack应用程序有惊人的快编译速度。创建React应用程序，对于较大的项目，需要一点时间来编译。创建Snowpack应用程序有<code class="fe mg mh mi mj b">O(n)</code>编译时间，因为它只重新编译你改变的文件。这意味着一个大型项目的编译速度将和一个较小的项目一样——这是CRA无法保证的。在感受到CRA在大型项目上的痛苦后，CSA是一个显而易见的选择。我没有回头。</p><p id="cb28" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">CSA是一个巨大的改变，它将加速你的下一个项目。</p><p id="8fca" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我构建了自己的CRA样板——它有我最喜欢的eslint配置和一些我喜欢使用的tsconfig更改。您可以对样板文件运行以下命令:)</p><p id="455e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mg mh mi mj b">git clone <a class="ae nm" href="https://github.com/antholeole/snowpack-boiler.git" rel="noopener ugc nofollow" target="_blank">https://github.com/antholeole/snowpack-boiler.git</a></code></p><h1 id="c394" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">5.只管造！</h1><p id="bbb1" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">我最好的建议是最大化你的编码时间。虽然所有这些技巧都会促进你的发展，但你必须学习你的方法。做到这一点的唯一方法是自己开发，不需要一个启发你的项目的指导。</p><p id="831a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，我做的一个个人改变是我的eslint配置不允许分号。如果你喜欢分号，那是完美的，不要害怕开拓自己的道路。</p><p id="f688" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以下是您在前端旅程中必须决定的一些事情:</p><ul class=""><li id="6cb4" class="my mz it kh b ki kj km kn kq na ku nb ky nc lc nd ne nf ng bi translated">SCSS还是CSS？</li><li id="b022" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated">BEM范围界定？还是没有？</li><li id="a1ee" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated">自举还是顺风？还是自制的款式？</li><li id="f3b0" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated">你将如何包括SVG的？引导图标或将图像包含在您的公共文件夹中？</li></ul></div></div>    
</body>
</html>