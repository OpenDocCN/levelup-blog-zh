<html>
<head>
<title>Become an Expert in TypeScript Using Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成为使用泛型的打字专家</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/become-an-expert-in-typescript-using-generics-e5361caea7ef?source=collection_archive---------9-----------------------#2020-03-26">https://levelup.gitconnected.com/become-an-expert-in-typescript-using-generics-e5361caea7ef?source=collection_archive---------9-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1664" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用泛型优化您的代码！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/906f13699adefd462aff7458548f1449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZXHQsnKPMlT94BXpuwu-g.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@solmaz67?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">索尔马兹·哈塔米安</a>在<a class="ae le" href="https://unsplash.com/s/photos/typescript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="8097" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你是否曾经编写过做完全相同事情的函数，而你不得不重复代码来支持多种类型？</p><p id="1348" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您的答案是肯定的，那么有一个使用<em class="lf">泛型</em> <strong class="js iu">的代码复制解决方案！</strong></p><p id="81d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">泛型是允许你开发更多可重用代码的方式。虽然语法在开始看起来有点奇怪，但一点也不复杂。</p><p id="4066" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了理解<em class="lf">泛型</em>如何工作，以及何时/如何使用它们，让我们首先开始编写一些带有代码复制的函数，我们将使用<em class="lf">泛型</em>重构它们。</p><p id="9fa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您有一个函数，它返回给定索引处数组的值。如果你想返回<em class="lf">数字</em>，那么你的函数应该看起来像这样，</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">返回给定索引处的数值的函数</figcaption></figure><p id="5a10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，假设您想要有相同的函数，但是我们想要传递一个由<em class="lf">数字</em>组成的数组，而不是传递一个由<em class="lf">字符串</em>组成的数组，并且在给定的索引处返回一个<em class="lf">字符串</em>值。那么我们的函数应该是这样的，</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">从数组中给定索引处返回字符串的函数</figcaption></figure><p id="ab22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你能注意到我们在复制所有的东西吗？这两种方法看起来完全一样，唯一的区别是我们传递给函数的数组的类型和返回值的类型。除此之外，一切都一样。那么，我们如何重构这些方法，让一个方法接收并返回正确的值呢？</p><p id="a360" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有两种简单的方法可以解决它，第一种(不是最好的)是使用类型定义。所以，重写后的方法应该是这样的，</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">从给定索引处的数组中返回字符串或数值的函数</figcaption></figure><p id="8171" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前面的代码有一个主要问题。你能想到任何缺点吗？</p><p id="b1f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果出于某种原因，您想拆分调用<code class="fe li lj lk ll b">getValue</code>方法时得到的字符串，该怎么办？那么你必须做这样的事情，</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">从getValue中拆分结果字符串的函数</figcaption></figure><p id="dd53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们必须特别检查类型是否是一个<code class="fe li lj lk ll b">string</code>。那是因为如果你试图在结果上直接调用<code class="fe li lj lk ll b">split</code>，<em class="lf"> typescript </em>会报错，因为你不能在<code class="fe li lj lk ll b">number</code>上调用<code class="fe li lj lk ll b">.split</code>，<em class="lf"> typescript </em>不确定结果是字符串，所以你必须先检查<code class="fe li lj lk ll b">result</code>的类型。</p><p id="45a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们如何才能进一步简化这一点，避免产生额外的条件？这就是<em class="lf">仿制药</em>发挥作用的地方！</p><p id="d57f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以像这样简单地重写代码，</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用泛型从特定索引处的数组中获取值的函数</figcaption></figure><p id="ceb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以等一下…</p><p id="ba24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那个诡异的<code class="fe li lj lk ll b">T</code>是什么？而且typescript怎么可能不抱怨呢？</p><p id="3a69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那个字母<code class="fe li lj lk ll b">T</code>只是一个惯例，你可以写类似<code class="fe li lj lk ll b">TypeOfArray</code>或其他不同的东西，但是按照惯例我们通常使用字母<code class="fe li lj lk ll b">T</code>。所以，在幕后发生的事情是，typescript用我们在调用方法时传递的值替换每一次出现的<code class="fe li lj lk ll b">T</code>。换句话说，<code class="fe li lj lk ll b">get&lt;string&gt;(strings, 0)</code>基本就是用<code class="fe li lj lk ll b">string</code>代替<code class="fe li lj lk ll b">T</code>。这样，Typescript知道预期的数组应该是哪种类型以及返回类型是什么。因此我们可以调用<code class="fe li lj lk ll b">result1</code>上的<code class="fe li lj lk ll b">split</code>而不必检查它的类型。</p><h2 id="9927" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">真实世界的例子</h2><p id="55b5" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">到目前为止，我们已经用您可能从未用过的方法探索了假设的情况，所以让我们看看您可以在哪里真正使用<em class="lf">泛型</em> <strong class="js iu">！</strong></p><p id="5c34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个很好的例子就是处理HTTP请求以将数据保存到服务器中的类。你可以在angular中实现一个服务，或者在任何其他框架中实现类似的服务。</p><p id="114d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您有一个<code class="fe li lj lk ll b">Sync class</code>应该将一些数据保存到服务器中。如果你想在没有<em class="lf">泛型</em>的情况下做到这一点，一种方法是在你的应用程序中为每个类复制相同的<code class="fe li lj lk ll b">Sync class</code>或服务。例如，如果你有一个学生、老师、学校和一个主题<code class="fe li lj lk ll b">class</code>，你可以有4个不同的同步类，每种类型一个。它看起来会像这样:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">学生类和学生同步类</figcaption></figure><p id="3d66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是那会是一个多么可怕的反模式呢？一种简化的方法是只使用一个Sync类来处理所有类型的请求，</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">保存时同步类(数据:任何)</figcaption></figure><p id="7f7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我们所做的是将<code class="fe li lj lk ll b">save(data: Student)</code>更改为<code class="fe li lj lk ll b">save(data: any)</code>。这也是一种<strong class="js iu">不好的</strong>方式。你应该尽量避免使用<code class="fe li lj lk ll b">any</code>。使用<code class="fe li lj lk ll b">any</code>只会混淆<em class="lf">类型脚本</em>，并且不再做进一步的类型检查。你会失去<em class="lf">打字稿</em>的威力。</p><p id="02ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们如何解决这个问题？这也是<em class="lf">仿制药</em>发挥作用的地方！让我们重构我们的<code class="fe li lj lk ll b">Sync class</code>来利用<em class="lf">泛型</em>，</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用泛型同步类</figcaption></figure><p id="c9af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你现在可以看到，我们已经在我们的<code class="fe li lj lk ll b">Sync class</code>中使用了<em class="lf">泛型</em>，但是为什么我们还要添加那个<code class="fe li lj lk ll b">HasId</code> <code class="fe li lj lk ll b">interface</code>？这基本上只是告诉<em class="lf"> typescript </em>任何其他想要实例化<code class="fe li lj lk ll b">Sync</code>类型的<strong class="js iu">对象</strong>的类应该有一个<strong class="js iu">可选的</strong> id。如果我们没有明确地让<em class="lf"> typescript </em>知道那个id，那么当在save方法上对你的数据进行<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构</a>时，你会得到一个<strong class="js iu">错误</strong>，因为<em class="lf"> typescript </em>无法知道数据包含一个名为<code class="fe li lj lk ll b">id</code>的属性。</p><p id="45a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止看起来很棒，是吧？让我们看看另一个真实世界的例子，它可能看起来更复杂(但事实并非如此)！</p><p id="10cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来看看下面这个<strong class="js iu">学生</strong>T10】，</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="bd45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以看到我们有两个方法，一个是<strong class="js iu">获取</strong>学生的属性，另一个是<strong class="js iu">设置</strong>属性。如果我们有一个<strong class="js iu">老师</strong> <code class="fe li lj lk ll b">class</code>或者任何其他类，这两个方法可能是需要的。因为<code class="fe li lj lk ll b">get</code>和<code class="fe li lj lk ll b">set</code>不仅仅局限于学生，对吗？</p><p id="919e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，为了防止添加新模型时出现代码重复，让我们重构<strong class="js iu">学生</strong>T14】并创建一个新的<strong class="js iu">属性</strong> <code class="fe li lj lk ll b">class</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="04d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，这就是“疯狂”的部分。你现在可能想知道<code class="fe li lj lk ll b">K extends keyof T</code>是什么意思，或者为什么<code class="fe li lj lk ll b">get</code>方法的返回类型变成了<code class="fe li lj lk ll b">T[K]</code>？在typescript中，接口的所有键都被视为字符串！</p><p id="b189" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以基本上，我们在上面的代码中所说的是，当用<code class="fe li lj lk ll b">StudentProps</code>实例化对象时，<code class="fe li lj lk ll b">get</code>方法将把一个值作为<code class="fe li lj lk ll b">id</code>或<code class="fe li lj lk ll b">name</code>类型的参数。当用<code class="fe li lj lk ll b">TeacherProps</code>实例化一个对象时，那么<code class="fe li lj lk ll b">get</code>方法将只接受键<code class="fe li lj lk ll b">id</code>、<code class="fe li lj lk ll b">name </code>和<code class="fe li lj lk ll b">isGoodTeacher</code>。对<code class="fe li lj lk ll b">get</code>的每次调用返回的值类型将是我们想要获取其值的属性的类型！</p><p id="ef37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很棒吧？</p><h2 id="fbd5" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">结论</h2><p id="28be" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">泛型是一个强大的工具，它允许你设计一些复杂的组合模式，并使你的代码更加可重用。开始时，它们可能看起来有点可怕或怪异，但一旦你使用它们，你就会爱上它们！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="331e" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">更多关于泛型？</h2><ul class=""><li id="6c9a" class="mr ms it js b jt mf jx mg kb mt kf mu kj mv kn mw mx my mz bi translated"><a class="ae le" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">https://www.typescriptlang.org/docs/handbook/generics.html</a></li><li id="c8cb" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated"><a class="ae le" href="https://www.tutorialsteacher.com/typescript/typescript-generic-class" rel="noopener ugc nofollow" target="_blank">https://www . tutorialsteacher . com/typescript/typescript-generic-class</a></li></ul></div></div>    
</body>
</html>