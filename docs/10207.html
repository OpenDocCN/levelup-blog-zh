<html>
<head>
<title>Perform Distributed Computing Easily Using Ray in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的Ray轻松执行分布式计算</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/parallel-and-distributed-computing-in-python-using-ray-e14f9e46fc16?source=collection_archive---------3-----------------------#2021-11-06">https://levelup.gitconnected.com/parallel-and-distributed-computing-in-python-using-ray-e14f9e46fc16?source=collection_archive---------3-----------------------#2021-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bc5e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">介绍分布式计算的概念，并使用开源Python库Ray编写可在分布式系统上工作的可扩展代码。</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/d8ef0de6b41a2455bfd7e6e9c75bd455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4jpkC_R4Wynxk4Us"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kw" href="https://unsplash.com/@marcinjozwiak?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marcin Jozwiak </a>拍摄的照片</figcaption></figure><p id="800c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们在之前的文章中已经看到了如何使用<a class="ae kw" href="https://www.earthinversion.com/techniques/parallel-computing-in-python/" rel="noopener ugc nofollow" target="_blank">线程和多重处理</a>来同时执行我们的计算。即使是具有多个CPU内核的单处理器计算机(一个处理器具有一个或多个内核，一个计算机具有一个或多个处理器)，也会给人一种能够同时运行多个任务的错觉。当我们有多个处理器时，我们可以真正以并行方式执行计算。</p><h1 id="fce8" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">并行计算还是分布式计算？</h1><p id="7814" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">并行计算在现代计算中非常有用，几乎是必需的，其目标是实现最高性能。我们将长时间运行的计算分成更小的块，并将它们分配给不同的处理器。这种策略允许我们在相同的时间内做更多的计算。为了构建基于GUI的应用程序，系统的并行设计总是需要的，以便一个线程可以保持可用以更新GUI并响应用户输入。</p><p id="49c9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">并行计算和分布式计算的区别在于，对于并行计算，多个处理器驻留在同一个主板上。分布式计算同时使用多台计算机来解决一个问题。现代分布式系统能够通过网络(局域网/广域网)进行通信。分布式计算的优势在于它的价格和可扩展性。如果我们需要更多的电力，那么我们可以很容易地添加更多的计算机。</p><p id="5752" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">本质上，并行和分布式计算的架构非常相似。主要区别在于分布式计算使用分布式内存空间，而不是共享内存空间。拥有一个可以为我们的应用程序提供统一的逻辑(而不是物理)内存空间的软件层，可以帮助我们运行为分布式计算的并行计算编写的代码。</p><p id="ad49" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本文中，我们将看到如何使用开源Python库Ray来帮助我们执行并行和分布式计算。Ray采用Pythonic函数和类，并将它们转换为分布式设置的任务和参与者。我们将只看到函数的例子，但是类的概念是非常相似的。</p><h1 id="b193" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用<code class="fe mq mr ms mt b">pip</code>安装射线</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/164ae2690aa26b154dba85c48f4220f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dLW4VHioOS-ElPlA.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">作者图片</figcaption></figure><p id="9868" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这将安装支持仪表板+集群启动器的Ray。</p><pre class="kh ki kj kk gt mv mt mw mx aw my bi"><span id="145a" class="mz lu iq mt b gy na nb l nc nd">pip install 'ray[default]'</span></pre><p id="6723" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您需要最小安装:</p><pre class="kh ki kj kk gt mv mt mw mx aw my bi"><span id="da7b" class="mz lu iq mt b gy na nb l nc nd">pip install -U ray</span></pre><h1 id="dd65" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">Ray中带任务的并行计算</h1><p id="4db3" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">让我们执行一个来自我们在<a class="ae kw" href="https://www.earthinversion.com/techniques/parallel-computing-in-python/" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>的例子，我们使用<code class="fe mq mr ms mt b">concurrent.futures</code>运行，并与我们使用<code class="fe mq mr ms mt b">ray</code>运行相同的任务进行比较。</p><pre class="kh ki kj kk gt mv mt mw mx aw my bi"><span id="5263" class="mz lu iq mt b gy na nb l nc nd">import time<br/>import concurrent.futures<br/><br/><br/>Stime = time.perf_counter()<br/>tasks = []<br/>sleepTimes = [0.1, 0.2, 0.1, 0.5, 0.7, 0.9, 0.5,<br/>              0.4, 1.5, 1.3, 1.0, 0.3, 0.7, 0.6, 0.3, 0.8]<br/>print(f"Total time of sleep: {sum(sleepTimes)} for {len(sleepTimes)} tasks")<br/><br/>def my_awesome_function(sleepTime=0.1):<br/>    time.sleep(sleepTime)<br/>    return f"Sleep time {sleepTime}"<br/><br/>all_results = []<br/>with concurrent.futures.ProcessPoolExecutor() as executor:<br/>    tasks = [executor.submit(my_awesome_function, sleep)<br/>             for sleep in sleepTimes]<br/><br/>    for ff in concurrent.futures.as_completed(tasks):<br/>        all_results.append(ff.result())<br/><br/><br/>print(f"Finished in {time.perf_counter()-Stime:.2f}")</span></pre><p id="2479" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这返回</p><pre class="kh ki kj kk gt mv mt mw mx aw my bi"><span id="0d22" class="mz lu iq mt b gy na nb l nc nd">$ python test_ray.py <br/>Total time of sleep: 9.9 for 16 tasks <br/>Finished in 1.65</span></pre><p id="673e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">按顺序完成这项工作需要9.9秒。因为我们执行并行执行，所以我们在我的计算机上用1.65秒完成了这项工作。请注意，对于您的电脑，这个时间可能会有所不同。</p><p id="d73d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，让我们用雷做同样的工作。我们首先使用<code class="fe mq mr ms mt b">ray.init()</code>初始化光线。decorary<code class="fe mq mr ms mt b">ray.remote</code>将Python函数转换成可以远程异步执行的函数。它立即返回可以并行执行的函数的N个副本。</p><pre class="kh ki kj kk gt mv mt mw mx aw my bi"><span id="3800" class="mz lu iq mt b gy na nb l nc nd">import time<br/>import ray<br/><br/>import concurrent.futures<br/><br/><br/>Stime = time.perf_counter()<br/>tasks = []<br/>sleepTimes = [0.1, 0.2, 0.1, 0.5, 0.7, 0.9, 0.5,<br/>              0.4, 1.5, 1.3, 1.0, 0.3, 0.7, 0.6, 0.3, 0.8]<br/>print(f"Total time of sleep: {sum(sleepTimes)} for {len(sleepTimes)} tasks")<br/><br/># Start Ray.<br/>ray.init()<br/><br/>@ray.remote #convert to a function that can be executed remotely and asynchronously<br/>def my_awesome_function(sleepTime=0.1):<br/>    time.sleep(sleepTime)<br/>    return f"Sleep time {sleepTime}"<br/><br/>tasks = []<br/>for sleep in sleepTimes:<br/>    tasks.append(my_awesome_function.remote(sleep))<br/><br/>all_results = ray.get(tasks)<br/>print(f"Finished in {time.perf_counter()-Stime:.2f}")</span></pre><p id="04d0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这返回</p><pre class="kh ki kj kk gt mv mt mw mx aw my bi"><span id="2706" class="mz lu iq mt b gy na nb l nc nd">Total time of sleep: 9.9 for 16 tasks <br/>Finished in 3.18</span></pre><p id="ad0a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">开销会造成一些延迟，但对于大型计算来说，这种延迟可以忽略不计。</p><h1 id="bd80" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">大型计算的聚合值</h1><p id="e20b" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">Ray可以很容易地用来聚合多个值，这对于构建需要在多台机器上聚合计算的大型应用程序至关重要。对于大型计算，Ray可以将聚合的运行时间从线性改为对数。</p><p id="906f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们看一个例子:</p><pre class="kh ki kj kk gt mv mt mw mx aw my bi"><span id="5e54" class="mz lu iq mt b gy na nb l nc nd">import time<br/>import ray<br/>import numpy as np<br/><br/>Stime = time.perf_counter()<br/><br/>@ray.remote<br/>def create_matrix(size):<br/>    return np.random.normal(size=size)<br/><br/>@ray.remote<br/>def multiply_matrices(x, y):<br/>    return np.dot(x, y)<br/><br/>@ray.remote<br/>def sum_matrices(x, y):<br/>    return np.add(x, y)<br/><br/>m1 = create_matrix.remote([1000, 1000])<br/>m2 = create_matrix.remote([1000, 1000])<br/>m3 = create_matrix.remote([1000, 1000])<br/>m4 = create_matrix.remote([1000, 1000])<br/><br/>m12 = multiply_matrices.remote(m1, m2)<br/>m34 = multiply_matrices.remote(m3, m4)<br/><br/>a12_34 =  sum_matrices.remote(m12, m34)<br/><br/>## Results<br/>MM = ray.get(a12_34)<br/><br/><br/>print(f"Finished in {time.perf_counter()-Stime:.2f}")</span></pre><p id="5298" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在上面的例子中，我们首先创建四个矩阵，将它们分组为两个，将组中的矩阵相乘，然后将每组相乘的结果相加。这里，乘法是并行进行的，然后将结果相加得到总和。</p><h1 id="9dd5" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">参考</h1><ol class=""><li id="d62a" class="ne nf iq kz b la ml ld mm lg ng lk nh lo ni ls nj nk nl nm bi translated"><a class="ae kw" href="https://docs.ray.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank">安装射线</a></li><li id="6ff6" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">Pierfederici，F. (2016)。用Python实现分布式计算。《物理学杂志A:数学与理论》(第44卷，第8期)。帕克特出版有限公司</li><li id="ff52" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated"><a class="ae kw" href="https://towardsdatascience.com/modern-parallel-and-distributed-python-a-quick-tutorial-on-ray-99f8d70369b8" rel="noopener" target="_blank">现代并行和分布式Python:关于Ray的快速教程</a></li></ol></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="0a77" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nz">原载于2021年11月6日https://www.earthinversion.com</em><a class="ae kw" href="https://www.earthinversion.com/utilities/parallel-and-distributed-computing-in-python-using-ray/" rel="noopener ugc nofollow" target="_blank"><em class="nz"/></a><em class="nz">。</em></p></div></div>    
</body>
</html>