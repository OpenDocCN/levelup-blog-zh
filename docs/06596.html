<html>
<head>
<title>JavaScript Table Sorting (Part 1 of 2) — Start Out Simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript表格排序(第1部分，共2部分)——从简单开始</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-table-sorting-part-1-of-2-start-out-simple-1df3e0be8d4e?source=collection_archive---------5-----------------------#2020-12-10">https://levelup.gitconnected.com/javascript-table-sorting-part-1-of-2-start-out-simple-1df3e0be8d4e?source=collection_archive---------5-----------------------#2020-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2667dfda603221eee8913ac60661bb7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6a9zgTfn43QG8b1bKISeA.png"/></div></div></figure><p id="0764" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有很多关于这方面的不错的文章。特别是，<a class="ae kz" href="https://medium.com/javascript-in-plain-english/easy-table-sorting-with-javascript-370d8d97cad8" rel="noopener"> Bobby Jack在Medium </a>上的文章有几个突出的原因:</p><ol class=""><li id="d19f" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">他们从JavaScript中钩出标记，留下适当的语义。<strong class="kd iu">这是非常好的脚本</strong>因为这是一种“渐进增强”的形式。这意味着对于没有JavaScript可用的用户，或者在一些情况下——比如屏幕/盲文阅读器——它是高度不相关的，我们得到了“优雅的降级”。当你写JavaScript的时候，你应该尽可能地让页面对那些关闭/屏蔽/不可用的用户仍然可用。如果做不到这一点，基本上就是告诉大量用户——尤其是那些有可访问性需求的用户——自己走开。这是1985年的2020年，无障碍侵犯可不是闹着玩的。</li><li id="d624" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">这些标记并不完全是垃圾，因为它们实际上使用了<code class="fe lo lp lq lr b">&lt;thead&gt;</code>、<code class="fe lo lp lq lr b">&lt;tbody&gt;</code>和<code class="fe lo lp lq lr b">&lt;th&gt;</code>。除了<code class="fe lo lp lq lr b">&lt;tr&gt;</code>和<code class="fe lo lp lq lr b">&lt;td&gt;</code>之外，表格中还应该包含更多内容！</li><li id="f0db" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">它利用了这样一个事实，即<code class="fe lo lp lq lr b">appendChild</code>也删除了一个元素在DOM中的现有位置。重新排序一个表的最快方法之一就是将它们全部平铺<code class="fe lo lp lq lr b">appendChild</code>。这意味着您不必先手动<code class="fe lo lp lq lr b">parentNode.removeChild() </code>它们！这是我经常使用的一个非常巧妙的技巧，很高兴看到有人接受了。</li></ol><p id="8a7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总的来说，这是一个不错的实现，但是就像我见过的人们这样做的许多其他方式一样，我认为它也有一些问题。</p><ol class=""><li id="fa2e" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">示例标记可以更“完整”一点，比如应用范围，并对<code class="fe lo lp lq lr b">&lt;tbody&gt;</code>行中的第一个单元格使用<code class="fe lo lp lq lr b">&lt;th&gt;</code>。人们给出的太多例子的问题是有不完整的标记，这些标记只是一些粗人盲目的克隆。我知道这样做是为了“简化”那些刚刚学习的人，但从长远来看，这样做弊大于利。</li><li id="d1c8" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">它使用innerHTML，如果你的表格标题是用户生成的，这可能是一个风险。InnerHTML也很慢，尽管在这种情况下这并不是一个大问题。尽管如此，innerHTML已经过时了，你应该尽可能避免使用。它叫DOM，用它。不，innerHTML不是DOM操作，不管有多少无知的人声称不是。</li><li id="8679" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">它在“循环内部”做了大量的querySelectorAll，而不是遍历DOM。如果没有CSS选择器查询或getElement By(XXX)之类的东西，许多nodeList操作会更快完成。ParentNode、firstElementChild和nextElementSibling是你的朋友！</li><li id="279d" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">更糟糕的是，它使用了一些第n个子查询选择器来获取信息，而这些信息本可以从<code class="fe lo lp lq lr b">&lt;th&gt;</code>的<em class="ls"> cellIndex </em>属性中获取。</li><li id="19ce" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">各种各样的排序都是硬编码的，如果你试图扩展，它会变得有点“笨重”并且很难做到。如果使用引用适当动作的对象，就可以更简单、更快地完成。</li><li id="5d06" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">它没有范围隔离。我会使用IIFE，因为它更通用，并在它应该在的地方声明变量作用域:在脚本中，而不是在标记中。</li><li id="9056" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">排序的数据类型必须硬编码或测试，我建议使用数据属性来存储在<code class="fe lo lp lq lr b">THEAD &gt; TH</code>中使用的排序类型(日期、文本、数字等)。</li><li id="cc79" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">它使用<code class="fe lo lp lq lr b">&lt;a&gt;</code> nchors代替<code class="fe lo lp lq lr b">&lt;button&gt;</code>。锚的问题是，如果它们没有href，它们就不能用键盘/替代导航，如果它们有href，你需要在它们上面<code class="fe lo lp lq lr b">event.preventDefault();</code>。根据经验，如果元素只用于脚本行为。使用按钮标签！</li><li id="ee94" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">它们钩住表格，而不是点击事件的锚点。这意味着在表上的每一次点击都要经过排序函数，这可能是……低效的。它也不能在一些浏览器中提供正确的键盘导航。总的来说<code class="fe lo lp lq lr b">Event.target</code> vs <code class="fe lo lp lq lr b">Event.currentTarget</code>是一个不可靠的烂摊子，我个人倾向于避免。</li></ol><p id="9e48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有什么是不可克服的，但是所有这些加在一起导致它几乎是完成这项工作所需JavaScript的两倍。</p><p id="685c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，让我们以他为榜样，跟着他跑吧。</p><h1 id="c28b" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">加价</h1><p id="e6cf" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">我要做的第一件事是在那里获得一些范围，在表头上获得一些数据属性，等等。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="c18d" class="ne lu it lr b gy nf ng l nh ni">&lt;table&gt;<br/>  &lt;caption&gt;Sortable Table&lt;/caption&gt;<br/>  &lt;thead&gt;<br/>    &lt;tr&gt;<br/>      &lt;th scope="col" data-tablesort="text"&gt;Game&lt;/th&gt;<br/>      &lt;th scope="col" data-tablesort="number"&gt;Price&lt;/th&gt;<br/>      &lt;th scope="col" data-tablesort="date"&gt;Release date&lt;/th&gt;<br/>      &lt;th scope="col" data-tablesort="number"&gt;Rating&lt;/th&gt;<br/>    &lt;/tr&gt;<br/>  &lt;/thead&gt;&lt;tbody&gt;<br/>    &lt;tr&gt;<br/>      &lt;th scope="row"&gt;Super Mario Odyssey&lt;/th&gt;<br/>      &lt;td&gt;49.99&lt;/td&gt;<br/>      &lt;td&gt;October 27, 2017&lt;/td&gt;<br/>      &lt;td&gt;97&lt;/td&gt;<br/>    &lt;/tr&gt;&lt;tr&gt;<br/>      &lt;th scope="row"&gt;The Legend of Zelda: Breath of the Wild&lt;/th&gt;<br/>      &lt;td&gt;59.99&lt;/td&gt;<br/>      &lt;td&gt;March 3, 2017&lt;/td&gt;<br/>      &lt;td&gt;97&lt;/td&gt;<br/>    &lt;/tr&gt;&lt;tr&gt;<br/>      &lt;th scope="row"&gt;Super Smash Bros. Ultimate&lt;/th&gt;<br/>      &lt;td&gt;59.99&lt;/td&gt;<br/>      &lt;td&gt;December, 7 2018&lt;/td&gt;<br/>      &lt;td&gt;93&lt;/td&gt;<br/>    &lt;/tr&gt;&lt;tr&gt;<br/>      &lt;th scope="row"&gt;Ori and the Will of the Wisps&lt;/th&gt;<br/>      &lt;td&gt;24.99&lt;/td&gt;<br/>      &lt;td&gt;September 17, 2020&lt;/td&gt;<br/>      &lt;td&gt;93&lt;/td&gt;<br/>    &lt;/tr&gt;&lt;tr&gt;<br/>      &lt;th scope="row"&gt;Animal Crossing: New Horizons&lt;/th&gt;<br/>      &lt;td&gt;49.99&lt;/td&gt;<br/>      &lt;td&gt;March 20, 2020&lt;/td&gt;<br/>      &lt;td&gt;90&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>  &lt;/tbody&gt;<br/>&lt;/table&gt;</span></pre><p id="b1c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为此我们不需要父类或其他钩子，因为我们可以使用query selectorall(" th[data-table sort]")来获取TH。其他所有的元素访问都可以通过DOM遍历来完成。</p><p id="9337" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于那些不熟悉它的人来说，scope= " "属性说明了在哪个轴上应用一个<code class="fe lo lp lq lr b">&lt;th&gt;</code>。“行”或“列”(列)。如果您关心可访问性的话，这是构建表的重要部分。同样的道理也适用于在两个轴上正确设置<code class="fe lo lp lq lr b">&lt;th&gt;</code>，以便正确描述和属性表格数据。</p><h1 id="7401" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">脚本</h1><p id="b7b7" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">我想做的第一件事是设置一个life并“使用严格的”,这样我们就可以确保不扩大范围，并使用更快/更现代的JS实现。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="7132" class="ne lu it lr b gy nf ng l nh ni">(function(d) {</span><span id="b2b8" class="ne lu it lr b gy nj ng l nh ni">  "use strict";</span><span id="dcda" class="ne lu it lr b gy nj ng l nh ni">})(document);</span></pre><p id="41da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我把document作为“d”传递，这样我就不会在该死的地方到处键入“document”。如果它足够好让谷歌使用，它也足够好让我使用。</p><p id="2b57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步是创建几个包含排序函数的对象。一个用于一般比较，一个用于数据提取。</p><h2 id="91ce" class="ne lu it bd lv nk nl dn lz nm nn dp md km no np mh kq nq nr ml ku ns nt mp nu bi translated">比较</h2><p id="aeb1" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">这两种比较类型非常简单:</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="ad4f" class="ne lu it lr b gy nf ng l nh ni">var<br/>    comps = {<br/>      number : function(a, b) { return a - b; },<br/>      text : function(a, b) { return a &gt; b ? 1 : a &lt; b ? -1 : 0; }<br/>    },</span></pre><p id="3de9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">任何精通JS的人都应该知道这些是干什么用的。遗憾的是，与Firefox或传统IE不同的是，one Chrome-likes的“text”—<em class="ls">—</em>对于“大于”比较本身返回的“真/假”来说太愚蠢了，所以我们需要这种三元混乱来确保所有“blink”和“webkit”浏览器的行为符合预期。谢天谢地，对于数字，所有的浏览器实际上只测试符号和零。如果你对机器语言有所了解的话，这确实很有意义！</p><h2 id="161d" class="ne lu it bd lv nk nl dn lz nm nn dp md km no np mh kq nq nr ml ku ns nt mp nu bi translated">数据/内容提取</h2><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="12eb" class="ne lu it lr b gy nf ng l nh ni">    sortTypes = {<br/>      date : {<br/>        get : function(cell) {<br/>          return Date.parse(cell.textContent);<br/>        },<br/>        sort : comps.number<br/>      },<br/>      number : {<br/>        get : function(cell) {<br/>          return +cell.textContent;<br/>        },<br/>        sort: comps.number<br/>      },<br/>      text : {<br/>        get : function(cell) {<br/>          return cell.textContent;<br/>        },<br/>        sort : comps.text<br/>      }<br/>    },</span></pre><p id="4f17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只需提取适当的值并将其解析成所需的格式。</p><p id="622a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过以这种方式使用对象，我们可以很容易地在以后向流程中添加更多的数据类型或其他操作。</p><h1 id="1200" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">向我们的TH添加按钮</h1><p id="6006" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">首先，正如在标记中提到的，让我们使用属性选择器来获取它们。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="3b2e" class="ne lu it lr b gy nf ng l nh ni">    tablesortTh = d.querySelectorAll("th[data-tablesort]");</span></pre><p id="bfa6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不完全是火箭科学。</p><p id="ad7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这些标题，我们希望用一个<code class="fe lo lp lq lr b">&lt;button&gt;</code>标签来替换它们的内容。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="ea6c" class="ne lu it lr b gy nf ng l nh ni">for (var i = 0, th; th = tablesortTh[i]; i++) {<br/>  if (!sortTypes[th.dataset.tablesort]) continue;<br/>  var button = d.createElement("button");<br/>  button.className = "sortButton";<br/>  button.onclick = tablesort;<br/>  button.textContent = th.textContent;<br/>  button.type = "button"; // remember, default is SUBMIT!<br/>  th.textContent = "";<br/>  th.appendChild(button);<br/>}</span></pre><p id="8371" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，首先你可能会怀疑地盯着那个“for”循环。信不信由你，当你有一个最快的循环方式的节点列表。我是一个非常规元素循环方式的粉丝，这种方式的效率令人惊讶。它甚至绕着for/of打转，而且比带有回调开销的dumbass Array.forEach优越得多。<em class="ls">当彻底的垃圾隐晦的“箭头功能”垃圾介入时更是如此。</em></p><p id="a3a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从我们的<code class="fe lo lp lq lr b">&lt;th&gt;</code>中取出<em class="ls">数据表排序</em>，并查看它是否存在于我们的<em class="ls">排序类型</em>中。如果没找到我们就跳过这个<code class="fe lo lp lq lr b">&lt;th&gt;</code>。</p><p id="4b13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，按钮被创建为一个<code class="fe lo lp lq lr b">HTMLElement</code>对象，并设置了它的属性。通常情况下，人们不会<strong class="kd iu">而</strong>使用有利于<code class="fe lo lp lq lr b">addEventListener</code>的<code class="fe lo lp lq lr b">Element.onclick</code>属性，而是允许其他事件挂钩，但是因为我们自己在动态DOM中创建了这个元素，所以没有必要编写额外的代码。</p><p id="9956" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也不要忘记<code class="fe lo lp lq lr b">&lt;button&gt;</code>的缺省值是<code class="fe lo lp lq lr b">type=”submit”</code>。将它设置为“按钮”,这样点击它就不会意外地提交一个表单，如果它最终…在一个表单中。同样，使用按钮比在事件处理程序中使用<code class="fe lo lp lq lr b">Event.preventDefault();</code>要容易得多。</p><p id="743f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">Element.textContent</code>用于清空元素，因为它比innerHTML开销小(在现代浏览器中)。如果我写这篇文章是为了支持传统浏览器，我会考虑做一个<code class="fe lo lp lq lr b">while (e = th.firstChild) th.removeChild(e);</code>,因为在IE中这样更快……但是这些天我真的跳过了那个噪音。</p><p id="dcc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ls">事实上，我建议将X-UA-Compatible设置为IE=9，这样你就可以取回IE CC，然后使用条件注释来阻止向IE的所有版本发送CSS和JS！只要给他们你的普通语义标记…如果有的话。</em> <a class="ae kz" href="https://deathshadow.medium.com/html-5-and-the-w3c-going-to-hell-in-a-handbasket-6a9f9fda7226" rel="noopener"> <em class="ls">是的，即使W3C对IE=edge之外的任何值都已经满甘了。</em> </a> <em class="ls">在与web技术打交道的二十年中，我</em> <strong class="kd iu"> <em class="ls">从未想过我会说这个</em> </strong> <em class="ls">，但是如果他们要像那样愚蠢的话，我会说“验证”！</em></p><p id="62e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，一旦元素完成，追加它。</p><h2 id="3f9a" class="ne lu it bd lv nk nl dn lz nm nn dp md km no np mh kq nq nr ml ku ns nt mp nu bi translated">排序事件处理程序</h2><p id="7f64" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">像任何事件处理程序一样，它被传递给“事件”,所以让我们为它创建一个函数。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="968f" class="ne lu it lr b gy nf ng l nh ni">function tablesort(event) {<br/>} // tablesort</span></pre><p id="7560" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在其中，我们将通过<code class="fe lo lp lq lr b">parentNode</code>、<code class="fe lo lp lq lr b">nextElementSibling</code>和其他DOM遍历函数来挂钩对元素的大量引用。</p><p id="be98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一般来说，我喜欢把作用域中使用的所有变量放在函数块的开头。这可能源于我先学习了汇编语言，我的第一门“真正的”高级语言是Pascal，并且在ADA工作了十年。我发誓，如果有更多的人这样做，他们就会很少遇到他们试图用let/const“解决”的问题。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="fa80" class="ne lu it lr b gy nf ng l nh ni">var<br/>   button = event.currentTarget,<br/>   th = button.parentNode,<br/>   thead_tr = th.parentNode,<br/>   tbody = thead_tr.parentNode.nextElementSibling,</span></pre><p id="a9fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要这个按钮，并且经常使用它，因为它把我们送到了这里。<code class="fe lo lp lq lr b">&lt;th&gt;</code>我们需要拉“cellIndex”来说明我们正在排序的列。令人惊讶的是,<code class="fe lo lp lq lr b">&lt;thead&gt;&lt;tr&gt;</code>也提到了很多，当然我们需要<code class="fe lo lp lq lr b">&lt;tbody&gt; </code>,因为那是我们实际上正在做的。</p><p id="984c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们想知道我们在使用哪种排序方法。在任何循环或回调之前将它们存储在变量中可以加快速度。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="84da" class="ne lu it lr b gy nf ng l nh ni">  type = sortTypes[th.dataset.tablesort],<br/>  callback = (<br/>    (button.value = button.value == 1 ? 0 : 1) ?<br/>    function(a, b) { return type.sort(a.value, b.value); } :<br/>    function(a, b) { return type.sort(b.value, a.value); }<br/>  ),</span></pre><p id="48f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是事情变得“可爱”的地方。因为按钮是一个表单元素，所以它可以有一个值。我们可以使用这个值来存储我们的排序顺序状态！</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="6ddd" class="ne lu it lr b gy nf ng l nh ni">// value == ""     unsorted column<br/>// value == "1"    sort ascending<br/>// value == "0"    sort descending</span></pre><p id="223c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们测试它是否== 1(是的，松散，它可以是字符串或数字)，如果它被设置为降序。如果不是——未排序或降序——将其设置为升序。然后我们可以把它赋给button.value. <em class="ls">是的，那个single =不是错误。抱歉，JavaScript“粉丝们”，但当谈到赋值求值时，PHP开发人员在嘲笑你！</em></p><p id="41e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，三元运算可以通过生成适当的匿名函数来确定传递排序参数的方式。因为“类型”在我们当前的范围内，匿名用户可以选择它。可笑的是，如果你有不止一个表，“let”或“const”可能会破坏这个代码。只是我认为那些新“功能”是毫无意义的垃圾的部分原因。</p><p id="53d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们需要我们的“工人变量”</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="efb6" class="ne lu it lr b gy nf ng l nh ni">  sortList = [],<br/>  e = th;</span></pre><p id="ff9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">sortList</code>是我们将<code class="fe lo lp lq lr b">TBODY &gt; TR</code>值/引用复制到的地方。在我的代码中,“e”变量通常被用作遍历DOM的“可重用工人”。我们开始将它设置为TH，这样我们就可以将当前TH的兄弟上的value= " "设置为空。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="da6f" class="ne lu it lr b gy nf ng l nh ni">while (e = e.previousElementSibling) e.firstElementChild.value = "";<br/>e = th;<br/>while (e = e.nextElementSibling) e.firstElementChild.value = "";</span></pre><p id="a4ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您从未进行过DOM遍历，这可能看起来很奇怪，但这比尝试执行querySelectorAll或GetElementsByTagName、使用for循环并测试我们没有更改实际正在处理的DOM要快得多。</p><p id="9f07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，对于第二个循环，我们必须将“e”重置为th，这样我们就可以走另一个方向。</p><blockquote class="nv"><p id="e1cb" class="nw nx it bd ny nz oa ob oc od oe ky dk translated">在苏联，大教堂会带你去…</p></blockquote><p id="d715" class="pw-post-body-paragraph kb kc it kd b ke of kg kh ki og kk kl km oh ko kp kq oi ks kt ku oj kw kx ky im bi translated">说真的，我不明白为什么人们这么害怕与DOM打交道。她又没有鞭子。</p><p id="63e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们可以使用类似的DOM遍历来填充排序列表。我们只是测试tbody的firstElementChild并赋值，然后do/while。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="165f" class="ne lu it lr b gy nf ng l nh ni">if (e = tbody.firstElementChild) do {<br/>  sortList.push({<br/>    tr : e,<br/>    value : type.get(e.cells[th.cellIndex])<br/>  });<br/>} while (e = e.nextElementSibling);</span></pre><p id="fd35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是的，<strong class="kd iu">做/WHILE！</strong>正如我在<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/php-array-functions-and-c-syntax-loop-methods-few-people-even-know-33c198782a55">上一篇文章</a>中所说的，大多数关于它有多“坏”或“错”的说法似乎都可以归结为某个<strong class="kd iu">所谓的该领域的</strong>专家说<em class="ls">“我太笨了，无法理解它，所以其他人不应该被允许使用它！”</em></p><p id="caf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有一个非常好的“如果”来执行我们的安全检查，但是迭代器需要一个不同的值。同样，“Pascal”思想完全符合DOM的结构和工作方式……同样比这里的“querySelectorAll”或“getElementsByTagName”快很多倍。</p><p id="86aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们推送的值包含对我们正在处理的TR的引用，并从TR中相应的单元格获取数据。</p><p id="86e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这才是真正有趣的地方，我们可以使用<code class="fe lo lp lq lr b">HTMLTableCellElement.cellIndex </code>来寻址TR (e)中的单元格。因为我们使用的是<code class="fe lo lp lq lr b">HTMLTableRowElement.cells</code>，所以小区是TH还是TD也无关紧要！</p><p id="4fed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来我们做我们的排序。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="88e1" class="ne lu it lr b gy nf ng l nh ni">sortList.sort(callback);</span></pre><p id="8e5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后使用与Bobby Jack的原始文章相同的<code class="fe lo lp lq lr b">Node.appendChild</code>方法插入我们排序的单元格，但是使用我在遍历数组和其他迭代时使用的“赋值求值”技术，我知道没有有效值是loose false。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="6dc1" class="ne lu it lr b gy nf ng l nh ni">for (var i = 0; e = sortList[i]; i++) tbody.appendChild(e.tr);</span></pre><p id="9723" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嘣，干活的那种。</p><h1 id="de82" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">一些CSS来显示排序控件</h1><p id="9845" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">当我们给<code class="fe lo lp lq lr b">&lt;button&gt;</code>标签赋值时，我们可以通过属性选择器在CSS中使用该值来显示我们的排序状态。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="b321" class="ne lu it lr b gy nf ng l nh ni">th[data-tablesort] button[value="1"]:after {<br/> content:"\25BC";<br/>}</span><span id="21c3" class="ne lu it lr b gy nj ng l nh ni">th[data-tablesort] button[value="0"]:after {<br/> content:"\25B2";<br/>}</span></pre><p id="3e35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加这些内容可以改变标题的宽度，这会使布局“跳跃”一点。我对此的解决方案是固定生成内容的宽度，然后填充相同宽度的另一边。</p><pre class="mw mx my mz gt na lr nb nc aw nd bi"><span id="aa48" class="ne lu it lr b gy nf ng l nh ni">th[data-tablesort] button {<br/>  padding:0 0 0 1.2em;<br/>  font-weight:bold;<br/>  font-family:inherit;<br/>  font-size:1em;<br/>  text-decoration:underline;<br/>  border:none;<br/>  background:transparent;<br/>  color:inherit;<br/>  cursor:pointer;<br/>}</span><span id="b0c4" class="ne lu it lr b gy nj ng l nh ni">th[data-tablesort] button:after {<br/> display:inline-block;<br/> width:1.2em;<br/> text-align:right;<br/> content:"";<br/>}</span></pre><p id="5110" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在非价值目标上使用内容确保了这个“空间”被显示。请注意，我去掉了大部分样式，使它看起来更像一个锚而不是一个按钮。</p><p id="e7c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这在左对齐的列上看起来“不合适”,一个简单的方法是简单地从按钮上移除左填充。对于右对齐，删除填充，然后使用:before而不是:after。</p><h1 id="a11e" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">现场演示</h1><div class="ok ol gp gr om on"><a href="https://cutcodedown.com/for_others/medium_articles/tableSort/simple/tableSort.html" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">用JavaScript实现简单的表格排序</h2><div class="ou l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">cutcodedown.com</p></div></div></div></a></div><p id="817c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如同我所有的例子目录:<br/><a class="ae kz" href="https://cutcodedown.com/for_others/medium_articles/tableSort/simple/" rel="noopener ugc nofollow" target="_blank">https://cutcodedown . com/for _ others/medium _ articles/table sort/simple/</a></p><p id="db4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是敞开的，可以很容易地接触到黏糊糊的东西，我还把整本书的一部分扔了进去。</p><p id="f74c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于那些喜欢钢笔的人来说:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h1 id="037f" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="ffe8" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">遍历DOM，利用现有的结构，如“cells”array-like和“cellIndex”属性，并将操作组织为对象方法，可以在减少完成某项工作所需的代码量、加快执行时间以及创建整体更好的代码库方面创造奇迹。</p><h1 id="f3c7" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">更进一步</h1><p id="8f1d" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated"><a class="ae kz" href="https://deathshadow.medium.com/javascript-table-sorting-part-2-of-2-enhancement-18fe607842b6" rel="noopener">请务必查看本文的第2部分</a>，在那里我实现了:</p><ol class=""><li id="e474" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">检测“日期”字段是否使用了<code class="fe lo lp lq lr b">&lt;time&gt;</code>标签，如果它有一个<code class="fe lo lp lq lr b">datetime</code>属性，就用它来代替<code class="fe lo lp lq lr b">textContent</code>。如果<code class="fe lo lp lq lr b">&lt;time&gt;</code>存在而没有<code class="fe lo lp lq lr b">datetime</code>，则使用<code class="fe lo lp lq lr b">&lt;time&gt;</code>的<code class="fe lo lp lq lr b">textcontent</code>，而不是整个表格单元。</li><li id="a2f5" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">支持从单元格内的<code class="fe lo lp lq lr b">&lt;input&gt;</code>、<code class="fe lo lp lq lr b">&lt;select&gt;</code>和<code class="fe lo lp lq lr b">&lt;textarea&gt;</code>获取数值或字符串值。</li><li id="bb9e" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">为TH添加一个<code class="fe lo lp lq lr b">data-tablesort-rxmatch</code>参数，这将让我们声明在排序之前对每个表格单元格的内容执行的正则表达式。</li><li id="1b60" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">检测一个<code class="fe lo lp lq lr b">&lt;caption data-tablesort-reset&gt;</code>是否存在，如果存在，给它添加一个<code class="fe lo lp lq lr b">&lt;button&gt;</code>来恢复原来的排序顺序。</li></ol><p id="9947" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这应该使它成为一个非常健壮和强大的普通JavaScript表排序。</p></div></div>    
</body>
</html>