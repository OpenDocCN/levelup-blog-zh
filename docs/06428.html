<html>
<head>
<title>Local Testing AWS Applications at No Cost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">免费本地测试AWS应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/local-testing-aws-applications-at-no-cost-c0bdd009d1d0?source=collection_archive---------2-----------------------#2020-11-24">https://levelup.gitconnected.com/local-testing-aws-applications-at-no-cost-c0bdd009d1d0?source=collection_archive---------2-----------------------#2020-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/46f3aac8bad4b87edea117985f06c565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWEwLgsr0VGUUoOBDHxuAw.png"/></div></div></figure><p id="0112" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AWS在所有云平台中一直如此受欢迎。正如所有平台的本质一样，在AWS上开发应用程序有许多挑战，比如部署、缺乏知识、调试，当然还有成本管理。为了减少和防止这些缺点，在部署到云之前，可以尝试一些有益的工具。LocalStack和AWS SAM是在本地进行测试的优秀工具。</p><p id="c829" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> LocalStack </strong>是一个开源框架，模仿了几个AWS云服务，并在本地提供了一个测试环境。更多细节可以看<a class="ae kw" href="https://localstack.cloud/" rel="noopener ugc nofollow" target="_blank">网页</a>和<a class="ae kw" href="https://github.com/localstack/localstack" rel="noopener ugc nofollow" target="_blank"> Github回购</a>。</p><p id="fee6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我设计了一个名为<em class="kx"> discount-spotter </em>的全无服务器审计项目，它只需抓取一个URL，如果价格低于阈值就发送通知。该项目基本上需要AWS服务，例如用于审计者的<a class="ae kw" href="https://aws.amazon.com/eventbridge/" rel="noopener ugc nofollow" target="_blank"> EventBridge </a>，用于数据转换的<a class="ae kw" href="https://aws.amazon.com/lambda" rel="noopener ugc nofollow" target="_blank"> Lambda </a>，用于消息队列的<a class="ae kw" href="https://aws.amazon.com/sqs" rel="noopener ugc nofollow" target="_blank"> SQS </a>，以及用于通知的<a class="ae kw" href="https://aws.amazon.com/sns" rel="noopener ugc nofollow" target="_blank"> SNS </a>。对于URL抓取步骤，我设置了5000的门槛，并在土耳其最大的电子商务公司Trendyol上选择了智能手机。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ky"><img src="../Images/08638dff7e8babc6318c56fc575ecb13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXELwtz95R5v3KDipXSHCA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">样本AWS项目的云基础设施</figcaption></figure><p id="581f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个λ<code class="fe lh li lj lk b">lambda_Url_Validator</code>是为了一般用途而添加的。它只从自己的环境变量中获取一个URL。如果您有几个URL需要审计折扣，您可以使用AWS提供的许多数据库服务中的一个，如<a class="ae kw" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> DynamoDB </em> </a>、<a class="ae kw" href="https://aws.amazon.com/rds/" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> RDS </em> </a>和<a class="ae kw" href="https://aws.amazon.com/rds/aurora" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> Aurora </em> </a>(不在自由层)。然后，您可以从数据库中获取URL，而不是从lambda环境变量中获取。</p><h1 id="95b9" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">运行LocalStack</h1><p id="575b" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">可以使用python和docker安装LocalStack。我更喜欢通过docker安装的方式。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/d2938d7efd136c1d96a4881cb5350ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95HXcrXa6yhVp1SsAmMIbA.png"/></div></div></figure><p id="2053" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以前，LocalStack为每个服务开放不同的端口，但现在它只在一个端口上运行，<em class="kx"> 4566 </em>。因此，您可能会在其他docker-compose文件中看到不同的端口分配。</p><p id="d757" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我所做的更改如下:添加特定的image标签，更改环境变量<em class="kx"> DEFAULT_REGION </em>，<em class="kx"> SERVICES </em>，<em class="kx"> DEBUG </em>，<em class="kx"> LAMBDA_EXECUTER </em>，<em class="kx"> LAMBDA_REMOTE_DOCKER，禁用第一个LocalStack卷</em>。</p><ul class=""><li id="55a7" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated"><strong class="ka ir"><em class="kx">image:local stack/local stack:0 . 12 . 2</em>&gt;</strong>local stack仍在开发中，因此使用不带任何标记的会影响您的本地测试环境。所以你最好用一个图像标签来拥有一个更稳定的系统。</li><li id="bda6" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir"><em class="kx">DEFAULT _ REGION = eu-central-1</em></strong>&gt;为了避免错误的API重定向，我添加了默认区域以防万一。</li><li id="7385" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir"> <em class="kx"> SERVICES=lambda，sqs，sns，events </em> </strong> &gt;保留这个变量不变，将导致所有的模拟服务都将由LocalStack启动。因此，最好指定需要哪些服务。</li><li id="cef9" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir"> <em class="kx"> DEBUG=1 </em> </strong> &gt;设置调试模式为1会让LocalStack详细写调试日志。</li><li id="5a39" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir"><em class="kx">LAMBDA _ EXECUTOR = docker-reuse</em></strong>&gt;该设置使得LocalStack为每个函数创建单独的容器，并重用它们。</li><li id="badf" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir"><em class="kx">LAMBDA _ REMOTE _ DOCKER = false</em></strong>&gt;设置为false，因为我们将使用本地代码进行LAMBDA调用。</li><li id="3c55" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><strong class="ka ir"><em class="kx">$ { TMPDIR:-/tmp/local stack }:/tmp/local stack</em></strong>&gt;我把这个卷去掉了。LocalStack存储每次执行出现的自己的数据。所以旧的数据可能会干扰当前的测试过程。</li></ul><p id="d8bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行完<code class="fe lh li lj lk b">docker-compose up</code>命令后，我们应该等待LocalStack让所有服务准备好。一旦信号<code class="fe lh li lj lk b">Ready</code>发出，我们就可以开始部署了。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/8447bee828c88bf222f98f32260a7fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEruQkB7ZJL1kxZj1-HT6g.png"/></div></div></figure><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/2c684d9cfcddd8cf0328b99d31ca7572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArZQW9CUt9ctBAzNdhLJ8g.png"/></div></div></figure><p id="c1b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时延迟可能会在初始化期间出现，因此我们应该手动检查我们启动的服务的状态。</p><p id="ac4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">LocalStack有一个用于健康检查的端点。简单访问网址；</p><p id="7882" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lh li lj lk b"><a class="ae kw" href="http://localhost:4566/health" rel="noopener ugc nofollow" target="_blank">http://localhost:4566/health</a></code></p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="782e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于部署，还有其他一些工具，如<code class="fe lh li lj lk b"><a class="ae kw" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank">AWS-CLI</a></code>、<code class="fe lh li lj lk b"><a class="ae kw" href="https://aws.amazon.com/serverless/sam/" rel="noopener ugc nofollow" target="_blank">AWS_SAM</a></code>、<code class="fe lh li lj lk b"><a class="ae kw" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">Serverless Framework</a></code>。我现在用的是<code class="fe lh li lj lk b">AWS-CLI</code>。<a class="ae kw" href="https://docs.aws.amazon.com/cli/latest/index.html" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到所有服务的所有CLI命令。在开始测试之前，必须首先应用AWS-CLI配置。只需运行<code class="fe lh li lj lk b">aws configure</code>命令并为凭证提供虚拟值。<em class="kx">区域</em>和<em class="kx">输出</em>值必须合理，分别像<em class="kx"> eu-central-1 </em>和<em class="kx"> json </em>。</p><p id="2f0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们继续进行本地部署时，我们应该将本地服务URL传递给每个CLI命令的参数<code class="fe lh li lj lk b">--endpoint</code>。这就是为什么LocalStack开发了一个名为<code class="fe lh li lj lk b"><a class="ae kw" href="https://github.com/localstack/awscli-local" rel="noopener ugc nofollow" target="_blank">awscli-local</a></code>的CLI包装器，可以自动为所有服务设置端点URL。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/0386049b7dea72550cdbb60317fe4b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKTz3CdnYnP3Cpisd0ojqA.png"/></div></div></figure><p id="a4db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有两个用于部署的shell脚本；<code class="fe lh li lj lk b">1_Create_SQS_SNS.sh</code>和<code class="fe lh li lj lk b">2_Create_lambdas.sh</code>如果来自bash的终端不同，您可能需要给予shell脚本文件执行权限。<code class="fe lh li lj lk b">chmod +x ./*.sh</code></p><p id="7d77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi nn translated"><span class="l no np nq bm nr ns nt nu nv di">1</span><strong class="ka ir">_ Create _ SQS _ SNS . sh</strong>&gt;这个文件包含的shell脚本简单地创建了两个SQS队列，<em class="kx"> sqs_queue_scrape </em>、<em class="kx"> sqs_queue_notify </em>和一个SNS主题<em class="kx"> sns_topic_price </em>。SNS中的电子邮件协议尚未开发，如这里的<a class="ae kw" href="https://github.com/localstack/localstack/blob/2f1c5d71f539fddd1f6db1f6e133ea957a55d45b/localstack/services/sns/sns_listener.py#L272" rel="noopener ugc nofollow" target="_blank">所示</a>。这就是为什么我会用一个虚拟手机订阅SNS主题，以短信的形式获得通知。Tough <a class="ae kw" href="https://aws.amazon.com/ses/" rel="noopener ugc nofollow" target="_blank"> AWS SES </a>是LocalStack中涉及的另一个选项。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/f36a47411d23edb2c3b94f4f1ddc49cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrZ5FD-WjV-e6UDC6iSsjA.png"/></div></div></figure><p id="a71e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi nn translated"><span class="l no np nq bm nr ns nt nu nv di">2</span><strong class="ka ir">_ Create _ lambdas . sh</strong>&gt;这个文件包含了简单创建三个lambda函数的shell脚本，<em class="kx"> lambdaUrlValidator </em>、<em class="kx"> lambdaScraper、</em>和<em class="kx">lambdan notifier</em>。由于我们将变量<em class="kx"> LAMBDA_EXECUTOR </em>设置为<em class="kx"> docker-reuse </em>，LocalStack将创建一个单独的容器。为了使lambda容器能够访问其他服务，它必须从其进程中获取主机URL。这就是为什么我们不能简单地在lambda代码中使用URL <code class="fe lh li lj lk b">localhost:4566</code>。必须按如下方式使用本地堆栈主机名:</p><pre class="kz la lb lc gt nx lk ny nz aw oa bi"><span id="52d7" class="ob lm iq lk b gy oc od l oe of">http://${LOCALSTACK_HOSTNAME}:4566/queue/${process.env.queue_name}</span></pre><p id="dce2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不想使用<em class="kx"> LOCALSTACK_HOSTNAME </em>来避免local和prod代码之间特定于环境的变化。这就是为什么我必须解析命令输出来获取主机URL，然后使用环境变量将它传递给lambda函数。功能<code class="fe lh li lj lk b">lambdaScraper</code>的样本创建和设置如下:</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/583706b740f72bee5ad0c7146a530c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDT4QzLDz39GT-5brvcIKA.png"/></div></div></figure><p id="9ddc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要测试和调用lambda函数，只需运行下面的命令。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/036e56afce94db3aaf4b176f918043de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JqiAqSSved3jJzsOGHYmVA.png"/></div></div></figure><p id="f412" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">热交换可用于lambda执行，因为函数代码是从本地目录中取出的。因此您可以更改代码，而无需重启LocalStack容器或重新创建函数。</p><h1 id="e38f" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">添加触发器</h1><p id="4fd5" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">EventBridge有类似于<code class="fe lh li lj lk b">rate</code>和<code class="fe lh li lj lk b">cron</code> job的规则来触发端点。我更喜欢cron设置特定的通知时间，但是您可以根据自己的意愿使用rate job。这个cron表示目标lambda函数将在每天的<code class="fe lh li lj lk b">8:00 AM</code>和<code class="fe lh li lj lk b">20:00 PM</code>被触发</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/7f6fc501a0b2da96c1db8b6480f3380f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hjf7MSbMkAqa7p25T2VFFQ.png"/></div></div></figure><p id="129f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试触发器，我最初将<code class="fe lh li lj lk b">rate</code>设置为<code class="fe lh li lj lk b">1 minutes</code>。因为lambda函数在另一个容器中运行，所以它们的日志比其他服务要晚一些。<code class="fe lh li lj lk b">invalid url</code>和<code class="fe lh li lj lk b">valid url</code>情况的日志如下:</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/aaf6e2f07ee7e68926b4c97a12072cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6IUcOKtwEoKlTipHj5u9g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">无效URL的LocalStack调试日志。</figcaption></figure><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/bf8329882f4b42dcdc5fe0536774608f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrPa2wtSbz3tMhvDQhsuXg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">有效URL的LocalStack调试日志。</figcaption></figure><h1 id="6cd1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">设计选择</h1><p id="1f5b" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我使用SQS来创建事件流，但在AWS云堆栈中还有其他选项，例如<code class="fe lh li lj lk b"><a class="ae kw" href="https://aws.amazon.com/step-functions" rel="noopener ugc nofollow" target="_blank">Step Functions</a></code>如果您有特定于业务的逻辑，您可以组装lambda函数来创建应用程序流。使用阶跃函数可以节省您的SQS收费，并根据域降低成本。当然，这取决于项目领域。</p><p id="5b4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，Lambda函数使用五个并行的长轮询连接来监听SQS，最大等待时间是20秒，如<a class="ae kw" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html#sqs-long-polling" rel="noopener ugc nofollow" target="_blank">开发者指南</a>和<a class="ae kw" href="https://aws.amazon.com/de/blogs/aws/aws-lambda-adds-amazon-simple-queue-service-to-supported-event-sources/" rel="noopener ugc nofollow" target="_blank">博客文章</a>中所述。假设您在AWS免费层，您只能使用一个队列作为事件源映射，而不会被收费。免费层允许您每月免费发送100万个请求。因此，一个队列映射每月将产生大约5 * 3 * 60 * 24 * 30 = 64万个请求。添加第二个映射可能会开始收费。这就是为什么在部署到prod之前在本地测试应用程序有利于减少付费请求的数量。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="5e60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个项目可以在<a class="ae kw" href="https://github.com/ustundag/localstack-demo" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Github repo </strong> </a>上找到一个简单的阶跃函数示例。如前所述，LocalStack仍在开发中，因此您最好继续关注下一个特性，以免受到变化的影响。</p></div></div>    
</body>
</html>