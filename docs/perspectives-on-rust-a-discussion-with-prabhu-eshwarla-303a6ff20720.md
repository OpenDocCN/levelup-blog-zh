# 铁锈透视

> 原文：<https://levelup.gitconnected.com/perspectives-on-rust-a-discussion-with-prabhu-eshwarla-303a6ff20720>

![](img/726ff9eb73f57f887b18a3b387e87775.png)

马泰奥·库图法在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

## 与帕布·埃什瓦拉的讨论

我最近有机会轻松编辑了[曼宁出版社](https://www.manning.com/?a_aid=gitconnected)对[Prabhu eshwara](https://www.linkedin.com/in/prabhu-eshwarla)的采访，他是一位资深软件工程师，正在写一本即将出版的关于用 Rust 构建系统的书。在与其他开发人员的聊天中，Rust 开始突然出现在我的雷达上，我发现这次采访对 Rust 的一些关键概念以及为什么它作为一种新语言越来越受欢迎提供了大量信息。经曼宁许可出版。尽情享受吧！:)

*在曼宁，我们总是有兴趣了解更多作者对抓住他们热情的技术的独特观点。我们采访了 Prabhu Eshwarla，他正在写一本名为《用 Rust 构建服务》的新书，我们了解了内存管理、垃圾收集以及 Rust 如何提供高级和低级编程语言的优势。*

帕布，谢谢你接受我们的采访。今天，我们要深入探究 Rust 编程语言。它越来越受欢迎，我们有几本关于这个主题的书。我们在 liveBook 论坛和从同行评论中收集的反馈中看到，开发人员真的很喜欢用 Rust 编码。他们也倾向于把它归类为低级语言。

的确如此——我认为这是语言的本性使然。

男:什么意思？

嗯，编程语言要么是低级语言，如 C 或 C++，让你管理整个内存层，要么是高级语言，这意味着你可以对内存管理有所了解，但从根本上说，这种语言是为你管理的。自然的结论是，如果语言能够在这个基础层面上发挥作用，它就一定是为了这个目的——而且仅仅是为了这个目的。但事实是，并不一定如此。与其他严格意义上的高级语言或严格意义上的低级语言不同，Rust 具有这两种语言的所有优点。

所以，帕布，我是一个出版商，不是开发商。对我来说，不清楚为什么内存管理是如此重要的考虑因素。内存不便宜吗？

在过去，缩放是垂直的。通常是购买越来越大的服务器。当负载变得很大，应用程序的响应时间变慢时，您可以给 IT 部门打电话，让他们增加服务器的内存。

**男:**但是现在我们有了云。

**体育:**正是。今天，云中的世界是水平可扩展的。您有这些商用服务器，您可以添加更多的服务器，或者为每个服务器添加更多的内核，让每个内核作为单独的虚拟机运行，在每个内核上，您可以并行运行程序——前提是程序以正确的方式编写。

我们通常认为的多线程编程。但是那不是已经失宠了吗？

PE: 是的，因为依靠多线程来实现并发，尽管它可能是高效的，但也引入了许多潜在的问题。

**M:** 可以简单理解吗？

**PE:** 是的。假设一个线程试图访问另一个线程也在使用的数据。这导致了所谓的竞争条件——系统试图同时做两个任务，比如读和写。但是要正确地完成，任务实际上需要按顺序完成。当这种情况发生时，您开始看到一些非常奇怪的结果，并且很难找出哪里出了问题。

对于像 C 这样的低级语言，你必须有意识地确保像竞争条件这样的问题不会发生。但是 Rust 最棒的一点是，它可以防止你编写可能导致竞态条件的代码。

**M:** 预防？它是怎么做到的？

PE: 和所有权挂钩。当一个线程获得一个变量的所有权时，它就完全获得了所有权。其他线程无法访问它。这样，您可以确保同一块内存不会被多个线程同时访问，并且数据不会以不可预知的方式被修改。当然，在某些情况下，您可能希望多个线程使用相同的数据，但是 Rust 也为您提供了安全的方法。

Rust 还避免了线程死锁的另一个方面。为了修改一段数据，线程锁定它供自己使用，并进行修改。在其他语言中，如果您忘记释放锁，它会创建一个死锁，所有其他线程都在等待锁的释放，结果系统可能会挂起。但是在 Rust 中，你没有这个问题。一旦线程锁超出范围，它就会被自动释放，供其他线程使用。

**M:** 所以内存安全和数据安全，那几类问题都是编译器直接排除的？

**PE:** 正是。当我第一次开始了解铁锈时，所有这些都深深吸引了我。当然，我很快意识到，让 Rust 如此强大的许多因素也意味着它确实非常复杂。即使对一个有经验的人来说，要掌握它也需要很大的努力，主要是因为当你开始在 Rust 工作时，如果你愿意，你必须采用一种不同的哲学。

困难不在于语法。这与这样一个事实有关:为了应用 Rust 工具集提供的构造，您几乎必须放弃您一直在做的事情。

**男:**那么，这种努力值得吗？

T4:哦，当然。Rust 带给你简洁、紧凑、低延迟、内存安全和数据竞争安全。所有这些好处通常只与低级语言相关。它还为您提供了高水平的生产力、函数式编程结构，甚至是编写高级框架的能力，使您可以非常快速地创建宏之类的东西，因此您不必编写样板代码。可以生成大量代码。

**M:** 什么叫可以生成？它有代码生成工具？

**PE:** 对！为此有两种工具。一种叫做宏，它让你写一行语句，然后编译器会在编译时把它扩展成一整套 Rust 代码，并把它编译成二进制文件。开发人员所要做的就是编写一行宏结构。

代码生成的第二层是所谓的泛型。

男:那就是说…？

嗯，通常每个变量的类型都是预先确定的。你必须在声明的时候指定类型。你说它是一个整数或者是一个字符串或者是别的什么。但是泛型的概念解决了这个问题，有时你不知道变量的类型是什么。结果是，你必须编写程序来适应多种变量类型。

例如，如果我有一个 ID 字段，我可能不知道该值是整数还是字符串。这意味着我必须编写两次代码来处理这两种潜在的类型。另一方面，如果语言支持泛型，我可以写代码说明值可以是整数也可以是字符串。通过只编写一段代码，我可以重用我的代码，而不会影响性能。Rust 生成的代码就像你自己为每一种可能的不同类型编写代码一样有效。Rust 支持编译时泛型(简称泛型)和运行时泛型(称为 trait 对象)

M:这样你就能获得更高的生产率。

**PE:** 正确。您可以使用这些结构来快速完成工作。Rust 不是唯一拥有泛型和宏支持的语言。关键是，所有这些东西的结合使它走到了一起。语言设计者投入了大量的精力来平衡系统编程和开发人员的生产力。我认为对于程序员来说，这是一种非常令人愉快的语言，同时它给了你很多控制权。

**M:** 回到内存控制的问题:难道我们没有内存充足的服务器吗？我们可以并行运行，对吧，所以本质上我们不是有我们需要的那么多内存吗？为什么开发者还需要手动控制内存？

**PE:** 手动控制内存有两个原因。第一个原因是防止内存膨胀。比方说，你分配了内存，然后你忘了取消分配。例如，如果您运行一个 Unix 系统工具，您可能会看到该工具占用了 20 兆字节的内存。但是，随着该工具长时间运行，您将开始看到，几天或几周后，内存消耗慢慢地从 20 兆字节增加到 25 兆字节，然后增加到 30 兆字节等等。正在发生内存泄漏，这会降低系统的处理速度。

M: 但这不就是垃圾收集处理的吗？

是的，但是垃圾收集是有成本的:你不知道垃圾会在哪个时间点被收集。我是说，这个垃圾收集器到底是做什么的？基本上就是清道夫。在某些时候，它只会说“嘿，伙计们，停止一切。”如果有请求传入服务器，垃圾收集器会说“嘿，不，在我清理的时候，你必须阻止它们。”这就像当你的公司有清洁服务，他们在洗手间外面挂了一个牌子，上面写着“暂停服务”，这个洗手间正在被清洁。即使你碰巧有急事要去洗手间，对不起，你也要等一等。

**男:**哈哈。很好的例子。

**PE:** 对吧？最棒的是他们不会告诉你他们什么时候打扫。这不是预先安排的维护。在任何时候，他们可能会决定进来打扫卫生，收集垃圾，然后你就停下来。在这宝贵的几毫秒时间里，你要等待——这几毫秒可以决定错过一个即将到来的事务还是成功处理它。

M: 好的，我们能回到 Rust 是如何做的吗，与你手动做的相比？随着时间的推移，任何进程中内存的使用量，即您保存在内存中的数据量都会增加。当您手动进行清理时，如何进行清理或限制使用的内存量？你对此有什么看法？

所以 Rust 处理这个问题的方式是使用一个叫做 scope 的东西。对于程序中的每个变量，都有作用域。例如，假设我有一些花括号内的代码。我在花括号中声明了一个变量。代码执行超出花括号的那一刻，变量就超出了范围。这叫做作用域——大多数语言都是这样工作的。

Rust 的做法是，每当变量值超出范围时，它会自动运行一个叫做“析构函数”或“删除”代码的东西。Rust 允许你定制当一个值超出范围时会发生什么，你可以说如果这个类型超出范围就释放它的资源。所以基本上它会去释放内存。如果内存被分配在堆栈上，它将从堆栈中移除它；如果它在堆上，它将移除指针并移除堆上存储的实际内存。当变量超出范围时，所有的清理都自动发生。所有这些都可以嵌入到二进制文件中，所以在编译时你告诉编译器，“生成这段代码，这样你就不会有运行时问题了。”重点是将内存清理的问题从运行时转移到编译时。铁锈就是这样解决问题的。编译器只是使用预定义的规则来编写代码，为您动态处理释放，这样您就不会忘记处理它。就这么简单。

**M:** 我不知道栈和堆是什么，但是我们没时间让你教我。不过，我想知道 Rust 做这件事的方式和垃圾收集器做这件事的方式有什么不同？

**PE:** 垃圾收集器不查看作用域，它只查看某个时间点的进程。例如，内存中可能有很多对象。垃圾收集器主要检查是否有对给定对象的引用，是否有人仍在使用它。如果没有人使用它，那么垃圾收集会删除它。

M: 对于 Rust 来说，这就像是低级别的垃圾收集。你在清理自己的垃圾——而不是把它留在外面让拾荒者去捡，你只是在完成后马上清理。这就像是我妻子处理厨房和我处理厨房的区别。她比我快多了，但我边走边收拾。

**PE:** 正是。这是一个恰当的类比。

**M:** 好吧，但是难道没有哪种内存泄漏可以潜在地激增，也就是说，并且非常快速地产生大量垃圾吗？就像，你犯了一个错误，突然你的厨房堆满了垃圾。您所描述的这种手动内存管理本质上是否完全避免了这些情况，因此您永远不会遇到大规模的垃圾事件？

编程中最流行的两个内存相关问题是内存安全和内存泄漏。Rust 使得编写泄漏内存的代码变得困难，甚至不可能。例如，从理论上讲，可以编写一些奇特的代码，比如循环共享引用，它不会释放内存，编译器也无法检测到这种情况，但这些都是边缘情况。当谈到内存安全时，不允许对像悬空指针或双释放这样的损坏的内存进行操作，Rust 闪耀着光芒。

你能解释一下吗？

**PE:** 这都归结于栈和堆的区别。

男:(默默:又来了。)

**PE:** 本质上有两种类型的变量:整数、字符之类的原始数据类型，向量、hashmaps 之类的引用数据类型。

原始数据类型从来都不是问题，因为它们总是存储在堆栈中，因为编译器事先就知道它们的大小。堆栈是后进先出的。当一件事情完成后，堆栈抛出最后一个变量，并执行下一个变量。在堆上分配内存时会出现问题。堆是动态内存，它是在运行时分配的。

假设你要主持一个电话会议。如果您事先知道只有四个人会加入，您可以编写代码为四个人静态分配空间，然后您就知道没有内存泄漏。但是如果你不知道有多少人要加入呢？然后，一切都必须动态地发生——每当有新的人加入呼叫时，代码都必须动态地分配更多的内存。这就是问题变得复杂的地方。假设有 100 个人加入了呼叫，我为每个人分配了内存。如果我忘记释放内存会发生什么？这些都是 Rust 让你变得容易的事情。你不必记得打扫卫生。它会为你做的。

**M:** 那么，在这个例子中，自动取消分配是如何发生的呢？

PE: 好吧，假设有一百个人加入了电话会议。通常，每个值都有一个与之相关联的特定范围。一旦控件超出了这个范围，例如，当控件从被调用的函数中返回时，Rust 就会添加一段代码，告诉它释放所有与之相关的内存。你需要程序员方面的额外努力来计划这些事情，但是一旦你做了计划并告诉 Rust，事情就是这样，Rust 将生成额外的代码来为你清理系统。

M: 所以，根据你的例子，这并不意味着你可以编写一个程序来接受无限数量的调用者，对吗？是吗？

**PE:** 是也不是，通常情况下，你会为事物指定一个假设的上限，但世界上的情况实在太多了。例如，你能猜出在某一天你的时间线上会出现多少条推文吗？你无法预先预测这些事情，所以你需要寻找灵活性。但是它受到系统中可用内存量的限制。这就是人们监控内存使用的原因:仅仅写代码是不够的。你继续监控你的程序，你说，“我需要实现负载平衡。我不会让一台服务器处理所有的请求；相反，我将向这台服务器发送一些请求，向另一台服务器发送一些请求。

**M:** 现在，你的书将是关于使用 Rust 的系统开发，也是关于应用程序开发，对吗？

**PE:** 你知道，我真的想强调一下你在对话开始时提出的观点:任何对 Rust 稍有了解的人都会很自然地认为，因为你处理的是非常低级的内存管理——线程管理、并发性等等——所以它更适合系统编程。从长远来看，也许我们真的可以考虑用 Rust 取代 C++。这似乎是业界的想法，很多工作都是在这样的想法下完成的。

但大多数人似乎不知道的是，将其作为高级语言之一的替代品同样有效。尽管 Rust 没有垃圾收集器，但由于其独特的所有权模型，它可以为您提供 Java 和 Python 等语言所期望的许多高级功能。

我认为库和框架发展非常迅速是一个保守得很好的秘密。一两年前，我不可能考虑写一本书，因为 Rust 仍然非常非常不成熟。整个异步特性，作为语言固有的一部分，只是在几个月前才出现。因此，事情开始变得有趣多了。此外，一些与之相关的最佳框架现在已经成熟或经历了多次迭代。所以我认为是时候向世界展示铁锈的威力了。

谢谢你的谈话，帕布！真的很有启发性。祝你写作好运——这将会是一本很棒的书。

[*Prabhu eshwara*](https://www.linkedin.com/in/prabhu-eshwarla)*是一名资深 IT 专业人士，在软件工程和服务行业拥有超过 26 年的从业经验。他目前运营 SudhanvaTech，这是一家专注于开发分布式系统软件和云原生应用的公司，他在这里专业地使用 Rust，并热衷于帮助他人学习使用它。他的书将于 2021 年春季发行。*

访问 Manning.com，了解这些相关的书籍和视频

*   [**锈在行动**](https://www.manning.com/books/rust-in-action?a_aid=gitconnected)
*   [**运动中生锈**](https://www.manning.com/livevideo/rust-in-motion?a_aid=gitconnected)
*   [**C++并发在行动中**](https://www.manning.com/books/c-plus-plus-concurrency-in-action?a_aid=gitconnected)
*   [**c++中的函数式编程**](https://www.manning.com/books/functional-programming-in-c-plus-plus?a_aid=gitconnected)