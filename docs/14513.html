<html>
<head>
<title>Some Linux Commands That Can Boost Your Work Efficiency Dramatically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一些Linux命令可以显著提高你的工作效率</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/some-linux-commands-that-can-boost-your-work-efficiency-dramatically-9dc802a10618?source=collection_archive---------0-----------------------#2022-12-04">https://levelup.gitconnected.com/some-linux-commands-that-can-boost-your-work-efficiency-dramatically-9dc802a10618?source=collection_archive---------0-----------------------#2022-12-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e44e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从实际例子中学习一些方便和高级的Linux命令</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b157b758826cc41ae2d8c5834d4c63cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jamI-nfmp62PdWZh"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/4Mw7nkQDByk" rel="noopener ugc nofollow" target="_blank">加布里埃尔·海因策在Unsplash拍摄的图片</a></figcaption></figure><p id="718f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名软件开发人员，Linux命令是必备的技能。尽管您可能使用Windows或macOS，但您总会发现需要Linux命令的场合。例如，大多数Docker映像都是基于Linux系统的。你需要擅长Linux，至少一些常用命令，才能进行DevOps的工作。</p><p id="1808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我将介绍一些我每天都会用到的命令。如果您是Linux新手，或者如果您想更新或提高Linux命令的知识，这篇文章会很有帮助。然而，这篇文章不会关注像<code class="fe lv lw lx ly b">cd</code>或<code class="fe lv lw lx ly b">ls</code>这样非常基础的东西，而是一些从实践中学到的更高级的东西。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="5f2c" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">自定义bash提示符</h2><p id="f59b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">好吧，这个话题本身就是一篇冗长的文章。然而，我们不需要什么都学。在大多数情况下，我们只需要改变<code class="fe lv lw lx ly b">PS1</code>变量，它指定了每个命令之前显示的内容。如果不改的话，它会在提示里显示路径，这在我们深入一个文件夹的时候非常不方便。我更喜欢在提示符下只显示用户名和当前文件夹，可以用以下命令设置:</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="583e" class="ni mh it ly b be nj nk l nl nm">export PS1="[\u@\W]\$"</span></pre><p id="c11f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里<code class="fe lv lw lx ly b">\u</code>代表当前用户名，<code class="fe lv lw lx ly b">\W</code>代表当前工作目录。<code class="fe lv lw lx ly b">[</code>、<code class="fe lv lw lx ly b">]</code>和<code class="fe lv lw lx ly b">@</code>按原样显示。对于<code class="fe lv lw lx ly b">\$</code>，如果当前用户不是root，则显示<code class="fe lv lw lx ly b">$</code>，否则显示<code class="fe lv lw lx ly b">#</code>。更多代码可在<a class="ae ky" href="https://www.cyberciti.biz/tips/howto-linux-unix-bash-shell-setup-prompt.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="b99c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果您想保持更改，该命令和下面显示的命令应添加到<code class="fe lv lw lx ly b">~/.bashrc</code>。如果你对<code class="fe lv lw lx ly b">~/.bashrc</code>和<code class="fe lv lw lx ly b">~/.bash_profile</code>、<a class="ae ky" href="https://superuser.com/questions/183870/difference-between-bashrc-and-bash-profile" rel="noopener ugc nofollow" target="_blank">感到好奇，这个</a>是一个很好的线程。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="76e5" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">查找文件或文件夹</h2><p id="8c72" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">查找文件或文件夹是一个非常常见的请求，可以通过<code class="fe lv lw lx ly b">find</code>命令完成:</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="a6a0" class="ni mh it ly b be nj nk l nl nm"># Find a file:<br/>find ~ -type f -name data-model.ts<br/><br/># Find a folder:<br/>find ~ -type d -name angular15</span></pre><p id="bcf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，第一个参数是查找目标文件或文件夹的路径。如果未指定，类型默认为文件。</p><p id="0169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这似乎有点太简单了😏。让我们做一些更复杂的事情。让我们找到一些文件，并计算每个文件的行数:</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="dcf9" class="ni mh it ly b be nj nk l nl nm"># Find all the .html files and count the number of lines for each file:<br/>find src/app/ -name "*.html" -exec wc -l {} \;</span></pre><p id="f9e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意这里的<em class="nn">魔法</em>语法。<code class="fe lv lw lx ly b">-exec</code>为每个找到的文件指定一个运行的命令。花括号<code class="fe lv lw lx ly b">{}</code>是找到的文件的占位符，转义分号<code class="fe lv lw lx ly b">\;</code>用于防止shell解释命令。为此，我们也可以使用加号<code class="fe lv lw lx ly b">+</code>:</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="b43a" class="ni mh it ly b be nj nk l nl nm">find src/app/ -name "*.html" -exec wc -l {} +</span></pre><p id="97ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出会略有不同。如果命令以<code class="fe lv lw lx ly b">+</code>结束，总数将被打印出来。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="9f06" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">更改文件和文件夹的权限</h2><p id="2cd2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">更改文件/文件夹权限也是一项常见任务。我们很容易与许可代码混淆。<a class="ae ky" href="https://www.multacom.com/faq/password_protection/file_permissions.htm" rel="noopener ugc nofollow" target="_blank">这篇文章</a>很好地解释了许可代码和不同的组合。这里我们将只展示最常见的几种:</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="d8ac" class="ni mh it ly b be nj nk l nl nm"># Share a folder with others so they can check the contents in the folder:<br/>chmod 755 &lt;path-to-your-folder&gt;<br/><br/># Share a non-executable file with others:<br/>chmod 644 &lt;path-to-your-file&gt;<br/><br/># Share an executable file with others:<br/>chmod 755 &lt;path-to-your-file&gt;<br/><br/># Make a file read only:<br/>chmod 400 &lt;path-to-your-file&gt;<br/><br/># Make a file executable:<br/>chmod +x &lt;path-to-your-file&gt;</span></pre><p id="3378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">建议检查<a class="ae ky" href="https://www.multacom.com/faq/password_protection/file_permissions.htm" rel="noopener ugc nofollow" target="_blank">该位置</a> t的代码含义，此处不再赘述。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="ecef" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">自定义<code class="fe lv lw lx ly b">rm</code>将文件移至垃圾桶</h2><p id="c5cd" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果您不小心删除了Linux系统上的一些文件，恢复它们将非常困难。因此，设置<code class="fe lv lw lx ly b">rm</code>命令将文件或文件夹移动到垃圾箱而不是删除它们是一个安全的策略。我们可以在以后需要的时候倒垃圾。</p><p id="1c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种定制可以通过别名来完成，别名在Linux上是一个非常方便的工具(稍后将详细介绍):</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="56ef" class="ni mh it ly b be nj nk l nl nm">alias rm='gio trash'</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="835a" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">使用别名来节省一些打字</h2><p id="7180" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果您有一个带有许多参数的长命令，或者如果您有应该一起执行的链式命令，使用别名非常方便:</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="5061" class="ni mh it ly b be nj nk l nl nm"># Set aliases for long commands:<br/>alias dc="docker compose"<br/>alias prettier="npx prettier -w"<br/>alias eslint="npx eslint --fix"<br/>alias pre="pre-commit run --files"<br/><br/># Chain some commands together:<br/>alias update-container="docker-compose pull &lt;service-name&gt; &amp;&amp; docker-compose stop &lt;service-name&gt; &amp;&amp; yes | docker-compose rm &lt;service-name&gt; &amp;&amp; docker-compose up -d &lt;service-name&gt;"</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="cdbd" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">用<code class="fe lv lw lx ly b">awk</code>从输入中提取数据</h2><p id="17fe" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><code class="fe lv lw lx ly b">awk</code>是Linux中非常强大的工具。您甚至可以用<code class="fe lv lw lx ly b">awk</code>编写脚本，尽管可读性和维护性的问题是另一回事。作为软件开发人员，我们通常使用<code class="fe lv lw lx ly b">awk</code>从输入文件或之前命令的输出中获取我们需要的字段。</p><p id="b540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们<em class="nn">ping</em>google.com，并获得每次ping的时间:</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="57fc" class="ni mh it ly b be nj nk l nl nm">ping google.com -c 2 | grep -iE 'time=.*ms' | awk 'BEGIN {FS="="} {print $NF}'</span></pre><p id="f9f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此命令的重要注意事项:</p><ul class=""><li id="a635" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">我们使用<code class="fe lv lw lx ly b">-iE</code>为<code class="fe lv lw lx ly b">grep</code>指定一个正则表达式，因此只有与模式匹配的消息才会被进一步处理。</li><li id="b263" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">对于<code class="fe lv lw lx ly b">awk</code>，<code class="fe lv lw lx ly b">BEGIN</code>表示在处理文本之前要执行的命令。这里，我们指定字段分隔符(<code class="fe lv lw lx ly b">FS</code>)应该是等号。此外，<code class="fe lv lw lx ly b">NF</code>代表字段的数量，<code class="fe lv lw lx ly b">$NF</code>将返回最后一个字段。<a class="ae ky" href="https://www.howtogeek.com/562941/how-to-use-the-awk-command-on-linux/" rel="noopener ugc nofollow" target="_blank">这个</a>是<code class="fe lv lw lx ly b">awk</code>很好的参考，如果你想了解更多的话。</li></ul><p id="7735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述命令也可以简化如下:</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="5c6f" class="ni mh it ly b be nj nk l nl nm">ping google.com -c 2 | grep -iE 'time=.*ms' | awk -F"=" '{print $NF}'<br/>ping google.com -c 2 | awk -F"=" '/time=.*ms/ {print $NF}'</span></pre><p id="d5ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些简化版本中，我们利用了<code class="fe lv lw lx ly b">awk</code>的另外两个特性:</p><ul class=""><li id="bf39" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">可通过<code class="fe lv lw lx ly b">-F</code>选项直接指定字段分隔符。</li><li id="0cee" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">正则表达式模式也可以在花括号前的<code class="fe lv lw lx ly b">awk</code>中指定。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="4b8c" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">用xargs链接命令</h2><p id="a873" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们已经展示了<code class="fe lv lw lx ly b">-exec</code>选项可以用来链接<code class="fe lv lw lx ly b">find</code>命令的命令。一个更好的工具是<code class="fe lv lw lx ly b">xargs</code>，它可以用来以更灵活的方式链接任何命令。</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="ddf2" class="ni mh it ly b be nj nk l nl nm"># Check the size of each file in the current folder:<br/>ls | xargs -I % du -sh %<br/><br/># Find some files and copy them to a new location:<br/>find ~/Downloads/ -name "*.jpeg" | xargs -I {} cp {} ~/Pictures/<br/><br/># Change the permissions of all folders and subfolders to 755:<br/>find . -type d | xargs -I {} chmod 755 {}<br/><br/># Change the permissions of all files in the current folder and subfolders to 644:<br/>find . -type f | xargs -I {} chmod 644 {}</span></pre><p id="0721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，<code class="fe lv lw lx ly b">-I</code>选项指定了一个可以在任何需要的地方使用的占位符。占位符可以是任何有效的字符串，其中最常见的是<code class="fe lv lw lx ly b">%</code>和<code class="fe lv lw lx ly b">{}</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="502c" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">为脚本传递变量</h2><p id="49c6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">有时我们需要为脚本传递一些变量。这些变量可以在命令运行脚本之前在命令行上指定。例如:</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="5f69" class="ni mh it ly b be nj nk l nl nm"># some_script.sh<br/>echo mysql -u ${USERNAME} -p${PASSWORD}<br/><br/># On the command line:<br/>USERNAME=johndoe PASSWORD=12345 bash some_script.sh</span></pre><p id="1f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于在一些云环境中运行的一些脚本来说尤其重要，比如<a class="ae ky" href="https://lynn-kwong.medium.com/build-a-docker-image-with-cloud-build-in-google-cloud-platform-5f6840af2c05" rel="noopener"> Cloud Build </a>中可以自动注入变量。</p><p id="0e86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个脚本需要很多变量，那么在命令行中指定所有变量就变得很麻烦。在这种情况下，它们可以存储在一个文件中，并在运行脚本时获取:</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="fb79" class="ni mh it ly b be nj nk l nl nm"># variables.env<br/>USERNAME=johndoe<br/>PASSWORD=12345<br/><br/># On the command line:<br/>env $(grep -v '^#' variables.env | xargs) bash some_script.sh</span></pre><p id="ed5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，使用该命令，变量从目标文件中读取(不包括注释),并使用<code class="fe lv lw lx ly b">xargs</code>命令执行。<code class="fe lv lw lx ly b">env</code>命令用于在修改后的环境中运行脚本，而不是在当前的shell环境中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="8cbd" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">重定向标准输出和标准错误</h2><p id="7e13" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">命令的输出和错误被写入标准输出(STDOUT)和标准错误(STDERR)。STDOUT和STDERR的文件描述符分别是1和2。默认情况下，STDOUT和STDERR都指向控制台。但是，我们可以将它们重定向到一个文件或void (/ <code class="fe lv lw lx ly b">dev/null</code>)来丢弃它们。</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="6f24" class="ni mh it ly b be nj nk l nl nm"># Let's assume existing.txt exists, whereas non-existing.txt does not.<br/><br/># Redirect STDOUT to a file. This is the most common use case.<br/>ls -al existing.txt 1&gt;out.log<br/># The file descriptor for STDOUT is optional.<br/>ls -al existing.txt &gt;out.log<br/><br/># Redirect STDOUT to a file and STDOUT to another file.<br/>ls -al existing.txt non-existing.txt 1&gt;out.log 2&gt;error.log<br/><br/># Rdirect both STDOUT and STDERR to the same file:<br/>ls -al existing.txt non-existing.txt 1&gt;combined.log 2&gt;&amp;1<br/># And it can be simplified as:<br/>ls -al existing.txt non-existing.txt &amp;&gt;combined.log<br/><br/># Ignore the output and error of the command:<br/>ls -al existing.txt non-existing.txt 1&gt;/dev/null 2&gt;&amp;1<br/>ls -al existing.txt non-existing.txt &amp;&gt;/dev/null</span></pre><p id="3c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，并不是所有的shells都支持<code class="fe lv lw lx ly b">&amp;&gt;</code>语法。它由常用的BASH支持。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="d1af" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">命令行模糊查找器</h2><p id="0ecb" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们可以按下<strong class="lb iu"> CTRL-R </strong>找到我们使用过的历史命令。但是默认情况下，我们输入的时候它只显示一条命令，不方便找到我们想要的那条。</p><p id="7dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，<a class="ae ky" href="https://github.com/junegunn/fzf" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="nn"> fzf </em> </strong> </a>大幅增强了CTRL-R的功能。<em class="nn"> fzf </em>是一个通用命令行模糊查找器，支持历史命令的模糊搜索。最重要的是，它将匹配的命令显示为一个列表，这使得找到我们想要的命令变得非常方便:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/a38415a8386a689c2db5de6e256c8ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*066OGJ8E2E5zCVhFQsSUqw.png"/></div></div></figure><p id="0c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn"> fzf </em>的<a class="ae ky" href="https://github.com/junegunn/fzf#installation" rel="noopener ugc nofollow" target="_blank">安装</a>非常简单:</p><pre class="kj kk kl km gt ne ly nf bn ng nh bi"><span id="8d85" class="ni mh it ly b be nj nk l nl nm"># Linux:<br/>git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf<br/>~/.fzf/install  # You can accept all the default settings.<br/><br/># MacOS:<br/>brew install fzf<br/>$(brew --prefix)/opt/fzf/install</span></pre><p id="b7d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你以前从未尝试过fzf，绝对值得一试，你会立刻爱上它😍。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="0e4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，介绍了一些方便的Linux命令，如果你还不知道它们，它们可以提高你的效率。不可能在一篇文章中涵盖所有的Linux命令。然而，我们不需要学习所有的东西，通常只需要学习我们工作中真正需要的东西。希望这篇帖子能对你的工作有所帮助。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="14e9" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">相关文章:</h2><ul class=""><li id="935b" class="no np it lb b lc mz lf na li od lm oe lq of lu nt nu nv nw bi translated"><a class="ae ky" href="https://medium.com/geekculture/common-vim-commands-and-operations-that-i-want-to-share-3b7fbc3d7ee9" rel="noopener">学习方便的Vim命令和操作，可以显著提高您的效率</a></li><li id="a04f" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://lynn-kwong.medium.com/build-a-docker-image-with-cloud-build-in-google-cloud-platform-5f6840af2c05" rel="noopener">使用谷歌云平台中的云构建功能自动构建Docker映像</a></li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ca10" class="og mh it bd mi oh oi oj ml ok ol om mo jz on ka mr kc oo kd mu kf op kg mx oq bi translated">分级编码</h1><p id="cde2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="1f67" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="e164" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">📰查看<a class="ae ky" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="0075" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">🔔关注我们:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ky" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="e87e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🚀👉<a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>