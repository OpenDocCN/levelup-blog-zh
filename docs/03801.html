<html>
<head>
<title>Model driven data aggregation for Angular nested forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于角度嵌套形式的模型驱动的数据聚集</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-model-driven-component-data-communication-82737d58c581?source=collection_archive---------10-----------------------#2020-05-27">https://levelup.gitconnected.com/angular-model-driven-component-data-communication-82737d58c581?source=collection_archive---------10-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/630af2f185900384cf63985f7cbcee09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9aEgl5r8syw5eMWWfQOScg.jpeg"/></div></div></figure><div class=""/><p id="ffcb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当你开发angular web应用程序来允许用户向表单输入数据时，你的主要目标将集中在创建表单组，添加一些表单控件，并用数据修补它们，例如使用反应式表单。到目前为止一切顺利。然而，在单独的组件中实现关系数据时，会遇到一些恼人的事实:</p><ul class=""><li id="5f0a" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">表单可能很复杂，数据模型也可能很复杂。这通常会导致嵌套表单。</li><li id="ec1c" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">数据聚合通常是丑陋的，因为它不符合组件的松散耦合；例如，为什么父容器需要知道其子容器的表单控件属性名称来聚集数据？</li><li id="5a27" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">是的，测试。为复杂的大数据编写单元测试真的很痛苦。</li></ul><p id="8228" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文旨在展示一种可能的解决方案，使实现具有可伸缩性、可测试性、类型安全性和可维护性。让我们后退一步，看看这个ER数据模型。</p><figure class="ll lm ln lo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lk"><img src="../Images/ab41e3352820af3c45b35abfd09ddf5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsTiKrJelTykeZ9AqBpj_A.png"/></div></div></figure><p id="5a0f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在典型的用例中，数据模型将作为DTO传输到后端服务。然而，在这一步之前，您必须在前端采取一些预防措施来聚合数据。</p><p id="5edb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于上面显示的ER数据模型，应该首先澄清如何以及在哪里聚集数据的问题。如果为每个图元实现一个单独的角度分量，效果最好。组件之间的关系如下所示。</p><figure class="ll lm ln lo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lp"><img src="../Images/7907100c242c9667660f9c92da3a9ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ciBVZG5t52yk3lzj7BPhg.png"/></div></div></figure><p id="35ae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些组件满足两个重要的方面。首先，他们负责接收数据，也负责共享数据。</p><ul class=""><li id="9d90" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">通信流是双向的:数据由父节点读取，也发送给子节点。</li><li id="bcce" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">数据模型是类型安全的:父容器确切地知道它从子容器获得的数据，而不需要从子容器的表单组中获取数据。</li><li id="1e3a" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">因为主窗体主要用于验证，所以它将作为一个FormArray来实现。子组件将在初始化时集成它们的表单组。</li><li id="917c" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">是的，通过使用NGXS，子数据是有状态的——当没有后端服务交互来持久化数据时也是如此。一旦子窗体被初始化，状态数据就被用来设置窗体控件的值。</li></ul><p id="40d3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下文中，我将包括Angular、NGXS和RxJS来解释一个实际的实现。不幸的是，我不能详细介绍NGXS和RxJS，因为这超出了本文的范围。如果你不熟悉NGXS和RxJS，那么你应该使用你熟悉的库。架构最终还是一样的。</p><h1 id="580a" class="lq lr jb bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">父组件</h1><p id="d0b8" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">让我们首先创建两个组件来演示概念验证。首先，我们将创建主容器，命名为<em class="mt">parent-container . component . ts</em>。</p><figure class="ll lm ln lo gt is"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">父容器.组件. ts</figcaption></figure><ul class=""><li id="b721" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><em class="mt"> addFormGroup </em>将在带有初始化的嵌套表单组的子组件中发出。</li><li id="d385" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><em class="mt"> @SelectSnapshot </em>获取子组件的状态数据，用最后编辑的数据填充嵌套表单。数据(<em class="mt"> addressFormData </em>)将被输入到子组件的<em class="mt"> @Input initialFormData </em>中。</li><li id="c43a" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><em class="mt"> addressFormData </em>中的数据对象只在最初修补嵌套表单时需要。通过发出函数<em class="mt"> updateAddressFormData </em>将嵌套表单的未来更改发送给父组件。</li></ul><p id="c4e1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是父HTML模板:</p><figure class="ll lm ln lo gt is"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">parent-container.component.html</figcaption></figure><h1 id="e1e8" class="lq lr jb bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">子组件</h1><p id="7839" class="pw-post-body-paragraph jy jz jb ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">让我们继续处理子组件<em class="mt">地址。</em></p><figure class="ll lm ln lo gt is"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">地址.组件. ts</figcaption></figure><p id="8e54" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，<em class="mt"> dataChangedTrigger </em>在表单值改变时被调用，数据对象映射在<em class="mt"> formValueChanges </em>中。该函数有双重作用:它触发表单数据对象向父对象的导出，并将其保存在NGXS存储中供以后使用。</p><p id="85f8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有子组件必须实现接口<em class="mt"> DataIOComponent </em>。这定义了子类必须实现的基本功能，以支持基于模型的通信。</p><figure class="ll lm ln lo gt is"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated"><a class="ae na" href="https://gist.github.com/eltonmrk/7b89d3af46aae75ed21ba82621faef7e#file-data-io-component-ts" rel="noopener ugc nofollow" target="_blank"> data-io.component.ts </a></figcaption></figure><p id="1226" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后是数据模型，<em class="mt"> address.dto.ts </em>。</p><figure class="ll lm ln lo gt is"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">address.dto.ts</figcaption></figure><p id="90cc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。主要概念也可以用于其他组件和模型。欢迎你和我分享你的想法、建议或者一句简单的“你好”。</p><p id="791f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">☕️，祝你试用愉快</p></div></div>    
</body>
</html>