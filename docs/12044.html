<html>
<head>
<title>Under the Hood: React vs. Vue vs. Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下:反应vs. Vue vs .苗条</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/under-the-hood-react-vs-vue-vs-svelte-cef44d26c0bc?source=collection_archive---------11-----------------------#2022-05-10">https://levelup.gitconnected.com/under-the-hood-react-vs-vue-vs-svelte-cef44d26c0bc?source=collection_archive---------11-----------------------#2022-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3845" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">前端框架的权衡</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6b9b66ea546603eae710d1f603ddc9b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vdO_W7-tTEF0PHEK"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">艾莉森·伊万塞克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="58a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前端开发中的框架是不断更新变化的。从早年的jQuery到近几年的React、Vue、Svelte。很多开发人员厌倦了不断变化的框架，但事实上，这些框架之间的许多设计理念是相同的。</p><p id="9a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将从引擎盖下揭示它们之间的异同，希望对你有所帮助。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7c45" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">语法差异:</h1><p id="f510" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在jQuery时代，它的大部分框架都是基于字符串模板进行渲染的。例如下划线、baiduTemplate等。</p><p id="dc3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的本质原理很简单，就是用数据填充我们写的模板，最后转换成DOM。但这有一个缺点，就是每次数据更改都需要重新生成，无法重用。</p><p id="6acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现代前端框架中，Vue和Svelte延续了这种模板思想。如果你用过他们，你肯定能说一两种他们提供的<a class="ae ky" href="https://en.wikipedia.org/wiki/Domain-specific_language" rel="noopener ugc nofollow" target="_blank"> DSL </a>。例如Vue中的“v-for”、“v-if”指令等。</p><p id="b170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于框架开发人员来说，这些模板的DSL允许他们在编译时做尽可能多的事情。例如，Vue可以标记在编译时从不改变的静态虚拟DOM。所以在做虚拟DOM的Diff算法时，Vue可以跳过这些静态标签。从而减少CPU计算量，提高性能。</p><p id="08cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像Svelte这样更“激进”的框架严重依赖模板。只要开发者按照其指定的语法编写，就会在编译时将所有模板语法转换成原生DOM操作。因此，它抛弃了庞大的虚拟DOM Diff算法，将所有内容都恢复到原始状态，从而提高了性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/d72c9a20b491def5d8ddbba7c3a475ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8S1YXuyE2OENsqvC"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lautaroandreani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">劳塔罗·安德烈亚尼</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React一直很欣赏JSX。它使用JavaScript来描述DOM，这给我们的开发带来了很大的自由度。但是，对于框架开发人员来说，在编译时可以完成的优化更少。</p><p id="f0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，DSL用得越多，它提供的API就越多越复杂。比如写子组件的时候，React没有对应的API，而Vue提供了slot特性，Svelte提供了4个API，分别是<code class="fe na nb nc nd b">&lt;slot&gt;</code>、<code class="fe na nb nc nd b">$$slots</code>、<code class="fe na nb nc nd b">&lt;slot name="name" &gt;</code>、<code class="fe na nb nc nd b">&lt;slot key={value}&gt;</code>。可以看出，那些DSL较多的框架，编写复杂组件的成本更高，也容易出错。</p><p id="c06c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DSL无疑引入了新概念和新语法。这都给开发者带来了一定的学习成本。但同时，其限制性的语法也给框架带来了更多的可能性。</p><h1 id="0956" class="mc md it bd me mf ne mh mi mj nf ml mm jz ng ka mo kc nh kd mq kf ni kg ms mt bi translated">运行时间差异:</h1><p id="f2dc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">相比React或Vue提供的虚拟DOM，Svelte将模板转换为原生JavaScript操作，因此几乎没有额外的运行时逻辑。所以主要说说React和Vue。</p><p id="9661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vue一直倡导数据可变的理念。早期的Vue@1.x没有使用虚拟DOM而是使用<code class="fe na nb nc nd b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="noopener ugc nofollow" target="_blank">Object.defineProperty()</a></code>对所有数据进行反应式数据绑定。当数据发生变化时，可以通知相应的侦听器，并更改相应的DOM。但是如果数据量非常大，监听器会很多，会极大的消耗CPU操作，占用更多内存。那么就会极大的影响性能。</p><p id="2d71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在Vue@2.x甚至Vue@3.x中加入了虚拟DOM的diff算法，他们把监控的粒度提升到组件级别，把虚拟DOM的Diff限制在组件级别。当组件中的数据改变时，组件的虚拟DOM的Diff任务被添加到任务队列中。并在Vue提供的<a class="ae ky" href="https://vuejs.org/api/general.html#nexttick" rel="noopener ugc nofollow" target="_blank"> nextTick </a>中执行Diff算法。</p><p id="937e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该解决方案在组件级别控制反应式监听器。它极大地减少了侦听器的数量(从而减少了内存消耗和CPU操作)。而且还能准确定位哪个或哪些组件受到当前数据变化的影响，从而有效降低虚拟DOM的比较量级(减少CPU计算)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/5be2e3ea78275931c155c780c6c7b4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MpmJnbL2ct3JTiyT"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@redaquamedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼·米勒</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="14ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React一直倡导不可变数据的理念。每一个数据变化都会触发整个应用级虚拟DOM的差异。如果当前应用程序的虚拟DOM树非常大，那么递归计算整个树的Diff将需要很长时间。所以最近更新的18版本正式采用了纤程架构。这种架构将Diff计算小型化，通过“链表”将计算量分配到浏览器每一帧的空闲时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/9aa8ca852a3e13cada8146edd1b86cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*orvwqNDWOX0gw45J.png"/></div></div></figure><p id="56db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React的解决方案没有减少CPU的计算量，但它很聪明地做到了这一点，而没有牺牲渲染性能。要了解更多细节，你也可以看看我的另一篇文章:</p><div class="nl nm gp gr nn no"><a href="https://betterprogramming.pub/how-does-reacts-interruptible-updates-work-5340bcaadb1a" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">React的可中断更新是如何工作的？</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Vue为什么不用光纤架构？</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">better编程. pub</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ks no"/></div></div></a></div><p id="53fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们需要跟踪状态变化时，React的数据不变性给我们带来了极大的便利。这也使得我们的代码更容易理解和维护。在我看来，Vue的可变性只是为了方便书写。</p><p id="5fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相对于一类强调编译的web框架，比如Svelte，React和Vue都是在运行时加入虚拟DOM。这无疑会增加额外的处理逻辑。但在我看来，虚拟DOM更大的潜力在跨端。就像React-Native一样，它的真实渲染层可以调用相应平台的API进行绘制。</p><p id="060f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你觉得这些框架怎么样？你喜欢哪一个？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="7a98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="od">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="od">中等会员</em> </a> <em class="od">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="od">我的链接</em> </a> <em class="od">报名，我会得到一点佣金。</em></p><p id="77f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的支持对我来说非常重要——谢谢。</p></div></div>    
</body>
</html>