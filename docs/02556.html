<html>
<head>
<title>Learning Go: Strings and String Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋:字符串和字符串函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-go-strings-and-string-functions-67626bb18bae?source=collection_archive---------10-----------------------#2020-03-21">https://levelup.gitconnected.com/learning-go-strings-and-string-functions-67626bb18bae?source=collection_archive---------10-----------------------#2020-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/26ff913d9569bc97b7ee892f314aa9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O43hAPRTUzQHobnu"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">塔拉·埃文斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c221" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将向您展示如何在Go中形成和使用字符串。像大多数现代语言一样，string数据类型的大部分功能来自一个库，或者在Go中是一个包。这个包叫做<code class="fe le lf lg lh b">strings</code>，我将演示这个包中的几个函数。</p><h1 id="7d40" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">字符串数据类型</h1><p id="855f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">Go字符串是不可变的字节序列。不可变意味着一旦一个字符串被创建，它就不能被改变，尽管如果一个字符串被存储在一个变量中，这个变量是可以被改变的。</p><p id="674c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符串是通过将希望被视为字符串的字节放在双引号之间而形成的。以这种方式形成的字符串称为字符串文字，可以在赋值中使用，也可以作为函数的参数使用。</p><p id="7ebc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是字符串变量和字符串文字的一些示例:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6a7f" class="mt lj it lh b gy mu mv l mw mx">name := "Dennis Ritchie"<br/>var greeting string = "Hello, world!"</span></pre><p id="c0f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一节中，我将演示字符串不可变的含义。</p><h1 id="be7a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">对字符串的基本操作</h1><p id="234c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我要演示的第一个操作是len函数。这个函数返回字符串中的字符数。这里有一个例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="bee2" class="mt lj it lh b gy mu mv l mw mx">func main() {<br/>  greeting := "Hello, world!"<br/>  fmt.Printf("The length of greeting is %d.\n", len(greeting))<br/>}</span></pre><p id="6818" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Go字符串的索引类似于数组和切片。我可以使用索引的<code class="fe le lf lg lh b">for</code>循环显示字符串的每个字节(也可以使用range函数):</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3b5a" class="mt lj it lh b gy mu mv l mw mx">func main() {<br/>  greeting := "Hello, world!"<br/>  for i:=0; i&lt;len(greeting); i++ {<br/>    fmt.Println(greeting[i])<br/>  }<br/>}</span></pre><p id="8663" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">稍后我将向您展示如何将字节转换成字母字符。</p><p id="5176" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管可以通过索引访问字符串的每个字节，但不能以这种方式修改字节:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ae0d" class="mt lj it lh b gy mu mv l mw mx">greeting[1] = "E"</span></pre><p id="fe5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这导致了恐慌，并证明了Go字符串的不变性。</p><p id="d155" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我可以把一根绳子切成几段，把它切成几片:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d483" class="mt lj it lh b gy mu mv l mw mx">func main() {<br/>  greeting := "Hello, world!"<br/>  fmt.Println(greeting[0:5]) // displays Hello<br/>}</span></pre><p id="0bcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有不同的处理切片的方法都适用于字符串。</p><p id="935b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以使用串联将多个字符串“粘合”在一起。Go串联运算符是<code class="fe le lf lg lh b">+</code>。这里有一个例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="da66" class="mt lj it lh b gy mu mv l mw mx">func main() {<br/>  first := "Ken"<br/>  last  := "Thompson"<br/>  full := first + " " + last<br/>  fmt.Println(full) // displays Ken Thompson<br/>}</span></pre><p id="3109" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和其他语言一样，Go有特殊的字节字符序列，可以嵌入到字符串中。这些序列类似于C和C++中的序列，比如新行的<code class="fe le lf lg lh b">\n</code>和tab的<code class="fe le lf lg lh b">\t</code>。</p><h1 id="1372" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">字符串包</h1><p id="0214" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">处理字符串所需的大部分功能都在<code class="fe le lf lg lh b">strings</code>包中。在这一节中，我将介绍这个包中的几个函数。</p><p id="1cc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要看的第一个函数是<code class="fe le lf lg lh b">contains</code>。这个布尔函数检查一个字符串是否包含指定的子串。这里有一个例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="097b" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="5ed5" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strings"<br/>)</span><span id="e468" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  address := "3000 W. Scenic Drive"<br/>  if strings.Contains(address, "Scenic") {<br/>    fmt.Print("Located on Scenic Drive")<br/>  } else {<br/>      fmt.Print("Located somewhere else.")<br/>  }<br/>}</span></pre><p id="1bbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我要看的下一个函数是<code class="fe le lf lg lh b">count</code>。此函数返回指定子串在字符串中出现的次数。它是这样工作的:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="739b" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="2903" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strings"<br/>)</span><span id="0938" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  s := "now is the time for all good people"<br/>  os := strings.Count(s, "o")<br/>  fmt.Println(s)<br/>  fmt.Printf("There are %d o's in the string.\n", os)<br/>}</span></pre><p id="5bc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来是<code class="fe le lf lg lh b">fields </code>函数。这个函数将一个字符串分解成一个或多个空白字符序列，返回剩余子字符串的一部分。该函数的一个示例如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6d42" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="372b" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strings"<br/>)</span><span id="c07f" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  s := "   now is   the     time for    all good       people"<br/>  words := strings.Fields(s)<br/>  fmt.Println(words)<br/>}</span></pre><p id="134a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">index</code>函数返回子串在字符串中的索引位置，如果在字符串中没有找到子串，则返回<code class="fe le lf lg lh b">-1</code>。下面是一个使用该函数的程序:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="af67" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="14a3" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strings"<br/>)</span><span id="2bc2" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  s := "now is the time for all good people"<br/>  foundAt := strings.Index(s, "time")<br/>  if foundAt &gt; -1 {<br/>    fmt.Printf("time is found at position %d in the string.\n",<br/>               foundAt)<br/>  } else {<br/>    fmt.Println("time is not found in string.")<br/>  }<br/>}</span></pre><p id="f0e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我描述的下一个函数用于将几个子字符串放入一个字符串中。这个功能叫做<code class="fe le lf lg lh b">join</code>。第一个参数是一个包含一组字符串的切片。第二个参数是一个分隔符，它将被放置在切片中的每个字符串之间。</p><p id="4417" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4d96" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="565b" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strings"<br/>)</span><span id="dfff" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  sl := []string{"now","is","the","time"}<br/>  joined := strings.Join(sl," ")<br/>  fmt.Println(joined)<br/>}</span></pre><p id="6cee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">repeat</code>函数将字符串重复指定的次数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="75fa" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="2464" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strings"<br/>)</span><span id="022e" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  fmt.Println(strings.Repeat("ei", 2) + "o") // displays eieio<br/>}</span></pre><p id="4c8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">replace</code>函数将用另一个子字符串替换前<em class="mz"> n </em>个子字符串，并返回新的字符串。如果<em class="mz"> n </em>小于0，那么它将尽可能多地进行替换。</p><p id="d518" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的示例演示如何使用函数在字符串中进行一次替换:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6302" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="7eea" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strings"<br/>)</span><span id="f67b" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  misspellings := "recieve decieve reciever deciever believe"<br/>  fmt.Println(misspellings)<br/>  count := 1<br/>  spellings := strings.Replace(misspellings, "cie", "cei",<br/>                               count)<br/>  fmt.Println(spellings)<br/>}</span></pre><p id="9c07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想用一个不同的子串替换一个字符串中的所有子串，使用<code class="fe le lf lg lh b">ReplaceAll</code>函数。它是这样工作的:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8ca8" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="7af1" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strings"<br/>)</span><span id="3efc" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  misspellings := "recieve decieve reciever deciever believe"<br/>  fmt.Println(misspellings)<br/>  spellings := strings.ReplaceAll(misspellings, "cie", "cei")<br/>  fmt.Println(spellings)<br/>}</span></pre><p id="89c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我要演示的下一个函数是<code class="fe le lf lg lh b">join</code>的姊妹函数。<code class="fe le lf lg lh b">split</code>函数接受一个字符串和一个分隔符，并返回一个包含分隔符之间所有文本的切片。如果字符串是<code class="fe le lf lg lh b">“Meredith,Allison,Mason”</code>，分隔符是，那么返回的切片是<code class="fe le lf lg lh b">[Meredith Allison Mason]</code>。下面是实现这一点的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d5a0" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="93bb" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strings"<br/>)</span><span id="dc3f" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  siblings := "Meredith,Allison,Mason"<br/>  splitUp := strings.Split(siblings, ",")<br/>  fmt.Println(splitUp)<br/>}</span></pre><p id="905c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来的两个函数可以用来改变字符串的大小写。<code class="fe le lf lg lh b">ToLower</code>将字符串改为全小写，而<code class="fe le lf lg lh b">ToUpper</code>将大小写改为全大写。这里有一个例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="73d0" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="4dd6" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strings"<br/>)</span><span id="f1bc" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  s := "I'M YELLING"<br/>  fmt.Println(strings.ToLower(s))<br/>  s = "i'm whispering"<br/>  fmt.Println(strings.ToUpper(s))<br/>}</span></pre><p id="2c7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我要演示的最后一个例子是<code class="fe le lf lg lh b">TrimSpace</code>函数，它从字符串的开头和结尾开始修剪所有的空格。这个函数是这样工作的:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e4b0" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="a977" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strings"<br/>)</span><span id="1d98" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  name := "  Dennis Ritchie    "<br/>  fmt.Println(name)<br/>  name = strings.TrimSpace(name)<br/>  fmt.Println(name)<br/>}</span></pre><p id="845f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这只是在strings包中找到的函数的一个示例，您应该查看包中的Go文档以查看完整的列表。</p><h1 id="82c9" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">字符串转换</h1><p id="1cb5" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我需要非常简单地再提一个包— <code class="fe le lf lg lh b">strconv</code>。这个包包含了将字符串转换成数字和将数字转换成字符串的函数，以及其他转换。</p><p id="a825" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe le lf lg lh b">Itoa</code>将整数转换成字符串。下面是它的用法示例:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="352a" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="4863" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strconv"<br/>)</span><span id="519b" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  fmt.Print("Hello, Agent " + strconv.Itoa(99) + ".")<br/>}</span></pre><p id="1ae3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe le lf lg lh b">Atoi</code>将字符串转换成整数。它还返回一个必须在函数调用中处理的错误对象，如下例所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ef8f" class="mt lj it lh b gy mu mv l mw mx">package main</span><span id="726c" class="mt lj it lh b gy my mv l mw mx">import (<br/>  "fmt"<br/>  "strconv"<br/>)</span><span id="2242" class="mt lj it lh b gy my mv l mw mx">func main() {<br/>  number1, err := strconv.Atoi("1")<br/>  number2, err1 := strconv.Atoi("2")<br/>  result := number1 + number2<br/>  if err == nil &amp;&amp; err1 == nil {<br/>    fmt.Printf("%d + %d = %d.\n", number1, number2, result)<br/>  }<br/>}</span></pre><p id="873d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">strconv</code>包中还有几个功能，但这是你最常用的两个。</p><p id="385e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有另外两个关于Go strings、bytes和Unicode的包，但是我不打算在这里介绍它们。如果您对这些包感兴趣，请参阅Go文档。</p><h1 id="611c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">字符串和字符</h1><p id="0e49" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">您应该注意到Go中没有char类型。<code class="fe le lf lg lh b">byte</code>类型用于此目的，正如我们在本文开始时看到的，当时我使用索引for循环遍历一个字符串。在这篇文章的最后，我将向您展示如何使用<code class="fe le lf lg lh b">Printf</code>函数将字节转换成字符串:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="88b1" class="mt lj it lh b gy mu mv l mw mx">func main() {<br/>  greeting := "Hello, world!"<br/>  for i:=0; i&lt;len(greeting); i++ {<br/>    fmt.Printf("%c\n", greeting[i])<br/>  }<br/>}</span></pre><p id="0320" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">格式规范%c会将字节转换为字符，以便在输出中显示。</p><h1 id="78d0" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">去和弦</h1><p id="b4bc" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">Go有一个很好的、现代的字符串实现。在这篇文章中，我介绍了我认为在Go中使用字符串最重要的方面，但是我没有介绍所有的内容。我特别避免谈论Go如何在字符串的实现中使用Unicode。如果你想了解更多这方面的知识，我建议你读一读艾伦·多诺万和布莱恩·柯尼根的书《Go编程语言》。</p><p id="8e8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件提出意见和建议。</p></div></div>    
</body>
</html>