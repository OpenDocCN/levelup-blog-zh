<html>
<head>
<title>Kickstart the Process for Building an Online Analytical Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">启动构建在线分析引擎的过程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kickstart-the-process-for-building-an-online-analytical-engine-b69f1d7e7bf7?source=collection_archive---------30-----------------------#2021-01-19">https://levelup.gitconnected.com/kickstart-the-process-for-building-an-online-analytical-engine-b69f1d7e7bf7?source=collection_archive---------30-----------------------#2021-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ddc9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解它是如何工作的，以及我们有哪些选择是第一步</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2eebd5b0d23593c988c4fc08cde7b9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3B7uy7EftcBIe5vzvsSWw.jpeg"/></div></div></figure><p id="dd21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">分析的使用不再局限于财大气粗的大公司。它现在已经普及，59%的企业在某种程度上使用了分析。公司正以多种方式利用这项技术。根据德勤(T2)的一项调查，49%的受访者表示，分析帮助他们做出更好的决策，16%的人表示，分析可以更好地实现关键的战略计划，10%的人表示，分析可以帮助他们改善与客户和业务合作伙伴的关系。</p><p id="cf14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了充分利用这些优势，您需要知道如何从您的数据中获取最大价值。这就是超快速分析引擎的用武之地。这些是在选择最佳方法时应该考虑的因素:</p><p id="93b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">→ <strong class="kw iu">摄取时间</strong>:数据需要多长时间准备好以供查询</p><p id="512d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">→ <strong class="kw iu">查询延迟</strong>:UI应该多快显示结果</p><p id="be1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">→ <strong class="kw iu">存储开销</strong>:将存储多少数据</p><p id="27ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">→ <strong class="kw iu">数据格式</strong>:数据有预定义的模式还是没有模式</p><p id="f6d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有多种开源产品就是为此而构建的。在大多数情况下，它们适用于正常的分析目的。我想到的一些是:</p><ul class=""><li id="01f9" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">德鲁伊和比诺在工作方式上非常相似，因此我把他们归为一类。原始数据作为片段被接收、索引和存储。<a class="ae lq" href="https://druid.apache.org/docs/latest/design/index.html" rel="noopener ugc nofollow" target="_blank">德鲁伊</a>对其所有用例使用反转的<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/insights-into-indexing-using-bitmap-index-c28a3db1ad97">位图索引</a>，而<a class="ae lq" href="https://docs.pinot.apache.org/" rel="noopener ugc nofollow" target="_blank">皮诺</a>拥有基于数据的多种索引技术。索引数据被写成在分配的时间量之后不可变的段。段类似于分区。<br/>查询引擎获取索引数据并检索结果。</li><li id="1b0b" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><strong class="kw iu">麒麟</strong> <br/> <a class="ae lq" href="http://kylin.apache.org/" rel="noopener ugc nofollow" target="_blank">麒麟</a>更是典型的OLAP发动机。摄取的数据存储为聚合多维数据集。它使用一个<a class="ae lq" href="https://tech.ebayinc.com/engineering/cube-planner-build-an-apache-kylin-olap-cube-efficiently-and-intelligently/" rel="noopener ugc nofollow" target="_blank">立方体规划器</a>来高效智能地构建立方体。然后，这些立方体被写入纵列拼花文件格式(在旧版本中，数据被写入HBASE)。对于在线查询，它仍然使用与Druid或Pinot类似的方法，将数据编入索引并保存在内存中。经过一段分配的时间后，立方体由此生成并转储到拼花文件中。</li></ul><p id="0b58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两种系统各有利弊。这两种解决方案都非常快，尽管Apache Druid更成熟、更常用。在开始任何工作之前，通读他们的文档是一个好主意。</p><p id="9c51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论出于什么原因，如果您计划构建一个定制的分析引擎，这里有一个典型的分析引擎的三个主要支柱</p><h1 id="ba5e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">事件流平台(消息系统)</h1><p id="2c02" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">最常见的消息系统是Apache Kafka。如果你对Kafka不熟悉，它是一个可扩展的、容错的、发布-订阅消息系统，使你能够构建分布式应用程序，并为LinkedIn、Twitter、Airbnb等网络规模的互联网公司提供支持。</p><p id="f67e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kafka是一个分布式系统，由<strong class="kw iu">服务器</strong>和<strong class="kw iu">客户端</strong>组成，它们通过高性能<a class="ae lq" href="https://kafka.apache.org/protocol.html" rel="noopener ugc nofollow" target="_blank"> TCP网络协议</a>进行通信。它可以部署在本地和云环境中的裸机硬件、虚拟机和容器上。</p><p id="17f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">服务器</strong> : Kafka作为一个或多个服务器的集群运行，这些服务器可以跨越多个数据中心或云区域。其中一些服务器构成了存储层，称为代理。为了让您实现任务关键的用例，Kafka集群具有高度的可伸缩性和容错性:如果它的任何一个服务器出现故障，其他服务器将接管它们的工作，以确保连续运行而不会丢失任何数据。</p><p id="5b3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">客户端</strong>:它们允许你编写分布式应用和微服务，并行、大规模、容错地读取、写入和处理事件流，即使在网络问题或机器故障的情况下。Kafka附带了一些这样的客户端，由Kafka社区提供的<a class="ae lq" href="https://cwiki.apache.org/confluence/display/KAFKA/Clients" rel="noopener ugc nofollow" target="_blank">几十个客户端</a>增强:客户端可用于Java和Scala，包括更高级的<a class="ae lq" href="https://kafka.apache.org/documentation/streams/" rel="noopener ugc nofollow" target="_blank"> Kafka Streams </a>库，用于Go、Python、C/C++和许多其他编程语言以及REST APIs。</p><p id="04fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">其他类似系统</strong></p><p id="6b3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有许多消息传递系统都有消息队列、分布式消息传递和高性能事件流系统的用例。基于来自<a class="ae lq" href="https://www.confluent.io/kafka-vs-pulsar/" rel="noopener ugc nofollow" target="_blank"> confluent </a>的统计数据，以下是Apache Kafka、Apache Pulsar和RabbitMQ的对比</p><p id="512c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">→ Kafka提供了所有系统中最高的吞吐量，根据流行的OpenMessaging基准测试，其写入速度比RabbitMQ快15倍，比Pulsar快2倍*</p><p id="acd1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">→ Kafka以更高的吞吐量提供了<a class="ae lq" href="https://www.confluent.io/blog/kafka-fastest-messaging-system/" rel="noopener ugc nofollow" target="_blank">最低延迟</a>(p99时5毫秒)，同时还提供了强大的耐用性和高可用性*</p><p id="4296" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">→ RabbitMQ可以实现比Kafka更低的端到端延迟，但吞吐量要低得多(Kafka为30K消息/秒，而Kafka为200K消息/秒)，之后延迟会显著降低。</p><h1 id="1f75" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">流式传输、聚合和数据分析引擎</h1><p id="6066" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">Apache Spark是大数据领域使用最多的分析引擎。Spark的快速处理速度使其非常适合数据清理、数据争论和ETL。它有一个先进的DAG执行引擎，支持非循环数据流和内存计算，这有助于运行程序的速度比Hadoop MapReduce快100倍。</p><p id="2a42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着<a class="ae lq" href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html" rel="noopener ugc nofollow" target="_blank">结构化流</a>(在Spark 2.x中)的增加，更高级别的API本质上允许开发人员创建无限的流数据帧和数据集。它还解决了用户在早期框架中遇到的一些非常实际的问题，特别是关于处理事件时间聚合和消息延迟交付的问题。对结构化流的所有查询都经过Catalyst查询优化器，甚至可以以交互方式运行，允许用户对实时流数据执行SQL查询。</p><p id="cd56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Spark提供了3个选项来聚集和操作数据。如何选择以及选择什么是基于您的用例的。</p><p id="ee49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> RDD </strong></p><ul class=""><li id="76ef" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">您希望对数据集进行低级转换、操作和控制</li><li id="36ca" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">您的数据是非结构化的，例如媒体流或文本流</li><li id="b6cf" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">您希望使用函数式编程结构而不是特定于领域的表达式来操作数据</li></ul><p id="1812" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">数据集或数据帧</strong></p><ul class=""><li id="ddc7" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">如果您想要丰富的语义、高级抽象和特定于领域的API，请使用DataFrame或Dataset。</li><li id="c94b" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">如果您的处理需要高级表达式、过滤器、映射、聚合、平均值、求和、SQL查询、列访问以及在半结构化数据上使用lambda函数，请使用DataFrame或Dataset。</li><li id="f62d" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">如果您想在编译时获得更高程度的类型安全，想要类型化的JVM对象，利用Catalyst优化，并受益于钨的高效代码生成，请使用Dataset。</li><li id="d595" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">如果您想要跨Spark库统一和简化API，请使用DataFrame或Dataset</li></ul><p id="52c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应该根据您的使用情况和舒适度来决定使用哪一种。</p><h1 id="3643" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">数据存储</h1><p id="7517" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">选择数据存储是一项棘手的工作，不是因为我们有众多的选项，而是因为这些选项是如此多样。对于一个用例来说完美的数据存储对于另一个用例来说可能会彻底失败。</p><p id="6025" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过与大量客户和用例打交道，我发现要考虑的最重要的标准是:</p><ul class=""><li id="dc47" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><strong class="kw iu">卷— </strong>需要存储和查询多少数据</li><li id="f127" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><strong class="kw iu">查询模式</strong> —需要运行的查询类型</li><li id="bae7" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><strong class="kw iu">延迟</strong> —检索结果需要多长时间</li></ul><p id="dd33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您的数据量在GBs级别，选择Postgres这样的关系数据库可能是一个非常好的选择。您拥有的数据越多，非关系数据库就越有用，因为它不会对传入的数据施加限制，使您可以更快地编写。</p><p id="5347" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查询模式是在决定数据存储时起着非常关键作用的另一个因素。如果您希望查询运行大量的“连接”和“分组”操作，像Cassandra这样的NoSQL数据库可能不是一个很好的选择。然而，如果您的查询本质上是选择性的(大海捞针)，那么Cassandra可能就在其中。</p><p id="7ef0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个重要因素是查询的延迟。只有少数商店可以提供亚秒级延迟的结果。像Redis这样的键值存储或者像Cassandra这样的非SQL数据库可能是一个很好的选择。如果您可以对延迟宽容一些，基于Hadoop的解决方案也可以工作。</p><p id="6465" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我见过的两个最常见的数据存储是:</p><ol class=""><li id="5b6a" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp nc lx ly lz bi translated"><strong class="kw iu"> HDFS与Hive: </strong>这是最常见的数据存储，许多团队都依赖它来满足他们的分析需求。使用的理想数据格式是<a class="ae lq" href="https://databricks.com/session_eu19/the-parquet-format-and-performance-optimization-opportunities" rel="noopener ugc nofollow" target="_blank">拼花地板</a>。最适合的查询引擎是<a class="ae lq" href="https://blog.treasuredata.com/blog/2015/03/12/presto-sql-on-hadoop/" rel="noopener ugc nofollow" target="_blank">。Presto是一个纯基于内存的架构，设计用于对任何大小的数据进行快速分析查询。这项工作可能需要使用Spark进行一些数据操作来优化查询检索。这种方法在数据模式和查询类型方面更灵活，但在延迟方面可能不是最有效的。</a></li><li id="d076" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nc lx ly lz bi translated">Cassandra :另一个用于分析目的的流行数据存储是Cassandra。它是一个高度可伸缩、高性能的分布式数据库。然而，采用Cassandra作为一个单一的，一刀切的数据库有几个缺点。分区/分布式数据存储模型使得在关系数据库中更直接的某些类型的查询或数据分析变得困难(通常效率很低)。此外，需要在数据聚合层做大量的准备工作，以获得低延迟的查询功能。</li></ol></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="f535" class="mf mg it bd mh mi nk mk ml mm nl mo mp jz nm ka mr kc nn kd mt kf no kg mv mw bi translated">参考</h1><div class="np nq gp gr nr ns"><a href="https://medium.com/swlh/insights-into-parquet-storage-ac7e46b94ffe" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">对拼花储物的洞察</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">从事大数据工作的大多数人都会听说过parquet，以及它是如何针对存储等进行优化的。在这里我将…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://aws.amazon.com/blogs/startups/picking-the-right-data-store-for-your-workload/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">为您的工作负载选择合适的数据存储|亚马逊网络服务</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">选择的暴政为什么AWS有这么多的数据存储选项？哪个适合我？在这个博客系列中，我…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">aws.amazon.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og ks ns"/></div></div></a></div></div></div>    
</body>
</html>