<html>
<head>
<title>Mobx Tips And Pitfalls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Mobx提示和陷阱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mobx-tips-and-pitfalls-92e635108653?source=collection_archive---------2-----------------------#2020-07-11">https://levelup.gitconnected.com/mobx-tips-and-pitfalls-92e635108653?source=collection_archive---------2-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/2dde2bccc1d13c5054e9ad8c957f9ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*wZItRuJY6TvZ8tJ1TCnLIQ.png"/></div></figure><p id="a8c7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以最近我开始看到越来越多的人使用MobX，我想分享我在使用它一段时间后获得的一些见解。我将写一些对于MobX新用户来说不太明显的话题。这篇文章确实需要Mobx的基础知识或以前的用法，我已经准备了Github repo来玩这个东西(<a class="ae ks" href="https://github.com/stolenng/mobx-tips-and-pitfalls" rel="noopener ugc nofollow" target="_blank">这里</a>)</p><h1 id="68e3" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">计算值缓存</h1><p id="a0e8" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">因此，我们在MobX中有一个称为“计算”的惊人功能，它允许从状态中获取值，但是如果您尝试调试它，您会看到一些值被缓存，而一些没有，那么为什么会发生这种情况呢？计算函数只有在被<strong class="jw ir">观察到</strong>时才会被缓存/记忆，例如被自动运行、反应或mobx-react观察器观察。这样设计是为了避免计算，并且只有当mobx观察到变化时才这样做。</p><p id="4ce1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">更多信息请点击此处:</p><ul class=""><li id="163c" class="lw lx iq jw b jx jy kb kc kf ly kj lz kn ma kr mb mc md me bi translated"><a class="ae ks" href="https://mobx.js.org/best/pitfalls.html#computed-values-run-more-often-than-expected" rel="noopener ugc nofollow" target="_blank">当计算值运行时</a></li><li id="df5b" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated"><a class="ae ks" href="https://mobx.js.org/refguide/computed-decorator.html" rel="noopener ugc nofollow" target="_blank">电脑装饰</a></li></ul><h1 id="004b" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">重新分配可观测量</h1><p id="3311" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">MobX用自己的接口和方法来包装<strong class="jw ir"> observables </strong>，以便能够观察到变化，因此，如果您给它重新赋值，您可能会删除MobX包装器，然后失去它的所有功能，并且需要一段时间来理解为什么会发生这种情况。</p><p id="10c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽可能多地使用可观察的方法，例如，如果是一个数组，就使用像push、pop等数组方法…</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mk"><img src="../Images/eefc90d46056fd9e1a5a890fcaf6e090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYGO1eZWy6S5ImJMXyyWuw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">简单数组与可观察数组的示例</figcaption></figure><p id="b88b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上图显示了两个可观察到的，左边的一个已经被重新分配并失去了if能力，右边的一个使用了数组的<code class="fe mx my mz na b">push</code>方法并保留了MobX能力。</p><h1 id="43da" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为您的数据建模</h1><p id="dc11" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我建议尽可能多地尝试对你的数据建模，而Mobx <strong class="jw ir"> observables </strong>会自动使你的大部分对象<strong class="jw ir">可观察</strong>它可能会错过一些地方，因为它的规则使<strong class="jw ir">可观察</strong>然后你可以进入一个迷宫，试图了解哪里出错了，而不是仅仅控制你的对象，并自己决定什么是<strong class="jw ir">可观察的</strong>和什么不是。</p><p id="feb6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是一个例子，您可以控制每个对象/类:)</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/55ff93e4f5b97746f1bd72b1baabe86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*E3zM6xvooa3WgmPg7ujBTA.png"/></div></figure><p id="649f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在这里阅读规则:</p><div class="nc nd gp gr ne nf"><a href="https://mobx.js.org/refguide/observable.html" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">可观察的MobX</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">egghead.io第一课:可观察对象&amp;观察者托管在egghead.io egghead.io第四课:可观察对象&amp;地图托管…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">mobx.js.org</p></div></div><div class="no l"><div class="np l nq nr ns no nt js nf"/></div></div></a></div><h1 id="a11d" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何组织你的商店</h1><p id="dcb9" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我最喜欢的方法是把你的商店组织成一棵树，从一个包含两个商店的根商店开始，一个是数据商店，一个是UI商店，然后从那里开始建立树。我还创建了一个简单的库来帮助依赖注入和从树的任何地方获取根，你可以在这里查看:<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/introducing-mobx-easy-cd281ace9e6e"> mobx-easy </a></p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nu"><img src="../Images/da3d1476f726edc88b177fba2d95cc4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_PJIlExTrWhlT-IAEJJnw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">商店结构图</figcaption></figure><p id="0a6e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本指南更深入地讨论了这一概念:</p><div class="nc nd gp gr ne nf"><a href="https://mobx.js.org/best/store.html" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">构建大规模可维护项目的最佳实践</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">构建大规模可维护项目的最佳实践</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">构建大规模可维护projectsmobx.js.org的MobX最佳实践</p></div></div><div class="no l"><div class="nv l nq nr ns no nt js nf"/></div></div></a></div><h1 id="4e5f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">连接您的商店以做出反应</h1><p id="09e7" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们将创建<a class="ae ks" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React Context </a>并用提供者包装我们的<code class="fe mx my mz na b">&lt;App /&gt;</code>组件，然后将根存储作为值传递给它，我们还将创建一个函数名<code class="fe mx my mz na b">createStore</code>来帮助我们创建根存储(在实际项目中，我们可以在那里传递额外的功能)。</p><p id="7de0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将创建自定义的<code class="fe mx my mz na b">hook</code>来通过我们刚刚创建的上下文检索根存储。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nw"><img src="../Images/cacaa5d34c5c716a9e86b3a108444d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TaqhDbooORCyCSytt1AS1g.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">上面的例子。</figcaption></figure><p id="7065" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我们可以像这样轻松地访问每个react组件中的存储:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nx"><img src="../Images/e972c2f2bed0a4fac7f09b429b4a9b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xVY91AmhXOt5podGYJqGw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">使用useStore挂钩</figcaption></figure><h1 id="2a9d" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用观察者/观察者</h1><p id="0611" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">因此，对于最后一个主题，我们将关注实际的连接，之前的主题只是一个设置。</p><p id="455b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你的项目只包含函数组件，你可以使用<a class="ae ks" href="https://github.com/mobxjs/mobx-react-lite" rel="noopener ugc nofollow" target="_blank"> mobx-react-lite </a>，如果你对组件进行分类，你需要使用<a class="ae ks" href="https://github.com/mobxjs/mobx-react" rel="noopener ugc nofollow" target="_blank"> mobx-react </a>。</p><p id="fd77" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这两个库基本上通过为我们提供<code class="fe mx my mz na b">observer</code> / <code class="fe mx my mz na b">useObserver</code>函数来帮助我们连接react组件，就像<code class="fe mx my mz na b">autorun</code>一样，它们观察每个mobx可观察的用法。</p><p id="b586" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你用<code class="fe mx my mz na b">observer</code>包装你的组件，所有在组件内部使用的可观察对象都将被观察到，组件将在任何改变后重新呈现。如果你用<code class="fe mx my mz na b">useObserver</code>包装你的返回值，只有其中的可观察对象会被跟踪，如果你不使用它们中的任何一个，那么你的组件根本不会重新呈现。(你可以在这里找到示例代码:<a class="ae ks" href="https://github.com/stolenng/mobx-tips-and-pitfalls/blob/master/src/examples/observing-components.tsx" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><h1 id="8164" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">MobX 6 peek</h1><p id="5a9f" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">所以本周MobX团队公布了v6的首个候选版本:【https://www.npmjs.com/package/mobx/v/6.0.0-rc.1 T2】</p><p id="0cb9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们在这里可以期待看到的主要事情是慢慢开始摆脱decorator的使用，因为它的提议在tc39中没有进展，我们将需要开始使用名为<code class="fe mx my mz na b">makeObservable</code>和<code class="fe mx my mz na b">makeAutoObservable</code>的新函数，这将帮助我们决定类中哪些属性是可观察的/动作的/计算的，哪些不是不使用decorator的。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ny"><img src="../Images/b581b97a5b5bb70bc6e2321a6b204f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZ-ka7XPAPuTLC_-W0y2vA.png"/></div></div></figure><p id="93be" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在本期中读到关于从装饰者转移的决定和更多信息:</p><div class="nc nd gp gr ne nf"><a href="https://deploy-preview-2327--mobx-docs.netlify.app/best/decorators.html" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">最佳/装饰者MobX</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">编辑描述</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">部署-预览-2327 - mobx-docs.netlify.app</p></div></div><div class="no l"><div class="nz l nq nr ns no nt js nf"/></div></div></a></div><p id="3b2c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还有更多mobx 6的更新文档，你可以在这里查看:</p><div class="nc nd gp gr ne nf"><a href="https://deploy-preview-2327--mobx-docs.netlify.app/refguide/make-observable.html" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">make observable/makeoutobservable MobX</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">make observable/make auto observable</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">MobX make observable/makeautobservabledeploy-preview-2327-MobX-docs . net lify . app</p></div></div><div class="no l"><div class="oa l nq nr ns no nt js nf"/></div></div></a></div><h1 id="8ee9" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">总结</h1><p id="066e" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我试图让这个主题尽可能的简短和直接，我创建了一个包含所有示例的知识库，这样你就可以在代码中体验它，并且比在文章中看到的效果更好。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/stolenng/mobx-tips-and-pitfalls" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">stolenng/mobx-提示和陷阱</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">你可以用npm run start运行这个项目，并选择所选的例子，它会自己运行，你可以玩…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="ob l nq nr ns no nt js nf"/></div></div></a></div><p id="3d03" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我希望这篇文章能帮助使用MobX的人，或者至少让他们思考或给出如何改进他们目前正在从事的项目的想法:)</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="c314" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="oj"> 9/20更新</em> </strong></p><p id="025f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我发布了一个关于MobX的广泛课程，请在这里随意查看:</p><div class="nc nd gp gr ne nf"><a href="https://www.udemy.com/course/mobx-in-depth-with-react/?referralCode=B7FD24C7EB1A51684160" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">使用React深入研究MobX(Hooks+TypeScript)</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">高级软件开发人员—在以色列空军服役3年，是一名软件开发人员——曾担任…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">www.udemy.com</p></div></div><div class="no l"><div class="ok l nq nr ns no nt js nf"/></div></div></a></div></div></div>    
</body>
</html>