<html>
<head>
<title>Cognito Triggers Deep Dive— PreSignUp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cognito触发深度潜水—预注册</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cognito-lambda-triggers-in-dotnet-presignup-4c465c6f81a?source=collection_archive---------6-----------------------#2022-08-31">https://levelup.gitconnected.com/cognito-lambda-triggers-in-dotnet-presignup-4c465c6f81a?source=collection_archive---------6-----------------------#2022-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ad71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文是Dotnet 系列中<strong class="jp ir"> Cognito Lambda触发器的一部分，致力于理解和处理Cognito Lambda触发器。</strong></p><p id="a983" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想了解Lambda触发器，以及如何设计一个Lambda函数来更普遍地处理各种触发器源，请参考Dotnet 中的相关母文章<a class="ae kl" href="https://medium.com/@oliver.schenk/cognito-lambda-triggers-in-dotnet-3bf13a55eda3" rel="noopener"> Cognito Lambda触发器。如果你去那里，你也会发现处理其他触发源的链接。</a></p><p id="013f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在以下章节中，我们将关注<strong class="jp ir">预启动</strong>触发源。您将在Cognito <a class="ae kl" href="https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-sign-up.html" rel="noopener ugc nofollow" target="_blank">文档</a>中找到技术细节，但是通常更重要的是理解它为什么存在以及为什么您可能想要使用它。</p><p id="e25f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里你会找到一个解释，包括用例、有效负载示例、处理程序实现和测试脚本。</p><p id="588c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会在Github 上找到<a class="ae kl" href="https://github.com/oliverschenk/cognito-lambda-triggers-dotnet" rel="noopener ugc nofollow" target="_blank">源代码。这将随着时间的推移，更多的例子更新。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7624f5e4839d2e9c0305e103925d8356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGLJ0-8oENh4CyHItqSvXQ.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://unsplash.com/@moneyphotos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> regularguy.eth </a>在<a class="ae kl" href="https://unsplash.com/s/photos/password?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="1093" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">预注册</h1><p id="a0d4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><code class="fe mf mg mh mi b">PreSignUp_*</code>触发器属于一类触发器，当收到新用户注册请求时，在Cognito注册新用户之前触发。</p><p id="13be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据创建新用户的请求来自何处，有三种可能的触发源。</p><ul class=""><li id="ac68" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated"><strong class="jp ir">预注册_注册</strong> —通过<a class="ae kl" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-app-integration.html" rel="noopener ugc nofollow" target="_blank">托管UI </a>或<a class="ae kl" href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_SignUp.html" rel="noopener ugc nofollow" target="_blank">注册</a> API调用的用户自助注册流程</li><li id="3868" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><strong class="jp ir">presign up _ AdminCreateUser</strong>—用户由系统使用<a class="ae kl" href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminCreateUser.html" rel="noopener ugc nofollow" target="_blank"> AdminCreateUser </a> API调用创建(比如由系统管理员创建)</li><li id="5120" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><strong class="jp ir">pre sign up _ external provider</strong>—用户首次使用外部提供商登录，如社交登录(如脸书、谷歌等)、SAML(如Active Directory)或OIDC(如Salesforce)。<br/>注意，设置起来有点复杂，因为它涉及到将第三方系统与Cognito连接起来。参见<a class="ae kl" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-identity-federation.html" rel="noopener ugc nofollow" target="_blank">通过第三方添加用户池登录</a>。</li></ul><h1 id="93b6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">事件有效负载</h1><p id="8563" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">传递给触发器处理函数的事件有效负载将由一组<a class="ae kl" href="https://medium.com/@oliver.schenk/cognito-lambda-triggers-in-dotnet-3bf13a55eda3#ddd6" rel="noopener">公共参数</a>和特定于触发器源的请求和/或响应属性组成。</p><h2 id="a892" class="mx ld iq bd le my mz dn li na nb dp lm jy nc nd lq kc ne nf lu kg ng nh ly ni bi translated">请求</h2><p id="9d4b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">预注册<code class="fe mf mg mh mi b">request</code>参数由以下属性组成。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8e52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mf mg mh mi b">ClientMetadata</code>和<code class="fe mf mg mh mi b">ValidationData</code>属性是键值数据，当进行<code class="fe mf mg mh mi b">AdminCreateUser</code>或<code class="fe mf mg mh mi b">SignUpUser</code> API调用时，这些数据被传递到Lambda触发器处理程序中。</p><p id="2c3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mf mg mh mi b">ClientMetadata</code>属性的目的是允许客户端将进一步的信息传递给预注册功能。<code class="fe mf mg mh mi b">ValidationData</code>的目的是允许客户端传递关于用户验证的更多信息。您的函数可以使用这些额外的信息。</p><p id="4844" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为这些数据来自客户端，从安全的角度来看，只有当注册是在安全的后端环境中通过API调用而不是通过公共客户端完成时，这些数据才是真正可靠的。</p><p id="d032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用元数据的一种方法是将信息从客户端传递到后端，然后在另一个触发器处理程序中重用该信息。</p><h2 id="c271" class="mx ld iq bd le my mz dn li na nb dp lm jy nc nd lq kc ne nf lu kg ng nh ly ni bi translated">反应</h2><p id="c852" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">预注册响应参数由以下属性组成。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="febe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> AutoConfirmUser </strong> —将此项设置为true以自动将用户的确认状态设置为已确认，而不是发送验证电子邮件或短信。他们将能够立即登录。</p><p id="abce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">自动验证电话</strong> —将此项设置为true，以将电话号码标记为已验证。</p><p id="05f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">自动验证电子邮件</strong> —将此项设置为true以将电子邮件地址标记为已验证。</p><h1 id="33ec" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">用例</h1><p id="fa95" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">此触发器的目的是确定是否应该允许用户注册，如果是，他们是否需要验证他们的详细信息，或者用户或他们的电子邮件或电话号码详细信息是否可以被强制为已验证状态。</p><p id="94a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是您可以做的一些示例:</p><ul class=""><li id="7fe3" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">您可以通过引发异常来防止创建用户。您可以做一些简单的事情，如检查用户属性的长度，也可以做一些复杂的事情，如调用其他服务来检查该用户是否已经存在，电子邮件地址域是否在允许的域内，或者电话号码是否在特定的国家内，等等。</li><li id="1aa7" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">通常，新用户将处于未确认状态。但是，您可以通过将<code class="fe mf mg mh mi b">AutoConfirmUser</code>参数设置为<code class="fe mf mg mh mi b">true</code>来强制用户在创建后立即进入确认状态。例如，您可以根据企业客户端的域电子邮件地址来验证它们，而不需要它们验证自己。如果您这样做，将不会发送验证码。</li><li id="aa25" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">您可以通过将<code class="fe mf mg mh mi b">AutoVerifyEmail</code>或<code class="fe mf mg mh mi b">AutoVerifyPhone</code>参数设置为<code class="fe mf mg mh mi b">true</code>来强制自动验证电子邮件和/或电话属性。这通常与<code class="fe mf mg mh mi b">AutoConfirmUser</code>配合使用。</li><li id="b55f" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">如果您使用多个使用相同电子邮件地址的外部提供商，您可以使用预注册触发器将两个提供商链接到同一个Cognito用户。参见下面的<a class="ae kl" href="https://stackoverflow.com/questions/59635482/aws-cognito-best-practice-to-handle-same-user-with-same-email-address-signing" rel="noopener ugc nofollow" target="_blank"> stackoverflow post </a>。</li></ul><h1 id="db71" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">重要提示</h1><p id="d8ff" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">有些事情你需要注意:</p><ul class=""><li id="e988" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">使用AdminCreateUser API调用时，Cognito会忽略<code class="fe mf mg mh mi b">AutoConfirmUser</code>、<code class="fe mf mg mh mi b">AutoVerifyEmail</code>和<code class="fe mf mg mh mi b">AutoVerifyPhone</code>参数。</li><li id="3282" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">通过AdminCreateUser API调用创建的用户会被自动确认，并且用户的状态会变为FORCE_CHANGE_PASSWORD。然后，用户必须在登录后或首次登录时更改密码。</li><li id="599b" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">当将<code class="fe mf mg mh mi b">AutoConfirmUser</code>设置为<code class="fe mf mg mh mi b">true</code>并且不验证用户的电子邮件地址或电话号码时要小心。如果用户忘记了密码，而没有经过验证的电子邮件或电话号码，他们将无法恢复密码。</li></ul><p id="262f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于电子邮件和电话号码验证，<a class="ae kl" href="https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-sign-up.html" rel="noopener ugc nofollow" target="_blank"> Cognito文档</a>也提供了一些重要的提示。</p><blockquote class="nl nm nn"><p id="49d5" class="jn jo no jp b jq jr js jt ju jv jw jx np jz ka kb nq kd ke kf nr kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>如果已经存在相同电话号码的别名，该别名将被移动到新用户，之前用户的<code class="fe mf mg mh mi b">phone_number</code>将被标记为未验证。电子邮件地址也是如此。为了防止这种情况发生，您可以使用用户池<a class="ae kl" href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_ListUsers.html" rel="noopener ugc nofollow" target="_blank"> ListUsers API </a>来查看是否有一个现有用户已经在使用新用户的电话号码或电子邮件地址作为别名。</p></blockquote><h1 id="466d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">处理程序示例</h1><p id="0fa9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">下面是每个预注册触发源的示例处理程序实现。模板可以在<a class="ae kl" href="https://github.com/oliverschenk/cognito-lambda-triggers-dotnet/tree/main/lambda-triggers/src/CognitoLambdaTriggers/Handlers" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><h2 id="1e29" class="mx ld iq bd le my mz dn li na nb dp lm jy nc nd lq kc ne nf lu kg ng nh ly ni bi translated">预注册_注册</h2><p id="db95" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在这个例子中，触发处理器自动确认用户，但是假设不同的过程将处理电子邮件/电话验证。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="8730" class="mx ld iq bd le my mz dn li na nb dp lm jy nc nd lq kc ne nf lu kg ng nh ly ni bi translated">预注册_AdminCreateUser</h2><p id="6115" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在这个例子中，触发器处理程序抛出一个异常并拒绝用户注册。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="a606" class="mx ld iq bd le my mz dn li na nb dp lm jy nc nd lq kc ne nf lu kg ng nh ly ni bi translated">预注册_外部提供商</h2><p id="b03d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在这个例子中，触发器处理程序检查具有给定用户名的用户是否已经存在，如果存在，就将新的提供者链接到这个现有用户。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="e77f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">测试</h1><p id="d273" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">为了简化初始测试，我提供了一些示例脚本，可以用来创建用户和清除用户。只是要小心删除用户的脚本，因为它会删除指定Cognito用户池中的所有用户！</p><ul class=""><li id="59fd" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated"><a class="ae kl" href="https://github.com/oliverschenk/cognito-lambda-triggers-dotnet/blob/main/lambda-triggers/test/commands/admin-create-user.sh" rel="noopener ugc nofollow" target="_blank"><em class="no">admin-create-user . sh</em></a>—使用AdminCreateUser API调用创建用户</li><li id="8967" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae kl" href="https://github.com/oliverschenk/cognito-lambda-triggers-dotnet/blob/main/lambda-triggers/test/commands/create-user-signup.sh" rel="noopener ugc nofollow" target="_blank"><em class="no">create-user-sign up . sh</em></a>—使用自行注册创建用户</li><li id="052a" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae kl" href="https://github.com/oliverschenk/cognito-lambda-triggers-dotnet/blob/main/lambda-triggers/test/commands/delete-users.sh" rel="noopener ugc nofollow" target="_blank"><em class="no">delete-users . sh</em></a>—删除给定用户池中的所有用户</li></ul><p id="7152" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我下面的示例中，你会看到我已经将用户池ID和用户池客户端ID分别放入环境变量<code class="fe mf mg mh mi b">USER_POOL_ID</code>和<code class="fe mf mg mh mi b">USER_POOL_CLIENT_ID</code>中，以避免一直粘贴这些值。</p><h2 id="dc0e" class="mx ld iq bd le my mz dn li na nb dp lm jy nc nd lq kc ne nf lu kg ng nh ly ni bi translated">注册处理程序</h2><p id="0135" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">可以使用<code class="fe mf mg mh mi b">aws cognito-idp sign-up</code> CLI命令触发注册处理程序。为了简化事情，我创建了一个<code class="fe mf mg mh mi b">create-user-signup.sh</code>脚本来简化创建一个新的随机用户。</p><p id="afbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用该脚本，请在您的用户池客户端ID后输入一个电子邮件地址。该脚本将使用<code class="fe mf mg mh mi b">+</code>符号自动生成一个随机别名。在电子邮件世界中，这仍然会在你的基本电子邮件地址结束。其他的都是随机生成的。</p><p id="3779" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个脚本不需要任何AWS凭证，因为它应该由未经身份验证的用户调用。</p><pre class="kn ko kp kq gt ns mi nt nu aw nv bi"><span id="a355" class="mx ld iq mi b gy nw nx l ny nz">$ export USER_POOL_CLIENT_ID=&lt;your_user_pool_client_id&gt;</span><span id="e515" class="mx ld iq mi b gy oa nx l ny nz">$ ./create-user-signup.sh $USER_POOL_CLIENT_ID your_email@account.com</span><span id="ed39" class="mx ld iq mi b gy oa nx l ny nz">Creating a user with the following details:<br/><a class="ae kl" href="mailto:Email=oliver.schenk+3aedd2@gmail.com" rel="noopener ugc nofollow" target="_blank">Email=your_email+3aedd2@account.com</a><br/>Phone=+61437340252<br/>Name=Susan6599<br/>Password=0117e007b8cdce52dd98ABC!</span><span id="a01a" class="mx ld iq mi b gy oa nx l ny nz">UserConfirmed: true<br/>UserSub: 9ff6b3de-0f13-48b1-8e29-af4190a1cf2f<br/>Finished.</span></pre><p id="309c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到，如果您在Lambda触发器处理程序中将<code class="fe mf mg mh mi b">AutoConfimUser</code>设置为<code class="fe mf mg mh mi b">true</code>，您会看到Cognito调用将使用<code class="fe mf mg mh mi b">UserConfirmed: true</code>进行响应，并且您不会收到任何确认电子邮件。但是，您的电子邮件地址仍将无法验证。</p><p id="174b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以证明用户状态如下。</p><pre class="kn ko kp kq gt ns mi nt nu aw nv bi"><span id="b7d2" class="mx ld iq mi b gy nw nx l ny nz">$ aws cognito-idp admin-get-user --user-pool-id $USER_POOL_ID --username 9ff6b3de-0f13-48b1-8e29-af4190a1cf2f<br/>Enabled: true<br/>UserAttributes:<br/>- Name: sub<br/>  Value: 9ff6b3de-0f13-48b1-8e29-af4190a1cf2f<br/>- Name: email_verified<br/>  Value: 'false'<br/>- Name: name<br/>  Value: Susan6599<br/>- Name: phone_number_verified<br/>  Value: 'false'<br/>- Name: phone_number<br/>  Value: '+61437340252'<br/>- Name: email<br/>  Value: <a class="ae kl" href="mailto:Email=oliver.schenk+3aedd2@gmail.com" rel="noopener ugc nofollow" target="_blank">your_email+3aedd2@account.com</a><br/>UserCreateDate: '2022-08-29T22:15:07.324000+08:00'<br/>UserLastModifiedDate: '2022-08-29T22:15:07.324000+08:00'<br/>UserStatus: CONFIRMED<br/>Username: 9ff6b3de-0f13-48b1-8e29-af4190a1cf2f</span></pre><p id="6aae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，<code class="fe mf mg mh mi b">UserStatus</code>是<code class="fe mf mg mh mi b">CONFIRMED</code>，但是<code class="fe mf mg mh mi b">email_verified</code>字段是<code class="fe mf mg mh mi b">false</code>。这意味着用户可以使用用户名(在这种情况下是电子邮件或电话号码)和密码登录，但如果用户忘记了密码，则不可能恢复帐户。</p><p id="8e36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以试着重设密码。</p><pre class="kn ko kp kq gt ns mi nt nu aw nv bi"><span id="ea1d" class="mx ld iq mi b gy nw nx l ny nz">$ aws cognito-idp forgot-password --client-id $USER_POOL_CLIENT_ID --username 9ff6b3de-0f13-48b1-8e29-af4190a1cf2f<br/>CodeDeliveryDetails:<br/>  AttributeName: email<br/>  DeliveryMedium: EMAIL<br/>  Destination: 9***@h***</span></pre><p id="193a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能想知道为什么我们得到了成功的回应？如果你仔细观察，这实际上不是一个成功的回答，而是假装的。</p><p id="e9c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这实际上是由于Cognito处理错误响应的方式。在用户池客户端的Terraform代码中,<code class="fe mf mg mh mi b">prevent_user_existence_errors</code>参数被设置为<code class="fe mf mg mh mi b">ENABLED</code>,这意味着Cognito将掩盖具有给定用户名的用户不存在或电子邮件和/或电话号码未被验证的事实。这是一个安全特性<a class="ae kl" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pool-managing-errors.html" rel="noopener ugc nofollow" target="_blank">，记录在这里</a>。</p><h2 id="8674" class="mx ld iq bd le my mz dn li na nb dp lm jy nc nd lq kc ne nf lu kg ng nh ly ni bi translated">AdminCreateUser处理程序</h2><p id="832d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">可以使用<code class="fe mf mg mh mi b">aws cognito-idp admin-create-user</code> CLI命令触发AdminCreateUser处理程序。为了简化事情，我创建了一个<code class="fe mf mg mh mi b">admin-create-user.sh</code>脚本来简化创建一个新的随机用户。</p><p id="2788" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与注册调用不同，AdminCreateUser调用需要AWS凭证，因为它是供管理Cognito用户池及其用户的用户或服务使用的。</p><p id="2dbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的示例是处理程序引发异常时收到的响应。异常消息将包含在CLI错误消息中。</p><pre class="kn ko kp kq gt ns mi nt nu aw nv bi"><span id="5e3c" class="mx ld iq mi b gy nw nx l ny nz">$ ./admin-create-user.sh $USER_POOL_ID <a class="ae kl" href="mailto:oliver.schenk@gmail.com" rel="noopener ugc nofollow" target="_blank">your_email@account.com</a><br/>Creating a user with the following details:<br/><a class="ae kl" href="mailto:Email=oliver.schenk+fb08c0@gmail.com" rel="noopener ugc nofollow" target="_blank">Email=</a><a class="ae kl" href="mailto:Email=oliver.schenk+3aedd2@gmail.com" rel="noopener ugc nofollow" target="_blank">your_email</a><a class="ae kl" href="mailto:Email=oliver.schenk+fb08c0@gmail.com" rel="noopener ugc nofollow" target="_blank">+fb08c0@account.com</a><br/>Phone=+61453330042<br/>Name=Susan1348<br/>Password=0ddad52a3ead8331ea6bABC!</span><span id="a2bb" class="mx ld iq mi b gy oa nx l ny nz">An error occurred (UserLambdaValidationException) when calling the AdminCreateUser operation: PreSignUp failed with error User could not be created..</span></pre><p id="d0cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如果我们不在处理程序中抛出异常会发生什么(注释掉在处理程序中抛出异常的代码并重新部署Lambda)。</p><pre class="kn ko kp kq gt ns mi nt nu aw nv bi"><span id="161e" class="mx ld iq mi b gy nw nx l ny nz">./admin-create-user.sh $USER_POOL_ID <a class="ae kl" href="mailto:oliver.schenk@gmail.com" rel="noopener ugc nofollow" target="_blank">your_email@account.com</a><br/>Creating a user with the following details:<br/><a class="ae kl" href="mailto:Email=oliver.schenk+8ebc46@gmail.com" rel="noopener ugc nofollow" target="_blank">Email=your_email+8ebc46@account.com</a><br/>Phone=+61418115255<br/>Name=Susan25233<br/>Password=ef7dfcf02365818ee008ABC!</span><span id="b7da" class="mx ld iq mi b gy oa nx l ny nz">User:<br/>  Attributes:<br/>  - Name: sub<br/>    Value: 74740674-e7aa-4bf7-9bbf-74ff3d80ca98<br/>  - Name: name<br/>    Value: Susan25233<br/>  - Name: phone_number<br/>    Value: '+61418115255'<br/>  - Name: email<br/>    Value: <a class="ae kl" href="mailto:Email=oliver.schenk+8ebc46@gmail.com" rel="noopener ugc nofollow" target="_blank">your_email+8ebc46@account.com</a><br/>  Enabled: true<br/>  UserCreateDate: '2022-08-31T20:47:00.770000+08:00'<br/>  UserLastModifiedDate: '2022-08-31T20:47:00.770000+08:00'<br/>  UserStatus: FORCE_CHANGE_PASSWORD<br/>  Username: 74740674-e7aa-4bf7-9bbf-74ff3d80ca98<br/>Finished.</span></pre><p id="3d6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一次创建了用户。用户已被确认，但状态为<code class="fe mf mg mh mi b">FORCE_CHANGE_PASSWORD</code>，这意味着用户必须在下次登录时更改密码。</p><p id="2fad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AdminCreateUser API调用有许多可能的参数，可以用来控制注册和验证流程。关键是触发响应不控制用户属性验证的行为。传递给AdminCreateUser API调用的参数决定了是否发送邀请消息、是否自动验证用户属性等等。</p><p id="9530" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最好的学习方法是尝试不同的设置。</p><h2 id="daa5" class="mx ld iq bd le my mz dn li na nb dp lm jy nc nd lq kc ne nf lu kg ng nh ly ni bi translated">外部提供程序处理程序</h2><p id="e21f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">ExternalProvider处理程序仅在用户首次使用外部提供程序登录时调用一次。</p><p id="22a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不打算在这里花太多时间讨论如何建立一个外部提供者，因为那将是另一整篇文章，而且已经有一些了。</p><p id="540a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">触发器的关键点在于，当第一次使用外部提供者时，这使您有机会采取一些措施。</p><p id="4776" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，您可以检查用户名或电子邮件是否已经存在于用户池中，如果已经存在，那么使用<a class="ae kl" href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminLinkProviderForUser.html" rel="noopener ugc nofollow" target="_blank">AdminLinkProviderForUser</a>API调用来链接它。</p><p id="85d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会自动验证电子邮件地址，但您可能需要手动询问并验证电话号码，因为这不是由外部提供商提供的。你会发现，如今许多应用程序将使用多步用户注册流程，而不仅仅是一个大型注册表单，特别是因为外部提供商可能只会给你电子邮件地址，而不会给你其他任何信息。</p><p id="6cf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还是那句话，这种题目本身就是一个相当大的题目。</p><h1 id="a176" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">其他触发器实现</h1><p id="0ca6" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">观看<a class="ae kl" href="https://awstip.com/cognito-lambda-triggers-in-dotnet-3bf13a55eda3" rel="noopener ugc nofollow" target="_blank">这个空间</a>中关于如何处理每种类型触发源的解释和例子的文章。</p><p id="a86a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关注我或订阅以接收这些文章发布时的通知。</p><p id="148b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的宝贵时间！</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="9834" class="lc ld iq bd le lf oi lh li lj oj ll lm ln ok lp lq lr ol lt lu lv om lx ly lz bi translated">分级编码</h1><p id="f771" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="d17a" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="bc33" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">📰查看<a class="ae kl" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="436d" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">🔔关注我们:<a class="ae kl" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kl" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kl" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="6896" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae kl" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>