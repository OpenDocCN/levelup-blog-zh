<html>
<head>
<title>More Program Templates for Arrays, Lists, and Vectors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多数组、列表和向量的程序模板</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/more-program-templates-for-arrays-lists-and-vectors-735a0c95515?source=collection_archive---------13-----------------------#2020-03-03">https://levelup.gitconnected.com/more-program-templates-for-arrays-lists-and-vectors-735a0c95515?source=collection_archive---------13-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fce1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理顺序数据的模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f0fbaf454fb9ccd93f354766e7f0156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctRjv5OAkdAFtLCHLhblVw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·Ku在<a class="ae ky" href="https://unsplash.com/s/photos/program-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="daac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我介绍了三个用于处理顺序数据集合(数组、列表或向量)的程序模板。在本文中，我将讨论这类数据集合的另外三个程序模板——如何将数据插入到顺序集合中，如何复制顺序集合，以及如何插入和复制顺序集合。</p><h1 id="2291" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么程序模板对程序员学习很重要</h1><p id="3ef8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">程序模板代表程序员用来快速评估如何解决问题的大量编程知识。专家学者认为组块是获得某一领域专业知识的必要条件。组块是通过研究一个领域中的常见使用模式并练习使用这些组块来解决越来越难的问题而实现的。一旦专家吸收了许多语块，他们就能比没有掌握那么多语块的人表现出更高水平的专业技能。</p><h1 id="4292" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">插入收藏</h1><p id="71b1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们要看的第一个程序模板是<em class="ms">插入到一个集合中</em>。当您需要将一段数据添加到集合中，并且它不能位于集合的开头或结尾时，可以使用该模板。</p><p id="ff10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当插入一个值序列时，首先要找到要插入新值的位置。然后将插入点右侧的所有值移动一个位置，为新值腾出空间。最后，在移位完成后，将新值插入移位打开的空间。</p><p id="1cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模板的伪代码如下所示:</p><p id="989c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">(新值将被插入到集合中的位置p) <br/>将变量(I)设置为集合的最后一个元素的索引加1(k)<br/>当I大于p+1时重复:<br/>coll[I]= coll[I-1]<br/>coll[p]=新值<br/>将集合元素的编号加1</em></p><p id="82a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个使用这个模板的问题:你有一组按数字顺序排列的成绩，你需要在这组成绩的中间添加一个成绩来保持顺序。</p><p id="4ec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个JavaScript解决方案:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="eaa8" class="my lw it mu b gy mz na l nb nc">let grades = new Array(71, 82, 85, 88, 89, 91);</span><span id="e127" class="my lw it mu b gy nd na l nb nc">let new_grade = 86</span><span id="b61f" class="my lw it mu b gy nd na l nb nc">// find place for grade<br/>let pos;<br/>for (pos = 0; pos &lt; grades.length; pos++) {<br/>  if (grades[pos] &gt; new_grade) {<br/>    break;<br/>  }<br/>}<br/>// shift the elements to the right<br/>for (let index = grades.length; index &gt; pos; index--) {<br/>  grades[index] = grades[index-1];<br/>}<br/>// insert the new grade<br/>grades[pos] = new_grade;</span></pre><p id="d0d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用数组的C++解决方案:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="91e6" class="my lw it mu b gy mz na l nb nc">int main()<br/>{<br/>  const int NUM_GRADES = 10;<br/>  int grades[NUM_GRADES] = {71, 82, 85, 88, 89, 91,0,0,0,0};<br/>  int new_grade = 86;<br/>  int pos;<br/>  for (pos = 0; pos &lt; NUM_GRADES; pos++) {<br/>    if (grades[pos] &gt; new_grade) {<br/>      break;<br/>    }<br/>  }<br/>  for (int index = NUM_GRADES-1; index &gt; pos; index--) {<br/>    grades[index] = grades[index-1];<br/>  }<br/>  grades[pos] = new_grade;<br/>  for (int grade : grades){<br/>    cout &lt;&lt; grade &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="70d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将数据插入到顺序集合中可能会非常昂贵。出于这个原因，大多数现代编程语言库都包括一些其他类型的集合，比如列表，这使得插入和删除的代价更低。如果你不熟悉链表的概念，你应该通过互联网搜索来探索它们是如何工作的。</p><h1 id="82dd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">深层复制收藏</h1><p id="5f4a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">许多初学编程的人认为他们可以通过简单的赋值来复制一个集合，比如一个数组或一个列表。这似乎是可行的，但是你剩下的就是所谓的<em class="ms">浅拷贝</em>。</p><p id="8608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将一个现有集合分配给一个新集合时，您正在进行引用，因此新集合仅引用旧集合。结果是，如果旧的集合被改变，则该改变反映在新的集合中。</p><p id="eed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面演示了在JavaScript中进行浅层复制时会发生什么:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3307" class="my lw it mu b gy mz na l nb nc">let grades = new Array(77, 88, 99);<br/>let grades1 = grades;<br/>grades[1] = 89;<br/>print(grades);<br/>print(grades1);</span></pre><p id="01ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序的输出是:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5f1a" class="my lw it mu b gy mz na l nb nc">77, 89, 99<br/>77, 89, 99</span></pre><p id="cfa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到grades1数组反映了grades数组中的变化。这就是浅拷贝的情况。</p><p id="6b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是用一个<em class="ms">深度拷贝</em>将一个集合拷贝到一个新集合。深层副本是旧集合到新集合的一个元素一个元素的赋值。以下是深层拷贝的计划模板:</p><p id="92c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">声明没有元素的新集合<br/> for i =索引旧集合的开始到索引旧集合的结束:<br/>将旧集合的I元素赋给新集合的k元素</em></p><p id="8917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何在JavaScript中使用该程序模板来创建深层副本:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f41d" class="my lw it mu b gy mz na l nb nc">let grades = new Array(77, 88, 99);<br/>let grades1 = new Array();<br/>for (let i = 0; i &lt; grades.length; i++) {<br/>  grades1[i] = grades[i];<br/>}<br/>grades[1] = 89;<br/>print(grades);<br/>print(grades1);</span></pre><p id="b5b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序的输出是:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="dbe4" class="my lw it mu b gy mz na l nb nc">77, 89, 99<br/>77, 88, 99</span></pre><p id="2131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明更改grades数组并不会更改grades1数组，因为grades1数组由于深度复制而没有引用grades数组。</p><p id="2ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中也存在同样的行为。除非您想要浅拷贝的行为，否则您应该总是制作列表的深拷贝。</p><p id="407c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">C++不允许你将一个数组赋给另一个数组，因为数组名是指向数组第一个元素的指针。您将需要使用一个函数来执行数组赋值，这将导致您总是制作数组的深层副本。</p><h1 id="03cf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">复制收藏时插入</h1><p id="7065" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">通常，您会想要复制一个集合，同时向该集合中插入新元素。该程序模板将旧集合中的元素复制到新集合中，直到插入点，然后将新元素添加到新数组的末尾。</p><p id="8015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在C++这样的语言中工作，数组的大小是固定的，并且如果您想要添加新元素，您将需要创建一个新的、更大的数组(假设您不想使用动态内存和指针)，则此模板非常有用。</p><p id="e4f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是模板伪代码:</p><p id="a27b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">当有元素要插入时，执行:<br/>从源集合复制到目标集合，直到插入点<br/>添加要插入到目标集合末尾的元素</em></p><p id="dc47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个问题，我们可以使用这个模板来解决。您有一个来自一个班级的十个成绩的数组，并且您决定要将另一个班级的十个成绩相加，这样您就可以计算两个班级的平均值。下面是一个C++解决方案:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="b008" class="my lw it mu b gy mz na l nb nc">int main()<br/>{<br/>  const int NUM_GRADES = 10;<br/>  int class_one[] = {91, 77, 74, 82, 98, 83, 77, 99, 80, 68};<br/>  int class_two[] = {84, 74, 88, 93, 100, 88, 62, 81, 93, 75};<br/>  int both_size = NUM_GRADES * 2;<br/>  int both_classes[both_size];<br/>  for (int i = 0; i &lt; NUM_GRADES; i++) {<br/>    both_classes[i] = class_one[i];<br/>  }<br/>  for (int i = NUM_GRADES, start = 0; i &lt; both_size;<br/>                                     i++, start++) {<br/>    both_classes[i] = class_two[start];<br/>  }<br/>  int total = 0;<br/>  for (int grade : both_classes) {<br/>    total += grade;<br/>  }<br/>  double average = static_cast&lt;double&gt;(total) / both_size;<br/>  cout &lt;&lt; "The average of both classes is: " &lt;&lt; average<br/>       &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="d40b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在C++中，更好的解决方案是使用向量而不是数组，尤其是当速度不是项目中最重要的因素时。向量可以很容易地增长和收缩，它们不会像过去那样影响性能。大多数编程专家现在强烈推荐使用向量而不是数组，除非访问速度至关重要。</p><p id="247b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用像Python这样的动态语言编写这个程序也容易得多，特别是因为Python允许列表连接。下面是上面用Python编写的程序:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="25e5" class="my lw it mu b gy mz na l nb nc">class_one = [91, 77, 74, 82, 98, 83, 77, 99, 80, 68]<br/>class_two = [84, 74, 88, 93, 100, 88, 62, 81, 93, 75]<br/>both_classes = class_one + class_two<br/>total = 0<br/>for i in range(0, len(both_classes)):<br/>  total = total + both_classes[i]<br/>average = total / len(both_classes)<br/>print("The average of the two classes is:", average)</span></pre><p id="b902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的C++学生讨厌看到这样的例子。</p><h1 id="b088" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">学习模板是发展专业技能的关键</h1><p id="2717" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我向我的学生灌输的一件事是，像本文中讨论的学习模板对于培养计算机程序员的专业技能至关重要。当一个程序员面临一个问题，并能迅速确定解决问题的合适模板时，他们就节省了时间，可以用来在项目中做更有创造性的工作，就像国际象棋大师使用他们的组块来帮助他们更快地走更好的棋。</p><p id="e123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想成为一名专家程序员，花时间学习和掌握程序模板。</p></div></div>    
</body>
</html>