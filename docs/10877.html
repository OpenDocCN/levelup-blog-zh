<html>
<head>
<title>Managing Docker Apps With Kubernetes Ingress Controller</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes入口控制器管理Docker应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/managing-docker-apps-with-kubernetes-ingress-controller-d20eef243940?source=collection_archive---------18-----------------------#2022-01-18">https://levelup.gitconnected.com/managing-docker-apps-with-kubernetes-ingress-controller-d20eef243940?source=collection_archive---------18-----------------------#2022-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ab4a5d400efacad8baee8e7617d0482f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SK6b5uuUxBxfnZmed6wRKA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@create4eyes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Olga subah</a>在<a class="ae jg" href="https://unsplash.com/s/photos/port?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="bb1b" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">在本教程中，学习如何使用Kubernetes部署Dockerized应用程序，使用入口控制器来公开容器的端口以供外部访问。</h2></div><p id="e8ef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回想一下您的开发团队何时切换到Dockerized容器。曾经需要虚拟机上多种服务的应用程序转变为由多个整洁的Docker容器组成的应用程序。虽然结果是一个精简的系统，过渡可能是令人生畏的。</p><p id="8a59" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，是时候进行另一次变革性的飞跃了:从一组容器转移到使用Kubernetes的副本集的高可用性、协调部署。这似乎是一个巨大的转变，但您可以通过使用开源入口控制器来简化您的任务，并提供可以根据您的需要定制的插件，从而减少道路上的颠簸。</p><p id="461e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本教程中，我们将从一个由三个容器组成的Dockerized应用程序开始:一个web服务器、一个数据库和一个键值存储。我们将介绍如何使用Kubernetes (K8s)部署这个应用程序，使用Kong的Kubernetes Ingress控制器(<a class="ae jg" href="https://docs.konghq.com/kubernetes-ingress-controller/" rel="noopener ugc nofollow" target="_blank">文档</a>)来公开容器的端口以供外部访问。最后，我们将熟悉如何用入口控制器设置一些<a class="ae jg" href="https://docs.konghq.com/hub/" rel="noopener ugc nofollow" target="_blank">孔插件</a>。</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h1 id="ddea" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">核心概念</h1><p id="582c" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">在我们开始之前，让我们简要地看一下我们的演练的一些核心概念。</p><h1 id="2fc1" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">码头工人</h1><p id="04af" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated"><a class="ae jg" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>通常用于平台即服务(PaaS)产品，通过将应用的各个部分隔离到容器中来进行应用开发。每个容器都是一个标准化的软件单元，可以独立运行。</p><p id="de6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，一个特定版本的PostgreSQL数据库可以完全在它自己的Docker容器中运行。该容器是标准的，可以在任何开发人员的机器上运行。不再有这样的问题，“为什么查询在我的机器上有效，而在你的机器上无效？您的环境设置是什么？”当您在Docker容器中运行应用程序服务时，您可以确保每个人都在相同的环境中运行相同的应用程序。</p><h1 id="20de" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">库伯内特斯(K8s)</h1><p id="a588" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">应用程序很快从单个Docker容器发展到多个容器一起工作的组合。人们可以使用类似于<a class="ae jg" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>的应用程序来部署多容器应用程序。</p><p id="6c64" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，下一步是将同一应用程序的多个副本协调为一个集群，将负载分布在集群内的副本节点上，并在单个应用程序节点出现故障时提供备用节点。今天这种编排和管理的事实标准是Kubernetes。许多云服务提供商——包括AWS、Azure和谷歌云——都提供Kubernetes。</p><h1 id="aff4" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">Kong Kubernetes入口控制器</h1><p id="0ecb" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated"><a class="ae jg" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口</a>是K8s的关键部分，管理外部对Kubernetes集群内部服务的访问。在一个集群中，web服务器容器可能会与数据库容器对话，但是如果外部世界不能与web服务器对话，那又有什么好处呢？在K8s中，与外界的通信需要一个<a class="ae jg" href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" rel="noopener ugc nofollow" target="_blank">入口控制器</a>。开源的Kong Kubernetes Ingress控制器围绕<a class="ae jg" href="https://konghq.com/kong/" rel="noopener ugc nofollow" target="_blank"> Kong Gateway </a>和Kong的各种插件来扮演这个关键角色。</p><h1 id="03e1" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">基本使用案例</h1><p id="2d8e" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">在我们的基本用例中，我们有一个由web服务器(NGINX)、数据库(PostgreSQL)和键值存储(Redis)组成的应用程序。这个应用程序通常作为三个Docker容器运行。我们需要将这个应用程序转移到K8s，但是我们需要设置一个入口，以便从K8s集群外部的<em class="mx">访问我们的服务。</em></p><h1 id="751f" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">我们的小型项目方法</h1><p id="87d2" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">对于我们的小型项目演练，我们将采用这种方法:</p><ol class=""><li id="cecb" class="my mz jj la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated">使用<a class="ae jg" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">Google Kubernetes Engine(GKE)</a>创建一个简单、低成本的K8s集群。</li><li id="9e1c" class="my mz jj la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">使用kubectl来配置集群，以部署我们的多容器应用程序。</li><li id="13b4" class="my mz jj la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">配置和集成<a class="ae jg" href="https://konghq.com/solutions/kubernetes-ingress/" rel="noopener ugc nofollow" target="_blank"> Kong Kubernetes入口控制器</a>，使我们能够从外部访问我们的应用服务。</li><li id="5944" class="my mz jj la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">添加一个用于支持的cert-manager，以及用于外部日志和请求路由的Kong插件。</li></ol><h1 id="6783" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">你需要什么</h1><p id="1a54" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">为了和我们一起完成这个演练，你需要一个谷歌云平台账户，它有一个初始的<a class="ae jg" href="https://cloud.google.com/free" rel="noopener ugc nofollow" target="_blank">免费层和一个初始使用信用</a>。</p><p id="3c1f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在您的本地机器上，您将需要在安装了以下工具的情况下舒适地使用命令行:</p><ul class=""><li id="c07a" class="my mz jj la b lb lc le lf lh na ll nb lp nc lt nm ne nf ng bi translated"><a class="ae jg" href="https://kubernetes.io/docs/tasks/tools/" rel="noopener ugc nofollow" target="_blank"> kubectl </a> —用于在K8s集群上运行配置命令</li><li id="9a55" class="my mz jj la b lb nh le ni lh nj ll nk lp nl lt nm ne nf ng bi translated"><a class="ae jg" href="https://cloud.google.com/sdk/docs/install" rel="noopener ugc nofollow" target="_blank"> Google Cloud SDK </a> —用于连接到您的GKE集群，使其成为您的kubectl环境</li></ul><p id="3466" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您准备好深入容器和集群了吗？开始了。</p><h1 id="91be" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">步骤1:创建GKE集群</h1><p id="8442" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">假设您已经设置了Google Cloud Platform帐户，导航到控制台，并通过左上方的项目列表下拉菜单创建一个新项目:</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/95839d10077ab3b756089e76a32a157e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*L1bzanq7C2XtfL82rnpIxQ.png"/></div></figure><p id="96d4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为项目选择一个名称(例如:<code class="fe no np nq nr b">k8s-with-kong</code>)并创建它。在该项目中，浏览左侧菜单边栏，找到“Kubernetes Engine → Clusters”</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/989f4b8518f4241368f1e0aa2fe02be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*GrEuP6z9z9uBfSXUJ_T88A.png"/></div></figure><p id="aa5d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在出现的页面上，点击“启用”按钮，在您的项目中使用GKE。这个过程可能需要一到两分钟，谷歌开始为您的项目做好一切。之后，您会发现自己在GKE的集群页面上。点击“创建”</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b89e1c79791fda3617c4039d0126ddc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*xGp-cIiIDVcVgyYxqYqqFA.png"/></div></figure><p id="d69b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选择配置“标准”集群。为您的集群设置一个名称，以及一个区域。</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/5dd38f871c48084d8486ccfc0e788d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*6S8dePovwtRWWOEZHfliuA.png"/></div></figure><p id="2cb8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，在左侧菜单栏中，找到“节点池”并单击“默认池:”</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/6b806e985d4234484e2d1ec505f74754.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*-N74ZsnMveAfzvDpGWq5aQ.png"/></div></figure><p id="2011" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于节点池，将大小设置为<code class="fe no np nq nr b">1</code>。</p><p id="9931" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将保持集群的资源使用量较小，因为这只是一个演示迷你项目。</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/32ed0ed288077f76a4cf1dc2c7ea8598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*RNuHEKbuYwRksqFwSoXPwQ.png"/></div></figure><p id="7a6d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击页面底部的“创建”。</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/2d6efdd5b8a0a2e49916449682f16ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*QnmXBw8TW3nA3zjJkBPVFA.png"/></div></figure><p id="1e61" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您的K8s群集将需要几分钟的时间来启动。</p><h1 id="b4cb" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">使用gcloud为kubectl配置集群访问</h1><p id="fdfb" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">随着我们的GKE集群的启动和运行，我们希望通过本地机器上的<code class="fe no np nq nr b">kubectl</code>来设置对集群的访问。为此，我们遵循这个<a class="ae jg" href="https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-access-for-kubectl" rel="noopener ugc nofollow" target="_blank"> GKE文档页面</a>上的简单步骤。</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="a23d" class="oc mb jj nr b gy od oe l of og">~$ gcloud init<br/># Follow the prompts to login to your Google Cloud account.<br/> <br/># Choose your cloud project (in our example: k8s-with-kong)<br/> <br/>Do you want to configure a default Compute Region and Zone? (Y/n)? n</span></pre><p id="399f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将生成一个<code class="fe no np nq nr b">kubeconfig</code>条目，对我们的GKE集群运行我们的<code class="fe no np nq nr b">kubectl</code>命令。对于此步骤，您将需要在创建集群时指定的集群名称和区域:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="b8ba" class="oc mb jj nr b gy od oe l of og">~$ gcloud container clusters get-credentials my-application --region=us-central1<br/>Fetching cluster endpoint and auth data.<br/>kubeconfig entry generated for my-application.</span></pre><p id="50e4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，我们可以开始通过<code class="fe no np nq nr b">kubectl</code>运行命令来配置我们的部署。</p><h1 id="f32a" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">步骤2:通过kubectl部署应用程序</h1><p id="3f18" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">为了部署我们的应用程序，我们需要创建一个<code class="fe no np nq nr b">deployment.yml</code>文件和一个<code class="fe no np nq nr b">service.yml</code>文件。<code class="fe no np nq nr b">deployment.yml</code>文件应该是这样的:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="f172" class="oc mb jj nr b gy od oe l of og">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: my-app<br/>  labels:<br/>    app: my-app<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: my-app<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: my-app<br/>    spec:<br/>      containers:<br/>        - name: server<br/>          image: nginx:1.19-alpine<br/>          imagePullPolicy: Always<br/>          ports:<br/>            - containerPort: 80<br/>        - name: postgres<br/>          image: postgres:13.2-alpine<br/>          imagePullPolicy: Always<br/>          env:<br/>            - name: POSTGRES_PASSWORD<br/>              value: postgrespassword<br/>          ports:<br/>            - containerPort: 5432<br/>        - name: redis<br/>          image: redis:6.2-alpine<br/>          imagePullPolicy: Always<br/>          ports:<br/>            - containerPort: 6379<br/>          command: ["redis-server"]<br/>          args: ["--requirepass", "redispassword"]</span></pre><p id="91ae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的部署将运行我们的应用程序的单个副本，它由三个容器组成。我们有一个<code class="fe no np nq nr b">nginx</code>网络服务器，我们称之为<code class="fe no np nq nr b">server</code>。服务器感兴趣的容器端口是端口<code class="fe no np nq nr b">80</code>。</p><p id="d601" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们有一个运行在名为<code class="fe no np nq nr b">postgres</code>的容器中的PostgreSQL数据库。这个数据库容器映像的默认用户是<code class="fe no np nq nr b">postgres</code>。我们还会将该用户的密码设置为<code class="fe no np nq nr b">postgres</code>。数据库容器的端口是<code class="fe no np nq nr b">5432</code>。</p><p id="7664" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们有Redis键值存储，它将在容器上公开端口<code class="fe no np nq nr b">6379</code>。在Redis服务器启动时，我们将密码设置为<code class="fe no np nq nr b">redis</code>。</p><p id="5b09" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">部署配置就绪后，让我们将其应用到集群中:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="b8d4" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f deployment.yml<br/>deployment.apps/my-app created</span></pre><p id="e3c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几分钟后，您可以验证您的部署是否已启动:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="f4a8" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl get deployment my-app<br/>NAME     READY   UP-TO-DATE   AVAILABLE   AGE<br/>my-app   1/1     1            1           3m15s<br/> <br/>~/project$ kubectl get pods<br/>NAME                      READY   STATUS    RESTARTS   AGE<br/>my-app-55db7c65f5-qjxs8   3/3     Running   0          4m16<br/> <br/>~/project$ kubectl logs my-app-55db7c65f5-qjxs8 server<br/>...<br/>Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf<br/>/docker-entrypoint.sh: Configuration complete; ready for start up<br/> <br/>~/project$ kubectl logs my-app-55db7c65f5-qjxs8 postgres<br/>... database system is ready to accept connections<br/> <br/>~/project$ kubectl logs my-app-55db7c65f5-qjxs8 redis<br/>... Ready to accept connections</span></pre><p id="c4b6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们需要配置<code class="fe no np nq nr b">service.yml</code>，以便集群容器上的端口可以从集群外部访问。</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="f229" class="oc mb jj nr b gy od oe l of og">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: my-app<br/>  labels:<br/>    app: my-app<br/>spec:<br/>  selector:<br/>    app: my-app<br/>  ports:<br/>  - name: server<br/>    port: 80<br/>    targetPort: 80<br/>  - name: postgres<br/>    protocol: TCP<br/>    port: 5432<br/>    targetPort: 5432<br/>  - name: redis<br/>    protocol: TCP<br/>    port: 6379<br/>    targetPort: 6379</span></pre><p id="1ffc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们配置了一个<a class="ae jg" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> K8s服务</a>，将pod上的传入端口映射到pod中各个容器上的目标端口。为简单起见，我们将对<code class="fe no np nq nr b">port</code>和<code class="fe no np nq nr b">targetPort</code>使用相同的值。如果我们可以获得对K8s pod上的端口<code class="fe no np nq nr b">80</code>的请求，该请求将被发送到服务器容器(我们的<code class="fe no np nq nr b">nginx</code>容器)的端口<code class="fe no np nq nr b">80</code>。类似地，对端口<code class="fe no np nq nr b">5432</code>的请求将被映射到我们<code class="fe no np nq nr b">postgres</code>容器上的端口<code class="fe no np nq nr b">5432</code>，而对端口<code class="fe no np nq nr b">6379</code>的请求将被映射到我们<code class="fe no np nq nr b">redis</code>容器上的端口<code class="fe no np nq nr b">6379</code>。</p><p id="e60f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用这个新的服务配置来更新我们的集群:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="337e" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f service.yml<br/>service/my-app created</span></pre><p id="7ab2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">稍后，我们可以检查我们的配置是否就绪:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="4239" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl describe service my-app<br/>Name:              my-app<br/>Namespace:         default<br/>Labels:            app=my-app<br/>Annotations:       cloud.google.com/neg: {"ingress":true}<br/>Selector:          app=my-app<br/>Type:              ClusterIP<br/>IP Families:       &lt;none&gt;<br/>IP:                10.72.128.227<br/>IPs:               &lt;none&gt;<br/>Port:              server  80/TCP<br/>TargetPort:        80/TCP<br/>Endpoints:         10.72.0.130:80<br/>Port:              postgres  5432/TCP<br/>TargetPort:        5432/TCP<br/>Endpoints:         10.72.0.130:5432<br/>Port:              redis  6379/TCP<br/>TargetPort:        6379/TCP<br/>Endpoints:         10.72.0.130:6379<br/>Session Affinity:  None<br/>Events:            &lt;none&gt;</span></pre><p id="4769" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一切都很好，但是您可能会注意到，通过查看端点IP地址，虽然我们的端口都是公开和映射的，但我们仍然在私有网络中工作。我们需要将整个K8s集群暴露给外界。为此，我们需要一个入口控制器。进入孔。</p><h1 id="3f46" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">步骤3:配置Kong的Kubernetes入口控制器</h1><p id="6d49" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">配置Kong的入口控制器相当简单。让我们一步一步来。</p><h1 id="0584" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">将Kong Kubernetes入口控制器部署到GKE</h1><p id="cbbe" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">根据<a class="ae jg" href="https://docs.konghq.com/kubernetes-ingress-controller/1.3.x/deployment/gke/" rel="noopener ugc nofollow" target="_blank"> Kong关于Kong入口控制器和GKE </a>的文档页面，我们首先需要创建一个<code class="fe no np nq nr b">ClusterRoleBinding</code>来对我们即将进行的一些GKE集群配置进行适当的管理访问。用以下内容创建一个名为<code class="fe no np nq nr b">gke-role-binding.yml</code>的文件:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="6af0" class="oc mb jj nr b gy od oe l of og">apiVersion: rbac.authorization.k8s.io/v1<br/>kind: ClusterRoleBinding<br/>metadata:<br/>  name: cluster-admin-user<br/>roleRef:<br/>  apiGroup: rbac.authorization.k8s.io<br/>  kind: ClusterRole<br/>  name: cluster-admin<br/>subjects:<br/>  - kind: User<br/>    name: [YOUR GOOGLE CLOUD ACCOUNT EMAIL ADDRESS]<br/>    namespace: kube-system</span></pre><p id="b888" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们应用这个角色绑定:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="dc67" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f gke-role-binding.yml<br/>clusterrolebinding.rbac.authorization.k8s.io/cluster-admin-user created</span></pre><p id="2bfe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们部署入口控制器，使用部署和服务配置文件，该文件是Kong定制编写的，并在此处<a class="ae jg" href="https://bit.ly/k4k8s" rel="noopener ugc nofollow" target="_blank">提供</a>。</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="16ec" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f https://bit.ly/k4k8s<br/>namespace/kong created<br/> <br/>...<br/> <br/>service/kong-proxy created<br/>service/kong-validation-webhook created<br/>deployment.apps/ingress-kong created</span></pre><p id="e99b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查入口控制器是否已部署。对<code class="fe no np nq nr b">kong-proxy EXTERNAL_IP</code>进行设置可能需要一分钟时间:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="e586" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl get services -n kong<br/>NAME                  TYPE          CLUSTER-IP     EXTERNAL-IP    PORT(S)                     AGE<br/>kong-proxy            LoadBalancer  10.72.130.214  34.71.43.9     80:32594/TCP,443:30982/TCP  71s<br/>kong-validation-webhook  ClusterIP  10.72.130.92   &lt;none&gt;         443/TCP                     70s</span></pre><p id="12f7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们设置一个环境变量<code class="fe no np nq nr b">PROXY_IP</code>，来保存与Kong代理相关联的IP地址。</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="cefd" class="oc mb jj nr b gy od oe l of og">~/project$ export PROXY_IP=$(kubectl get -o \<br/>jsonpath="{.status.loadBalancer.ingress[0].ip}" \<br/>service -n kong kong-proxy)<br/> <br/>~/project$ echo $PROXY_IP<br/>34.71.43.9   # Your IP address will differ<br/> <br/>~/project$ curl -i $PROXY_IP<br/>HTTP/1.1 404 Not Found<br/>Date: Tue, 18 May 2021 04:51:48 GMT<br/>Content-Type: application/json; charset=utf-8<br/>Connection: keep-alive<br/>Content-Length: 48<br/>X-Kong-Response-Latency: 1<br/>Server: kong/2.3.3<br/> <br/>{"message":"no Route matched with those values"}</span></pre><p id="7b43" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">非常好。我们的Kong Kubernetes入口控制器已部署，可在<code class="fe no np nq nr b">PROXY_IP</code>到达。只需要为正确的请求路由进行配置。</p><h1 id="a004" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">添加入口以将HTTP请求映射到Web服务器</h1><p id="2c96" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">接下来，让我们配置Kong Kubernetes入口控制器来监听到根<code class="fe no np nq nr b">/</code>路径的HTTP请求，然后将这些请求映射到我们的K8s服务的端口<code class="fe no np nq nr b">80</code>(将该请求映射到NGINX <code class="fe no np nq nr b">server</code>容器的端口<code class="fe no np nq nr b">80</code>)。我们将创建一个名为<code class="fe no np nq nr b">http-ingress.yml</code>的文件:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="fbb0" class="oc mb jj nr b gy od oe l of og">apiVersion: networking.k8s.io/v1<br/>kind: Ingress<br/>metadata:<br/>  name: my-app<br/>  annotations:<br/>    konghq.com/strip-path: "true"<br/>    kubernetes.io/ingress.class: kong<br/>spec:<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /<br/>        pathType: Prefix<br/>        backend:<br/>          service:<br/>            name: my-app<br/>            port:<br/>              number: 80</span></pre><p id="caa3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应用入口配置:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="094a" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f http-ingress.yml<br/>ingress.networking.k8s.io/my-app created</span></pre><p id="73fc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们执行一个<code class="fe no np nq nr b">curl</code>请求。结果如下:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="c36e" class="oc mb jj nr b gy od oe l of og">~/project$ curl $PROXY_IP<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>...</span></pre><p id="d314" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有用！我们已经成功地配置了Kong Kubernetes入口控制器来接收HTTP请求，并通过K8s服务将它们映射到NGINX容器上。</p><p id="8c5e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想通过TCP连接而不是HTTP请求与容器和端口对话，该怎么办？为此，我们将使用<a class="ae jg" href="https://docs.konghq.com/kubernetes-ingress-controller/1.2.x/guides/using-tcpingress/" rel="noopener ugc nofollow" target="_blank">孔的自定义TCP press</a>。</p><h1 id="4e53" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">添加TCPIngress以映射连接请求</h1><p id="24ff" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">默认情况下，通过Kong Kubernetes入口控制器设置的Kong代理服务监听端口<code class="fe no np nq nr b">80</code>和<code class="fe no np nq nr b">443</code>。这就是为什么我们能够配置我们的入口来将HTTP请求映射到我们的NGINX服务器，因为HTTP请求默认情况下会到达端口<code class="fe no np nq nr b">80</code>。</p><p id="8121" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我们的用例，我们需要Kong在几个额外的端口上监听TCP流量，这些端口将用于Postgres和Redis连接。之前，我们通过应用Kong提供的自定义配置<a class="ae jg" href="https://bit.ly/k4k8s" rel="noopener ugc nofollow" target="_blank">部署了Kong Kubernetes入口控制器。现在，我们想对该配置应用两个补丁，以满足我们特定的TCP流需求。</a></p><p id="0e46" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，创建一个名为<code class="fe no np nq nr b">patch-kong-deployment.yml</code>的文件，包含以下内容:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="a924" class="oc mb jj nr b gy od oe l of og">spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        - name: proxy<br/>          env:<br/>            - name: KONG_STREAM_LISTEN<br/>              value: "0.0.0.0:11111, 0.0.0.0:22222"<br/>          ports:<br/>            - containerPort: 11111<br/>              name: postgres-listen<br/>              protocol: TCP<br/>            - containerPort: 22222<br/>              name: redis-listen<br/>              protocol: TCP</span></pre><p id="4ca6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们配置Kong的TCP流来监听端口<code class="fe no np nq nr b">11111</code>(我们将用于postgres连接)和<code class="fe no np nq nr b">22222</code>(我们将用于Redis连接)。接下来，创建一个名为<code class="fe no np nq nr b">patch-kong-service.yml</code>的文件，包含以下内容:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="0c98" class="oc mb jj nr b gy od oe l of og">spec:<br/>  ports:<br/>    - name: postgres-listen<br/>      port: 11111<br/>      protocol: TCP<br/>      targetPort: 11111<br/>    - name: redis-listen<br/>      port: 22222<br/>      protocol: TCP<br/>      targetPort: 22222</span></pre><p id="bf12" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此补丁修改了Kong Kubernetes Ingress控制器相关的K8s服务，暴露了我们需要的端口。现在，我们应用这两个补丁:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="906b" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl patch deploy -n kong ingress-kong \<br/>--patch-file=patch-kong-deployment.yml<br/>deployment.apps/ingress-kong patched<br/> <br/>~/project$ kubectl patch service -n kong kong-proxy \<br/>--patch-file=patch-kong-service.yml<br/>service/kong-proxy patched</span></pre><p id="8803" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经为Kong打好了补丁，让它在正确的端口上监听TCP连接，让我们配置我们的TCPIngress资源。创建一个名为<code class="fe no np nq nr b">tcp-ingress.yml</code>的文件:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="a0e4" class="oc mb jj nr b gy od oe l of og">apiVersion: configuration.konghq.com/v1beta1<br/>kind: TCPIngress<br/>metadata:<br/>  name: my-app<br/>  annotations:<br/>    kubernetes.io/ingress.class: kong<br/>spec:<br/>  rules:<br/>  - port: 11111<br/>    backend:<br/>      serviceName: my-app<br/>      servicePort: 5432<br/>  - port: 22222<br/>    backend:<br/>      serviceName: my-app<br/>      servicePort: 6379</span></pre><p id="a762" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该配置监听端口<code class="fe no np nq nr b">11111</code>上的TCP流量。它在端口<code class="fe no np nq nr b">5432</code>将流量转发给我们的K8s服务。您可能还记得，该服务将端口<code class="fe no np nq nr b">5432</code>的流量映射到端口<code class="fe no np nq nr b">5432</code>的<code class="fe no np nq nr b">postgres</code>容器。类似地，我们的TCPIngress将端口<code class="fe no np nq nr b">22222</code>上的流量转发到我们服务的端口<code class="fe no np nq nr b">6379</code>，该流量随后到达端口<code class="fe no np nq nr b">6379</code>上的<code class="fe no np nq nr b">redis</code>容器。</p><p id="5d2b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们应用这个配置:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="6854" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f tcp-ingress.yml<br/>tcpingress.configuration.konghq.com/my-app created</span></pre><p id="b4c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那应该是所有的了。现在，我们来测试一下。</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="70dc" class="oc mb jj nr b gy od oe l of og">~/project$ psql -h $PROXY_IP -p 11111 -U postgres<br/>Password for user postgres: postgrespassword<br/>psql (13.2 (Ubuntu 13.2-1.pgdg16.04+1))<br/>Type "help" for help.<br/> <br/>postgres=#</span></pre><p id="bd84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们能够连接到<code class="fe no np nq nr b">postgres</code>容器！现在，让我们试试Redis:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="aeb2" class="oc mb jj nr b gy od oe l of og">~/project$ redis-cli -h $PROXY_IP -p 22222 -a redispassword<br/>34.71.43.9:22222&gt;</span></pre><p id="fc06" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们进去了。我们已经成功地配置了Kong Kubernetes入口控制器，将我们的HTTP请求映射到web服务器，并将我们的TCP连接映射到数据库和键值存储。在这一点上，你应该有相当的基础，为自己的业务需求量身定制孔Kubernetes入口控制器。</p><p id="5e8a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们结束我们的演练之前，让我们通过将一些插件与我们的入口控制器集成来做一点试验。</p><h1 id="4647" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">步骤4:将插件与入口控制器集成</h1><h1 id="0b98" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">证书管理和HTTPS</h1><p id="2645" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">我们将从配置入口控制器来使用<code class="fe no np nq nr b">cert-manager</code>开始，它管理SSL证书的部署。这将使我们的NGINX网络服务器可以通过HTTPS访问。</p><h2 id="426d" class="oc mb jj bd mc oh oi dn mg oj ok dp mk lh ol om mm ll on oo mo lp op oq mq or bi translated">将<code class="fe no np nq nr b">cert-manager</code>安装到GKE仪表组上</h2><p id="f9b9" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">为了安装<code class="fe no np nq nr b">cert-manager</code>，我们遵循<a class="ae jg" href="https://cert-manager.io/docs/installation/kubernetes/" rel="noopener ugc nofollow" target="_blank"> Kubernetes文档页面</a>上概述的步骤。文档步骤提到，如果您使用GKE，则为集群管理访问创建一个ClusterRoleBinding。但是，我们在本演练的前面已经这样做了。</p><p id="0aec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们使用cert-manager将<code class="fe no np nq nr b">CustomResourceDefinition</code>安装到我们的集群，然后我们验证安装:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="c72f" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f \<br/>https://github.com/jetstack/cert-manager/releases/download/v1.3.1/cert-manager.yaml<br/> <br/>~/project$ kubectl get pods --namespace cert-manager<br/>NAME                                      READY  STATUS   RESTARTS  AGE<br/>cert-manager-7c5c945df9-5rvj5             1/1    Running  0          1m<br/>cert-manager-cainjector-7c67689588-n7db6  1/1    Running  0          1m<br/>cert-manager-webhook-5759dc48f-cfwd6      1/1    Running  0          1m</span></pre><h2 id="cead" class="oc mb jj bd mc oh oi dn mg oj ok dp mk lh ol om mm ll on oo mo lp op oq mq or bi translated">设置域名指向<code class="fe no np nq nr b">kong-proxy</code> IP</h2><p id="8fbf" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">您会记得，我们将我们的<code class="fe no np nq nr b">kong-proxy</code> IP地址存储为<code class="fe no np nq nr b">PROXY_IP</code>。假设您拥有对某个域名的控制权，添加一个将您的域名解析为<code class="fe no np nq nr b">PROXY_IP</code>的DNS记录。对于这个例子，我向我的域(<code class="fe no np nq nr b">codingplus.coffee</code>)添加了一个A记录，它将子域<code class="fe no np nq nr b">kong-k8s.codingplus.coffee</code>解析为我的<code class="fe no np nq nr b">kong-proxy</code> IP地址。</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/939689c58c9497801a0071cb60436fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUB075tE0BuCzAe3y-p7mg.png"/></div></div></figure><p id="3af7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正确解析子域后，我们需要修改http-ingress.yml文件，为http请求指定一个主机，而不仅仅是使用一个IP地址。当然，您将使用您已经配置的域名:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="1dbc" class="oc mb jj nr b gy od oe l of og">apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: my-app<br/>  annotations:<br/>    konghq.com/strip-path: "true"<br/>    kubernetes.io/ingress.class: kong<br/>spec:<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /<br/>        backend:<br/>          serviceName: my-app<br/>          servicePort: 80<br/>    host: kong-k8s.codingplus.coffee</span></pre><p id="8a52" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们应用更新的<code class="fe no np nq nr b">http-ingress.yml</code>文件:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="a78a" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f http-ingress.yml<br/>ingress.networking.k8s.io/my-app configured</span></pre><p id="de10" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们使用我们的域名的curl请求到达NGINX服务器:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="99d1" class="oc mb jj nr b gy od oe l of og">~/project$ curl http://kong-k8s.codingplus.coffee<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>...</span></pre><h2 id="3eea" class="oc mb jj bd mc oh oi dn mg oj ok dp mk lh ol om mm ll on oo mo lp op oq mq or bi translated">请求SSL证书</h2><p id="f0f5" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">接下来，我们为cert-manager创建一个ClusterIssuer资源。创建一个名为<code class="fe no np nq nr b">cluster-issuer.yml</code>的文件，包含以下内容(替换为您自己的电子邮件地址):</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="3989" class="oc mb jj nr b gy od oe l of og">apiVersion: cert-manager.io/v1alpha2<br/>kind: ClusterIssuer<br/>metadata:<br/>  name: letsencrypt-prod<br/>  namespace: cert-manager<br/>spec:<br/>  acme:<br/>    email: [YOUR EMAIL ADDRESS]<br/>    privateKeySecretRef:<br/>      name: letsencrypt-prod<br/>    server: https://acme-v02.api.letsencrypt.org/directory<br/>    solvers:<br/>    - http01:<br/>        ingress:<br/>          class: kong</span></pre><p id="500f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建此资源:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="ef50" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f cluster-issuer.yml<br/>clusterissuer.cert-manager.io/letsencrypt-prod created</span></pre><p id="d190" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们想再次更新<code class="fe no np nq nr b">http-ingress.yml</code>以提供一个证书并使用它:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="c64d" class="oc mb jj nr b gy od oe l of og">apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: my-app<br/>  annotations:<br/>    konghq.com/strip-path: "true"<br/>    kubernetes.io/ingress.class: kong<br/>    kubernetes.io/tls-acme: "true"<br/>    cert-manager.io/cluster-issuer: letsencrypt-prod<br/>spec:<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /<br/>        backend:<br/>          serviceName: my-app<br/>          servicePort: 80<br/>    host: kong-k8s.codingplus.coffee<br/>  tls:<br/>  - secretName: my-ssl-cert-secret<br/>    hosts:<br/>    - kong-k8s.codingplus.coffee</span></pre><p id="ede1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们应用更新的<code class="fe no np nq nr b">http-ingress.yml</code>清单:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="a845" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl get certificates<br/>NAME                 READY   SECRET               AGE<br/>my-ssl-cert-secret   True    my-ssl-cert-secret   24s</span></pre><p id="e02a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的证书已准备好。现在，我们可以使用HTTPS发送请求:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="90d7" class="oc mb jj nr b gy od oe l of og">~/project$ curl https://kong-k8s.codingplus.coffee<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br/>...</span></pre><h1 id="f564" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">步骤5:添加插件</h1><h1 id="5b6e" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">集成孔的HTTP日志插件</h1><p id="ecec" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">接下来，让我们配置我们的入口控制器使用一个Kong插件。我们将使用<a class="ae jg" href="https://docs.konghq.com/hub/kong-inc/http-log/" rel="noopener ugc nofollow" target="_blank"> HTTP日志插件</a>，它记录对单独的HTTP服务器的请求和响应。</p><h2 id="2f67" class="oc mb jj bd mc oh oi dn mg oj ok dp mk lh ol om mm ll on oo mo lp op oq mq or bi translated">创建一个Mockbin来接收日志数据</h2><p id="f965" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">我们将使用<a class="ae jg" href="https://mockbin.org/" rel="noopener ugc nofollow" target="_blank"> Mockbin </a>，它给我们一个端点来告诉我们的插件发送它的数据。在Mockbin，通过简单的步骤创建一个新的bin。你最终会得到一个唯一的链接。</p><h2 id="4ab7" class="oc mb jj bd mc oh oi dn mg oj ok dp mk lh ol om mm ll on oo mo lp op oq mq or bi translated">创建HTTP日志插件资源</h2><p id="507f" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">用以下内容创建一个名为<code class="fe no np nq nr b">http-log-plugin.yml</code>的文件。确保使用您自己的Mockbin端点URL:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="2494" class="oc mb jj nr b gy od oe l of og">apiVersion: configuration.konghq.com/v1<br/>kind: KongPlugin<br/>metadata:<br/>  name: http-log-plugin<br/>plugin: http-log<br/>config:<br/>  http_endpoint: https://mockbin.org/bin/ENTER-YOUR-OWN-BIN-ID-HERE<br/>  method: POST</span></pre><p id="13de" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用此清单文件创建插件:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="319d" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f http-log-plugin.yml<br/>kongplugin.configuration.konghq.com/add-http-log-plugin created</span></pre><h2 id="27cb" class="oc mb jj bd mc oh oi dn mg oj ok dp mk lh ol om mm ll on oo mo lp op oq mq or bi translated">更新入口清单</h2><p id="1974" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">接下来，我们将再次更新<code class="fe no np nq nr b">http-ingress.yml</code>，确保我们的入口控制器知道使用我们的新插件，因为它处理对Nginx服务器的HTTP请求:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="0189" class="oc mb jj nr b gy od oe l of og">apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: my-app<br/>  annotations:<br/>    konghq.com/strip-path: "true"<br/>    kubernetes.io/ingress.class: kong<br/>    kubernetes.io/tls-acme: "true"<br/>    cert-manager.io/cluster-issuer: letsencrypt-prod<br/>    konghq.com/plugins: "http-log-plugin&lt;strong&gt;"&lt;/strong&gt;<br/>...</span></pre><p id="1470" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">应用更新的文件:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="1cf9" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f http-ingress.yml<br/>ingress.networking.k8s.io/my-app configured</span></pre><h2 id="109f" class="oc mb jj bd mc oh oi dn mg oj ok dp mk lh ol om mm ll on oo mo lp op oq mq or bi translated">发送请求并检查Mockbin</h2><p id="8c9c" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">现在我们已经添加了插件，我们可以向web服务器发送另一个请求:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="2d58" class="oc mb jj nr b gy od oe l of og">~/project$ curl <a class="ae jg" href="https://kong-k8s.codingplus.coffee" rel="noopener ugc nofollow" target="_blank">https://kong-k8s.codingplus.coffee</a></span></pre><p id="303e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在Mockbin查看我们bin的请求历史。我们看到我们最近的<a class="ae jg" href="https://mockbin.org/bin/d0db7354-f749-4d69-91e4-1046598c0cd0/log#entry-2" rel="noopener ugc nofollow" target="_blank">请求被发布到了Mockbin </a>上，同时在Mockbin请求体中还有关于我们请求的数据:</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/36d651f8525ce8a49934a172b19d276d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y6Cn8hVMh-QOWGbgV113vA.png"/></div></div></figure><p id="c3fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看起来我们的HTTP日志插件已经启动并运行了！</p><h1 id="1bab" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">集成孔的关联ID插件</h1><p id="0a49" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">最后，我们将集成一个Kong插件:<a class="ae jg" href="https://docs.konghq.com/hub/kong-inc/correlation-id/" rel="noopener ugc nofollow" target="_blank"> Correlation ID </a>。这个插件为每个请求的标题附加一个唯一的值(通常是一个UUID)。首先，我们创建关联ID插件资源。创建一个名为<code class="fe no np nq nr b">correlation-id-plugin.yml</code>的文件:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="b298" class="oc mb jj nr b gy od oe l of og">apiVersion: configuration.konghq.com/v1<br/>kind: KongPlugin<br/>metadata:<br/>  name: correlation-id-plugin<br/>plugin: correlation-id<br/>config:<br/>  header_name: my-unique-id<br/>  generator: uuid<br/>  echo_downstream: false</span></pre><p id="cdf3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的插件配置中，我们给所有请求添加了一个名为<code class="fe no np nq nr b">my-unique-id</code>的标题。它将包含一个UUID。安装插件:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="a33d" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f correlation-id-plugin.yml<br/>kongplugin.configuration.konghq.com/add-correlation-id-plugin configured</span></pre><p id="5c5c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将插件和HTTP日志插件一起添加到我们的<code class="fe no np nq nr b">http-ingress.yml</code>清单中:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="20cb" class="oc mb jj nr b gy od oe l of og">apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: my-app<br/>  annotations:<br/>    konghq.com/strip-path: "true"<br/>    kubernetes.io/ingress.class: kong<br/>    kubernetes.io/tls-acme: "true"<br/>    cert-manager.io/cluster-issuer: letsencrypt-prod<br/>    konghq.com/plugins: "http-log-plugin,correlation-id-plugin"<br/>...</span></pre><p id="7448" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将更改应用到入口控制器:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="8f0e" class="oc mb jj nr b gy od oe l of og">~/project$ kubectl apply -f http-ingress.yml<br/>ingress.networking.k8s.io/my-app configured</span></pre><p id="4288" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">配置好插件后，我们发送另一个curl请求:</p><pre class="lu lv lw lx gt ny nr nz oa aw ob bi"><span id="2015" class="oc mb jj nr b gy od oe l of og">~/project$ curl <a class="ae jg" href="https://kong-k8s.codingplus.coffee" rel="noopener ugc nofollow" target="_blank">https://kong-k8s.codingplus.coffee</a></span></pre><p id="00b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，我们检查我们的<a class="ae jg" href="https://mockbin.org/bin/d0db7354-f749-4d69-91e4-1046598c0cd0/log#entry-5" rel="noopener ugc nofollow" target="_blank"> Mockbin历史以获得最新的请求</a>。这一次，当我们仔细查看标题时，我们看到了<code class="fe no np nq nr b">my-unique-id</code>，它来自我们的关联ID插件。</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/456e7a9394f8c06de4e06767c3c1ba52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*ackpb14UEgDi63v5bUqs_Q.png"/></div></figure><p id="702c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">成功！我们的关联ID插件正在工作！</p><h1 id="cc30" class="ma mb jj bd mc md me mf mg mh mi mj mk kp ml kq mm ks mn kt mo kv mp kw mq mr bi translated">结论</h1><p id="9570" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">在本演练中，我们已经介绍了很多内容。我们从一个由三个Docker容器组成的简单应用程序开始。一步一步地，我们用Kubernetes部署了我们的容器，并且我们部署了开源的Kong Kubernetes入口控制器来管理对我们集群的容器的外部访问。最后，我们通过集成cert-manager for支持和一些Kong插件进一步定制了我们的入口控制器。</p><p id="d2ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，在Kong的Kubernetes Ingress控制器的帮助下，您现在就有了将Dockerized应用程序部署到Kubernetes的全面基础。您已经准备好根据自己的业务应用程序需求定制您的部署。</p><p id="17a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">【本文原载<a class="ae jg" href="https://konghq.com/blog/docker-kubernetes-ingress-controller/" rel="noopener ugc nofollow" target="_blank">此处</a>。]</p></div></div>    
</body>
</html>