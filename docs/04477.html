<html>
<head>
<title>Unit Testing Using Mocking in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中使用模拟的单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-testing-using-mocking-in-go-f281122f499f?source=collection_archive---------3-----------------------#2020-06-29">https://levelup.gitconnected.com/unit-testing-using-mocking-in-go-f281122f499f?source=collection_archive---------3-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8b85cac14dc41f7e7e5f8e724e661d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DjmCfyJMoi5_WdJN"/></div></div></figure><h1 id="9955" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">概念概述</h1><p id="ccad" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">(如果你知道什么是单元测试和模拟，只是想看看它是如何在代码层面上完成的，可以跳过这一节🙂)</p><p id="4a2f" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu"> <em class="lx">单元测试</em> </strong>在Go或者一般的单元测试中，就是简单的对我们代码中的一个单元进行测试。单元是系统中可以逻辑隔离的最小代码片段。在大多数编程语言中，它是一个函数、子例程或属性。单元测试的目的是验证代码中的每个单元都按照设计执行。</p><p id="b8ac" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在，在一个工业级代码中，我们想要测试的每一个单元，可能有也可能没有对其他单元/方法/功能的外部依赖。在案例中，我们有一些外部依赖的概念，<strong class="lb iu"> <em class="lx">嘲讽</em> </strong>发挥作用。</p><p id="5e67" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu"> <em class="lx">嘲讽</em> </strong>是当被测单元存在外部依赖时，在单元测试中使用的过程。模仿的目的是隔离并关注被测试的代码，而不是外部依赖的行为或状态。在mocking中，依赖关系被模拟真实对象行为的严密控制的替换对象所取代。替换对象可以有三种类型:<em class="lx">假货、存根</em>和<em class="lx">仿制品。</em></p><p id="27c7" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">一个<strong class="lb iu"> <em class="lx">假的</em> </strong>是一个对象，它将通过实现相同的接口来替换实际的代码，但不与其他对象交互。通常假的是硬编码返回固定的结果。</p><p id="9b31" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">一个<strong class="lb iu"> <em class="lx"> Stub </em> </strong>是一个基于一组特定输入返回特定结果的对象，通常不会对测试编程之外的任何事情做出响应。</p><p id="440b" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">一个<strong class="lb iu"> <em class="lx"> Mock </em> </strong>是一个更加复杂的存根版本。它仍然会像存根一样返回值，但是它也可以根据每个方法应该被调用多少次、以什么顺序和用什么数据来编程。</p><p id="2758" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">最初，模仿可能听起来有点乏味和耗时，但是在现有模仿框架的帮助下可以很容易地实现。在我下面提供的例子中，我在golang中使用了<strong class="lb iu"> <em class="lx"> go-mock </em> </strong>框架，只用一行命令就生成了整个接口的模拟对象。</p><p id="98e4" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">那么，现在你对什么是单元测试以及如何使用mocking来完成单元测试有了一个基本的概念，让我们在编码教程的帮助下将这些概念形象化。这里需要注意的一点是，在下面的例子中，我已经为那些作为接口一部分的函数编写了测试用例。在这种情况下，模拟生成变得很容易。因此，将函数包装在一个接口中总是一个好的选择。</p><h1 id="14be" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">安装指南</h1><p id="ff70" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">首先，让我们直接为您的go函数安装一个像样的模拟生成器。我们将使用<strong class="lb iu"> <em class="lx"> mockgen </em> </strong>代码生成工具进行同样的操作。此外，我们将使用<strong class="lb iu"> <em class="lx"> gomock </em> </strong>包作为编写单元测试用例的辅助工具。</p><p id="d1eb" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这两个都可以使用<em class="lx"> go get </em>进行安装:</p><ul class=""><li id="0541" class="md me it lb b lc ly lg lz lk mf lo mg ls mh lw mi mj mk ml bi translated">去找github.com/golang/mock/gomock</li><li id="cdc4" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">去找github.com/golang/mock/mockgen</li></ul><p id="cca5" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">要检查mockgen二进制文件是否安装正确，只需运行以下命令:</p><ul class=""><li id="bdfc" class="md me it lb b lc ly lg lz lk mf lo mg ls mh lw mi mj mk ml bi translated">$GOPATH/bin/mockgen</li></ul><p id="745b" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="lx">注意:如果您还没有将$GOPATH/bin添加到您的$PATH os环境变量中，请执行相同的操作。否则，在使用这个二进制文件时，你必须总是提到它的完整路径。</em></p><h1 id="c723" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">编码教程</h1><p id="3b76" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">由于这只是一个教程，让我们保持简单。让我们假设一辆接口车:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="305e" class="na kc it mw b gy nb nc l nd ne">type CAR interface {</span><span id="d02f" class="na kc it mw b gy nf nc l nd ne">   Start(*gin.Context, string, CAR) bool</span><span id="a56f" class="na kc it mw b gy nf nc l nd ne">   EngineCheck(*gin.Context, CAR) bool</span><span id="9205" class="na kc it mw b gy nf nc l nd ne">}</span><span id="1662" class="na kc it mw b gy nf nc l nd ne">type CARSTRUCT struct {<br/>}</span><span id="163a" class="na kc it mw b gy nf nc l nd ne">func (car CARSTRUCT) Start(context *gin.Context, key string, carInterface CAR) bool {</span><span id="7bdb" class="na kc it mw b gy nf nc l nd ne">   if carInterface.EngineCheck(context,carInterface) {<br/>      if key == "carkey" {<br/>         fmt.Println("Let's start the car!")<br/>         return <em class="lx">true<br/>      </em>} else {<br/>         fmt.Println("You don't have the right key!")<br/>         return <em class="lx">false<br/>      </em>}<br/>   } else {<br/>      return <em class="lx">false<br/>   </em>}<br/>}</span><span id="5936" class="na kc it mw b gy nf nc l nd ne">func (car CARSTRUCT) EngineCheck(context *gin.Context, carInterface CAR) bool {<br/>   return <em class="lx">true<br/></em>}</span></pre><p id="a2cc" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">首先让我们使用mockgen生成这个接口的模拟。只需运行以下命令:</p><p id="ba01" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu"><em class="lx">mock gen-destination = Mocks/mock _ car . go-package = Mocks-source = cars . go</em></strong></p><p id="ecf7" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">确保你创建了一个目录来存储你的模拟文件(<em class="lx">模拟</em>)。<em class="lx"> destination </em>是这个目录(Mocks/mock_car.go)的位置，<em class="lx"> package </em>是生成的模拟文件的包名，<em class="lx"> source </em>是你希望模拟的接口所在的文件的位置。</p><p id="7de1" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">生成的模拟文件如下所示:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0336" class="na kc it mw b gy nb nc l nd ne">// Code generated by MockGen. DO NOT EDIT.<br/>// Source: cars.go<br/>// Package Mocks is a generated GoMock package.<br/>package Mocks<br/>import (<br/>   gin "github.com/gin-gonic/gin"<br/>   gomock "github.com/golang/mock/gomock"<br/>   testing "middleware/middleware/testing"<br/>   reflect "reflect"<br/>)<br/>// MockCAR is a mock of CAR interface<br/>type MockCAR struct {<br/>   ctrl *gomock.Controller<br/>   recorder *MockCARMockRecorder<br/>}<br/>// MockCARMockRecorder is the mock recorder for MockCAR<br/>type MockCARMockRecorder struct {<br/>   mock *MockCAR<br/>}<br/>// NewMockCAR creates a new mock instance<br/>func NewMockCAR(ctrl *gomock.Controller) *MockCAR {<br/>   mock := &amp;MockCAR{ctrl: ctrl}<br/>   mock.recorder = &amp;MockCARMockRecorder{mock}<br/>   return mock<br/>}<br/>// EXPECT returns an object that allows the caller to indicate expected use<br/>func (m *MockCAR) EXPECT() *MockCARMockRecorder {<br/>   return m.recorder<br/>}<br/>// Start mocks base method<br/>func (m *MockCAR) Start(arg0 *gin.Context, arg1 string, arg2 testing.CAR) bool {<br/>   m.ctrl.T.Helper()<br/>   ret := m.ctrl.Call(m, "Start", arg0, arg1, arg2)<br/>   ret0, _ := ret[0].(bool)<br/>   return ret0<br/>}<br/>// Start indicates an expected call of Start<br/>func (mr *MockCARMockRecorder) Start(arg0, arg1, arg2 interface{}) *gomock.Call {<br/>   mr.mock.ctrl.T.Helper()<br/>   return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockCAR)(nil).Start), arg0, arg1, arg2)<br/>}<br/>// EngineCheck mocks base method<br/>func (m *MockCAR) EngineCheck(arg0 *gin.Context, arg1 testing.CAR) bool {<br/>   m.ctrl.T.Helper()<br/>   ret := m.ctrl.Call(m, "EngineCheck", arg0, arg1)<br/>   ret0, _ := ret[0].(bool)<br/>   return ret0<br/>}<br/>// EngineCheck indicates an expected call of EngineCheck<br/>func (mr *MockCARMockRecorder) EngineCheck(arg0, arg1 interface{}) *gomock.Call {<br/>   mr.mock.ctrl.T.Helper()<br/>   return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EngineCheck", reflect.TypeOf((*MockCAR)(nil).EngineCheck), arg0, arg1)<br/>}</span></pre><p id="146d" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在我们有了模拟，让我们开始编写测试用例。我们将使用<em class="lx"> gomock </em>包来编写我们的单元测试用例，下面是我们在编写测试用例时将遵循的整个工作流程:</p><ol class=""><li id="34b3" class="md me it lb b lc ly lg lz lk mf lo mg ls mh lw ng mj mk ml bi translated">在我们的测试中，首先创建一个<em class="lx"> gomock的实例。控制器</em>并将其传递给模拟对象的构造函数以获得模拟对象。</li><li id="d24c" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw ng mj mk ml bi translated">在您的模拟上调用<strong class="lb iu"> Expect() <em class="lx"> </em> </strong>来设置它们的期望值和返回值。如果所考虑的函数有对其他函数的外部调用，这是必需的。</li><li id="846b" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw ng mj mk ml bi translated">调用main函数(我们正在为其编写测试用例的函数)来触发代码流通过参数中的模拟接口，而不是真正的接口。</li><li id="9d98" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw ng mj mk ml bi translated">在模拟控制器上调用<strong class="lb iu"> Finish() </strong>，然后断言模拟的期望。</li><li id="3a8f" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw ng mj mk ml bi translated">最后，断言被调用的主函数的预期最终结果。</li></ol><p id="ab4e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">让我们看看<strong class="lb iu"> Start() </strong>函数的单元测试用例是什么样子的:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4ea7" class="na kc it mw b gy nb nc l nd ne">func TestCARSTRUCT_Start(t *testing.T) {</span><span id="f83b" class="na kc it mw b gy nf nc l nd ne">   controller := gomock.NewController(t)</span><span id="3f43" class="na kc it mw b gy nf nc l nd ne">   defer controller.Finish()</span><span id="64db" class="na kc it mw b gy nf nc l nd ne">   MockInterface := Mocks.NewMockCAR(controller)</span><span id="61ed" class="na kc it mw b gy nf nc l nd ne">   var ctx *gin.Context<br/>   MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(<em class="lx">true</em>)</span><span id="a8fe" class="na kc it mw b gy nf nc l nd ne">   result := CARSTRUCT{}.Start(ctx,"carkey",MockInterface)</span><span id="d1f0" class="na kc it mw b gy nf nc l nd ne">   assert.Equal(t,<em class="lx">true</em>,result)<br/>}</span></pre><p id="8c46" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">最初的几个步骤非常简单，我们创建了一个gomock控制器，然后用它来创建我们界面的模拟版本。</p><p id="c96e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在，正如我们所看到的，有一个对函数<em class="lx"> EngineCheck()，</em>的外部调用，因此有一个对该函数的期望检查。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9ef5" class="na kc it mw b gy nb nc l nd ne">MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(<em class="lx">true</em>)</span></pre><p id="f807" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这种期望检查做的比看起来要多，我们传递的参数值是针对运行时接收的值断言的(在我们的测试用例中，在我们调用<em class="lx"> Start() </em>之后，实际上调用了<em class="lx"> EngineCheck() </em>)。我们还提到了一个返回值，它将在期望调用匹配时返回。</p><p id="a1b6" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">最后，我们调用实际的<em class="lx"> Start() </em>函数来触发我们的测试流程，并断言我们的预期返回值。</p><h1 id="4f22" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">参数比较器</h1><p id="bdb2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们可能关心也可能不关心调用模拟时使用的参数值。在这两种情况下，参数比较器可用于断言或忽略模拟方法的特定参数值:</p><ul class=""><li id="944f" class="md me it lb b lc ly lg lz lk mf lo mg ls mh lw mi mj mk ml bi translated"><em class="lx"> gomock。Any():匹配任何值(任何类型)</em></li><li id="de3f" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><em class="lx"> gomock。Eq(x):用于匹配深度等于x的值</em></li><li id="4b8a" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><em class="lx"> gomock。Nil():匹配nil </em></li><li id="1a3b" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><em class="lx"> gomock。Not(x):匹配深度不等于x的值</em></li></ul><p id="e9be" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">一个参数可以有一个固定的值(通过在预期的调用中指定值，就像我们到目前为止所做的那样),或者可以使用这些比较器进行比较。例如，在对<em class="lx"> EngineCheck() </em>进行期望调用时，如果我们想要忽略第二个参数值，将按如下方式进行:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="586c" class="na kc it mw b gy nb nc l nd ne">MockInterface.EXPECT().EngineCheck(ctx, gomock.Any()).Return(true)</span></pre><h1 id="2b46" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">验证呼叫订单</h1><p id="c48a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">假设我们在主函数中多次调用外部函数，通常这些调用的顺序也很重要。所以还有一种方法是使用gomock的<strong class="lb iu"> <em class="lx"> After() </em> </strong>方法来断言调用顺序。举个例子，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="462e" class="na kc it mw b gy nb nc l nd ne">FirstCall := MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(true)</span><span id="4923" class="na kc it mw b gy nf nc l nd ne">callA :=  MockInterface.EXPECT().MethodA(ctx,MockInterface).After(FirstCall)</span><span id="f3ba" class="na kc it mw b gy nf nc l nd ne">callB := MockInterface.EXPECT().MethodB(ctx,MockInterface).After(callA)</span></pre><p id="f52a" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在这种情况下，我们断言对MethodA的调用是在对EngineCheck的调用之后进行的，对MethodB的调用是在对MethodA的调用之后进行的。</p><h1 id="2963" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">使用通道和指定模拟动作</h1><p id="a37b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在go中使用通道和goroutines时，单元测试变得有点棘手。让我们修改我们的<em class="lx"> Start() </em>函数，并为我们的汽车界面添加更多的函数，如下所示:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="5788" class="na kc it mw b gy nb nc l nd ne">type CAR interface {<br/>   Start(*gin.Context, string, CAR) bool<br/>   EngineCheck(*gin.Context, CAR) bool<br/>   SuspensionCheck(*gin.Context, CAR, chan bool)<br/>   BrakesCheck(*gin.Context, CAR, chan bool)<br/>}</span><span id="5d87" class="na kc it mw b gy nf nc l nd ne">type CARSTRUCT struct {<br/>}</span><span id="800b" class="na kc it mw b gy nf nc l nd ne">func (car CARSTRUCT) Start(context *gin.Context, key string, carInterface CAR) bool {</span><span id="c6bc" class="na kc it mw b gy nf nc l nd ne">   if carInterface.EngineCheck(context, carInterface) {</span><span id="33f1" class="na kc it mw b gy nf nc l nd ne">      if key == "carkey" {</span><span id="2537" class="na kc it mw b gy nf nc l nd ne">         fmt.Println("Let's start the car!")<br/><br/>         var brakes = make(chan bool)<br/><br/>         var suspension = make(chan bool)<br/><br/>         go carInterface.BrakesCheck(context,carInterface,brakes)</span><span id="f910" class="na kc it mw b gy nf nc l nd ne">         go        carInterface.SuspensionCheck(context,carInterface,suspension)<br/><br/>         if &lt;-brakes &amp;&amp; &lt;-suspension {<br/>            return <em class="lx">true<br/>         </em>} else {<br/>            return <em class="lx">false<br/>         </em>}<br/>      } else {<br/>         fmt.Println("You don't have the right key!")<br/>         return <em class="lx">false<br/>      </em>}<br/>   } else {<br/>      return <em class="lx">false<br/>   </em>}<br/>}</span><span id="e2bc" class="na kc it mw b gy nf nc l nd ne">func (car CARSTRUCT) EngineCheck(context *gin.Context, carInterface CAR) bool {<br/>   return <em class="lx">true<br/></em>}</span><span id="6a5b" class="na kc it mw b gy nf nc l nd ne">func (car CARSTRUCT) SuspensionCheck(context *gin.Context, carInterface CAR, result chan bool) {<br/>   result &lt;- <em class="lx">true<br/></em>}</span><span id="08f3" class="na kc it mw b gy nf nc l nd ne">func (car CARSTRUCT) BrakesCheck(context *gin.Context, carInterface CAR, result chan bool) {<br/>   result &lt;- <em class="lx">true<br/></em>}</span></pre><p id="0d20" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在，我们在Start()方法中有了对函数SuspensionCheck()和BrakesCheck()的两个goroutine调用，以及接收这些异步调用输出的布尔通道。我们还必须使用上面提到的mockgen命令重新生成我们的模拟。</p><p id="8d90" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">函数<em class="lx"> SuspensionCheck() </em>和<em class="lx">brake check()</em>在其输出通道中写入真布尔值。因此，当期望调用相同的匹配时，我们需要通过模拟函数来模拟这种行为。通常情况下，这是不可能的，因为被模仿的对象只会在适当的时候提供扫描响应，并记录它们的呼叫。但这可以通过gomock的<strong class="lb iu"> <em class="lx"> Do() </em> </strong>或<strong class="lb iu"><em class="lx">DoAndReturn()</em></strong>方法来完成，这些方法用于指定模拟动作。让我们看看我们的测试用例现在是什么样子:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4c69" class="na kc it mw b gy nb nc l nd ne">func TestCARSTRUCT_Start(t *testing.T) {<br/><br/>   controller := gomock.NewController(t)<br/><br/>   defer controller.Finish()<br/><br/>   MockInterface := Mocks.NewMockCAR(controller)<br/><br/>   var ctx *gin.Context<br/><br/>   MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(<em class="lx">true</em>)<br/><br/>   MockInterface.EXPECT().BrakesCheck(ctx,MockInterface,gomock.Any()).DoAndReturn(func(arg0, arg1, arg2 interface{}){<br/>      arg2.(chan bool) &lt;- <em class="lx">true<br/>   </em>})<br/><br/>   MockInterface.EXPECT().SuspensionCheck(ctx,MockInterface,gomock.Any()).DoAndReturn(func(arg0, arg1, arg2 interface{}){<br/>      arg2.(chan bool) &lt;- <em class="lx">true<br/>   </em>})<br/><br/><br/>   result := testing2.CARSTRUCT{}.Start(ctx,"carkey",MockInterface)<br/><br/>   assert.Equal(t,<em class="lx">true</em>,result)<br/><br/>}</span></pre><p id="3f72" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">让我们看看对<em class="lx"> BrakesCheck() </em>的期望检查:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="154c" class="na kc it mw b gy nb nc l nd ne">MockInterface.EXPECT().BrakesCheck(ctx,MockInterface,gomock.Any()).DoAndReturn(func(arg0, arg1, arg2 interface{}){<br/>   arg2.(chan bool) &lt;- <em class="lx">true<br/></em>})</span></pre><p id="78db" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们所做的是，当期望匹配时，即使用所提到的参数值调用了模拟的<em class="lx">brake check()</em>，那么将执行DoAndReturn()中的函数(<em class="lx"> func() </em>)。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="1ba7" class="na kc it mw b gy nb nc l nd ne">func(arg0, arg1, arg2 interface{}){<br/>   arg2.(chan bool) &lt;- <em class="lx">true<br/></em>}</span></pre><p id="ea81" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">因此，当对<em class="lx"> BrakesCheck() </em>的调用匹配时，<em class="lx"> func() </em>被执行，布尔值true被写入结果通道。这正是需要模仿的行为。</p><p id="1bca" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="lx">注意:Do()或DoAndReturn()中的函数将具有与我们正在模拟的函数的期望方法相同的参数签名，</em></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9c3e" class="na kc it mw b gy nb nc l nd ne">// BrakesCheck indicates an expected call of BrakesCheck<br/>func (mr *MockCARMockRecorder) BrakesCheck(arg0, arg1, arg2 interface{}) *gomock.Call {<br/>   mr.mock.ctrl.T.Helper()<br/>   return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BrakesCheck", reflect.TypeOf((*MockCAR)(nil).BrakesCheck), arg0, arg1, arg2)<br/>}</span></pre><p id="4ed7" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="lx">同样，这些自变量中的每一个(arg0，1，3..)对应于在期望调用匹配后调用模拟函数所用的实际参数。就像在我们的例子中，func()正好有3个类型接口的参数arg0、arg1和arg2，这与我们的BrakesCheck()函数的期望方法相同，arg0对应于上下文(*gin。上下文)，arg1是MockInterface，arg2对应于结果bool通道。</em></p><p id="4729" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="lx">这就是为什么当期望调用匹配时，我们知道结果通道在第三个参数位置或arg2被传递，所以我们简单地将arg2类型转换为bool通道，并在其中写入值true，以通过它的mock模拟BrakesCheck()的实际行为，</em></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="fe85" class="na kc it mw b gy nb nc l nd ne">arg2.(chan bool) &lt;- <em class="lx">true</em></span></pre></div></div>    
</body>
</html>