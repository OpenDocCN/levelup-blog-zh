<html>
<head>
<title>Mocking in Python Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python单元测试中的模仿</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mocking-in-python-unit-tests-3567fc77d55a?source=collection_archive---------3-----------------------#2022-10-29">https://levelup.gitconnected.com/mocking-in-python-unit-tests-3567fc77d55a?source=collection_archive---------3-----------------------#2022-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Mock更好地利用Pytest</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/10a95df4b742caf99d6f5b07e80e654f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIrK3BOfnqfVp-e8pLDh5g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cdr6934?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae ky" href="https://unsplash.com/@cdr6934?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c0ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/p/5c59cdf89529" rel="noopener">之前的文章</a>中，我们看到了pytest的第一个介绍——Python的单元测试框架，很多人都选择了它。</p><p id="12c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们将看看另一个特点，即嘲讽。在测试中，模仿被用来替换我们不想或者不能运行的函数。这方面的主要用例是昂贵、耗时的功能，需要外部资源和/或数据的功能——或者通常是遵循单元测试思想的测试:与完整的<a class="ae ky" href="https://en.wikipedia.org/wiki/Integration_testing" rel="noopener ugc nofollow" target="_blank">集成测试</a>相比，单独的、可测试的组件。</p><h1 id="2c35" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">概观</h1><p id="95e1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我看来，嘲讽是一个复杂的话题，你可以随意深入其中。老实说，我不太喜欢Python，因为有太多的选择，却缺少好的文档。</p><p id="236d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的目的不是试图解释嘲讽的所有特性，而是——给出一个快速的概述，使你能够以我认为最简单的方式使用嘲讽。特别是，我们将利用<em class="ms">打补丁</em>。如果你想更深入，我想参考一些现有的资源，比如<a class="ae ky" href="https://realpython.com/python-mock-library/" rel="noopener ugc nofollow" target="_blank"> realpython </a>。</p><p id="3f29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将使用Python的<a class="ae ky" href="https://pypi.org/project/mock/" rel="noopener ugc nofollow" target="_blank">模拟</a>包，它包含在Python 3.3版本的标准库中(对于早期版本，通过<code class="fe mt mu mv mw b">pip install mock</code>手动安装)。</p><h1 id="c0cd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用模拟</h1><p id="6167" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们以下面的例子为基础:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="b72f" class="nb lw it mw b be nc nd l ne nf">from unittest.mock import patch<br/>import time<br/><br/>def expensive_function():<br/>    time.sleep(10)<br/>    return 42<br/><br/>def function_to_be_tested():<br/>    expensive_operation_result = expensive_function()<br/>    return expensive_operation_result * 2<br/><br/>def test_function_to_be_tested():<br/>    assert function_to_be_tested() == 84</span></pre><p id="3b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要测试<code class="fe mt mu mv mw b">function_to_be_tested</code>，它简单地调用<code class="fe mt mu mv mw b">expensive_function</code>并返回其乘以2的返回值。在<code class="fe mt mu mv mw b">expensive_function</code>内部，我们等待10s(或者想象其他慢函数)，这对于单元测试来说是不可行的。</p><p id="2493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们使用mock来修改单元测试。我们首先定义我们将使用的函数，而不是<code class="fe mt mu mv mw b">expensive_function</code>:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="b561" class="nb lw it mw b be nc nd l ne nf">def mocked_expensive_function():<br/>    return 42</span></pre><p id="ac57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，我们现在想在现有的函数上“修补”这个函数。为此，有两种选择——使用<a class="ae ky" href="https://medium.com/@hrmnmichaels/python-decorators-816236066ed8" rel="noopener">装饰器</a>或<a class="ae ky" href="https://medium.com/@hrmnmichaels/managing-resources-in-python-with-context-managers-with-statement-f07afc1afb4f" rel="noopener">上下文管理器</a>。</p><h2 id="275f" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">使用上下文管理器打补丁</h2><p id="bd67" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">使用上下文管理器打补丁看起来像这样——瞧——测试立即完成:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="2d03" class="nb lw it mw b be nc nd l ne nf">def test_function_to_be_tested():<br/>    with patch(<br/>        "sample_file.expensive_function",<br/>        new=mocked_expensive_function,<br/>    ):<br/>        assert function_to_be_tested() == 84</span></pre><p id="0bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这里我们必须指定函数的完整路径——在“何处打补丁”一节中有更多相关内容。</p><p id="8996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化上述内容，我们还可以使用lambda函数:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="fb71" class="nb lw it mw b be nc nd l ne nf">def test_function_to_be_tested():<br/>    with patch(<br/>        "sample_file.expensive_function",<br/>        new=lambda: 42,<br/>    ):<br/>        assert function_to_be_tested() == 84</span></pre><h2 id="58ee" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">用装饰者修补</h2><p id="4d81" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">或者(通常，我会采用这种方法——但这在某种程度上取决于它的使用场合),可以使用decorators进行修补(为了正确输入，导入<code class="fe mt mu mv mw b">from unittest.mock import MagicMock</code>)——然后将上面的代码写成:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="5cbd" class="nb lw it mw b be nc nd l ne nf">@patch("sample_file.expensive_function")<br/>def test_function_to_be_tested(mock_expensive_function: MagicMock):<br/>    mock_expensive_function.return_value = 42<br/>    assert function_to_be_tested() == 84</span></pre><p id="c69c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，打了补丁的函数现在变成了类型为<code class="fe mt mu mv mw b">MagicMock</code>的函数参数。这个参数的名称是任意的，但是，请注意参数的“反转”顺序，即:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="9880" class="nb lw it mw b be nc nd l ne nf">@patch("sample_file.expensive_function")<br/>@patch("sample_file.foo")<br/>def test_function_to_be_tested(foo: MagicMock, mock_expensive_function: MagicMock):<br/>    mock_expensive_function.return_value = 42<br/>    assert function_to_be_tested() == 84</span></pre><h2 id="169f" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">哪里打补丁</h2><p id="6451" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">知道在哪里打补丁可能有点痛苦，而且容易搞砸。更糟糕的是，您不会收到错误通知，而是修补一个未使用的函数，同时仍然使用原来的函数。为了便于演示，让我们将上述代码分成如下两个文件:</p><p id="cb23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> sample_file_two.py: </strong></p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="70b6" class="nb lw it mw b be nc nd l ne nf">import time<br/><br/><br/>def expensive_function():<br/>    time.sleep(10)<br/>    return 42</span></pre><p id="619c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> sample_file.py: </strong></p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="52c7" class="nb lw it mw b be nc nd l ne nf">from unittest.mock import MagicMock, patch<br/>import sample_file_two<br/><br/><br/>def function_to_be_tested():<br/>    expensive_operation_result = sample_file_two.expensive_function()<br/>    return expensive_operation_result * 2<br/><br/><br/>@patch("sample_file_two.expensive_function")<br/>def test_function_to_be_tested(mock_expensive_function: MagicMock):<br/>    mock_expensive_function.return_value = 42<br/>    assert function_to_be_tested() == 84</span></pre><p id="dab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码是正确的，并且遵循我们介绍的符号。不过，可以考虑把进口改成<code class="fe mt mu mv mw b">from sample_file_two import expensive_function</code>。然后，我们需要将代码修改为:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="b58e" class="nb lw it mw b be nc nd l ne nf">from unittest.mock import MagicMock, patch<br/>from sample_file_two import expensive_function<br/><br/><br/>def function_to_be_tested():<br/>    expensive_operation_result = expensive_function()<br/>    return expensive_operation_result * 2<br/><br/><br/>@patch("sample_file.expensive_function")<br/>def test_function_to_be_tested(mock_expensive_function: MagicMock):<br/>    mock_expensive_function.return_value = 42<br/>    assert function_to_be_tested() == 84</span></pre><p id="d97d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即从当前文件中瞄准<code class="fe mt mu mv mw b">expensive_function</code>。原因是导入的第二个版本将实际函数绑定到局部范围。这也可以作为一个经验法则:在函数存在/被查找范围内打补丁。</p><h2 id="537e" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">修补对象</h2><p id="0bd3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，让我们快速浏览一下模仿对象。假设以下场景:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="1d55" class="nb lw it mw b be nc nd l ne nf">class MySummationClass:<br/>    def expensive_sum(self, x, y):<br/>        time.sleep(10)<br/>        return x + y<br/><br/>def test_sum():<br/>    my_summation_class = MySummationClass()<br/>    assert my_summation_class.expensive_sum(2, 3) == 5</span></pre><p id="0cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模仿成员函数<code class="fe mt mu mv mw b">expensive_sum</code>与上面的例子非常相似，但是现在我们只需要使用<code class="fe mt mu mv mw b">mock.patch.object()</code>，并且记住包括该函数的所有参数，也就是<code class="fe mt mu mv mw b">self</code>:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="ba51" class="nb lw it mw b be nc nd l ne nf">def test_sum():<br/>    my_summation_class = MySummationClass()<br/>    with mock.patch.object(MySummationClass, "expensive_sum", new=lambda self, x, y: x + y):<br/>        assert my_summation_class.expensive_sum(2, 3) == 5</span></pre><h1 id="e27a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="ab54" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这篇文章中，我们讨论了用pytest在Python中模拟。我们看到了如何使用上下文管理器和装饰器来修补函数，还讨论了修补的位置。此外，我们还略读了对象的修补函数。感谢阅读！如果你对C++感兴趣，<a class="ae ky" href="https://medium.com/gitconnected/mocking-with-googletest-gtest-6dde5230e7aa" rel="noopener">本帖</a>用gtest描述嘲讽。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="8d1b" class="lv lw it bd lx ly nz ma mb mc oa me mf jz ob ka mh kc oc kd mj kf od kg ml mm bi translated">分级编码</h1><p id="86b4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="bba1" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="33b5" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">📰查看<a class="ae ky" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="18dd" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">🔔关注我们:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae ky" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="1e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🚀👉<a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>