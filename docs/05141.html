<html>
<head>
<title>A Walk Through Setting the Types in Typescript: Annotations vs Inference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Typescript中设置类型的演练:注释与推理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-walk-through-setting-the-types-in-typescript-annotations-vs-inference-1da62e7492ae?source=collection_archive---------12-----------------------#2020-08-06">https://levelup.gitconnected.com/a-walk-through-setting-the-types-in-typescript-annotations-vs-inference-1da62e7492ae?source=collection_archive---------12-----------------------#2020-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f4efb44fff93fda7b2d6426377bbee7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wt0rEUEKIWyuxmnD"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@zoltantasi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zoltan·塔西</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f434" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将讨论:</p><ul class=""><li id="71b1" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">什么是类型</li><li id="005a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在typescript中设置类型的两个系统:注释与推理</li><li id="1888" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">基元值的类型用法</li><li id="b185" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">带函数的类型:箭头函数、<code class="fe lp lq lr ls b">function</code>关键字、匿名函数</li><li id="6bc1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">为什么我们应该总是使用注释来设置返回类型</li><li id="1b73" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">对象类型:对象析构，嵌套对象</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="2210" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在typescript中，任何值——任何可以保存到变量中的值——都有类型。</p><p id="3d7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单地说，我们可以把类型看作是一种容易引用一个值的不同属性和功能的方式。当我们想到一个有方法的值时，首先想到的是一个有自定义方法的类或对象。但是请记住，即使是基本类型也有许多与该类型相关联的内置方法。例如，<code class="fe lp lq lr ls b">number</code>的类型有<code class="fe lp lq lr ls b">toString()</code>方法，<code class="fe lp lq lr ls b">string</code>的类型有<code class="fe lp lq lr ls b">charAt()</code>方法。当我们为值使用正确的类型时，typescript还会检查这种内置方法在特定类型上的可用性。</p><p id="6b4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">typescript使用两个不同的系统来计算值的类型，<em class="ma">类型</em> <em class="ma">注释</em>和<em class="ma">类型</em> <em class="ma">推理</em>，它们并肩工作。</p><p id="02ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，当我们使用类型注释时，这意味着开发人员明确地告诉了typescript类型是什么。另一方面，类型推断意味着typescript“猜测”了类型(从值周围的代码中派生出来)。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="45c8" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">使用具有基元值的类型</h2><p id="4994" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">在大多数情况下，依靠推理系统来处理<em class="ma">原语</em>类型是完全没问题的。例如，以下代码在两种情况下都会导致完全相同的错误:</p><pre class="mz na nb nc gt nd ls ne nf aw ng bi"><span id="7a94" class="mb mc iq ls b gy nh ni l nj nk">let apples: number = 5;</span><span id="a1ad" class="mb mc iq ls b gy nl ni l nj nk">let count = 7;</span><span id="5b37" class="mb mc iq ls b gy nl ni l nj nk">// Type '"plenty"' is not assignable to type 'number'<br/>// Type '"a lot"' is not assignable to type 'number'</span><span id="4535" class="mb mc iq ls b gy nl ni l nj nk">apples = 'a lot';</span><span id="7d22" class="mb mc iq ls b gy nl ni l nj nk">count = 'plenty';</span></pre><p id="e0bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在三种情况下，我们最好使用类型注释并显式设置类型。让我们一个一个来看:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/03cf94a33221d4772532f2265a03b8e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LOcKl2xdppfnMGFWJXcVQg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">函数返回“任意”类型</figcaption></figure><p id="815e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一种情况是当函数返回类型<code class="fe lp lq lr ls b">any</code>时，我们想要澄清它。在这种情况下<code class="fe lp lq lr ls b">JSON.parse</code>从字符串中返回有效的JS。它可以是任意数量的东西，这取决于传递的字符串。这里我们使用类型注释来明确地设置我们期望<code class="fe lp lq lr ls b">coords</code>值是一个具有<code class="fe lp lq lr ls b">x</code>和<code class="fe lp lq lr ls b">y</code>属性的对象；两个都是<code class="fe lp lq lr ls b">number</code>。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/9781391b5bdcc782768184db9ccde1ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQ6GG3kFgIYpa9ri7gyJtQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">延迟变量初始化</figcaption></figure><p id="4fd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">诚然，这是一个有点奇怪的例子；实际上，我们可能会将<code class="fe lp lq lr ls b">foundGreen</code>初始化为<code class="fe lp lq lr ls b">false</code>，或者更好的是，使用<code class="fe lp lq lr ls b">includes()</code>数组方法。然而，如果出于某种原因，我们需要在初始化变量之前声明它，我们必须使用类型注释来指定类型。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/7792c92a9573d3583a5f9197a0d0a27e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPaKG0mdvsLr_NwQvNcTeA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">无法合理推断类型</figcaption></figure><p id="1270" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们希望有一个正数或<code class="fe lp lq lr ls b">false</code>的变量。如果我们想让一个变量改变类型，我们必须提前指定所有可能的类型。</p><p id="c688" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总而言之，对于原始值，我们将尽可能依赖类型推断，并对上述三种情况使用类型注释。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="d6b2" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">将类型与函数一起使用</h2><p id="cea5" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">对于基本类型来说非常简单，但是对于函数来说就有点复杂了。对于函数，我们不仅要为参数指定类型，还要为返回值指定类型。除了常规的数字和字符串，一个函数可以隐式返回<code class="fe lp lq lr ls b">undefined</code>或者根本没有返回值，而是抛出一个错误。</p><p id="823b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于箭头函数、用<code class="fe lp lq lr ls b">function</code>关键字声明的常规函数和匿名函数，类型注释将完全相同。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ca"><img src="../Images/72637460badb8dbb828721eee02baabc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Tz5oZ6lWMi6KVlrZVStww.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">函数的类型注释</figcaption></figure><p id="16cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想特别指出的一点是，我们应该总是显式地设置返回类型，即使它与推断类型完美地一起工作。这样做的原因是，否则，如果开发人员错误地忘记从函数返回值，typescript只会推断返回类型为<code class="fe lp lq lr ls b">void</code>，而不会将其标记为错误。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ca"><img src="../Images/a518123a9daa7721013639cbebd355fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMSnVvbWgqv_zI9A2HFaAg.png"/></div></div></figure><p id="5795" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于没有返回值的函数，有一个特殊的返回类型叫做<code class="fe lp lq lr ls b">void</code>。Void表示函数没有返回值。我们知道，JavaScript中没有<code class="fe lp lq lr ls b">return</code>关键字的函数隐式返回<code class="fe lp lq lr ls b">undefined</code>。所以拥有<code class="fe lp lq lr ls b">return undefined</code>或<code class="fe lp lq lr ls b">return null</code>仍然会算作<code class="fe lp lq lr ls b">void</code>返回类型。</p><p id="286c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个如何在typescript中对函数使用参数析构的示例。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ca"><img src="../Images/6f0e83f90f1218bf0f557b3c27458988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CvJfujLJVBU3h0k3YNIyQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">具有析构函数参数的类型</figcaption></figure><p id="2e21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，sintax需要一点时间来适应，所以让我们一步一步地回顾一下正在发生的事情。</p><p id="15a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数接收一个对象作为参数，我们使用看起来与JavaScript中的对象文字几乎相同的类型注释。注意，我们在这里使用<em class="ma">分号</em>而不是逗号来分隔属性。在这个例子中，我们说<code class="fe lp lq lr ls b">logWeather</code>接收一个对象，该对象具有类型为<code class="fe lp lq lr ls b">Date</code>的属性<code class="fe lp lq lr ls b">date</code>和类型为<code class="fe lp lq lr ls b">string</code>的属性<code class="fe lp lq lr ls b">weather</code>，并返回<code class="fe lp lq lr ls b">void</code></p><p id="215e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在使用<code class="fe lp lq lr ls b">consoleWeather</code>函数的情况下，我们更进一步，使用ES6参数析构。注意，我们并不试图在析构对象本身中指定类型。相反，语法是在析构之后有一个冒号分隔的类型注释。我们使用分号来分隔类型注释中的属性。</p><p id="51de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总而言之，对于函数，我们将在所有情况下使用注释。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="c44b" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">具有对象文字的类型</h2><p id="d2d4" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">最后，让我们看看如何对对象和嵌套对象使用类型注释。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ca"><img src="../Images/01c64eb60e5c6def959e62a0fb0ee25b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZxVCTBQEqr0Ke9rZCk0uA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用对象键入注释</figcaption></figure><p id="13e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，当析构<code class="fe lp lq lr ls b">{ age, name }</code>时，我们看到了与析构函数的参数时使用的相同的熟悉语法。当我们必须处理嵌套对象的析构时，这种语法背后的思想变得更加清晰。语法看起来很难，但实际上我们做的和普通JavaScript一样，然后加上一个冒号并定义一个“类型对象”来描述析构参数的结构。同样，记住在对象的类型注释中用分号而不是普通的逗号来分隔属性。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="6fba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是在typescript中设置简单类型的快速指南。typescript是对JavaScript世界的一个强大补充，并且越来越受欢迎。当然，除了设置我们在这里讨论的类型之外，还有很多事情要做。有接口、联合和许多其他情况，但一次只能做一件事。</p><p id="c7fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们研究了:</p><ul class=""><li id="919d" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">typescript中类型批注和推断类型的区别</li><li id="6416" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">何时依赖推断的类型系统，何时使用注释</li><li id="7f7f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">箭头、常规和匿名函数的类型</li><li id="5aef" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">具有对象文本和处于对象析构中的类型</li></ul><p id="cd95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读，我希望它能为您进一步澄清类型的概念！</p><p id="cd86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用typescript构建可读和可伸缩的应用程序，享受乐趣，一如既往地快乐编码！</p></div></div>    
</body>
</html>