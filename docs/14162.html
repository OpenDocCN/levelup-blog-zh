<html>
<head>
<title>5 Reasons Why Experienced Developers Use Gradle Version Catalogs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有经验的开发人员使用梯度版本目录的5个原因</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-reasons-why-experienced-developers-use-gradle-version-catalogs-54902605b8c1?source=collection_archive---------12-----------------------#2022-11-06">https://levelup.gitconnected.com/5-reasons-why-experienced-developers-use-gradle-version-catalogs-54902605b8c1?source=collection_archive---------12-----------------------#2022-11-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="ec46" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何使用分级版本目录实现更简单、更灵活、更安全的依赖管理</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/6f0873dd9bcdb6f9ca57b726714315a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9IIyzPCwtawmfBFdL9aJg.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">Lexica.art</figcaption></figure><p id="d184" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">大多数Java开发人员都乐于使用Gradle或Maven。</em> </strong></p><p id="6078" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">但是依赖管理还有什么其他的选择呢？</em> </strong>一个是Gradle版本目录。大多数人忽视了这个工具的好处。</p><p id="14d5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这里有5个你应该使用Gradle版本目录的理由。T12】</p><h1 id="a1b0" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">您可以自动更新依赖关系</h1><p id="67a6" class="pw-post-body-paragraph kz la iu lb b lc mo jv le lf mp jy lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">正如你所看到的，很多前端仓库都有自己的<strong class="lb iv">依赖机器人</strong>为它们更新库。<strong class="lb iv"> <em class="lv">我们可以对后端进行同样的操作吗？</em> </strong></p><p id="86c7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果我们研究一下相关问题，我们会发现<strong class="lb iv">依赖机器人</strong>不支持分级版本目录。</p><p id="1d03" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">为什么？</em> </strong> <strong class="lb iv"> GitHub喜欢C#，所以没有Java。玩笑归玩笑，<strong class="lb iv">dependent bot</strong>目前不支持Gradle版本目录。虽然有意志力来支持这个特性，但是没有人开始研究这个。</strong></p><p id="4b62" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">那么，有什么别的方法可以获得自动更新呢？ </p><p id="c651" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们可以检查<a class="ae mt" href="https://github.com/apps/renovate" rel="noopener ugc nofollow" target="_blank">翻新</a>。你需要安装这个应用程序。这是安装屏幕。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mu"><img src="../Images/6adc786250804d8af45ccdd1877c266e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbPo1FV6FD9K_qg6ztDqzQ.png"/></div></div></figure><p id="a9f9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在回购的根中，您还需要下面的<code class="fe mv mw mx my b">renovate.json</code>。</p><pre class="kk kl km kn gu mz my na nb aw nc bi"><span id="2a5e" class="nd lx iu my b gz ne nf l ng nh">{</span><span id="c630" class="nd lx iu my b gz ni nf l ng nh">    "$schema": "https://docs.renovatebot.com/renovate-schema.json",</span><span id="ce7d" class="nd lx iu my b gz ni nf l ng nh">    "extends": [</span><span id="9f5d" class="nd lx iu my b gz ni nf l ng nh">    "local&gt;DanySK/renovate-config"</span><span id="16b1" class="nd lx iu my b gz ni nf l ng nh">    ],</span><span id="165c" class="nd lx iu my b gz ni nf l ng nh">    "baseBranches": [ "master", "minimal" ],</span><span id="4f2e" class="nd lx iu my b gz ni nf l ng nh">    "automerge": false</span><span id="0f25" class="nd lx iu my b gz ni nf l ng nh">}</span></pre><p id="50c0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">拉取请求将开始滚滚而来。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="e314" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为什么我们甚至需要这些自动更新？ 手动更新没什么不好。</p><p id="94c0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但是你损失了很多时间，这是一项繁重的工作。而翻新的另一点是<strong class="lb iv"> <em class="lv">安全</em> </strong>。你将获得全新的更新并消除安全问题。T48】</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/215c451619ef7712e0b8a99403429db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4oTYZsyZvkn2WbBRKa2X0A.png"/></div></div></figure><p id="1fad" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">你将拥有类型安全的依赖访问。 </p><p id="9da3" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">没有版本目录，向所有子项目添加一个依赖项是一件麻烦的事情。对于版本目录，这与导入一个新类是一样的。</p><p id="d129" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">安全型保证了易用性。随着我们获得了自动完成特性，我们在添加新的依赖项时会加快速度。</p><p id="e39f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于IntelliJ，您可以在 <code class="fe mv mw mx my b"><a class="ae mt" href="https://youtrack.jetbrains.com/issue/IDEA-279603/Code-completion-for-Gradle-Version-Catalogs-in-groovy-build-files#focus=Comments-27-6109308.0-0" rel="noopener ugc nofollow" target="_blank">build.gradle</a></code>中添加一个构建脚本<a class="ae mt" href="https://youtrack.jetbrains.com/issue/IDEA-279603/Code-completion-for-Gradle-Version-Catalogs-in-groovy-build-files#focus=Comments-27-6109308.0-0" rel="noopener ugc nofollow" target="_blank">，以实现自动完成。</a></p><pre class="kk kl km kn gu mz my na nb aw nc bi"><span id="d6fb" class="nd lx iu my b gz ne nf l ng nh">buildscript { dependencies { classpath files(libs.class.superclass.protectionDomain.codeSource.location) } }</span></pre><p id="3560" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在<code class="fe mv mw mx my b">settings.gradle</code>中，您需要添加以下内容:</p><pre class="kk kl km kn gu mz my na nb aw nc bi"><span id="9ab9" class="nd lx iu my b gz ne nf l ng nh">dependencyResolutionManagement { versionCatalogs { create("libs") { from("com.test:test-gradle-dependencies:1.0-SNAPSHOT") } } }</span></pre><h1 id="ebc0" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">您将拥有一个灵活的单一依赖源</h1><p id="2310" class="pw-post-body-paragraph kz la iu lb b lc mo jv le lf mp jy lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">如果您将版本目录放在一个单独的repo中，您将有一个地方来更改依赖关系。</p><p id="e24f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你和巴泽尔一起工作过，这和<code class="fe mv mw mx my b">WORKSPACE</code>文件是一样的。您将在那里定义所有的依赖项，并在monorepo中进行更改。</p><p id="9f95" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">类似于版本目录，尽管如果需要，您可以覆盖子项目中的依赖关系。覆盖的灵活性仍然可用。<strong class="lb iv"> <em class="lv">但在未来版本目录将是依赖关系的唯一来源。</em>T9】</strong></p><p id="ecc1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这里有一个教程可以启用单独的版本目录回购:<a class="ae mt" href="https://umang91.medium.com/integrating-a-version-catalog-c5c7d45516db" rel="noopener">集成版本目录|介质</a></p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="25fb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">单一依赖源解决什么？</em>T15】</strong></p><ul class=""><li id="9565" class="nr ns iu lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">跨项目更快更新</li><li id="68b7" class="nr ns iu lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">更轻松的版本更新</li><li id="6c19" class="nr ns iu lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">更容易添加新的依赖项</li></ul><p id="16e0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">要更新到较新的依赖版本，您只需要在一个地方进行更新。更新版本目录条目后，您需要打包一个新的版本目录。并在相关项目中使用它。</p><p id="9a69" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">没有版本目录，您需要更新每个项目。当处理多个项目时，这可能会慢一些。</p><p id="db6c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果您需要添加一个新的依赖项，您将只在版本目录中添加它。在所需的依赖项目中，您将添加一个新条目。</p><p id="9313" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">如何从目录中移除依赖关系？</em> </strong>您在<code class="fe mv mw mx my b">toml</code>文件中删除它，并更新相关项目中的目录。在编译时，你会得到一个错误指出删除的依赖。</p><p id="2975" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">依赖项目不知道版本的变化。您只需将版本目录更新到最新版本，然后继续前进。<strong class="lb iv"> <em class="lv">每一个属地都会马上得到收拾。</em> </strong></p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="32cb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">版本目录的另一个优点是什么？库更改监控。 </p><p id="95a9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您将很容易跟踪依赖性的变化。因为它们都在一个地方，所以你知道什么时候发生了什么变化。</p><p id="dd29" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">否则，你会用代码PR偷偷修改依赖关系。</em> </strong></p><p id="da40" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有了版本目录，每个版本目录PR只更新依赖项。如果需要，您可以退回到旧版本目录并继续前进。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h1 id="1ff2" class="lw lx iu bd ly lz of mb mc md og mf mg ka oh kb mi kd oi ke mk kg oj kh mm mn bi translated">这不是解决依赖性问题的灵丹妙药</h1><p id="7239" class="pw-post-body-paragraph kz la iu lb b lc mo jv le lf mp jy lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">使用版本目录也有缺点。本质上不是缺点，但不是目录版本的用例。</p><p id="a5ca" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您需要将版本目录仅仅视为愚蠢的库版本声明。</p><p id="00ff" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">所以不能做依赖排除的事情。</em> </strong>你只能把它们当神器用，知道自己需要什么版本。没有什么智能内置，因为这不是版本目录的用例。</p><blockquote class="ok ol om"><p id="668c" class="kz la lv lb b lc ld jv le lf lg jy lh on lj lk ll oo ln lo lp op lr ls lt lu in bi translated">这不是版本目录的目的。我们不应该鼓励使用排除，而是相反。目录是关于不可知论的库声明:它们不关心调用位置，从某种意义上说，它们不关心它们的用途。特别是，他们应该使用什么变体:这是关于坐标的。— <a class="ae mt" href="https://github.com/gradle/gradle/issues/20274#issuecomment-1078802201" rel="noopener ugc nofollow" target="_blank">投稿人</a></p></blockquote><p id="52b3" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">版本目录回购的另一个骗局是什么？</em> </strong>你也需要维护这个回购。如果你有很多项目，有时这可能是一个问题。YMMV，但是版本目录对您的团队来说可能是一个很好的依赖管理工具。</p><p id="5318" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">同样，你也不能为插件定义版本。</em>T15】</strong></p><p id="2331" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这样做是出于一致性问题，但是现在<a class="ae mt" href="https://melix.github.io/blog/2021/03/version-catalogs-faq.html#_can_i_use_a_version_catalog_to_declare_plugin_versions" rel="noopener ugc nofollow" target="_blank">你只能拥有无版本插件</a>。不是一个大的交易破坏者，但你不希望这种行为。</p><h1 id="3b32" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">您可以捆绑常见的依赖项</h1><p id="8ae0" class="pw-post-body-paragraph kz la iu lb b lc mo jv le lf mp jy lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">如果有共同的依赖项，可以将它们捆绑在一起。这样你可以用更少的语法做更多的事情。</p><p id="e134" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">包在库文件<code class="fe mv mw mx my b">toml</code>的包部分声明。</p><pre class="kk kl km kn gu mz my na nb aw nc bi"><span id="47ae" class="nd lx iu my b gz ne nf l ng nh">[bundles]<br/>testDependencies = ["junit-jupiter", "junit-engine"]</span></pre><p id="5a77" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在依赖项目中，您可以像使用任何其他依赖项一样使用它们。</p><pre class="kk kl km kn gu mz my na nb aw nc bi"><span id="85aa" class="nd lx iu my b gz ne nf l ng nh">testImplementation libs.bundles.testDependencies</span></pre><p id="24cd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用捆绑包从您的<code class="fe mv mw mx my b">build.gradle</code>中移除了许多样板文件。但是另一件好事是这是一个共享的依赖包。您可以在所有项目中使用包。</p><p id="2c5a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">只捆绑共同的或相关的依赖关系。</em> </strong>正如你不能把依赖从捆绑中分割出来。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="ac3f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> <em class="lv">那么到底需要设置什么版本目录呢？</em> </strong>你可以在下面的repo中找到设置:<a class="ae mt" href="https://github.com/zone84-examples/version-catalog-consumer-demo" rel="noopener ugc nofollow" target="_blank">GitHub—zone 84—examples/version—catalog—consumer—Demo:共享Gradle版本目录的演示项目</a></p></div></div>    
</body>
</html>