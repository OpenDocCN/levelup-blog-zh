<html>
<head>
<title>Memoization and Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">记忆和递归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/memoization-and-recursion-290f0e5a0351?source=collection_archive---------7-----------------------#2020-11-20">https://levelup.gitconnected.com/memoization-and-recursion-290f0e5a0351?source=collection_archive---------7-----------------------#2020-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/00651f46c2658592c7bb07157ec8fc24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MllPB0_sqsA4NzDA.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="kc">照片由</em> <a class="ae kd" href="https://unsplash.com/@edgarraw" rel="noopener ugc nofollow" target="_blank"> <em class="kc"> @edgarraw </em> </a></figcaption></figure><p id="2cb0" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在我的上一篇<a class="ae kd" href="https://ionabrabender.medium.com/recursion-revealed-38e4a0a5acb" rel="noopener">博客文章</a>中，我研究了递归，并且看了一些我们如何实现递归的基本例子。当我在学习递归的时候，我不断遇到这个词——<strong class="kg ir">记忆化</strong>。我不确定这是什么意思，也不知道这有什么关系，所以我决定进一步调查。在这篇文章中，我将讨论为什么记忆化是实现递归时的一个重要因素，并举例说明如何使用它。</p><h1 id="ecd4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是记忆化？</h1><p id="fff3" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">记忆化是一种可能使使用递归的函数运行得更快的方法。正如我将在下面的例子中展示的，一个递归函数可能会多次使用相同的输入执行相同的计算。这意味着它可能会比迭代方法花费更长的时间。记忆功能允许我们将输入与计算结果一起存储。因此，它可以简单地返回存储在缓存中的值，而不必使用相同的输入再次做相同的工作。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/2ce5b95e036590ff8b4108f11d7ca304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q2u70KMlVsUiSEqwrPkAgA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="kc">照片由</em><a class="ae kd" href="https://unsplash.com/@yespanioly" rel="noopener ugc nofollow" target="_blank"><em class="kc">@ yespanioly</em></a></figcaption></figure><h1 id="ddde" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">记忆化和斐波那契</h1><p id="611e" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">为了真正理解记忆化，我发现在使用递归计算斐波那契数列中的第<em class="mk">n</em>个数字时，看看如何使用记忆化是很有用的。这是一个非常常见的例子，绝对可以成为你在技术面试中需要实现的东西。</p><p id="6369" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><em class="mk">关于</em> <a class="ae kd" href="https://www.livescience.com/37470-fibonacci-sequence.html" rel="noopener ugc nofollow" target="_blank"> <em class="mk">斐波纳契数列</em> </a> <em class="mk">的快速注释:这是一个数列，其中每个数字都是前面两个数字的和。我们总是从0和1开始。下一个数字将是另一个1，因为0 + 1 = 1。然后我们得到2 (1 + 1 = 2)，然后是3 (1 + 2 = 3)，依此类推。</em></p><p id="2091" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">最初的递归解决方案可能如下所示:</p><pre class="mg mh mi mj gt ml mm mn mo aw mp bi"><span id="fb86" class="mq ld iq mm b gy mr ms l mt mu">function recursiveFibonacci(n) {</span><span id="9547" class="mq ld iq mm b gy mv ms l mt mu">   if (n &lt;= 1) {</span><span id="49be" class="mq ld iq mm b gy mv ms l mt mu">      return n;</span><span id="71f6" class="mq ld iq mm b gy mv ms l mt mu">   }</span><span id="0e80" class="mq ld iq mm b gy mv ms l mt mu">   return recursiveFibonacci(n-1) + recursiveFibonacci(n-2);</span><span id="753e" class="mq ld iq mm b gy mv ms l mt mu">}</span><span id="0fca" class="mq ld iq mm b gy mv ms l mt mu">recursiveFibonacci(6);</span><span id="8b51" class="mq ld iq mm b gy mv ms l mt mu">// 8</span><span id="7af2" class="mq ld iq mm b gy mv ms l mt mu">recursiveFibonacci(10);</span><span id="0b67" class="mq ld iq mm b gy mv ms l mt mu">// 55</span><span id="c4ac" class="mq ld iq mm b gy mv ms l mt mu">recursiveFibonacci(20);</span><span id="e8a0" class="mq ld iq mm b gy mv ms l mt mu">// 6765</span></pre><p id="c894" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><em class="mk">如果你不清楚递归是如何工作的，你可以看看我之前的</em> <a class="ae kd" href="https://ionabrabender.medium.com/recursion-revealed-38e4a0a5acb" rel="noopener"> <em class="mk">博客文章</em> </a> <em class="mk">，它提供了递归的概述，或者</em> <a class="ae kd" href="https://medium.com/launch-school/recursive-fibonnaci-method-explained-d82215c5498e" rel="noopener"> <em class="mk">这篇文章</em> </a> <em class="mk">，它专门处理递归和斐波那契数列。</em></p><p id="df3d" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">耶，成功了！但是，虽然这个函数只有几行长，但它的效率非常低，并且比迭代方法花费的时间更长。运行时间是指数级的，这意味着每当我们将输入增加1，计算时间就会大幅增长。这是因为使用相同的参数多次调用了该函数。</p><p id="b475" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们可以在这张图表中看到这是如何发生的:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/865ceb4017e18336d9b633a5f5889980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*uFxxudp72mwc0FXbDpZ-2Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="kc">递归斐波那契函数树表示法</em></figcaption></figure><p id="ffe6" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当输入为6时，该函数使用6之前的每个数字进行几次递归调用。例如，F(2)被调用五次！虽然这可能不会有很大的影响，但是我们可以想象当我们的输入为1000时，运行时会受到多大的负面影响。显然，我们需要一个更好的解决方案。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/661658a78ab4b61d7dfa754f33b315d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-JQJRXPH3YWafUybzZurw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="kc">照片由</em><a class="ae kd" href="https://unsplash.com/@steffipereira" rel="noopener ugc nofollow" target="_blank"><em class="kc">@ steffipereira</em></a></figcaption></figure><p id="4929" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">记忆拯救世界！通过记忆功能，我们可以创建一个缓存，在其中存储输入及其计算结果。然后，每当我们有一个已经看到的输入时，我们可以简单地检索结果，而不用重新做任何工作。</p><p id="91ae" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">下面，我们可以看到如何创建这样一个函数的示例:</p><pre class="mg mh mi mj gt ml mm mn mo aw mp bi"><span id="1594" class="mq ld iq mm b gy mr ms l mt mu">// We’ve separated out the memoization function from our Fibonacci calculating function to allow it to be reused.</span><span id="83ba" class="mq ld iq mm b gy mv ms l mt mu">function memoize(fn) {</span><span id="c77f" class="mq ld iq mm b gy mv ms l mt mu">   // We create the cache which we'll use to store the inputs and calculated results.</span><span id="f90f" class="mq ld iq mm b gy mv ms l mt mu">   const memoCache = {};</span><span id="0bf0" class="mq ld iq mm b gy mv ms l mt mu">   return function(n) {</span><span id="6310" class="mq ld iq mm b gy mv ms l mt mu">      // We can check if we've already performed a calculation using the given input.</span><span id="0eb6" class="mq ld iq mm b gy mv ms l mt mu">      // If we have, we can simply return that result.</span><span id="8dfe" class="mq ld iq mm b gy mv ms l mt mu">      if(memoCache[n]) {</span><span id="7efc" class="mq ld iq mm b gy mv ms l mt mu">         return memoCache[n];</span><span id="0c10" class="mq ld iq mm b gy mv ms l mt mu">      }</span><span id="1c80" class="mq ld iq mm b gy mv ms l mt mu">      // If we don't find the current input in our cache, we'll need to perform the calculation.</span><span id="58e4" class="mq ld iq mm b gy mv ms l mt mu">      // We also need to make sure we store that input and result for future use.</span><span id="3c1a" class="mq ld iq mm b gy mv ms l mt mu">      const result = fn(n);</span><span id="9ac3" class="mq ld iq mm b gy mv ms l mt mu">      memoCache[n] = result;</span><span id="bea3" class="mq ld iq mm b gy mv ms l mt mu">      return result;</span><span id="4d58" class="mq ld iq mm b gy mv ms l mt mu">      }</span><span id="b459" class="mq ld iq mm b gy mv ms l mt mu">}</span><span id="1f40" class="mq ld iq mm b gy mv ms l mt mu">// Our recursiveFibonacci function can remain the same.</span><span id="fbaa" class="mq ld iq mm b gy mv ms l mt mu">function recursiveFibonacci(n) {</span><span id="28f5" class="mq ld iq mm b gy mv ms l mt mu">   if (n &lt;= 1) {</span><span id="8a2a" class="mq ld iq mm b gy mv ms l mt mu">      return n;</span><span id="8df8" class="mq ld iq mm b gy mv ms l mt mu">   }</span><span id="c5d5" class="mq ld iq mm b gy mv ms l mt mu">   return recursiveFibonacci(n - 1) + recursiveFibonacci(n - 2);</span><span id="e5ac" class="mq ld iq mm b gy mv ms l mt mu">}</span><span id="05de" class="mq ld iq mm b gy mv ms l mt mu">// We reassign recursiveFibonacci to our memoize function with recursiveFibonacci passed as the argument.</span><span id="08ed" class="mq ld iq mm b gy mv ms l mt mu">recursiveFibonacci = memoize(recursiveFibonacci);</span><span id="9ea8" class="mq ld iq mm b gy mv ms l mt mu">recursiveFibonacci(6);</span><span id="fab9" class="mq ld iq mm b gy mv ms l mt mu">// 8</span><span id="85ac" class="mq ld iq mm b gy mv ms l mt mu">recursiveFibonacci(10);</span><span id="ef74" class="mq ld iq mm b gy mv ms l mt mu">// 55</span><span id="1dcc" class="mq ld iq mm b gy mv ms l mt mu">recursiveFibonacci(20);</span><span id="5776" class="mq ld iq mm b gy mv ms l mt mu">// 6765</span></pre><p id="cb0d" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">太好了！我们现在有了一个更有效的递归解决方案，可以避免重复同样的工作。这意味着，当正确实现时，我们的运行时变得线性而不是指数，这是一个巨大的改进。</p><p id="0e06" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">此外，由于这是一个非常通用的函数，我们甚至可以结合其他递归函数重用它。在这种情况下，您可能还希望增加函数能够接受的参数数量，例如使用…args，以便使它更加抽象。</p><h1 id="3f2f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">关于记忆化的一个注记</h1><p id="0542" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">通过创建缓存，我们使用了额外的空间，所以你必须决定是否值得提高速度。如果你有一个非常大的输入范围，你不太可能需要重复相同的计算，记忆可能不是一个有效的解决方案。</p><h1 id="30c9" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">来源</h1><ol class=""><li id="68cf" class="mx my iq kg b kh ma kl mb kp mz kt na kx nb lb nc nd ne nf bi translated"><a class="ae kd" href="https://codeburst.io/understanding-memoization-in-3-minutes-2e58daf33a19" rel="noopener" target="_blank">“3分钟理解JavaScript记忆化</a>”，Codesmith在codeburst.io上，2020年11月20日访问</li><li id="1751" class="mx my iq kg b kh ng kl nh kp ni kt nj kx nk lb nc nd ne nf bi translated"><a class="ae kd" href="https://medium.com/@reallygordon/implementing-memoization-in-javascript-5d140bb04166" rel="noopener">“在Javascript中实现记忆化</a>”，Arielle Gordon on Medium，2020年11月20日访问</li><li id="0b43" class="mx my iq kg b kh ng kl nh kp ni kt nj kx nk lb nc nd ne nf bi translated"><a class="ae kd" href="https://medium.com/launch-school/recursive-fibonnaci-method-explained-d82215c5498e" rel="noopener">“递归斐波纳契方法解释</a>”，Bennie van der Merwe，LaunchSchool on Medium，2020年11月20日访问</li><li id="cf70" class="mx my iq kg b kh ng kl nh kp ni kt nj kx nk lb nc nd ne nf bi translated"><a class="ae kd" href="https://www.livescience.com/37470-fibonacci-sequence.html" rel="noopener ugc nofollow" target="_blank">“什么是斐波那契数列？</a>，Tia Ghose关于生命科学，2020年11月20日获取</li></ol></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="de8f" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><em class="mk">原载于2020年11月20日</em><a class="ae kd" href="https://dev.to/ionabrabender/memoization-and-recursion-228f" rel="noopener ugc nofollow" target="_blank"><em class="mk">https://dev . to</em></a><em class="mk">。</em></p></div></div>    
</body>
</html>