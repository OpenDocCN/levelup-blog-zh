<html>
<head>
<title>Basics of Caching Data in GraphQL Apollo React Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL Apollo React客户端中缓存数据的基础知识</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/basics-of-caching-data-in-graphql-7ce9489dac15?source=collection_archive---------2-----------------------#2019-01-02">https://levelup.gitconnected.com/basics-of-caching-data-in-graphql-7ce9489dac15?source=collection_archive---------2-----------------------#2019-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fcf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个剧本，讲述了在React Apollo GraphQL中访问和操作存储/缓存的一些常见模式。作为入门，请阅读<a class="ae kl" href="https://www.apollographql.com/docs/react/essentials/get-started.html#installation" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/docs/react/essentials/get-started . html # installation</a></p><h2 id="b642" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated"><strong class="ak">直接缓存访问</strong></h2><p id="8f07" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">要访问数据缓存，您可以通过<code class="fe lk ll lm ln b">DataProxy</code>接口使用阿波罗客户端类方法<code class="fe lk ll lm ln b">readQuery</code>、<code class="fe lk ll lm ln b">readFragment</code>、<code class="fe lk ll lm ln b">writeQuery</code>和<code class="fe lk ll lm ln b">writeFragment</code>。</p><h2 id="63d2" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">readQuery</h2><p id="77f5" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated"><code class="fe lk ll lm ln b">readQuery</code>永远不会向您的GraphQL服务器发出请求。它将总是从缓存中读取一个错误；因此，确保只读取你知道你在商店里的数据。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/799467b6223b2dd6a3b889aa7e446248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8YgqtDNO3AINXcmlqLZEQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">readQuery的用法示例</figcaption></figure><p id="ed9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，如果适当的数据不在您的缓存中，<code class="fe lk ll lm ln b">query</code>方法可能会向您的服务器发送一个请求。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi me"><img src="../Images/bcd13d4694f11c4d45164699928af129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mkDmjsySOil67N0R3Nhqg.png"/></div></div></figure><h2 id="fb1f" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">读取碎片</h2><p id="39ec" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated"><code class="fe lk ll lm ln b">readFragment</code>允许您从您查询的任何节点读取数据，而<code class="fe lk ll lm ln b">readQuery</code>只允许您从根查询类型读取数据。</p><p id="ec9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，您需要初始化ApolloClient时定义的由<code class="fe lk ll lm ln b">dataIdFromObject</code>函数返回的数据的<code class="fe lk ll lm ln b">id</code>。如果<code class="fe lk ll lm ln b">id</code>不存在于缓存中<code class="fe lk ll lm ln b">readFragment</code>将返回null。如果<code class="fe lk ll lm ln b">id</code>确实存在，但是没有片段查询指定的字段，那么将抛出一个错误。</p><p id="8ded" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">神奇的是，对象可以来自任何地方——它可能是商店中的单例对象，也可能是列表对象，甚至可能是变异对象。只要GraphQL服务器为您提供了片段形状的对象，您就可以从缓存中读取它。</p><h2 id="d65a" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">writeQuery和writeFragment</h2><p id="3322" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">您还可以将任何数据写入缓存。注意，这只会更改本地缓存中的数据，而不会更改服务器中的数据。如果重新加载，更改将会消失。</p><p id="c4d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些方法具有与<code class="fe lk ll lm ln b">readQuery</code>和<code class="fe lk ll lm ln b">readFragment</code>相同的函数签名，除了需要传递一个额外的<code class="fe lk ll lm ln b">data</code>变量。</p><p id="815c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Apollo客户端商店的任何订户都会看到这些更新，并相应地呈现UI。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mf"><img src="../Images/394378d379fc1a23f2ef21fccf16c403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovPcG5Ne2wcbiVTv6_-NRQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">writeQuery用法示例</figcaption></figure><h1 id="7363" class="mg kn iq bd ko mh mi mj kr mk ml mm ku mn mo mp kx mq mr ms la mt mu mv ld mw bi translated">为什么要使用数据存储？</h1><h2 id="2760" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">绕过缓存</h2><p id="2c2e" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">当对特定操作不使用缓存有意义时，您可以在查询中使用<code class="fe lk ll lm ln b">network-only</code>或<code class="fe lk ll lm ln b">no-cache</code> fetchPolicy <strong class="jp ir"> </strong>。</p><ul class=""><li id="3d65" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated"><code class="fe lk ll lm ln b">network-only</code>仍然将响应保存到缓存中以备后用，绕过读取并强制网络请求。这是为了确保与服务器的数据一致性，但这是以对用户的即时响应为代价的。</li><li id="4228" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated"><code class="fe lk ll lm ln b">no-cache</code>策略不会读取，也不会将响应写入缓存。它将始终使用您的网络接口向服务器发出请求。与仅网络策略不同，它不会在查询完成后将任何数据写入缓存。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nl"><img src="../Images/425f3d3e64cebb630c7d25958881201b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdJyucoa_43WEmaKlhKPJQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">用于查询的仅网络和缓存优先提取策略的使用示例</figcaption></figure><blockquote class="nm nn no"><p id="f4e2" class="jn jo np jp b jq jr js jt ju jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj kk ij bi translated">fetchPolicy有比这两个变体更多的内容。在<a class="ae kl" href="https://www.apollographql.com/docs/react/api/react-apollo.html#graphql-config-options-fetchPolicy" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/docs/react/API/react-Apollo . html # graph QL-config-options-fetchPolicy</a>上阅读有关fetch policy的更多信息</p></blockquote><h2 id="98ea" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">突变后更新</h2><p id="b2b9" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">如果您想在对象列表中添加一些内容而不重新提取整个列表，或者如果有些对象不能分配对象标识符，Apollo Client就不能更新现有的查询。</p><ul class=""><li id="f705" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated"><code class="fe lk ll lm ln b">refetchQueries</code>是更新缓存最简单的方法。使用<code class="fe lk ll lm ln b">refetchQueries</code>,您可以指定一个或多个在突变完成后要运行的查询，以重新提取可能受突变影响的存储部分。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nt"><img src="../Images/e18eac402865f6a7945a129134330521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*roxzNed6xs0p-Q_mK6L9Rw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">变异后refetchQueries的用法示例</figcaption></figure><p id="7799" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您用一个字符串数组调用<code class="fe lk ll lm ln b">refetchQueries</code>，那么Apollo Client将寻找以前调用的与提供的字符串同名的查询，然后用它们当前的变量重新提取这些查询。您还可以导入对其他组件的查询，以确保这些组件将被更新。</p><ul class=""><li id="3854" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated"><code class="fe lk ll lm ln b">update</code>允许您以自己喜欢的任何方式对数据模型进行更改，以响应突变。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nu"><img src="../Images/dc39f297497673f7b216107215def441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZg2ovTx7KEYpMpjVU9ZHg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">突变后更新的用法示例</figcaption></figure><blockquote class="nm nn no"><p id="b9b5" class="jn jo np jp b jq jr js jt ju jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj kk ij bi translated">注意突变后的更新有一整套技术挑战。在<a class="ae kl" href="https://www.apollographql.com/docs/react/features/optimistic-ui.html" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/docs/react/features/Optimistic-UI . html</a>上阅读有关乐观用户界面的更多信息</p></blockquote><h2 id="d675" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">增量装载</h2><p id="0097" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">如果您想处理无限滚动分页，或者当加载更多数据而不是丢弃一个列表时，只需将新加载的数据追加到已经在存储中的列表中，您可以使用<code class="fe lk ll lm ln b">fetchMore</code>。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nv"><img src="../Images/dbc5fd757df4948a6dc036eccf86b02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3HJsxiboZVS1d2DADcm5g.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">增量加载的fetchMore用法示例</figcaption></figure><p id="bcab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">fetchMore方法获取要与新查询一起发送的变量映射。我们需要传入一个偏移量来避免获取已经在存储中的项目。请注意，变量映射与为与组件相关联的查询指定的映射合并，因此，例如，一旦设置了变量映射，就不需要传递限制。</p><p id="be6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，<code class="fe lk ll lm ln b">fetchMore</code>查询是与容器相关联的查询，但是它也可以接受名为argument的查询，该查询可以是包含查询的GraphQL文档。</p><h2 id="0d54" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated"><code class="fe lk ll lm ln b">@connection</code>指令</h2><p id="ec1e" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">分页查询是相同的查询，只是对<code class="fe lk ll lm ln b">fetchMore</code>的调用更新了相同的缓存键。由于处理分页的字段通常有一些额外的参数，如cursor或limit，我们希望确保我们有一个干净的缓存键，不包括这些参数。</p><p id="6ed7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Apollo Client 1.6中引入的<code class="fe lk ll lm ln b">@connection</code>指令有助于指定从该字段返回的数据应该存储在所提供的键下，从而更容易由于突变或分页结果而追加到列表中。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nw"><img src="../Images/c471fdb53e00f636334e42c5ad51e636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lEd4MbDRilVAbgkpwMINw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">@connection指令的用法示例</figcaption></figure><p id="ae34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们不在那个字段上使用<code class="fe lk ll lm ln b">@connection</code>指令，我们的变异更新函数将需要重新生成最初传递给那个字段的参数的精确集合。</p><p id="3a78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为connection指令为结果指定了一个自定义的存储键，所以我们也不需要为访问缓存数据提供分页参数，比如限制、偏移量或游标。即使有多个<code class="fe lk ll lm ln b">fetchMore</code>，每次feed更新的结果总是会导致商店中的feed键被更新为最新的累积值。</p><p id="8157" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以使用<code class="fe lk ll lm ln b">@connection</code>指令的可选<code class="fe lk ll lm ln b">filter</code>参数在store键中包含<code class="fe lk ll lm ln b">type</code>查询参数，这将产生多个store值，这些值累积了来自每种类型提要的查询。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mf"><img src="../Images/7adf76b255fa3468ad2cdfaab410e8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qmnf8YF7hS1kCO7EIu-35A.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">在我们的变异中使用@connection指令的好处</figcaption></figure><blockquote class="nm nn no"><p id="da94" class="jn jo np jp b jq jr js jt ju jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj kk ij bi translated">在<a class="ae kl" href="https://www.apollographql.com/docs/react/features/pagination.html#connection-directive" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/docs/react/features/pagination . html # connection-directive</a>和<a class="ae kl" href="https://www.apollographql.com/docs/react/advanced/caching.html#connection-directive" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/docs/react/advanced/caching . html # connection-directive</a>上阅读有关<code class="fe lk ll lm ln b">@connection</code>指令的更多信息</p></blockquote><h2 id="8b54" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">用<code class="fe lk ll lm ln b">cacheRedirects</code>缓存重定向</h2><p id="45e2" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">在某些情况下，查询会请求已存在于客户端存储中的不同关键字下的数据。一个非常常见的例子是当你的UI有一个列表视图和一个细节视图，两者都使用相同的数据。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/522ec2fe65314fe4095c03eaef4aea93.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*r9B2HdVtFNqmG9EQyYCHwA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">查询以列出书籍</figcaption></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/a3ed91ed43cf75426c61227b91d06379.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*hmVhHNmgLaNwA7Q2jITqPA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">显示图书详细信息的查询</figcaption></figure><blockquote class="nm nn no"><p id="5bd1" class="jn jo np jp b jq jr js jt ju jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj kk ij bi translated">注意:列表查询返回的数据必须包括特定查询需要的所有数据。如果特定的图书查询获取了列表查询没有返回的字段，Apollo客户机就不能从缓存中返回数据。</p></blockquote><p id="7991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们知道数据很可能已经在客户端缓存中，但是因为它是由不同的查询请求的，所以Apollo客户端不知道这一点。为了告诉Apollo客户机在哪里寻找数据，我们可以定义定制的解析器。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nz"><img src="../Images/b8339abe77c0c62db7796d05615d16da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fH5p4tXnzK5GpDEs6_2yuQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用缓存重定向的自定义解析程序</figcaption></figure><p id="6c3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:只要您使用相同的方法，这也适用于自定义的dataIdFromObject方法。</p><p id="75f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:<code class="fe lk ll lm ln b">getCacheKey</code>在第三个参数中被传递给解析器，以根据其<code class="fe lk ll lm ln b">__typename</code>和<code class="fe lk ll lm ln b">id</code>生成对象的键。</p><p id="7a25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了弄清楚应该在<code class="fe lk ll lm ln b">__typename</code>属性中放入什么，在GraphiQL中运行一个查询，并获得<code class="fe lk ll lm ln b">__typename</code>字段。</p><h2 id="a7c3" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">重置商店</h2><p id="e47c" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated"><code class="fe lk ll lm ln b">client.resetStore</code>完全重置阿波罗缓存。它还会重新提取任何活动的查询，并且是异步的。</p><p id="b13b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想清空存储但不想重新提取活动的查询，使用<code class="fe lk ll lm ln b">client.clearStore()</code>而不是<code class="fe lk ll lm ln b">client.resetStore()</code>。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oa"><img src="../Images/1de17f3f14c8fffee35254f3175edfd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rIsSSLOaW5vtac9ugOGGog.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">client.resetStore的使用示例</figcaption></figure><p id="888c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要注册一个在存储被重置后执行的回调函数，使用<code class="fe lk ll lm ln b">client.onResetStore</code>并传递您的回调函数。要注册多个回调，请再次调用<code class="fe lk ll lm ln b">client.onResetStore</code>。所有回调都被放入一个数组中并发执行。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ob"><img src="../Images/797a3b5b16b41623675a65822ad2f3d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KJdp9saILISmaDZY4QzXw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">client.onResetStore的使用示例</figcaption></figure><p id="5e01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:如果您使用<code class="fe lk ll lm ln b">apollo-link-state</code>进行本地状态管理，并在应用程序中的任何地方调用<code class="fe lk ll lm ln b">client.resetStore</code>，请使用<code class="fe lk ll lm ln b">client.onResetStore</code>将默认值写入缓存。</p><p id="6350" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以从React组件中调用<code class="fe lk ll lm ln b">client.onResetStore</code>。如果您希望在重置存储后强制重新呈现用户界面，这将非常有用。</p><p id="eabe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想从<code class="fe lk ll lm ln b">client.resetStore</code>取消订阅您的回调，请使用<code class="fe lk ll lm ln b">client.onResetStore</code>的返回值来取消订阅功能。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oc"><img src="../Images/7b7d3fcd94aa09e9266091002af52a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POhdM3A6Dsshklfr7PTUng.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">取消订阅您的客户端。onResetStore回调</figcaption></figure></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="df9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://www.apollographql.com/docs/react/advanced/caching.html" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/docs/react/advanced/Caching . html</a>上阅读有关缓存数据的更多信息</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><figure class="lp lq lr ls gt lt gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi ok"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure><div class="ol om gp gr on oo"><a href="https://gitconnected.com/learn/graphql" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">学习GraphQL -最佳GraphQL教程(2019) | gitconnected</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">9大GraphQL教程。课程由开发者提交并投票，让你找到最好的图表</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">gitconnected.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ly oo"/></div></div></a></div></div></div>    
</body>
</html>