<html>
<head>
<title>Optimising JavaScript Array Searches: Benchmarked</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化JavaScript数组搜索:基准测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimising-javascript-array-searches-benchmarked-3d7e2725f17f?source=collection_archive---------3-----------------------#2019-12-15">https://levelup.gitconnected.com/optimising-javascript-array-searches-benchmarked-3d7e2725f17f?source=collection_archive---------3-----------------------#2019-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/efb7070be1ad475a74d4a9b9a8611687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwaCKr3izY6yfQkcBhF7_A.png"/></div></div></figure><p id="5090" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我看过许多关于JavaScript字符串数组循环的最佳方式的文章和基准，它们通常都给出相同的结果。我还没有看到任何人试图改进他们使用的循环方法，这给了我挑战。我想看看我们是否能改进数组迭代器，以便更好地找到存储在其中的数据。</p><p id="2580" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看JavaScript中遍历数组的不同方式</p><p id="b9a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有传统的<code class="fe kw kx ky kz b"><strong class="ka ir">for</strong></code> <strong class="ka ir"> </strong>循环:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="c857" class="li lj iq kz b gy lk ll l lm ln">for(let i = 0 ; i &lt; maxArraySize; i++) {<br/>    let item = array[i];<br/>}</span></pre><p id="7131" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后是<code class="fe kw kx ky kz b"><strong class="ka ir">forEach</strong></code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="bc6a" class="li lj iq kz b gy lk ll l lm ln">array.forEach(val =&gt; {<br/>    // Do something with val<br/>});</span></pre><p id="5cf7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，还有<code class="fe kw kx ky kz b"><strong class="ka ir">for…in</strong></code>，虽然很少使用，但仍然很有用:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="6d96" class="li lj iq kz b gy lk ll l lm ln">for (let val in array) {<br/>    // do something with val<br/>}</span></pre><p id="bd21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于那些懂JavaScript的人来说，他们知道有一个内置函数<code class="fe kw kx ky kz b"><strong class="ka ir">indexOf</strong></code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="cb66" class="li lj iq kz b gy lk ll l lm ln">array.indexOf(stringToFind);</span></pre><p id="b3de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">知道所有这些函数以及何时使用它们是很棒的，但是当你的字符串数组已经达到极限时，为什么不在你可以的地方优化它呢？</p><p id="f3c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我决定用一些不同的方法来看看是否有一种方法可以优化它们，但是这些方法大多依赖于运气。</p><p id="0f97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，从结尾开始循环:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="d899" class="li lj iq kz b gy lk ll l lm ln">for(let i = maxArraySize ; i &gt;= 0; i--) {<br/>    // Do something with array(i);<br/>}</span></pre><p id="8173" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有当你知道你的价值接近终点时，上面的方法才有效。</p><p id="abcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我于是想出了<code class="fe kw kx ky kz b"><strong class="ka ir">stabInTheDark</strong></code>方法:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="a562" class="li lj iq kz b gy lk ll l lm ln">function stabInTheDark(array, stringToFind){<br/>    while(true){<br/>        let index = Math.floor(Math.random() * Math.floor(maxArraySize));<br/>        if(array[index] === stringToFind){<br/>            return true;<br/>        }<br/>     }<br/>}</span></pre><p id="80de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上述方法的问题是，它会随机尝试并找到值，由于它不跟踪它以前做了什么(这将浪费时间)，因此有可能出现重复比较。</p><p id="d39a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我想到这个解决方案已经用了几十年了:<strong class="ka ir">索引你的数据</strong>。</p><p id="5e87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果数据库索引它们的数据以避免扫描，为什么我们不在编程语言中使用它？也许是因为我们可能只遍历一组数据一次，然后就将其转储，但是如果您必须多次重用相同的数据呢？我试了一下，结果如下。</p><p id="d090" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想出了下面的函数和索引生成器:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="138e" class="li lj iq kz b gy lk ll l lm ln">function searchInIndexed(indexedObj, stringToFind){<br/>    let firstChar = stringToFind[0];<br/>    let n = indexedObj[firstChar].length;<br/>    for(let i = 0 ; i &lt; n; i++) {<br/>        if(indexedObj[firstChar][i] === stringToFind){<br/>            return true;<br/>        }<br/>    }<br/>}</span><span id="9c50" class="li lj iq kz b gy lo ll l lm ln">function createIndexArr(array){<br/>    // Our indexed object<br/>    let newObj = {}<br/>    for(let i = 0 ; i &lt; maxArraySize; i++) {<br/>        // We'll use the first character of the string to base our index. Could in the range of [a-z,1-9]<br/>        let firstChar = array[i][0];<br/>        if(newObj[firstChar]){<br/>            newObj[firstChar].push(array[i]);<br/>        } else {<br/>            newObj[firstChar] = [array[i]];<br/>        }<br/>    }<br/>    return newObj;<br/>}</span></pre><p id="85a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是索引数据现在的样子:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/247e5c505a92e1ae703c707996b87bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfKkuoi6dkw6CStBmoWLXQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">索引字符串数组</figcaption></figure><p id="3c6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试规则如下:</p><ol class=""><li id="48e1" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated">搜索必须使用相同的字符串数组数据</li><li id="6d32" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">每个方法必须循环1000次</li><li id="045d" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">结果必须一致才有效</li></ol><p id="c23c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建单词数组花费了<strong class="ka ir"> 25.661秒，构建索引花费了</strong>0.591秒。</p><p id="b3c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是按最快秒排序的方法时间:</p><ol class=""><li id="b151" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated">索引搜索:<strong class="ka ir"> 23.794 </strong></li><li id="709c" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">指数:<strong class="ka ir"> 40.92 </strong></li><li id="55f7" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">forLoop: <strong class="ka ir"> 62.869 </strong></li><li id="84bc" class="lu lv iq ka b kb md kf me kj mf kn mg kr mh kv lz ma mb mc bi translated">预测:<strong class="ka ir"> 178.479 </strong></li></ol><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/e304aeaadb1cd178eb7c7d7ff519874d.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*FMbRnD8jgzZmuYE3LXvDKg.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">循环1000次的结果</figcaption></figure><p id="8511" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果循环只使用一次，那么<strong class="ka ir"> indexOf </strong>方法将是最快的，因为索引构建时间会增加搜索时间。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/a689c01716d463aef008775c1da0d031.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*Qfo4X5QLToVoGF3NIDJDwQ.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">循环一次的结果</figcaption></figure><p id="a30d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">总结</strong>:根据这些结果，我们可以了解到，你的应用程序总有优化的空间，尤其是当你知道你的数据看起来像什么，以及它在现实世界中如何运作的时候。如果您有一个包含几十万个字符串的字符串数组，那么索引这些数据将是最快的方法。</p><p id="5240" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使它不是一个字符串数组，当你遍历你的数据时，总是试图找到最快的方法来得到你想要的数据。这真的会有很大的不同。</p><p id="b3b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是完整的运行代码，供感兴趣的人参考:【https://github.com/CyberCyclone/optimising-string-arrays<a class="ae mk" href="https://github.com/CyberCyclone/optimising-string-arrays" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>