<html>
<head>
<title>Build the famous Tic Tac Toe game in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中构建著名的井字游戏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-the-famous-tic-tac-toe-game-in-flutter-8c6464869bca?source=collection_archive---------2-----------------------#2021-03-25">https://levelup.gitconnected.com/build-the-famous-tic-tac-toe-game-in-flutter-8c6464869bca?source=collection_archive---------2-----------------------#2021-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1b5cab7ef66f2208ce46de4611f48bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VtaHgkHryXueAlJ_j0AeBg.png"/></div></div></figure><p id="e648" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将探讨如何为著名游戏<strong class="kd iu">井字游戏</strong>构建UI和业务逻辑。</p><p id="f678" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我从头开始构建整个应用程序，我将深化这个框架的一些概念。</p><p id="36b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们开始创建`<em class="kz"> main.dart </em>文件:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="cb87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Flutter中，出现在屏幕上的所有东西都是一个小部件。当我们创建用户界面时，我们制作了一个小部件的组合。当我们将一个窗口小部件嵌套在另一个窗口小部件中时，我们创建了一个叫做<strong class="kd iu">窗口小部件树</strong>的层次结构。</p><p id="2adc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">`<em class="kz"> main() </em>'函数是入口点，而`<em class="kz"> runApp() </em>'函数获取`<em class="kz">小部件</em>的实例，并使其成为小部件树的根。</p><p id="6398" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">`<em class="kz"> MyApp </em>`是一个扩展了`<em class="kz"> StatelessWidget </em>的类。</p><p id="7b20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在`<em class="kz"> build </em>`方法中，我使用了由Flutter提供的`<em class="kz"> MaterialApp </em>`小部件。它代表了遵循材料设计准则的用户界面的框架。我的小部件的家是另一个小部件，叫做“主屏幕，我将很快创建它。</p><h2 id="d84b" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">无状态和有状态小部件</h2><p id="ac3e" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在Flutter中，一个小部件可以扩展或者`<em class="kz"> StatelessWidget </em>或者`<em class="kz"> StatefulWidget </em>`。</p><ol class=""><li id="cfa4" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated"><strong class="kd iu"> StatelessWidget </strong>是一种不需要可变状态的小部件，也就是说UI不会随着时间而改变。(<a class="ae mn" href="https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html" rel="noopener ugc nofollow" target="_blank">更多信息</a>)</li></ol><p id="6712" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.<strong class="kd iu"> StatefulWidget </strong>是一个具有可变状态的小部件，也就是说UI会随着时间而改变。(<a class="ae mn" href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html" rel="noopener ugc nofollow" target="_blank">更多信息</a>)</p><h2 id="b482" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">键</h2><p id="bd8c" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">您可能已经注意到，Flutter提供的任何小部件都有可选的“<em class="kz"> key </em>”参数。‘关键字’唯一地标识树中的小部件。</p><p id="5d1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">主屏幕用户界面</strong></p><p id="09e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我创建了另一个名为`<em class="kz"> home_screen.dart </em>的文件，这个类扩展了一个`<em class="kz"> StatefulWidget </em>`。该微件被插入到微件树中。` _HomeScreenState '是` HomeScreen `小工具的可变状态。</p><p id="b093" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当Flutter重建窗口小部件树刷新UI时，调用`<em class="kz"> build() </em>`方法。</p><p id="9ac6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">稍后我将详细介绍如何刷新我们的视图，现在让我们构建我们的UI。</p><p id="381d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在`<em class="kz"> build </em>`方法中有一个`<em class="kz"> Scaffold </em>`小部件，它实现了基本的材质设计布局结构。</p><p id="308f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它有一个`<em class="kz"> AppBar </em>`放置在屏幕的顶部，带有相对动作按钮、标题和主体，在我们的例子中是一个`<em class="kz">列</em>`小部件。</p><p id="26e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在动作中，我插入了一个“<em class="kz"> IconButton </em>”小部件，当图标被按下时，我将用它来重启游戏。</p><p id="1ba4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在`<em class="kz">列</em>`小部件中，我将在给定的空间约束下在垂直轴上插入三个孩子。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><h2 id="e490" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">点数表</h2><p id="f36c" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">`<em class="kz"> _buildPointsTable() </em>`方法，建立游戏的积分段。</p><p id="4835" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个简单的“<em class="kz">容器</em>,里面有一个“<em class="kz">行</em>”,在水平轴上放置更多的孩子。根据`<em class="kz"> mainAxisAlignment </em>的值，行中的小部件可以以不同的方式放置。在我们的例子中，我将小部件放在了行的中间。</p><p id="42f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我将使用一个`<em class="kz">列</em>小部件来输入玩家`<em class="kz"> o </em>和他的相对分数。对玩家`<em class="kz"> x </em>'和他的相对分数重复同样的事情。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">点数表微件</figcaption></figure><h2 id="4ed9" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">构建网格</h2><p id="20fc" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">`<em class="kz"> _buildGrid </em>()`方法，构建游戏的网格。本质上，它是一个3行x 3列的网格，带有边框装饰。对于网格中的每一项，我将添加一个点击事件，根据玩家的回合绘制一个`<em class="kz"> o </em>或`<em class="kz"> x </em>`。</p><p id="fc72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我也用白色或红色来区分两个玩家。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">构建网格小部件</figcaption></figure><h2 id="a019" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">建立转弯</h2><p id="c504" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">最后，在`<em class="kz"> _buildTurn() </em>`方法中，我构建了一个简单的小部件来显示玩家的回合。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">构建转弯微件</figcaption></figure><p id="dfb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，如果我在模拟器上启动应用程序，我将得到以下结果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/3f6078684534e8956a25a3d2d2fe461b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZaPswxhMdG5_qbdzAXUqw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">应用程序的框架</figcaption></figure><h2 id="ea08" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">业务逻辑</h2><p id="3988" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在进入管理游戏的逻辑部分之前，在我们的“build()”方法中，我插入了以下变量。</p><p id="6daa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个变量前的`<em class="kz"> _ </em>`表示它们是私有的。</p><p id="5deb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">`<em class="kz"> _xOrOList </em>`代表我们的网格，它将包含玩家的所有不同的移动。</p><p id="3f45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">网格的第一个单元格匹配数组的第一个元素，网格的第二个单元格匹配数组的第二个元素，依此类推。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">初始变量</figcaption></figure><h2 id="b9d6" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">抽头法</h2><p id="a74c" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">`<em class="kz"> _tapped() </em>`方法，每当任何玩家单击网格的单元格时都会调用该方法。</p><p id="16d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次点击都会检查是否轮到玩家“<em class="kz"> o </em>或玩家“<em class="kz"> x </em>”以及所选单元格是否为空。</p><p id="7645" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据具体情况，相应数组的索引值为“<em class="kz"> o </em>或“<em class="kz"> x </em>”,填充的单元格数量增加。</p><p id="6ed1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我会改变回合，通过调用`<em class="kz"> _checkTheWinner() </em>`方法来检查是否有赢家。</p><p id="1669" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">`<em class="kz">State&lt;T&gt;T43】的子类获得对`<em class="kz"> setState() </em>方法的访问，该方法重建小部件并因此刷新UI。</em></p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">抽头法</figcaption></figure><p id="272e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">`<em class="kz"> _checkTheWinner() </em>`方法，检查是否有赢家只需检查在对角线、水平或垂直行中有三次相同的符号` o '或` x ',并显示一个带有消息的警告对话框。</p><p id="80eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果不满足任何条件，并且所有9个单元格都已满，则会出现一个警告对话框，并显示一条绘制消息。</p><p id="e749" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">检查发生在:</p><ul class=""><li id="1b0c" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mt mk ml mm bi translated">第一排；</li><li id="9b20" class="me mf it kd b ke mu ki mv km mw kq mx ku my ky mt mk ml mm bi translated">第二排；</li><li id="90a5" class="me mf it kd b ke mu ki mv km mw kq mx ku my ky mt mk ml mm bi translated">第三排；</li></ul><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/f4acd27fc9aa580725a200ec52895074.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*97zZ6DGNXG4vTuTmMy6s9g.jpeg"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">三排</figcaption></figure><ul class=""><li id="78c5" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mt mk ml mm bi translated">第一列；</li><li id="bd88" class="me mf it kd b ke mu ki mv km mw kq mx ku my ky mt mk ml mm bi translated">第二列；</li><li id="1d81" class="me mf it kd b ke mu ki mv km mw kq mx ku my ky mt mk ml mm bi translated">第三列；</li></ul><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi na"><img src="../Images/96563a62011221250ec23d363e52155a.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*9ReLihHKyeT7cGHq_h5cFg.jpeg"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">三根柱子</figcaption></figure><ul class=""><li id="4f6c" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mt mk ml mm bi translated">两条对角线</li></ul><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e6de5e92480fd99ac695b4a5fd916069.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*TNHHnI9jUWqpfPMuO1XeVA.jpeg"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">两条对角线</figcaption></figure><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="6558" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我只用了很少几行代码就能构建出一个完整的程序，它可以在iOS和Android操作系统上运行。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/35d88d1e65630820ccfb389e2c125032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2cD2WWFC8GHmGZ1o_cQLg.png"/></div></div></figure><p id="28c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">链接到我的源代码https://github.com/davideagostini/tic_tac_toe<a class="ae mn" href="https://github.com/davideagostini/tic_tac_toe" rel="noopener ugc nofollow" target="_blank"/></p><p id="9831" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望这篇教程能对你接下来的移动开发有所帮助。</p><p id="343f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下节课再见。😉</p></div></div>    
</body>
</html>