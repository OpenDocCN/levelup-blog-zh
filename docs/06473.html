<html>
<head>
<title>Docker Desktop on WSL2: The Problem with Mixing File Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WSL2上的Docker桌面:混合文件系统的问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/docker-desktop-on-wsl2-the-problem-with-mixing-file-systems-a8b5dcd79b22?source=collection_archive---------1-----------------------#2020-11-29">https://levelup.gitconnected.com/docker-desktop-on-wsl2-the-problem-with-mixing-file-systems-a8b5dcd79b22?source=collection_archive---------1-----------------------#2020-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f1e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将Windows目录装入容器时，如何避免因缺少文件更改事件而导致的问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b6efbef786b7118f5131ad4df150cef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HfH8KWAoYVLtoUKyCGamew.png"/></div></div></figure><p id="efdc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中:</p><ul class=""><li id="91d2" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">查找使用WSL2时将NTFS文件夹装入dev容器的问题的根本原因</li><li id="d646" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">正在安装Linux版本2的Windows子系统(WSL2)</li><li id="c9b3" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">在WSL2中安装Linux发行版</li><li id="70f8" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">配置git以便在Linux发行版中使用</li><li id="9b42" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">在Linux发行版中启动VS代码</li><li id="58a0" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">启动并连接到开发容器</li><li id="e65b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">避免常见陷阱</li></ul><h1 id="4341" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">介绍</h1><p id="cd33" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">最初，我以为这篇文章是关于。网芯。然后，当我运行使用NTFS文件夹的dev容器时，我遇到了我认为的VS代码扩展的问题。</p><p id="0e82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在过去，我的设置非常有效。然而，最近在我阅读了几份报告后，我转向了WSL2，特别是文件操作快了2到4倍。问题是在切换到WSL2之后开始的。</p><p id="a9bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我观察到的一个问题是，C#扩展，即OmniSharp，在引用一个类型时，停止提出诸如是否添加using-statement的建议。此外，代码中有许多红色的曲线。过去，要解决这个问题，我只需重启OmniSharp。这在某种程度上仍然有效，但现在我必须每隔几分钟重启一次。然后，Roslynator，我最喜欢的扩展之一，开始出现问题，并最终停止工作。</p><p id="cf6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我决定把这件事弄个水落石出。</p><h2 id="7f40" class="nb mf it bd mg nc nd dn mk ne nf dp mo ld ng nh mq lh ni nj ms ll nk nl mu nm bi translated">根本原因</h2><p id="b917" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">为了理解根本原因，我们需要深入研究一些技术细节。</p><p id="10d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的研究结束时，我得出结论，根本原因本质上是从WSL1到WSL2的回归。例如，这篇来自2016年10月的<a class="ae nn" href="https://devblogs.microsoft.com/commandline/wsl-adds-inotify-filesystem-change-notification-support/" rel="noopener ugc nofollow" target="_blank">博客文章指出inotify &amp;文件系统更改通知被添加到WSL1中。然而，</a><a class="ae nn" href="https://youtu.be/lwhMThePdIo" rel="noopener ugc nofollow" target="_blank">在Build 2019 </a>上的讲话和<a class="ae nn" href="https://github.com/docker/for-win/issues/8479#issuecomment-692827857" rel="noopener ugc nofollow" target="_blank">在Docker Desktop for Windows的一个问题上的评论</a>证实了WSL2的inotify问题。在Build 2019的演讲中，演讲者说inotify支持是为未来计划的(参见演讲结尾的Q &amp; A部分)。在Github 上提交的这个问题表明，在撰写本文时，inotify还没有实现。项目经理Craig Loewen的评论也证实了这一点(他是</p><p id="235d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下图显示了我的设置(LXFS = Linux文件系统，NTFS = NT文件系统)。请注意，这个图表并不完全准确。它的唯一目的是帮助说明问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b6efbef786b7118f5131ad4df150cef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HfH8KWAoYVLtoUKyCGamew.png"/></div></div></figure><p id="a75a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在此设置中，文件夹托管在Windows上。这意味着它在NT文件系统(NTFS)中。当dev容器启动时，NTFS文件夹被挂载到容器中。然而，该容器使用Linux文件系统(LXFS)。当使用VS代码在dev容器中远程工作时，所有VS代码扩展也在那里执行。然而，在这个设置中，从dev容器的角度来看，我们混合了文件系统。大部分是Linux文件系统，但是挂载的文件夹其实是NTFS。</p><p id="e3b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种混合导致了问题。因为NTFS和LXFS非常不同，例如权限管理，所以需要映射两者之间的功能。这包括有关目录和文件更改的通知。对于WSL1，通知(即对inotify的支持)已经实现并起作用。对于WSL2，如上所述，还不支持inotify。</p><p id="0e42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一些VS代码扩展依赖于在文件或目录改变时得到通知。例如，当创建一个新文件时，OmniSharp会对其进行分析，然后提出建议或指出错误。显然，当关于改变的文件或目录的通知没有被发送时，这不再起作用。</p><p id="a651" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我现在需要一个不同的解决方案来完成这项工作。找到这个解决方案始于我在上面提到的一个问题中发现的评论:</p><p id="f893" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“是的，将您的文件保存在WSL 2文件系统中。不要跨虚拟机边界共享它们，因为这样做性能不佳，而且会失去智能。”(来源:<a class="ae nn" href="https://github.com/docker/for-win/issues/8479#issuecomment-692827857" rel="noopener ugc nofollow" target="_blank">评论此处</a>)</p><p id="acf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不幸的是，我无法找到关于工作设置的足够详细的信息，所以决定根据各种来源的信息来弄清楚。具体来说，我不确定如何“将所有内容保存在Linux文件系统中”。本文描述了如何实现这一点，以及一个有效的开发环境是什么样子的。</p><h2 id="c021" class="nb mf it bd mg nc nd dn mk ne nf dp mo ld ng nh mq lh ni nj ms ll nk nl mu nm bi translated">先决条件</h2><p id="1ab3" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">跟随这篇文章你需要的是:</p><ul class=""><li id="3501" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">Windows 10版本1909内部版本18362或更高版本</li><li id="49ff" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><a class="ae nn" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> Docker桌面Windows版</a>2.5.0.1，使用WSL2集成(见下文)</li><li id="e665" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">【Windows版Git</li><li id="126c" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><a class="ae nn" href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows" rel="noopener ugc nofollow" target="_blank"> Git凭证管理器</a>(注意:在编写新的<a class="ae nn" href="https://github.com/microsoft/Git-Credential-Manager-Core" rel="noopener ugc nofollow" target="_blank"> Git凭证管理器核心</a>时，它还处于测试阶段，所以我们不会在本文中使用它)</li></ul></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="e254" class="me mf it bd mg mh nv mj mk ml nw mn mo jz nx ka mq kc ny kd ms kf nz kg mu mv bi translated">用于Linux的Windows子系统(WSL)，版本1和2</h1><p id="6dde" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">Docker如果运行在Linux上效果最好。这是因为当它这样做时，它可以与主机共享操作系统资源。Windows作为一个操作系统与Linux非常不同，这使得同样的紧密集成非常困难。这就是为什么，微软几年前推出了Linux的Windows子系统(WSL)。</p><p id="3a64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Windows在20世纪90年代被称为Windows NT。很多人没有意识到的是，Windows NT从一开始就被设计成有多个子系统。最初有OS/2、POSIX和Win32的子系统。当程序启动时，它可以指示它需要这些“个性”中的哪一个，即它想要使用哪一组API。</p><p id="c8b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着时间的推移，这些最初的子系统被淘汰。但是，Windows NT内核保持了支持Win32以外的子系统的能力。用于Linux的Windows子系统(WSL1)使用这种机制(参见<a class="ae nn" href="https://docs.microsoft.com/en-us/archive/blogs/wsl/windows-subsystem-for-linux-overview" rel="noopener ugc nofollow" target="_blank">“用于Linux的Windows子系统概述”</a>)。为了允许本机Linux ELF64二进制文件运行，子系统将模拟fork()之类的系统调用。系统调用将被翻译成对Windows NT内核的调用。WSL1没有使用Linux内核。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/5956edb4d1556e12d1533fb66d8f0e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*HcMir8YGKDkQuqRDZ2AulQ.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">WSL1架构</figcaption></figure><p id="639c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">WSL2改变了这一点。微软开发了一个合适的Linux内核，并使其与NT内核共存。WSL2不使用模拟器调用Windows NT内核，而是使用真正的Linux内核，它与Windows NT内核并行运行。</p><p id="0818" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">两个内核都运行在一个薄薄的管理程序层上。事实上，当您在Windows 10(即Hyper-V)上启用虚拟化服务时，虚拟机管理程序就会接管，而NT内核只是运行在虚拟机管理程序之上的虚拟机。这种设计允许WSL2在与Windows NT内核并行运行的独立虚拟机中使用真正的Linux内核。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/06e9e0e8bd090e88e769221db260344b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*ECx-4UDiDZPVdp1jAroPVg.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">WSL2架构</figcaption></figure><p id="4b74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在有几个Linux发行版可以安装在WSL2上，甚至可以同时安装几个。您可以将其中一个设置为默认值。你可以随意切换。下图显示了这种设置。请注意，多个Linux实例运行在同一个Linux VM中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/8c36336cb01b5411d9a9e6e02e92151c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyLNkok3I53sX-CRMSZk4Q.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">带有多个Linux发行版的WSL2</figcaption></figure><p id="d953" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在有几个Linux发行版可以安装在WSL2上，甚至可以同时安装几个。您可以将其中一个设置为默认值。你可以随意切换。下图显示了这种设置。请注意，多个Linux实例运行在同一个Linux VM中。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="ead1" class="me mf it bd mg mh nv mj mk ml nw mn mo jz nx ka mq kc ny kd ms kf nz kg mu mv bi translated">装置</h1><h2 id="f5b8" class="nb mf it bd mg nc nd dn mk ne nf dp mo ld ng nh mq lh ni nj ms ll nk nl mu nm bi translated">WSL2和Linux发行版</h2><p id="339b" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">我不会详细讨论安装启用WSL2的所有先决条件。这取决于你使用的Windows 10的版本和版本。在某些情况下，您必须升级到更新的版本。最低版本是内部版本号18362。我使用的是1909版本，编译号是18363。我还没有更新到Windows 10版本2004或更高的版本号。</p><p id="fdad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要安装必备软件，请参考这篇<a class="ae nn" href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" rel="noopener ugc nofollow" target="_blank">文章</a>。那篇文章还描述了您选择的Linux发行版的安装。截至发稿时，有12个可供选择。出于本文的目的，我选择了“Ubuntu 20.04 LTS ”,因为它已经预装了“git ”,而且我过去也使用过Ubuntu。如果你已经有其他发行版，没问题。只要确保其中一个是Ubuntu 20.04，如果你想跟踪这篇文章。</p><h2 id="bac3" class="nb mf it bd mg nc nd dn mk ne nf dp mo ld ng nh mq lh ni nj ms ll nk nl mu nm bi translated">安装Docker桌面</h2><p id="336f" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">当您安装Docker Desktop for Windows时，请确保您选择了WSL2集成。如果您在安装/启用WSL2之前安装了Docker，那么请完全卸载Docker并重新安装。重新安装时，选择WSL2集成。</p><h2 id="2ea6" class="nb mf it bd mg nc nd dn mk ne nf dp mo ld ng nh mq lh ni nj ms ll nk nl mu nm bi translated">配置Docker桌面</h2><p id="e2a0" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">一旦您按照步骤安装了WSL2和Linux，现在是时候确保我们可以在我们的开发环境中使用发行版了。特别是，我们需要确保Docker与我们的发行版相集成。</p><p id="8ba2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Windows上，打开Docker桌面，进入“设置”。然后选择“资源”，然后选择左侧的“WSL集成”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/86b96d5449eb72615b0b5e8b65f8ed26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgpRLsWD8XZE5NIhT__nDA.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">与WSL2和发行版集成的Docker设置</figcaption></figure><p id="8f55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">确保选中了与默认WSL发行版的集成，并且启用了与“Ubuntu 20.04”的集成。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="b462" class="me mf it bd mg mh nv mj mk ml nw mn mo jz nx ka mq kc ny kd ms kf nz kg mu mv bi translated">查找主目录</h1><h1 id="41e0" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">在文件资源管理器中查找主目录</h1><p id="b2a9" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">在Windows中，打开文件资源管理器，并在地址栏中键入“\\wsl$”。您应该会看到类似下面的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/b2d6411bc434f44d7ec489b1ce5b4c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yHaZp359VMAB9ScsCLvoeQ.png"/></div></div></figure><p id="e268" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任何发行版中的Linux文件系统在Windows资源管理器中都显示为网络驱动器。Windows是客户机，每个Linux发行版充当文件服务器。</p><p id="4fb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前您应该有三个这样的“网络驱动器”:</p><ul class=""><li id="610e" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">" docker-桌面"</li><li id="9665" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">" docker-桌面-数据"</li><li id="4b9f" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">" Ubuntu-20.04 "</li></ul><p id="389d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前两个是由Docker Desktop创建的，我们可以放心地忽略它们。我们对标有“Ubuntu-20.04”的那个感兴趣。这个网络驱动器让我们能够访问我们刚刚安装的发行版的Linux文件系统。在幕后，Linux使用9P协议运行一个文件服务器。在这种情况下，Windows资源管理器是一个9P客户端。</p><p id="e7c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“Ubuntu-20.04”的内容应该类似于以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/468db26e88d44436a6f3acaefe5eeab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mfkXhDK8Q_JlLEduq94QRg.png"/></div></div></figure><p id="66fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您可能注意到的，这是Linux文件系统顶部的一组标准目录。让我们看看“home”目录的内部。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/9b2db09dfc814dca72ed13740969f2f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2aQ9s_UJsn78g7p2SsN8Q.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">Linux上主目录的内容</figcaption></figure><p id="a480" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，“home”目录包含每个用户的子目录(除了“root”)。您应该会看到一个这样的目录。它有你安装Ubuntu发行版时选择的任何用户的名字。在我的例子中，我选择了“曼弗雷德”，没有明显的原因。</p><p id="5666" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检查一下用户目录的内容。您应该选择您在安装发行版时选择的用户目录，在我的例子中是“manfred ”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/85318e08a39150a7f2b136e1ee827438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0f4hUr6E9Ch_nZZUjxk7Q.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">用户主目录的内容</figcaption></figure><p id="a403" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的情况下，该目录的内容可能会有所不同。</p><p id="76d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，通过使用Windows文件资源管理器，我们可以从Windows的角度查看该目录。不过，你看到的文件是在Linux文件系统中。这是Linux和Windows之间集成变得明显的一个地方。</p><h2 id="9808" class="nb mf it bd mg nc nd dn mk ne nf dp mo ld ng nh mq lh ni nj ms ll nk nl mu nm bi translated">在Linux中查找主目录</h2><p id="f39f" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">接下来，让我们从Linux的角度，即从我们安装在WSL2上的发行版中找到我们的主目录。我们将使用在终端内部运行的bash来访问Linux发行版。</p><p id="26f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用“开始”按钮或windows键，然后开始键入“Ubuntu ”,直到您看到“Ubuntu 20.04 LTS应用程序”作为建议:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/8524d72c9b6fdfa54240233769df0ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*im1HOblVsaKoM94zsDMKjg.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">启动Ubuntu终端</figcaption></figure><p id="42d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你点击“Ubuntu 20.04 LTS”时，你应该会发现自己在一个运行bash的终端窗口中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/b27c09904d1696b67992a9b669305bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*r4sb2ZClPrxhjWi1soncJw.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">Bash在终端中——用户在他们的主目录中(“~”)</figcaption></figure><p id="5770" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的情况下，提示符将显示不同的用户名和计算机名。在终端中输入并执行以下命令:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="8f43" class="nb mf it op b gy ot ou l ov ow">ls -lart</span></pre><p id="b4da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这列出了当前目录的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/bb4ecc75fb8334e834bd6946ec3ea847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykRbPggoP-lrxff5-Rj8aA.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">Linux发行版上用户主目录的内容</figcaption></figure><p id="1e42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将该命令的输出与我们上面使用的Windows资源管理器的内容进行比较。除了额外的两个条目“.”之外，内容是相同的还有“..”它们表示Linux中的当前目录和父目录。</p><p id="478a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们在终端窗口中运行命令“pwd ”,它显示了当前目录的完整路径:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/1cf50761a146205daf23660b3d72f0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*meHLbkG44093eOXoliQ16w.png"/></div></div></figure><p id="1eed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，我们确实在“/home/manfred”目录中(或者你选择的用户名是什么……我想你明白了)。在Linux中没有驱动器号。一切都从根开始，根是“/”。</p><p id="c522" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意提示符(“$”)前面的“~”(波浪号)。这是主目录的简短表示。为了方便起见，在Linux中当你输入“cd ~”时，你将被带到你的主目录。</p><p id="175b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，我们下一步做什么？我们需要弄清楚如何让VS代码运行起来。我们需要让它运行起来，这样它不仅可以运行，还可以使用Linux文件系统，也就是说，本质上是运行在WSL2上的发行版的文件系统。听起来很复杂，但实际上只是我们已有产品的延伸。</p><h2 id="86c1" class="nb mf it bd mg nc nd dn mk ne nf dp mo ld ng nh mq lh ni nj ms ll nk nl mu nm bi translated">潜在的陷阱</h2><p id="6c77" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">如果你打开一个终端，你可能会发现自己在一个名为“/mnt/c/User/ <username>”的文件夹中。例如:</username></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/e3e4b43d849e81f731e4ea7975a9af6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OtF6sxElq5C88B9YTuonkg.png"/></div></div></figure><p id="f63f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要在这个目录中启动VS代码。此目录是从NTFS装载的，因此不会发送文件更改通知。请使用“cd ~”切换到您的个人目录:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/3dd0af0e379e87828053e80603218533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmSyQU5OsJ7U539988ygdw.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">使用“pwd”进入主目录(“~”)</figcaption></figure><p id="49e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用命令“pwd”来确认您是否在正确的目录中。</p><p id="180e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">记住:</strong>目录“/mnt/c/Users/ &lt;用户名&gt;和“/home/ &lt;用户名&gt;不一样。前者是从NTFS挂载的。后者是Linux文件系统真正的一部分。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="229e" class="me mf it bd mg mh nv mj mk ml nw mn mo jz nx ka mq kc ny kd ms kf nz kg mu mv bi translated">将Repo克隆到WSL2上的Ubuntu中</h1><p id="48d5" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">随着Ubuntu终端的打开，我们接下来将创建一个回购场所。在终端中，确保您在主目录中。可以用“pwd”来确认。如果您不在主目录中，您可以随时使用“cd ~”到达那里。</p><p id="bfe1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后执行以下命令:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="8615" class="nb mf it op b gy ot ou l ov ow">mkdir projects</span></pre><p id="f3cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将创建一个新的目录“projects ”,我们将使用它来克隆存储库。用“cd项目”切换成项目。</p><p id="02bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将使用我用来诊断windows和Linux文件系统间同步问题的repo。使用以下命令克隆该存储库:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="79c6" class="nb mf it op b gy ot ou l ov ow">git clone <a class="ae nn" href="https://github.com/ManfredLange/issue-201121.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ManfredLange/issue-201121.git</a></span></pre><p id="5ab3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你愿意，你也可以叉这个回购。这将为您带来优势，即您还可以在试验此回购时推送提交。</p><p id="4fd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出应该类似于以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/dde710959f4cc89d09cc932c00d2d67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3rlfTebuWv3IkKsnojEvQ.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">从github克隆git repo</figcaption></figure><p id="cb9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们想使用git，所以我们需要确保我们已经设置了我们的名字和电子邮件。为此，请使用以下命令:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="dd2b" class="nb mf it op b gy ot ou l ov ow">git config — global user.name “&lt;your user name&gt;”<br/>git config — global user.email “&lt;your email address&gt;”</span></pre><p id="c430" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/0268b78fdc53673e2c134add2c65a4df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXLG4E0MLnJHE8td95Z90g.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">在发行版中配置git客户端</figcaption></figure><p id="df1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一步是配置git凭证管理器，因为我们不想为每个可能需要它的git操作输入凭证。好消息是:由于WSL2的集成，我们可以使用安装在主机上的git凭证管理器，例如在Windows中。我们需要做的就是执行这个一次性命令(全部在一行中):</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="fb46" class="nb mf it op b gy ot ou l ov ow">git config — global credential.helper “/mnt/c/Program\ Files/Git/mingw64/libexec/git-core/git-credential-manager.exe”</span></pre><p id="6552" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一次性的。如果我们创建了一个新的发行版或者重置了一个现有的发行版，我们只需要为git重复这些配置步骤。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="fcae" class="me mf it bd mg mh nv mj mk ml nw mn mo jz nx ka mq kc ny kd ms kf nz kg mu mv bi translated">开始VS代码</h1><p id="f3fa" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">配置好git并将存储库克隆到“项目”目录中后，我们就可以开始VS代码了。在目录“~/projects/issue-201121”中，执行以下命令:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="b2f1" class="nb mf it op b gy ot ou l ov ow">code .</span></pre><p id="98f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于WSL2和Windows系统之间的集成，这将无缝地工作。WSL2提供的集成允许它在服务器上找到命令“代码”。我们将当前目录作为参数传递。当前目录由“.”表示。</p><p id="b552" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">VS代码启动后，看一下VS代码窗口的左下角。它将显示类似“WSL: Ubuntu-20.04”的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/e05da0992238fece3c2c6da0e953d2c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*stabLYIIlhv5T_KeIk0ezA.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">VS代码远程连接到WSL2上的Ubuntu</figcaption></figure><p id="af09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，在VS代码中打开一个终端窗口。这应该类似于以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/d2ccc8bca15ea345d99fea6e5982d816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHWqmbs0g11r2T-i4GBBNA.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">VS代码中进入发行版的终端窗口</figcaption></figure><p id="1268" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这表明终端正在发行版内部运行。</p><p id="8864" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，VS代码前端正在主机上运行。后端，即vscode-server，运行在发行版内部。当我们启动命令(例如git)或终端时，它们也会在发行版内部执行。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="9cef" class="me mf it bd mg mh nv mj mk ml nw mn mo jz nx ka mq kc ny kd ms kf nz kg mu mv bi translated">启动开发容器</h1><p id="44c6" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">最后一步是启动Dev容器。由于backed运行在发行版内部，这也意味着docker命令可以在那里执行。因为我们已经打开了docker和我们的发行版之间的集成，docker命令将与在不同的“发行版”中运行的docker引擎交互，这个发行版是Docker已经安装的(见上文)。</p><p id="142e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在VS代码窗口中点击绿色左下角。这将显示一个与远程工作相关的命令菜单:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/5e39fd99e688b05fd36cfec343f14f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*bOcuK1PIp_zbLaUgy0pbmw.png"/></div></figure><p id="df35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将选择“远程容器:在容器中重新打开”。当这个命令执行时，请注意VS代码窗口的绿色左下角的文本是如何变成类似“Dev Container: repro”的内容的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/8d16a3defe101c12e1b4303aa39d1a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_smgAFYWMcgDNWyH4ATg1Q.png"/></div></div></figure><p id="75c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意用户如何更改为“repro ”,机器名称如何更改为dev容器的名称。现在显示的路径是“/workspace”，如果我们运行“ls -lart ”,我们会看到类似下面的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6dc8cf7c750b879dada8e86bdf26ccc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*_3NUqZwNEDzSJfhmqIX-ig.png"/></div></figure><h2 id="95c2" class="nb mf it bd mg nc nd dn mk ne nf dp mo ld ng nh mq lh ni nj ms ll nk nl mu nm bi translated">在开发容器中构建并运行</h2><p id="40ef" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">显然，我们还需要检查这个设置实际上是否有效。使用命令切换到子目录“CmdLine ”:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="f4a7" class="nb mf it op b gy ot ou l ov ow">cd CmdLine</span></pre><p id="9e1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后执行命令:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="bfaa" class="nb mf it op b gy ot ou l ov ow">dotnet run</span></pre><p id="ed60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们看到熟悉的“你好，世界！”与下面类似，我们知道我们可以构建并运行这个简单的控制台程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/d6235003671653f6211e6934beb0b4af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*ScSf5J4m_-eo0FT7nYTN8g.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">“你好，世界！”从运行在WSL2上的dev容器内部</figcaption></figure></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="d18c" class="me mf it bd mg mh nv mj mk ml nw mn mo jz nx ka mq kc ny kd ms kf nz kg mu mv bi translated">结论</h1><p id="c06a" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">总之，我们现在有了一个设置，我们在Windows主机上运行VS代码前端，在dev容器中运行VS代码后端(VS Code-server ), dev容器又在docker-engine中运行。docker也运行在Linux VM中。下图说明了这种新的设置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/d17173f0a96bb69505f51c96594ac01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5PBhnqFj7WKH83aQ_3a5g.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">WSL2的新设置</figcaption></figure><p id="542f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个设置中，我们将git存储库克隆到Linux文件系统中，而不是NTFS。当dev容器启动时，带有repo克隆的目录被挂载。由于我们现在运行的是一个真正的Linux内核，并且对发行版中的原始文件夹和dev容器中的原始文件夹使用相同的文件系统，所以文件夹和文件的更改通知会按预期发送。</p><p id="372e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，扩展再次像魔法一样工作。性能真的很好，虽然不是惊人的快。但话说回来，性能取决于许多不同的因素。我可以确定的是，这个设置到目前为止运行可靠，速度很快，并且最终解决了经常中断工作流程的问题。</p><p id="d6a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这是一篇相当专业的文章，但我希望通过分享这篇文章，我能帮你节省一些时间。如果你喜欢这篇文章，请考虑关注我或者通过<a class="ae nn" href="https://manfredmlange.medium.com/membership" rel="noopener">我的推荐页面</a>订阅Medium。</p><p id="ae4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读！</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="d029" class="me mf it bd mg mh nv mj mk ml nw mn mo jz nx ka mq kc ny kd ms kf nz kg mu mv bi translated">参考资料和附加材料</h1><p id="f459" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">和往常一样，这里有一些相关和附加材料的链接，如果您想了解更多细节或想探索相邻的主题，这些链接可能会有所帮助。因为本文的主题非常专业，所以下面的列表比通常的要长:</p><ul class=""><li id="13e6" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">在Github上提交的问题回复通知:<a class="ae nn" href="https://github.com/microsoft/WSL/issues/4739" rel="noopener ugc nofollow" target="_blank">"[wsl 2]Windows文件系统上Windows应用程序所做的文件更改不会触发Linux应用程序的通知"</a></li><li id="64dd" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">用于Linux的Windows子系统<a class="ae nn" href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" rel="noopener ugc nofollow" target="_blank">用于Windows 10的安装指南</a>。这是为了更新到WSL2(可以与WSL1共存)和安装新的发行版</li><li id="07cb" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">微软教程:<a class="ae nn" href="https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-git" rel="noopener ugc nofollow" target="_blank">“在Linux的Windows子系统上开始使用Git”</a></li><li id="448f" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">微软于2016年4月22日发布的博客文章，简要介绍了windows子系统的历史和WSL第一版的技术细节:<a class="ae nn" href="https://docs.microsoft.com/en-us/archive/blogs/wsl/windows-subsystem-for-linux-overview" rel="noopener ugc nofollow" target="_blank">“Linux的Windows子系统概述”</a></li><li id="e13b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">微软教程:<a class="ae nn" href="https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-containers" rel="noopener ugc nofollow" target="_blank">《Docker远程容器入门》</a></li><li id="1d09" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">中型文章:<a class="ae nn" href="https://manfredmlange.medium.com/building-a-dev-container-for-net-core-e43a2236504f?sk=36b027cd308db721daec6d5b726da367" rel="noopener">“为。净芯"</a>。这包括作为非根用户运行的说明。</li><li id="df74" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><a class="ae nn" href="https://youtu.be/lwhMThePdIo" rel="noopener ugc nofollow" target="_blank">“面向Linux架构的全新Windows子系统:深度探讨”</a> (58分钟)，在Microsoft Build 2019上的演讲</li><li id="2256" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">微软文档:<a class="ae nn" href="https://docs.microsoft.com/en-us/windows/wsl/compare-versions" rel="noopener ugc nofollow" target="_blank">“比较WSL1和wsl 2”</a></li><li id="e7a9" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">Docker文章:<a class="ae nn" href="https://docs.docker.com/docker-for-windows/wsl/" rel="noopener ugc nofollow" target="_blank">《Docker桌面WSL2后端》</a>。这篇文章还指出“如果原始文件存储在Linux文件系统中，Linux容器只接收文件更改事件(inotify)”。然而，没有进一步的细节是什么意思。如果你对Windows、WSL2和Linux如何协同工作了解不够，这可能是一个陌生的领域。</li></ul></div></div>    
</body>
</html>