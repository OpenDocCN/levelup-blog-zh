<html>
<head>
<title>Understanding the difference between useMemo and useCallback</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解useMemo和useCallback之间的区别</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-the-difference-between-usememo-and-usecallback-ec956adb2004?source=collection_archive---------0-----------------------#2020-08-28">https://levelup.gitconnected.com/understanding-the-difference-between-usememo-and-usecallback-ec956adb2004?source=collection_archive---------0-----------------------#2020-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4dbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React库为我们提供了两个内置的钩子来优化我们的应用程序的性能:useMemo &amp; useCallback。乍一看，它们的用法似乎非常相似，所以对于何时使用它们可能会感到困惑。为了消除这种困惑，让我们深入了解实际的区别以及使用它们的正确方法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1b20c6c5c107ca45ab94483d5823f050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-oaiaaoisECxNABVxeVbcg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">useMemo还是useCallback？</figcaption></figure><h1 id="97c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">功能组件有问题</h1><p id="80fa" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">功能组件很棒。与类组件相比，它们与钩子的组合允许更高的代码可重用性和灵活性。然而，它们有一个问题:一个函数组件和我们以前在类组件中使用的渲染函数是一样的。这是一个在任何属性/状态改变时重新运行的函数。</p><p id="812e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">意思是:</strong></p><p id="6674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">A.如果一个函数在组件内部被调用，它将在每次重新渲染时被一次又一次地重新计算。</p><p id="b572" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">B.如果在组件内部创建的函数被传递给子组件，它将被重新创建，这意味着指针将发生变化，导致子组件不必要地重新呈现或调用该函数(取决于具体情况)。</p><p id="8029" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题并防止可能的性能问题，React为我们提供了两个钩子:useMemo和useCallback。</p><h1 id="be51" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用备忘录</h1><p id="07de" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们从第一个问题开始，看看如何避免不必要的函数求值。</p><p id="4387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的演示中，我们有一个具有两种状态的组件:一个存储数字，另一个存储布尔值。<br/>我们需要对我们状态中的数字进行一些计算，所以我们调用我们的<code class="fe me mf mg mh b">plusFive</code>函数并呈现结果。</p><pre class="km kn ko kp gt mi mh mj mk aw ml bi"><span id="9297" class="mm lc iq mh b gy mn mo l mp mq"><strong class="mh ir">const plusFive = (num) =&gt; {<br/>  console.log("I was called!");<br/>  return num + 5;<br/>};</strong></span><span id="f579" class="mm lc iq mh b gy mr mo l mp mq">export default function App() {<br/><strong class="mh ir">  const [num, setNum] = useState(0);<br/>  const [light, setLight] = useState(true);<br/>  const numPlusFive = plusFive(num);</strong><br/>  return (<br/>  ...</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">不使用备忘录演示</figcaption></figure><p id="fdbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你打开控制台，你会看到无论我们点击“更新数字”设置一个新的数字，还是“切换灯”更新布尔状态(与numPlusFive无关)，都会调用<code class="fe me mf mg mh b">plusFive</code>。</p><p id="ee50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么如何才能防止这种情况发生呢？通过纪念<code class="fe me mf mg mh b">plusFive</code>！<br/>在我们收到新号码之前，该功能不会被调用。计算被跳过，我们将立即收到结果。</p><p id="4e1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将通过使用<code class="fe me mf mg mh b">useMemo</code>来做到这一点，它将看起来像这样:</p><pre class="km kn ko kp gt mi mh mj mk aw ml bi"><span id="aa45" class="mm lc iq mh b gy mn mo l mp mq">const numPlusFive = useMemo(() =&gt; plusFive(num), [num]);</span></pre><p id="0fd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">useMemo接收两个参数:一个返回函数调用的函数，以及一个依赖项数组。只有当其中一个依赖关系改变时，我们的函数才会被再次调用。useMemo返回该函数执行的结果，并将它存储在内存中，以防止该函数在使用相同参数的情况下再次运行。</p><p id="d810" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自己去看看吧(别忘了打开控制台):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用备忘录演示</figcaption></figure><h1 id="655d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用回调</h1><p id="4e4b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">既然我们知道了如何防止重新计算函数，让我们看看如何防止在组件内部创建的函数在每次渲染时被重新创建。</p><p id="936a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的演示中，我们有一个子组件(<somecomp>)，它接收我们在父组件(<app>)中创建的一个函数作为道具。注意，这个函数是在useEffect钩子内部使用的，因为它被列为useEffect的依赖项，所以它将被再次调用。是的，甚至当我们改变其他状态或收到道具时，与我们的“plusFive”功能无关。</app></somecomp></p><pre class="km kn ko kp gt mi mh mj mk aw ml bi"><span id="a38e" class="mm lc iq mh b gy mn mo l mp mq">const App = () =&gt; {<br/><strong class="mh ir">  const [num, setNum] = useState(0);<br/>  const [light, setLight] = useState(true);<br/>  const plusFive = () =&gt; {<br/>    console.log("I was called!");<br/>    return num + 5;<br/>  };</strong><br/>  return (<br/>    &lt;div className={light ? "light" : "dark"}&gt;<br/>      &lt;div&gt;<br/>        <strong class="mh ir">&lt;SomeComp someFunc={plusFive} /&gt;</strong><br/>  &lt;button onClick={() =&gt; { setLight(!light); }}&gt; Toggle the light &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="842f" class="mm lc iq mh b gy mr mo l mp mq">const SomeComp = ({ <strong class="mh ir">someFunc </strong>}) =&gt; {<br/>  const [calcNum, setCalcNum] = useState(0);<br/>  useEffect(() =&gt; {<br/>    // In this scenatio, someFunc will change on every render, so this useEffect will run.<br/>     <strong class="mh ir">setCalcNum(someFunc());</strong><br/>  }, [<strong class="mh ir">someFunc</strong>]);</span><span id="fd6a" class="mm lc iq mh b gy mr mo l mp mq">return &lt;span&gt; Plus five: {calcNum}&lt;/span&gt;;<br/>};</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">不使用回调</figcaption></figure><p id="7e07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了防止我们的函数被重新创建并在每轮渲染中改变指针，我们可以使用<code class="fe me mf mg mh b">useCallback</code>。这个React挂钩接收两个参数:一个函数和一个依赖关系数组:</p><pre class="km kn ko kp gt mi mh mj mk aw ml bi"><span id="f51d" class="mm lc iq mh b gy mn mo l mp mq">const plusFive = useCallback(() =&gt; {<br/>  console.log("I was called!");<br/>  return num + 5;<br/>}, [num]);</span></pre><p id="bc2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个钩子让我们保留这个函数，只有当它的一个依赖项改变时，它才会被重新创建。</p><p id="1ff2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是工作演示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用回调</figcaption></figure><h1 id="87e1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">但是等等！不要误用这些钩子！</h1><p id="aa66" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">虽然这两个挂钩为实际问题提供了解决方案，但它们可能很容易被误用，甚至会造成更大的伤害。</p><p id="fa26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，没有必要记住一个正在做一些基本计算的函数(就像演示中那样)。只有当你试图避免重新运行昂贵的函数时，才使用<code class="fe me mf mg mh b">useMemo</code>,这些函数会运行很多时间，或者使用很多资源。为什么？因为useMemo将函数执行的结果保存在内存中，它可能会变得很大，具有讽刺意味的是会损害你的应用程序的性能。</p><p id="5e84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe me mf mg mh b">useCallback</code>,事情可能会变得更糟:当不使用useCallback时，旧函数将被垃圾收集，但使用useCallback时，它将留在内存中，以防某个依赖项再次正确返回旧函数版本。</p><p id="1f13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么什么时候用<code class="fe me mf mg mh b">useCallback</code>合适呢？当您实际看到不使用它会损害您的性能，或者会导致不必要的繁重函数执行时(想象一下在useCallback演示中，这个函数执行一个API调用，而不仅仅是添加数字。这是值得防范的事情)。</p><h1 id="332b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">总结一下:</h1><p id="7213" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir"> useMemo </strong>如果一个函数没有收到之前使用过的一组参数，则阻止该函数再次执行。它返回函数的结果。当您希望防止在每次渲染时调用一些繁重或高成本的操作时，请使用该选项。</p><p id="0a6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> useCallback </strong>根据依赖列表，防止函数再次被重新创建。它返回函数本身。当您想要将它传播到子组件，并防止一个昂贵的函数重新运行时，请使用它。</p></div></div>    
</body>
</html>