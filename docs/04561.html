<html>
<head>
<title>Writing Your CSS like This Will Make Your Code Super-Clean</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像这样写你的CSS将会使你的代码非常干净</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-your-css-like-this-will-make-your-code-super-clean-f82d4bfeb468?source=collection_archive---------4-----------------------#2020-07-02">https://levelup.gitconnected.com/writing-your-css-like-this-will-make-your-code-super-clean-f82d4bfeb468?source=collection_archive---------4-----------------------#2020-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cf7e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让你的样式表保持整洁的6个技巧——让它们易于阅读、维护和重用。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/500c70bf307c5c1727ba459c483a30a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CGK4TZGUAPmf_GRNd0d9Kw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/cs-cz/@kovalrk?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">罗曼·科瓦尔</a>从<a class="ae ky" href="https://www.pexels.com/cs-cz/foto/makro-malirsky-stetec-malovani-platno-1639627/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄</figcaption></figure><p id="0008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的交互式网页和单页应用程序大量使用HTML、CSS和JavaScript作为它们的主要实现语言。除了最近在可维护性和可读性方面获得关注的JavaScript代码(TypeScript、ES模块和<code class="fe lv lw lx ly b">class</code>构造)之外，此类应用程序中的许多HTML和CSS代码都处于无人问津的状态。</p><p id="f242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这类应用程序中的HTML代码很可能充斥着非语义标签和过多的类，其对应的自定义CSS类只是一组随机命名的规则集，相互覆盖，这意味着几乎没有可重用性。</p><p id="e7f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种代码与各种JavaScript MVC框架的指令(如Angular、React或Vue)结合在一起，难以阅读、维护和调试。被框架无关类污染的HTML也对框架升级关闭，在更大的升级中需要很多耐心。</p><blockquote class="lz ma mb"><p id="4cde" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">编写可读、可维护和可重用的代码是优秀开发人员与伟大开发人员的区别。</p></blockquote><h1 id="e184" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">🏭使用CSS预处理器</h1><p id="cdaf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">你可能听说过或者使用过它们。CSS预处理程序将允许你的样式表有更简单的语法，让你的代码变得安全，帮助你管理你的颜色，并允许你自动创建样式表，比如用几行代码定义你的自定义网格系统。</p><p id="9b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有四个主要的前置处理器——<a class="ae ky" href="https://sass-lang.com" rel="noopener ugc nofollow" target="_blank">Sass</a>、<a class="ae ky" href="https://postcss.org" rel="noopener ugc nofollow" target="_blank"> PostCSS </a>、<a class="ae ky" href="http://lesscss.org" rel="noopener ugc nofollow" target="_blank"> Less </a>和<a class="ae ky" href="https://stylus-lang.com" rel="noopener ugc nofollow" target="_blank"> Stylus </a>，每一个都拥有有趣而令人敬畏的功能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/5a0b590dbf82eab0103e4f177f737d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iboTyfAsQCSfMmwmT5yIXQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ne"> CSS预处理器用法来自</em> <a class="ae ky" href="https://ashleynolan.co.uk/blog/frontend-tooling-survey-2019-results" rel="noopener ugc nofollow" target="_blank"> <em class="ne">前端工具调查2019 </em> </a></figcaption></figure><p id="0505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选哪个？从语法的角度来看，选择一个对你来说好的。本文中的代码将利用Sass预处理器的SCSS语法。</p><h1 id="9913" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">🧩模块化你的代码</h1><p id="6349" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当你根据你的页面结构将你的CSS分割成逻辑命名的<em class="mc">模块</em>(即单独的CSS文件)时，你本身就使得<em class="mc">在调试或更改的情况下容易定位代码</em>，另外<em class="mc">你有可能在下一个项目中重用</em>来自该模块的代码，并且有可能自动为类添加前缀，以便<em class="mc">避免类命名冲突</em>作为额外的好处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/0bc9b249abf210717200caf3282f9132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ibcr7hU-sxAy1T_ov2FARQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">main.scss包含所有需要的模块</figcaption></figure><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="42af" class="nk mh it ly b gy nl nm l nn no">/* The contents of the main.scss file which will be &lt;link&gt;-ed to your HTML page */</span><span id="1240" class="nk mh it ly b gy np nm l nn no">@import "./navbar.scss";<br/>@import "./footer.scss";<br/>@import "./typography.scss";<br/>@import "./reviews.scss";<br/>@import "./products.scss";</span></pre><p id="deca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">短的CSS模块通常易于维护——与包含数百或数千个类的大模块相比，它们对代码读者的认知影响较小。</p><p id="5ceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些模块还带来了<em class="mc">自然的可配置性</em>，例如在<a class="ae ky" href="https://sass-lang.com/documentation/at-rules/use#configuration" rel="noopener ugc nofollow" target="_blank"> Sass文档</a>中进一步阐述。</p><p id="fbc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Angular和Vue等前端应用程序框架通过它们的本地样式和作用域CSS特性支持模块化CSS。</p><h1 id="a2cd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">📜使用边界元方法</h1><p id="3259" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">BEM是<em class="mc">块-元素-修饰符</em>的简写。这是一种关于如何可预测地命名CSS类的方法。它在您的项目中的应用非常简单:</p><ul class=""><li id="dac0" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><em class="mc">块</em>是页面的一个独立的、可重用的部分，</li><li id="5f64" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><em class="mc">元素</em>是一个块或另一个元素的从属部分(~一个子块)，</li><li id="38a1" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><em class="mc">修改器</em>允许块和元素稍微改变它们的外观或行为，</li></ul><p id="5fd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命名类时，类的名称遵循以下命名约定:</p><ul class=""><li id="5841" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">对于作为可重用代码单元的块，</li><li id="f301" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">.block<strong class="lb iu">__element</strong></code>(用一个<em class="mc">双下划线</em>分隔各部分)对于元素——不应在其块之外使用的块的各个部分，</li><li id="bfd7" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">.block__element<strong class="lb iu">--modifier</strong></code>(用<em class="mc">双破折号</em>分隔各部分)用于修饰，表示元素的特定状态。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/606b15ae2910515bd73e7af38bd00be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Y8bEgeBemgCAPwgLnpQcg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将边界元方法应用于设计草案</figcaption></figure><p id="e6c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法还指出，<em class="mc">类的名称应该与它们真正的设计</em>分离——这就是为什么绿色子弹的类不被命名为<code class="fe lv lw lx ly b">.advantages-list__item--<strong class="lb iu">green</strong></code>的原因——因为将来颜色可能会改变或者可以基于每个模块进行配置。</p><p id="da78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个块/元素/修饰符识别过程是一种<em class="mc">软科学</em>。考虑下例中的按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/bf368f600d3a217f8ae6b1ff0ab0961c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LW_BwDgV-c4mH3-wYuTpag.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">BEM抓住你了</figcaption></figure><p id="986a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有三个按钮——一个绿色、一个粉色和一个粉色+圆形。绿色/粉色的情况很简单——它们显然是通用按钮块的修饰符。</p><p id="19ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是navbar中的圆形按钮可能是navbar的一个<em class="mc">元素</em>，假设这个圆形按钮不会在navbar之外的任何地方使用，或者它可能是一个普通按钮块的一个<em class="mc">修饰符</em>。这种微妙的决定很大程度上依赖于页面整体的设计语言。</p><h1 id="cfe1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">👌认可灵活的CSS选择器</h1><p id="f2cf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">CSS中有大量的选择器可用，其中大部分用于非常特殊和复杂的情况。然而，使用一些常见和明显的选择器可能会导致CSS代码在将来对HTML标记进行可能的更改时变得脆弱:</p><ul class=""><li id="7a45" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">像<code class="fe lv lw lx ly b">.button.green</code>这样的类组合选择器将使得<em class="mc">更难在页面中重用某些特定的行为</em>，</li><li id="2349" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">Child ( <code class="fe lv lw lx ly b">article &gt; .button</code>)、descendant ( <code class="fe lv lw lx ly b">article .button</code>)和sibling selector(<code class="fe lv lw lx ly b">.form-field + .button--search</code>)将<em class="mc">限制你的类</em>在HTML的不同上下文中的可重用性，</li><li id="01f8" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">选择器选择带有特定id的元素(<code class="fe lv lw lx ly b">#submit-query</code>)只会在重用CSS代码时<em class="mc">强迫你给HTML元素</em>不需要的id。</li></ul><p id="23da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mc">好的</em>选择器呢？这些通常有利于使用:</p><ul class=""><li id="7883" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">诸如<code class="fe lv lw lx ly b">.container</code>、<code class="fe lv lw lx ly b">.product-card</code>等著名的简单类选择器对于定义想要重用的样式特征非常有用，因为一般来说，它们具有<em class="mc">低特异性</em>，</li><li id="8ee2" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">元素选择器(<code class="fe lv lw lx ly b">h1</code>、<code class="fe lv lw lx ly b">p</code>、<code class="fe lv lw lx ly b">small</code>)对于设计项目的<em class="mc">基本版式</em>非常有用。</li></ul><p id="ae40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧。这是否意味着您应该只写这些，而不考虑任何其他的选择器组合？嗯……也就是说，ID /子代/后代/兄弟/组合选择器可能会在特定(<em class="mc">非常特定于项目)的小定制的情况下派上用场！</em>)等上下文进行局部定位调整。然而，<em class="mc">你应该避免在任何将来重用的代码中使用它们。</em></p><h1 id="5b0c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">♻️利用风格继承</h1><p id="feb4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是一个很好的例子，CSS预处理器的知识会有所回报。当试图使你的框架特定的HTML代码更容易阅读时，你迟早会遇到一个问题，即<em class="mc">许多元素会有大量的类</em>。下面的例子将说明这个问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/0769939d34bcc7cfae6a6beae114c543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZCYYk3ER8NiWAOK9OcOtA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有定制品牌的引导导航条</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">导航条的HTML代码被很多类污染了</figcaption></figure><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="2473" class="nk mh it ly b gy nl nm l nn no">.<em class="mc">navbar-brand </em>{<br/>  font-family: 'Orbitron', sans-serif; /* a customization */<br/>}</span></pre><p id="6bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过利用BEM和<em class="mc">风格继承</em>在SCSS使用<code class="fe lv lw lx ly b">@extend &lt;selector&gt;</code>指令(它在其他预处理器中也可用！)，这样的问题将得到缓解，HTML类的不可读的slush将被很好地隐藏在一个CSS类中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="8cf5" class="nk mh it ly b gy nl nm l nn no">.<em class="mc">topbar </em>{<br/>  <em class="mc">@extend </em>.<em class="mc">navbar</em>;<br/>  <em class="mc">@extend </em>.<em class="mc">navbar-light</em>;<br/>  <em class="mc">@extend </em>.<em class="mc">bg-light</em>;<br/><br/>  &amp;__brand { // this approximately means <strong class="ly iu">.topbar__brand</strong><br/>    <em class="mc">@extend </em>.<em class="mc">navbar-brand</em>;<br/><br/>    font-family: 'Orbitron', sans-serif; // a customization<br/>  }<br/>  &amp;__form {<br/>    <em class="mc">@extend </em>.<em class="mc">form-inline</em>;<br/><br/>    &amp;__searchbox { // <strong class="ly iu">~ .topbar__form__searchbox</strong><br/>      <em class="mc">@extend </em>.<em class="mc">form-control</em>;<br/>      <em class="mc">@extend </em>.<em class="mc">mr-sm-2</em>;<br/>    }<br/>    &amp;__submit {<br/>      <em class="mc">@extend </em>.<em class="mc">btn</em>;<br/>      <em class="mc">@extend </em>.<em class="mc">btn-outline-success</em>;<br/>      <em class="mc">@extend </em>.<em class="mc">my-2</em>;<br/>      <em class="mc">@extend </em>.<em class="mc">my-sm-0</em>;<br/>    }<br/>  }<br/>}</span></pre><p id="8f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个相当简单的例子中，这种方法的优点可能并不明显，但是假设有这样一种情况<em class="mc">，其中一大块HTML(如客户评级)在静态页面中反复出现</em>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/6e52a892f5b70721d07a0238cf4840ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fOc4IuYb009Q-M7tJvJDiw.png"/></div></div></figure><p id="395b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这个例子的HTML被框架工具类(比如<code class="fe lv lw lx ly b">py-3</code>、<code class="fe lv lw lx ly b">mt-4</code>等)污染了。)，改变名字、角色和等级的垂直间距将会非常费力——每次出现都必须改变。<em class="mc">在使用BEM和样式继承时，这样的改变只需要几行CSS代码。</em></p><p id="c0ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，利用BEM和样式继承的小部分HTML代码不需要修改，例如，如果我们将来使用一个新的很酷的动画库——只需使用<code class="fe lv lw lx ly b">@extend</code>就可以了。</p><p id="6a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都有一个折衷——作为一个web开发人员，你不应该允许<code class="fe lv lw lx ly b">@extend</code>们形成没有任何顺序的意大利面条式代码，所以实现类继承的过程应该被彻底地计划好。你的代码将不包含意大利面条，以防它会<code class="fe lv lw lx ly b">@extend</code>只在框架库中可用的类，而没有你自己的类。</p><p id="f6af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<em class="mc">样式继承</em>方法会导致编译后的输出CSS尺寸稍大一些(指令<code class="fe lv lw lx ly b">@extend</code>基本上会将<em class="mc">给定类的规则复制粘贴</em>到使用的上下文中)，但是用于压缩客户端和服务器之间的网络流量的最先进的压缩算法会减轻这个问题，因为它们在压缩包含重复出现的文本块的文本数据时非常有效。</p><h1 id="8669" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">📱利用风格构成</h1><p id="ae19" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您过去在<code class="fe lv lw lx ly b">media</code>查询中编辑移动样式覆盖并检查原始样式时肯定遇到过这个问题。<em class="mc">上下滚动。重复地。无限地。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="d0f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由SCSS和其他预处理程序实现的风格合成作为<em class="mc">混音</em>在此提供帮助。通过使用<code class="fe lv lw lx ly b">@include &lt;mixin&gt;</code>指令，前面提到的问题通过Bootstrap中一组本地可用的mixins得到了有效解决。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="e810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">样式组合还允许<em class="mc">定义自己的mixin</em>——参数化的可重用CSS代码片段，用于解决<em class="mc">重现的问题</em>，这些通常作为完整的库提供——看看<a class="ae ky" href="https://www.bourbon.io/docs/latest/" rel="noopener ugc nofollow" target="_blank">波旁</a>，一个用于Sass预处理器的mixin库。</p><h1 id="9da8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">🎁结论</h1><p id="1a2b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您已经看到了6个技巧，每个都改进了页面代码的不同方面，从而使HTML和CSS代码更加整洁。</p><p id="93bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这不仅仅是关于你作为网络开发者。也是关于你的队友——设计师。为了使设计更容易转换成可重用的BEM实体，你还应该指导你的设计师在页面上一致地设计重复出现的元素(当然，除非你正在实现一个非常奇特的页面)。</p><h1 id="f5d3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">👓值得一看的文章</h1><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/10-mistakes-i-made-as-a-newbie-self-taught-developer-2b3f14d01052"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">作为一个自学成才的新手，我犯的10个错误</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">完成理学硕士学位后，对过去的自己进行了批判性的反思。在软件工程和飞速发展的职业生涯中…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/learning-these-5-programming-languages-will-make-you-a-better-programmer-f9ffc6283ef9"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">学习这5种编程语言会让你成为更好的程序员</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">通过学习这5种编程语言中包含的概念，加快您的编程速度。</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ks on"/></div></div></a></div></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><p id="e744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mc">在你自己的项目中，这些方法有没有让你惊喜的经历？不要犹豫，在评论中告诉我们吧！</em></p></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><div class="kj kk kl km gt on"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">编写面试问题</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">掌握编码面试的过程</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">技术开发</p></div></div><div class="ow l"><div class="pk l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>