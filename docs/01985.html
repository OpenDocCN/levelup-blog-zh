<html>
<head>
<title>Functional Programming for JavaScript Developers — Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向JavaScript开发人员的函数式编程— Map</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-programming-for-javascript-developers-map-3627494cb5a6?source=collection_archive---------12-----------------------#2020-02-10">https://levelup.gitconnected.com/functional-programming-for-javascript-developers-map-3627494cb5a6?source=collection_archive---------12-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c72f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你可能完全误解了地图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d480e86315e3e41e607602d6c76dbcdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wp2A9xFW7LbCKFA_X2-sw.png"/></div></div></figure><p id="1c85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">欢迎来到面向JavaScript开发人员的函数式编程的第4部分。今天我们将讨论<code class="fe lq lr ls lt b">map</code>函数，以及我们如何在函数式编程(FP)中利用它。当我第一次开始学习<code class="fe lq lr ls lt b">Array.map</code>方法时，我认为它的主要目的是有一个快捷方式来循环数组中的项目。但是正如你将看到的，<code class="fe lq lr ls lt b">map</code>实际上根本不是关于循环的。</p><h2 id="8896" class="lu lv it bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">高阶函数</h2><p id="ad5d" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">刚开始时，可能很难理解什么是高阶函数以及它是如何工作的。简而言之，高阶函数是以一个或多个函数作为自变量的函数。它可以是以前定义的函数，也可以只是lambda函数。让我给你看几个关于<code class="fe lq lr ls lt b">map</code>的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="fd08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，正如你所料，<code class="fe lq lr ls lt b">map</code>是一个高阶函数。作为一名函数式程序员，你经常使用高阶函数的概念。这不仅限于<code class="fe lq lr ls lt b">map</code>，我们还创建了许多自己的高阶函数。如果你也熟悉<code class="fe lq lr ls lt b">filter</code>和<code class="fe lq lr ls lt b">reduce</code>，你可能已经用了很多了。</p><h2 id="c80e" class="lu lv it bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">Array.map是如何工作的？</h2><p id="cb0b" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">我认为现在这种情况可能已经改变了，但是不久前开发人员避免使用<code class="fe lq lr ls lt b">map</code>并坚持使用他们的旧<code class="fe lq lr ls lt b">for</code>循环。如果你是一个在操作数组时仍然执着于循环的人，让我举一个例子来比较这两种方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f708" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望我们能同意<code class="fe lq lr ls lt b">map</code>在提高可读性方面做得很好。实际上，在我开始用函数式风格编程之后，我已经完全从我的武器库中移除了<code class="fe lq lr ls lt b">for</code>循环。我根本不需要它们。我现在有了更好的工具来做这项工作。</p><p id="fd6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之,<code class="fe lq lr ls lt b">Array.map</code>是这样工作的:它循环遍历每一项，应用一个返回一些新数据的函数，并返回一个包含新数据的新<code class="fe lq lr ls lt b">array</code>,而不改变您映射的原始<code class="fe lq lr ls lt b">array</code>。应用的函数可以返回它想要的任何数据。它不必与传入的类型相同。但是，返回的数组将具有与原始数组相同的长度。</p><h2 id="d2df" class="lu lv it bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">为数组创建我们自己的映射函数</h2><p id="e895" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">内置的<code class="fe lq lr ls lt b">Array.map</code>有一些我们作为函数式程序员不喜欢的限制。如果你读过以前关于<a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/functional-programming-for-javascript-developers-compose-508d71b4e7b8">作曲</a>和<a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/functional-programming-for-javascript-developers-currying-2d16766909e9">奉承</a>的文章，你可能会明白为什么。</p><p id="4505" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使函数可组合，我们希望我们操作的数据是传入的最后一个参数。所以，让我们自己做一个满足这个标准的函数。</p><pre class="kj kk kl km gt mv lt mw mx aw my bi"><span id="c076" class="lu lv it lt b gy mz na l nb nc">const map = f =&gt; arr =&gt; arr.map(f);</span></pre><p id="ea81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">啊，好多了！现在我们有了自己定制的<code class="fe lq lr ls lt b">map</code>功能。它是这样工作的:</p><pre class="kj kk kl km gt mv lt mw mx aw my bi"><span id="ac09" class="lu lv it lt b gy mz na l nb nc">map (<em class="nd">n</em> =&gt; n * 2) ([1, 2, 3]); <br/>// [2, 4, 6]</span></pre><p id="a3cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">什么？这怎么更好？嗯，现在我们可以<code class="fe lq lr ls lt b">compose</code>用它了。而且函数式程序员真的很爱<code class="fe lq lr ls lt b">compose</code>。让我向你展示我们如何使用新的地图功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="952b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你看到了吗？我们的新<code class="fe lq lr ls lt b">map</code>与compose完美配合。</p><h2 id="8280" class="lu lv it bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">地图不是关于循环的</h2><p id="1a5b" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">正如我在介绍中提到的，这是一个非常普遍的误解，认为<code class="fe lq lr ls lt b">map</code>是一种编写循环的奇特方式。但是，循环根本不是主要特性。</p><blockquote class="ne"><p id="e1f9" class="nf ng it bd nh ni nj nk nl nm nn lp dk translated">Map是一个函数，允许您访问容器内部的数据并对其进行操作，而不改变原始数据。</p></blockquote><p id="da04" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">到目前为止，我们例子中的容器是<code class="fe lq lr ls lt b">array</code>。当谈到JavaScript中的内置函数时，<code class="fe lq lr ls lt b">array</code>是唯一拥有<code class="fe lq lr ls lt b">map</code>方法的类型。</p><p id="ee59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在函数式编程中，我们有其他的容器可以使用。所有这些都有自己的地图功能。在本文中，我不会深入讨论这些容器的细节，那是以后的事了。但是现在，我希望你把容器想象成一个可以包含数据的东西。每个容器都有一些非常有用的能力。</p><p id="6448" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数组有很多不同的能力，让你的生活更轻松。想象一下不用数组编写JavaScript。所有你需要手动完成的事情。这里有一个引子，在FP中，我们可以使用很多不同类型的容器，这让我们的生活变得更容易。所以请继续关注，因为我认为它会让你大吃一惊。</p><h2 id="766f" class="lu lv it bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">容器</h2><p id="2cc3" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">为了帮助您更好地理解容器，让我们创建一个不会让您大吃一惊的容器。因为除了不变性，它不会有任何有用的特性。请记住，我现在所做的一切都是为了帮助你明白<code class="fe lq lr ls lt b">map</code>不仅仅是对数组起作用。在下一篇文章中，我将向你展示一些在FP中有用的容器。但是，这是我们无用的容器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f413" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们在这里将<code class="fe lq lr ls lt b">Container</code>定义为一个类。但是不要把它当成一门课。把它想象成一个类型，就像一个<code class="fe lq lr ls lt b">array</code>一样。我鼓励你现在不要担心为什么。同样，我保证在下一篇文章中解释所有这些容器的东西。</p><p id="d5ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建一个包含数据的容器。</p><pre class="kj kk kl km gt mv lt mw mx aw my bi"><span id="b9f8" class="lu lv it lt b gy mz na l nb nc">const myContainer = Container.of('Hello');</span></pre><p id="be32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">容器中的数据可以是任何东西。在这种情况下，它的<code class="fe lq lr ls lt b">string</code>‘你好’。现在，我们如何访问和操作<code class="fe lq lr ls lt b">myContainer</code>中的数据呢？嗯，我们可以将<code class="fe lq lr ls lt b">myContainer.$value</code>设置为一个新值。但是这是一个巨大的禁忌。我们从来都不想改变数据，不是吗？所以我们需要另一种方法。你能想出别的办法吗？我在这篇文章里给了你一些提示…你得到了:<code class="fe lq lr ls lt b">map</code>！</p><p id="0de1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，让我们为容器写一个映射函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b40a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好，现在我们可以像这样改变容器内部的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="eb30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在<code class="fe lq lr ls lt b">myContainer2</code>是一个新的容器，里面有<code class="fe lq lr ls lt b">string</code>‘HELLO’。记住在函数式编程中我们从不改变数据，所以<code class="fe lq lr ls lt b">myContainer</code>仍然是不变的。</p><h2 id="f9af" class="lu lv it bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">通用地图功能</h2><p id="9fe1" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">你还记得我们增加了一个普通的地图功能来合成吗？实际上，还有一个原因我没有告诉你:我们需要一个除了数组以外的映射函数。我们希望它适用于所有具有<code class="fe lq lr ls lt b">map</code>功能的类型。</p><p id="941c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，我们很幸运…我们在开始时制作的函数已经适用于<code class="fe lq lr ls lt b">Container</code>。我只是想稍微改变一下论点的名称，就像这样:</p><pre class="kj kk kl km gt mv lt mw mx aw my bi"><span id="a28b" class="lu lv it lt b gy mz na l nb nc">const map = f =&gt; a =&gt; a.map(f);</span></pre><p id="0e09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就对了，我用<code class="fe lq lr ls lt b">a</code>替换了<code class="fe lq lr ls lt b">arr</code>只是为了说明最后一个参数可以接受任何有<code class="fe lq lr ls lt b">map</code>函数的类型。很酷，对吧？我们现在已经为映射任何类型的容器奠定了基础。很抱歉在没有解释更多的情况下把这个容器概念扔给你。这可能会让你有点困惑。这完全没关系。所有这一切的目的，是为你理解<code class="fe lq lr ls lt b">map</code>打下基础。一旦您阅读了本系列的下一篇文章，事情就会变得清楚了。</p><p id="5857" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我内心冒泡是因为给你看这个的兴奋。我也花了一些时间才明白这一点。但是我一看到就笑得停不下来。想出这个主意的人太聪明了。那肯定不是我。我只是一个想传播消息的普通人。如果我能理解，你也能！</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="8f23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我真的希望这篇文章能让你对<code class="fe lq lr ls lt b">map</code>的魔力有所了解。我希望您能继续关注下一部分，在那里我们真正开始使用我们的第一个容器类型<code class="fe lq lr ls lt b">Maybe</code>。你已经走了很长的路了。我为你们感到兴奋，因为你们即将步入一个新的编程世界。我相信通过理解这些概念，你会成为一名更好的开发人员。你会从中获得更多的乐趣！下次见，地图绘制愉快！</p></div></div>    
</body>
</html>