<html>
<head>
<title>A practical introduction to Docker with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">node . js Docker实用介绍</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-practical-introduction-to-docker-with-node-js-9c6fb7673e1f?source=collection_archive---------11-----------------------#2020-02-09">https://levelup.gitconnected.com/a-practical-introduction-to-docker-with-node-js-9c6fb7673e1f?source=collection_archive---------11-----------------------#2020-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将通过Node.js中的一个例子来了解Docker的基础知识，从而理解它的好处。您可以从本文<a class="ae kl" href="https://github.com/dustytrinkets/docker-node-example" rel="noopener ugc nofollow" target="_blank">这里</a>下载工作代码示例。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d49407b423cfc28824997aea24aa10df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SbClCOmaCD3tMGTN.jpg"/></div></div></figure><p id="404b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们谈论软件时，它包括一整套组件，包括前端和后端组件、数据库、库等。</p><p id="f623" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们软件的部署过程中，我们必须确保所有这些组件都能在我们的应用程序可能运行的各种平台上工作。</p><h1 id="26d0" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">docker是做什么用的？</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/f201d5f9e074040c453d666c0460cfce.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/0*Sd6tiMbrC_YGGQff.jpg"/></div></figure><p id="73f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我猜您已经面临过这样的情况:您在本地测试您的应用程序，当部署它时，有些东西不能像预期的那样工作。</p><p id="249b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Docker通过简化部署应用程序的过程来解决这个问题，它通过<strong class="jp ir">打包应用程序及其所有依赖项，并在一个隔离的环境中运行它</strong>，使这个过程变得非常简单和高效。</p><p id="a2a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然Docker可以出现在软件开发的整个工作流程中，但它的主要用途是在部署期间。</p><p id="b333" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，Docker将你的应用程序分离到一个标准化的单元中，我们称之为容器。</p><h1 id="5576" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是容器？</h1><p id="7c58" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">记得我们说过docker <strong class="jp ir">在一个隔离的环境</strong>中打包并运行你的应用。这就是我们所说的容器。</p><p id="3321" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">容器提供了一种打包机制，在这种机制中，应用程序可以从它们实际运行的环境中抽象出来，这为开发人员提供了创建可预测环境的可能性。容器成为测试应用程序的单元。</p><h1 id="1716" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么选择docker？</h1><h2 id="5406" class="mc kz iq bd la md me dn le mf mg dp li jy mh mi lm kc mj mk lq kg ml mm lu mn bi translated">Docker与虚拟机</h2><p id="19c7" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated"><strong class="jp ir"> <em class="mo">虚拟机</em></strong>(VM)是将一台服务器变成多台服务器的物理硬件的抽象。虚拟机管理程序是创建和运行虚拟机的计算机软件、固件或硬件，允许多个虚拟机在一台机器上运行。每个虚拟机都包含操作系统内核、应用程序和必要库的完整副本。虚拟机启动也可能很慢。</p><blockquote class="mp mq mr"><p id="9484" class="jn jo mo jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated"><strong class="jp ir">内核</strong>是操作系统的一部分，处理内存管理、资源分配和其他对系统至关重要的底层服务。</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mv"><img src="../Images/0fa5d9dc0ae1a02a38813495b7054c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FYLf2FmgeMdEN9QA.png"/></div></div></figure><p id="2b7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">容器和虚拟机具有相似的资源隔离和分配优势，但是<strong class="jp ir">功能不同，因为容器虚拟化的是操作系统而不是硬件。</strong></p><p id="dc81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">容器<em class="mo"> </em> </strong>是应用程序层的抽象，将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立的进程运行。</p><h2 id="b772" class="mc kz iq bd la md me dn le mf mg dp li jy mh mi lm kc mj mk lq kg ml mm lu mn bi translated">码头工人的好处</h2><p id="8851" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">从运营的角度来看，它可以提高基础设施的效率，从而更好地利用计算资源。这允许我们在给定的硬件组合上运行比使用虚拟机更多的容器。</p><p id="bdc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到容器，容器是docker映像的一个<strong class="jp ir">运行时实例。</strong>所以基本上，docker容器由docker映像、执行环境和一组标准指令组成。但是，什么是形象呢？</p><h1 id="6a20" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是图像？</h1><p id="52f3" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">正如我们所见，容器是图像的可运行实例。因此，与容器不同，图像<strong class="jp ir">没有状态</strong>，并且从不改变。图像是一个<strong class="jp ir">模板，带有创建docker容器</strong>的指令。</p><p id="4c75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里开始，我们将遵循来自<a class="ae kl" href="https://github.com/dustytrinkets/docker-node-example" rel="noopener ugc nofollow" target="_blank">库</a>的示例来构建我们的节点应用程序并将其归档。</p><p id="bcdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们有一个index.js文件，它公开了一个get并返回运行应用程序的端口。对于这个例子，我们需要安装express和dotenv作为依赖项。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">索引. js</figcaption></figure><p id="073c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们运行应用程序并浏览<a class="ae kl" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>服务器将返回</p><pre class="kn ko kp kq gt nc nd ne nf aw ng bi"><span id="9bc2" class="mc kz iq nd b gy nh ni l nj nk">Your application is running on port 3000</span></pre><p id="1201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么接下来的问题是，我们如何建立一个docker形象？</p><h1 id="a261" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Dockerfile是干什么用的？</h1><p id="c933" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">对于构建图像，我们使用Dockerfile。这是一个带有简单语法的文件，用于定义创建和运行我们的图像所需的步骤。</p><p id="9db9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，它是一个基于另一个图像的图像<strong class="jp ir">，带有一些额外的定制。这是Dockerfile文件包含的内容。因此，为了组装我们的图像，我们将创建一个文档，其中包含构建我们自己的应用程序的图像所需的所有命令。</strong></p><p id="2646" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以创建自己的图像，或者使用他人创建并在注册表中发布的图像。例如，我们可以使用在<strong class="jp ir"> Docker Hub上发布的任何图像。</strong></p><p id="1cb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将构建节点应用程序的映像。为此，我们可以从Ubuntu映像的开始<strong class="jp ir">，在它上面安装Node，然后安装我们的应用程序，或者直接从节点映像开始。</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">来自ubuntu映像的Dockerfile</figcaption></figure><p id="b42a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">docker文件中的每个指令在图像中创建一个层</strong>，当您更改docker文件并重建图像时，<strong class="jp ir">只有那些已更改的层才会被重建</strong>。这就是为什么图像如此轻便、小巧和快速。</p><p id="b303" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从节点映像启动<strong class="jp ir">，并从那里安装和运行我们的应用程序，如下所示:</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">来自节点映像的Dockerfile</figcaption></figure><p id="938e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这之后，我们有<strong class="jp ir">运行</strong>一对命令。第一个将Python作为构建依赖项安装。对于这个项目所具有的依赖项来说，这是不必要的，但是这是一个很好的例子来看看如何插入构建依赖项，也就是说，我们需要构建我们的应用程序，但是一旦程序被编译，我们就不再需要它了。第二个安装项目的依赖项。</p><p id="2268" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这些例子中，我们<strong class="jp ir">在源代码<strong class="jp ir">拷贝之前</strong>拷贝<strong class="jp ir"> package.json </strong>。。</strong>)。这是因为Docker映像是由<strong class="jp ir">层</strong>组成的，并且由于文件<strong class="jp ir"> package.json </strong>不像我们的源代码那样经常改变，所以我们不想在每次运行<code class="fe nl nm nn nd b">docker build</code>时都要重新构建我们的<strong class="jp ir"> node_modules </strong>。</p><p id="5082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将把<strong class="jp ir"> ENV </strong>变量端口和类型设置为3000，这样我们就可以在运行dockerised应用程序时看到不同之处。</p><p id="e5cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，<strong class="jp ir"> EXPOSE </strong>告诉Docker容器在运行时监听哪个端口，在本例中我们是公开端口3000。</p><p id="9b14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，<strong class="jp ir"> CMD </strong>命令告诉Docker如何运行我们打包在映像中的应用程序。CMD遵循格式<em class="mo"> CMD [“命令”、“参数”] </em>。</p><p id="ff24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在运行命令<code class="fe nl nm nn nd b">docker build .</code>,我们将构建刚刚创建的映像。如果我们想标记刚刚创建的图像，我们也可以运行<code class="fe nl nm nn nd b">docker build --tag myapp .</code>。</p><p id="733c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以看到我们刚刚用命令<code class="fe nl nm nn nd b">docker images</code>构建的图像。</p><p id="6bba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了提高构建的性能，我们应该通过向目录添加一个<code class="fe nl nm nn nd b">.dockerignore</code>文件来避免文件和目录包含在映像中。在我们的例子中，我们忽略了所有不需要的文件。</p><p id="8dfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以运行<code class="fe nl nm nn nd b">docker run -p 3001:3000 myapp</code>。这样，我们将主机端口3001映射到容器端口3000。图案是<code class="fe nl nm nn nd b">HOST:CONTAINER</code>。</p><p id="1b96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当我们访问http://localhost:3001时，服务器将返回:</p><pre class="kn ko kp kq gt nc nd ne nf aw ng bi"><span id="0376" class="mc kz iq nd b gy nh ni l nj nk">Your built with Dockerfile application is running on port 3000</span></pre><h1 id="af49" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">docker-compose是干什么用的？</h1><p id="bb82" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">假设我们想要运行两个容器，一个用于节点应用程序，另一个用于存储一些信息的数据库，例如MongoDB。这就是docker-compose变得有用的时候。</p><p id="d63c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">docker-compose定义了一个docker运行命令。这是创建和运行我们的容器的一组步骤。我们在一个文件中定义一个多容器应用程序，然后用一个命令启动我们的应用程序，这个命令完成了运行应用程序所需的一切。</p><p id="d9a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，确保在您的机器上安装了docker-compose，并添加这个docker.compose.yml文件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">docker-compose.yml</figcaption></figure><p id="c5c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里给出构建两个图像的指令，一个用于<strong class="jp ir"> <em class="mo"> myapp </em> </strong>一个用于<strong class="jp ir"> <em class="mo"> mymongo </em> </strong>。</p><p id="4ac6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在服务<strong class="jp ir"> <em class="mo"> myapp </em> </strong>中，我们告诉docker-compose使用同一个目录中的Dockerfile(即。从<code class="fe nl nm nn nd b">build .</code>指示运行build命令，Dockerfile，就在当前工作目录下)。</p><p id="c5c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还告诉myapp <code class="fe nl nm nn nd b">depends_on</code> mymongo，所以<em class="mo"> myapp </em>不会运行，直到<em class="mo"> mymongo </em>运行。</p><p id="ac49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe nl nm nn nd b">ports</code>指令，我们再次映射暴露于3001的端口，就像我们之前手动使用<code class="fe nl nm nn nd b">docker run</code>命令一样。</p><p id="a2e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们设置了<strong class="jp ir"> <em class="mo">环境</em> </strong>变量<strong class="jp ir">端口</strong>和<strong class="jp ir">类型</strong>，这样当我们运行命令<code class="fe nl nm nn nd b">docker-compose up</code>并检查<a class="ae kl" href="http://localhost:3001" rel="noopener ugc nofollow" target="_blank"> http://localhost:3001 </a>时，我们应该看到:</p><pre class="kn ko kp kq gt nc nd ne nf aw ng bi"><span id="bb57" class="mc kz iq nd b gy nh ni l nj nk">Your <!-- -->built and run with docker-compose <!-- -->application is running on port 3000</span></pre><p id="082b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令<code class="fe nl nm nn nd b">docker-compose up</code>根据docker-compose.yml为Docker提供构建图像和运行容器的指令。</p><p id="78e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令<code class="fe nl nm nn nd b">docker-compose down</code>关闭了之前脚本运行的所有服务。</p><p id="903a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<code class="fe nl nm nn nd b">docker ps</code>列出了docker引擎中所有正在运行的容器，<code class="fe nl nm nn nd b">docker-compose ps</code>列出了与<code class="fe nl nm nn nd b">docker-compose file</code>中声明的图像相关的容器，因此<code class="fe nl nm nn nd b">docker-compose ps</code>的结果是<code class="fe nl nm nn nd b">docker ps</code>结果的子集。</p><h1 id="d6ce" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Docker命令行备忘单</h1><p id="e3a4" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">以下是一些有用的Docker命令解释:</p><p id="c2dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn nd b">docker build --tag <strong class="jp ir"><em class="mo">tagname</em></strong> .</code> →从当前目录下的Dockerfile文件构建一个图像，并标记该图像。示例:<code class="fe nl nm nn nd b">docker build --tag myapp .</code></p><p id="7a12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn nd b">docker run -d -p 80:80 <strong class="jp ir"><em class="mo">tagname</em></strong> service nginx start</code> →例:<code class="fe nl nm nn nd b">docker build --tag myapp .</code></p><p id="19bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn nd b">docker ps</code> →检查运行中的容器。</p><p id="0fec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn nd b">docker ps -a</code> →显示所有容器(默认显示正在运行的容器)。</p><p id="51e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从给定的docker容器进入控制台。</p><p id="d151" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn nd b">docker images</code> →查看本地构建的图像</p><p id="2795" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn nd b">docker images -a</code> →查看本地存储的所有图像，包括中间图像。请记住，每个docker映像都由层组成，这些层之间具有父子层次关系。Docker称之为<strong class="jp ir">中间图像。</strong></p><p id="ff01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn nd b">docker image rm <strong class="jp ir"><em class="mo">imagename</em></strong></code> →删除一幅图像。</p><p id="7ffc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn nd b">docker stop <strong class="jp ir"><em class="mo">containername</em></strong></code> <em class="mo"> → </em>停止一个容器。</p><p id="6e10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn nd b">docker rm <strong class="jp ir"><em class="mo">containername</em></strong></code> →取出一个容器。</p><p id="755c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn nd b">docker-compose -f <strong class="jp ir"><em class="mo">path/to/docker-compose.yml</em></strong> up</code> →创建并启动docker合成文件中指定的容器。示例:<code class="fe nl nm nn nd b">docker-compose -f docker/docker-compose.yml up</code></p><p id="8593" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn nd b">docker-compose -f <strong class="jp ir"><em class="mo">path/to/docker-compose.yml</em></strong> down</code> →停止并移除容器、网络、图像和卷。例子:<code class="fe nl nm nn nd b">docker-compose -f docker/docker-compose.yml down</code></p></div></div>    
</body>
</html>