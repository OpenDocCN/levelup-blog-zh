<html>
<head>
<title>Protobuf — A high-performance data-interchange format.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Protobuf —一种高性能的数据交换格式。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/protobuf-a-high-performance-data-interchange-format-64eaf7c82c0d?source=collection_archive---------7-----------------------#2020-08-12">https://levelup.gitconnected.com/protobuf-a-high-performance-data-interchange-format-64eaf7c82c0d?source=collection_archive---------7-----------------------#2020-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bbb5420c6e6d87135e9549fada033263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7siaQBHwkuz2gDmv8ygHg.png"/></div></div></figure><p id="5468" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">协议缓冲区，通常称为<em class="kw"> protobuf </em>，是一种二进制数据交换格式，它保证了类型安全，同时是语言无关的和跨平台的。这种格式的大小是高效的，开发的重点是高序列化/反序列化性能。</p><p id="2a6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种格式依赖于预编译的模式，不像JSON等其他数据交换格式那样可以使用通用库进行序列化/反序列化。官方编译器支持C++、C#、Dart、Go、Java、Python。在编译器不支持的语言中使用protobuf，虽然可能，但相当麻烦。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="a5f9" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">模式文件</h1><p id="976f" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">该模式在<em class="kw">中定义。proto </em>文件使用官方<a class="ae mh" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank">语言指南</a>中定义的语言。它支持复杂的结构，包括嵌套类型、可选字段、重复字段<em class="kw">(数组)</em>、映射等等。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="feb2" class="mr lf iq mn b gy ms mt l mu mv">syntax = "proto3";</span><span id="b709" class="mr lf iq mn b gy mw mt l mu mv">package Example;</span><span id="56e2" class="mr lf iq mn b gy mw mt l mu mv">message Entity {<br/>  int32 identifier = 1;<br/>  optional string description = 2;<br/>  repeated Coordinate points = 3;<br/>}</span><span id="3deb" class="mr lf iq mn b gy mw mt l mu mv">message Coordinate {<br/>  optional int32 x = 1;<br/>  optional int32 y = 2;<br/>}</span></pre><p id="8d27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，使用<em class="kw">协议</em>将该模式编译成所需的语言，该协议为每个<em class="kw">消息</em>实体生成许多带有类定义的文件。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="3ae1" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">性能—消息大小</h1><p id="0242" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">我第一次发现protobuf是在开发Abathur的时候，abath ur是一个模块化星际争霸2代理的框架。每个<em class="kw">游戏步骤</em>都必须同步整个游戏状态(正常游戏速度下16Hz，更快时22.4hz)——这就产生了很高的带宽要求，所以我决定运行一些测试。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/c66afea6e58d628307c09eaa7fbf33d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEL-DxhMK-nzma1Dk1FJzw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><a class="ae mh" href="https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/sc2api.proto#L359" rel="noopener ugc nofollow" target="_blank"><em class="nc">response observation</em>s</a>与JSON相比格式化为protobuf的大小。作者图表。</figcaption></figure><p id="c90f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单个游戏状态对象(<a class="ae mh" href="https://github.com/Blizzard/s2client-proto/blob/01ab351e21c786648e4c6693d4aad023a176d45c/s2clientprotocol/sc2api.proto#L359" rel="noopener ugc nofollow" target="_blank"><em class="kw">response observation</em>s</a>)在地图<a class="ae mh" href="https://liquipedia.net/starcraft2/Troizinia_LE" rel="noopener ugc nofollow" target="_blank"> Trozinia LE </a>上格式化为JSON时大小在959.55千磅到1534.51千磅之间变化，大致等于<strong class="ka ir">实时玩时7.86–12.57 Mbps</strong>。当格式化为protobuf时，完全相同的对象在133.61KiB和169.01KiB之间变化，这导致<em class="kw">" only "</em><strong class="ka ir">1.09–1.38 Mbps</strong>。</p><p id="b71c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个特定的场景中，选择protobuf而不是JSON意味着总的消息大小节省了<strong class="ka ir"> 618.19% </strong>到<strong class="ka ir"> 807.93% </strong>。这对网络应用的性能产生了巨大的影响，并可能为云解决方案节省大量的纯数据传输速率。然而，Abathur在本地运行——但是节省的I/O操作值得赞赏。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="1f6a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">性能—序列化/反序列化</h1><p id="2abc" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在某些应用程序中，尤其是云解决方案中，减少数据传输本身可能值得对protobuf进行更改——但只有从纯粹的性能角度来看，如果花费在“<em class="kw">”压缩“</em>数据上的时间能够在传输数据时节省下来，才值得这样做。</p><p id="79e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">protobuf消息的二进制表示非常类似于C++对象的内部二进制表示。因此，这种格式在C++中非常高效，因为它几乎可以简单地将消息直接复制到内存中，并解释为一个对象。然而，Abathur是C#/Python的混合体——具有非常不同的内部数据表示的语言。因此，我决定进行一些测试…</p><p id="f3ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试集是通过在<a class="ae mh" href="https://liquipedia.net/starcraft2/Cinder_Fortress" rel="noopener ugc nofollow" target="_blank">煤渣堡垒</a>上运行两个精英人工智能来生成的，并连续请求<em class="kw">观察【16860步。然后将这些观察结果保存到磁盘上，并随后加载到小型测试应用程序中，以便对序列化/反序列化进行计时。修整平均值是25%的修整平均值。</em></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="42a5" class="mr lf iq mn b gy ms mt l mu mv">+-----------------------+----------+-----------+-----------+<br/>|     C# Results        | 25% mean | Max value | Min value |<br/>+-----------------------+----------+-----------+-----------+<br/>| proto serialization   | 1.00ms   | 27.899ms  | 0.326ms   |<br/>| json serialization    | 9.0916ms | 94.5744ms | 2.722ms   |<br/>| proto deserialization | 0.544ms  | 16.609ms  | 0.125ms   |<br/>| json deserialization  | 18.326ms | 124.808ms | 6.911ms   |<br/>+-----------------------+----------+-----------+-----------+</span></pre><p id="c875" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">这些测试是在一台运行Windows 10的普通笔记本电脑上进行的，该电脑配有I5–5200 u CPU、2.20GHz、8 GB RAM。C#中的序列化/反序列化是使用Google完成的。Protobuf.JsonFormatter和Google。proto buf . JSON parser</em><em class="kw">Python序列化/反序列化使用了Google . proto buf . JSON _ format</em></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="15c0" class="mr lf iq mn b gy ms mt l mu mv">+-----------------------+----------+------------+-----------+<br/>|    Python Results     | 25% mean | Max value  | Min value |<br/>+-----------------------+----------+------------+-----------+<br/>| proto serialization   | 23.788ms | 126.0893ms | 11.007ms  |<br/>| json serialization    | 38.021ms | 171.122ms  | 19.995ms  |<br/>| proto deserialization | 24.220ms | 124.0892ms | 10.007ms  |<br/>| json deserialization  | 46.635ms | 218.156ms  | 23.997ms  |<br/>+-----------------------+----------+------------+-----------+</span></pre><p id="8db3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Protobuf的序列化和反序列化比C#中的JSON要快得多，这并不奇怪，因为对象的内部数据表示与C++使用的数据表示相似，c++首先对格式进行了优化。然而Python也获得了实质性的性能提升！</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="c8af" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">反射</h1><p id="2968" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">protobuf是不是简单的比JSON好？<strong class="ka ir">当然不是。这两种格式差别很大，单纯从性能上比较它们是不公平的。JSON是人类可读的、自描述的、得到普遍支持的、有效的行业数据交换格式。</strong></p><p id="269b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，Protobuf可能很难使用，因为接收方必须知道模式，数据才有意义。如果不仔细遵循最佳实践，小的模式更改很容易破坏以前的集成——更不用说笨拙的模式编译工作流了。它不太为人所知，支持的语言也很少，所以它可能不是公共API的首选。</p><p id="14a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果你渴望高性能的数据传输，或者你的云提供商在数据传输费用上敲你竹杠，那就试试吧。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="50b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于2020年8月12日</em><a class="ae mh" href="https://adequatesource.com/protobuf/" rel="noopener ugc nofollow" target="_blank"><em class="kw">【https://adequatesource.com】</em></a><em class="kw">。</em></p></div></div>    
</body>
</html>