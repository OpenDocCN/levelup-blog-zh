<html>
<head>
<title>Metaprogram in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的元程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/metaprogram-in-go-5a2a7e989613?source=collection_archive---------2-----------------------#2020-01-22">https://levelup.gitconnected.com/metaprogram-in-go-5a2a7e989613?source=collection_archive---------2-----------------------#2020-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d8d9dd7db99236e93d83d37e556291e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CA-fzCSJMiCBQ9HegZeHCA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">标志归功于golang.org</figcaption></figure><div class=""/><div class=""><h2 id="c092" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">如何使用Golang对CRUD API进行元编程？</h2></div><p id="a9a4" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">大多数现代网站都正式或非正式地实施了某种MV*框架。如果你写了很多代码，你可能会一遍又一遍地写很多模型(M ),这些模型在结构上非常相似，只是在模式的细节上有所不同。您定义SQL模式，创建结构，并在两者之间组装一些基本的<a class="ae lt" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a> API。然后，您可以在开发应用程序逻辑的过程中对其进行调整。将其中一些自动化，以减少时间和错误，不是很好吗？</p><p id="6af3" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在本文中，我们将这样做。我们将在Go中探索元编程，以基于SQL表定义自动创建简单的CRUD API。</p><h2 id="6fb4" class="lu lv ji bd lw lx ly dn lz ma mb dp mc lg md me mf lk mg mh mi lo mj mk ml mm bi translated">介绍</h2><p id="5f33" class="pw-post-body-paragraph kx ky ji kz b la mn kj lc ld mo km lf lg mp li lj lk mq lm ln lo mr lq lr ls im bi translated">元编程本质上就是写程序写程序。因此，你是从特定的程序移出一个层次，而是求解一个更一般的程序类。Rails生成器(如Ruby on Rails)就是一个众所周知的例子。只需运行<code class="fe ms mt mu mv b">rails new test</code>就可以创建一个名为“test”的全功能项目。元编程通常需要更长的时间，但是最终您有了一个可以在类似问题上重用的工具。</p><p id="8cc4" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我通常将Postgres用于我的数据库，所以我想将一组SQL Create Table定义自动转换为Go code API。如果你看过CREATE TABLE的Postgres语法，它的<a class="ae lt" href="https://www.postgresql.org/docs/12/sql-createtable.html" rel="noopener ugc nofollow" target="_blank">非常丰富</a>，尽管它只有一条语句。幸运的是，我们不需要解析整个语法来满足我们的目标。为了构建我们的CRUD API，我们需要:</p><ol class=""><li id="5ab0" class="mw mx ji kz b la lb ld le lg my lk mz lo na ls nb nc nd ne bi translated">捕获整个CREATE TABLE语句</li><li id="0b37" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nb nc nd ne bi translated">捕获表名</li><li id="0912" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nb nc nd ne bi translated">捕获表列名</li><li id="2736" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nb nc nd ne bi translated">捕获表列类型</li></ol><p id="f7df" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这可能看起来很多，但实际上它将允许我们忽略CREATE TABLE语法的大部分可选部分。我们可以寻找我们想要的东西，忽略其他的。</p><p id="b496" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们将构建一个简单的编译器来筛选SQL表定义，保存我们关心的部分，以便我们稍后可以基于我们发现的内容生成新代码。我们的简单编译器有三个主要部分:一个词法分析器、一个语法分析器和一个生成器。我们的语法，基于Postgres文档，看起来像:</p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="832a" class="lu lv ji mv b gy ns nt l nu nv">CREATE [some_stuff]* TABLE [IF NOT EXISTS] table_name (<br/>    column_name data_type [some_stuff]*<br/>    [, ...]<br/>) [some_stuff]* ;</span></pre><p id="4b24" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们的秘籍是允许但忽略所有的[some_stuff]* SQL语法。我们必须解析[IF NOT EXISTS]选项，因为如果我们将它视为任意文本，我们可能会错过table_name。同样为了简单起见，我们不支持列列表中的table_constraints和LIKE语句<strong class="kz jj">，因为这将迫使我们进行更复杂的解析。该语句必须以“；”结尾。我们将支持所有主要的数据类型，并将它们转换成Go，如下所示:</strong></p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="f4a2" class="lu lv ji mv b gy ns nt l nu nv">SQL              GO  <br/>----------------|-------                                                 <br/>BOOLEAN          bool                                                 <br/>BOOL             bool                                                 <br/>CHAR(n)          string                                               <br/>VARCHAR(n)       string                                               <br/>TEXT             string                                               <br/>SMALLINT         int16                                                <br/>INT              int32                                                <br/>INTEGER          int32                                                <br/>BIGINT           int64                                                <br/>SMALLSERIAL      int16                                                <br/>SERIAL           int32                                                <br/>BIGSERIAL        int64                                                <br/>FLOAT(n)         float64                                              <br/>REAL             float32                                              <br/>FLOAT8           float32                                              <br/>DECIMAL          float64                                              <br/>NUMERIC          float64                                              <br/>NUMERIC(p,s)     float64                                              <br/>DOUBLE PRECISION float64                                              <br/>DATE             time.Time                        <br/>TIME             time.Time                <br/>TIMESTAMPTZ      time.Time<br/>TIMESTAMP        time.Time<br/>INTERVAL         time.Time<br/>JSON             []byte                                               <br/>JSONB            []byte                                               <br/>UUID             string</span></pre><p id="83a5" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们的目标是为任何SQL表(foo)自动构建以下内容:</p><ul class=""><li id="b873" class="mw mx ji kz b la lb ld le lg my lk mz lo na ls nw nc nd ne bi translated">func create table<strong class="kz jj">Foo</strong>(db * SQL。DB) (err error){}</li><li id="be21" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nw nc nd ne bi translated">类型<strong class="kz jj"> Foo </strong> struct{}</li><li id="4195" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nw nc nd ne bi translated">func(<strong class="kz jj">Foo * Foo</strong>)Create<strong class="kz jj">Foo</strong>(db * SQL。DB)(结果<strong class="kz jj"> Foo </strong>，err error){}</li><li id="f688" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nw nc nd ne bi translated">func ( <strong class="kz jj"> foo *Foo </strong>)检索<strong class="kz jj"> Foo </strong> (db *sql。DB)(结果<strong class="kz jj"> Foo </strong>，err error){}</li><li id="ae1e" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nw nc nd ne bi translated">func(<strong class="kz jj">Foo * Foo</strong>)retrieve all<strong class="kz jj">Foo</strong>(db * SQL。DB) ( <strong class="kz jj"> foo []Foo </strong>，err error){}</li><li id="2bc6" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nw nc nd ne bi translated">func(<strong class="kz jj">Foo * Foo</strong>)Update<strong class="kz jj">Foo</strong>(db * SQL。DB)(结果<strong class="kz jj"> Foo </strong>，err error){}</li><li id="a789" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nw nc nd ne bi translated">func(<strong class="kz jj">Foo * Foo</strong>)Delete<strong class="kz jj">Foo</strong>(db * SQL。DB) (err error){}</li><li id="aa26" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nw nc nd ne bi translated">func delete all<strong class="kz jj">Foo</strong>(db * SQL。DB) (err error){}</li></ul><h1 id="60f6" class="nx lv ji bd lw ny nz oa lz ob oc od mc ko oe kp mf kr of ks mi ku og kv ml oh bi translated">词法分析程序</h1><p id="5c81" class="pw-post-body-paragraph kx ky ji kz b la mn kj lc ld mo km lf lg mp li lj lk mq lm ln lo mr lq lr ls im bi translated">词法分析是从字符流中检测标记的过程。它可以简单到寻找空格分隔的单词，或者更常见的是识别特定的关键字和id。Go有用于<a class="ae lt" href="https://golang.org/pkg/go/scanner/" rel="noopener ugc nofollow" target="_blank">扫描</a>和<a class="ae lt" href="https://godoc.org/github.com/cznic/golex/lex" rel="noopener ugc nofollow" target="_blank"> lexing </a>的包来使这变得更容易。我选择了Tim Henderson的一个叫做<a class="ae lt" href="https://github.com/timtadh/lexmachine" rel="noopener ugc nofollow" target="_blank"> Lexmachine </a>的包，这个包有很好的文档记录。</p><p id="8294" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">使用Tim出色的点词法分析器示例作为模板，我们可以为上面简化的SQL子集构建一个词法分析器。关键字和文字非常简单。关键字是<strong class="kz jj">创建，表格，</strong>如果不存在，和我们的静态列表<strong class="kz jj">数据类型</strong>。同样，我们必须检测“如果不存在”选项来消除table_name的歧义。文字只是:<strong class="kz jj">()，；</strong></p><p id="d807" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">标识符有点复杂。这些将包括:<strong class="kz jj"> CHAR(n)、VARCHAR(n)、FLOAT(n)、NUMERIC(p，s)、ID(ID)、table_name和column_name，</strong> Lexmachine使用regex作为标识符，因此我们将对SQL使用以下内容:</p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="dc3e" class="lu lv ji mv b gy ns nt l nu nv">VARCHAR(n):   [vV][aA][rR][cC][hH][aA][rR]\([0-9]+\)<br/>CHAR(n):      [cC][hH][aA][rR]\([0-9]+\)<br/>FLOAT(n):     [fF][lL][oO][aA][tT]\([0-9]+\)<br/>NUMERIC(p,s): [nN][uU][mM][eE][rR][iI][cC]\([0-9]+,[0-9]+\)<br/>ID(ID):       ([a-z]|[A-Z]|_|#|@)([a-z]|[A-Z]|[0-9]|_|#|@|\$)*<br/>              \(([a-z]|[A-Z]|_|#|@)([a-z]|[A-Z]|[0-9]|_|#|@|\$)*\)<br/>ID:           ([a-z]|[A-Z]|_|#|@)([a-z]|[A-Z]|[0-9]|_|#|@|\$)*</span></pre><p id="c941" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">注意，Lexmachine还不支持类似(？I)，这解释了上面的正则表达式。ID(ID)是允许引用所必需的，否则由于括号的原因，这些引用将是错误的。ID可以用于表名和列名。lexer将跳过任何空白。就这样，莱克瑟完成了。</p><p id="590f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metaapi/metasql/lexer.go:</p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="953c" class="lu lv ji mv b gy ns nt l nu nv">//Derived from: <a class="ae lt" href="https://hackthology.com/writing-a-lexer-in-go-with-lexmachine.html" rel="noopener ugc nofollow" target="_blank">https://hackthology.com/writing-a-lexer-in-go-with-lexmachine.html</a></span><span id="ba65" class="lu lv ji mv b gy oi nt l nu nv">package metasql</span><span id="b456" class="lu lv ji mv b gy oi nt l nu nv">import (<br/>    "strings"</span><span id="51bd" class="lu lv ji mv b gy oi nt l nu nv">lex "github.com/timtadh/lexmachine"<br/>    "github.com/timtadh/lexmachine/machines"<br/>)</span><span id="4a05" class="lu lv ji mv b gy oi nt l nu nv">var Literals []string       <br/>var Keywords []string       <br/>var Tokens []string         <br/>var TokenIds map[string]int <br/>var Lexer *lex.Lexer        </span><span id="9209" class="lu lv ji mv b gy oi nt l nu nv">// Called at package initialization. Creates the lexer and populates token lists.<br/>func init() {<br/>    initTokens()<br/>    var err error<br/>    Lexer, err = initLexer()<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>}</span><span id="3644" class="lu lv ji mv b gy oi nt l nu nv">func initTokens() {<br/>    Tokens = []string{<br/>        "VARCHARID",<br/>        "CHARID",<br/>        "FLOATID",<br/>        "NUMERICID",<br/>        "REFID",<br/>        "ID",<br/>    }<br/>    Keywords = []string{<br/>        "CREATE",<br/>        "TABLE",<br/>        "IF",<br/>        "NOT",<br/>        "EXISTS",<br/>        "BOOLEAN",<br/>        "BOOL",<br/>        "TEXT",<br/>        "SMALLINT",<br/>        "INTEGER",<br/>        "BIGINT",<br/>        "INT",<br/>        "SMALLSERIAL",<br/>        "BIGSERIAL",<br/>        "SERIAL",<br/>        "REAL",<br/>        "FLOAT8",<br/>        "DECIMAL",<br/>        "NUMERIC",<br/>        "DOUBLE",<br/>        "PRECISION",<br/>        "DATE",<br/>        "TIMESTAMPTZ",<br/>        "TIMESTAMP",<br/>        "TIME",<br/>        "INTERVAL",<br/>        "JSONB",<br/>        "JSON",<br/>        "UUID",<br/>    }<br/>    Literals = []string{<br/>        "(",<br/>        ")",<br/>        ",",<br/>        ";",<br/>    }<br/>    Tokens = append(Tokens, Keywords...)<br/>    Tokens = append(Tokens, Literals...)<br/>    TokenIds = make(map[string]int)<br/>    for i, tok := range Tokens {<br/>        TokenIds[tok] = i<br/>    }<br/>}</span><span id="4791" class="lu lv ji mv b gy oi nt l nu nv">// Creates the lexer object and compiles the NFA.<br/>func initLexer() (*lex.Lexer, error) {<br/>    lexer := lex.NewLexer()</span><span id="bdd5" class="lu lv ji mv b gy oi nt l nu nv">for _, lit := range Literals {<br/>        r := "\\" + strings.Join(strings.Split(lit, ""), "\\")<br/>        lexer.Add([]byte(r), token(lit))<br/>    }<br/>    for _, name := range Keywords {<br/>        lexer.Add([]byte(strings.ToLower(name)), token(name))<br/>    }<br/>    lexer.Add([]byte(`[vV][aA][rR][cC][hH][aA][rR]\([0-9]+\)`), token("VARCHARID"))<br/>    lexer.Add([]byte(`[cC][hH][aA][rR]\([0-9]+\)`), token("CHARID"))<br/>    lexer.Add([]byte(`[fF][lL][oO][aA][tT]\([0-9]+\)`), token("FLOATID"))<br/>    lexer.Add([]byte(`[nN][uU][mM][eE][rR][iI][cC]\([0-9]+,[0-9]+\)`), token("NUMERICID"))<br/>    lexer.Add([]byte(`([a-z]|[A-Z]|_|#|@)([a-z]|[A-Z]|[0-9]|_|#|@|\$)*\(([a-z]|[A-Z]|_|#|@)([a-z]|[A-Z]|[0-9]|_|#|@|\$)*\)`), token("REFID"))<br/>    lexer.Add([]byte(`([a-z]|[A-Z]|_|#|@)([a-z]|[A-Z]|[0-9]|_|#|@|\$)*`), token("ID"))<br/>    lexer.Add([]byte("( |\t|\n|\r)+"), skip)</span><span id="896b" class="lu lv ji mv b gy oi nt l nu nv">    err := lexer.Compile()<br/>    if err != nil {<br/>        return nil, err<br/>    }<br/>    return lexer, nil<br/>}</span><span id="565b" class="lu lv ji mv b gy oi nt l nu nv">// a lex.Action function which skips the match.<br/>func skip(*lex.Scanner, *machines.Match) (interface{}, error) {<br/>    return nil, nil<br/>}</span><span id="759a" class="lu lv ji mv b gy oi nt l nu nv">// a lex.Action function with constructs a Token of the given token <br/>// type by the token type's name.<br/>func token(name string) lex.Action {<br/>    return func(s *lex.Scanner, m *machines.Match) (interface{}, error) {<br/>        return s.Token(TokenIds[name], string(m.Bytes), m), nil<br/>    }<br/>}</span></pre><h1 id="c71f" class="nx lv ji bd lw ny nz oa lz ob oc od mc ko oe kp mf kr of ks mi ku og kv ml oh bi translated">句法分析程序</h1><p id="1015" class="pw-post-body-paragraph kx ky ji kz b la mn kj lc ld mo km lf lg mp li lj lk mq lm ln lo mr lq lr ls im bi translated">解析是从词法分析器创建的标记流中检测特定语法部分的过程。</p><p id="0d97" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们现在将为上面的受限SQL语法构建一个简单的解析器。对于复杂的语法，我们倾向于使用基于递归下降或某种解析器生成器的真正解析器。我们的方法很简单，有限状态机就可以完成这项工作。一个简单的状态机遵循这样的模式:如果我处于状态<strong class="kz jj"> CurState </strong>并且我看到一些<strong class="kz jj">输入</strong>然后移动到一个<strong class="kz jj"> NextState </strong>并且<strong class="kz jj">T7】执行一些<strong class="kz jj">动作</strong>。这样做，直到达到某个终端状态，通常是EOF。在我们的例子中，输入将是令牌类型，动作将是我们调用来保存表数据或忽略它的某个函数。这是我们的状态表，您会注意到它的大部分都与检测不同的数据类型有关:</strong></p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="5151" class="lu lv ji mv b gy ns nt l nu nv">Cur                 Next<br/>State Input         State Action<br/>---------------------------------------<br/>0    Error          0     error_state<br/>1    CREATE         2     create_table<br/>2    TABLE          3     nop<br/>2    ID             2     some_stuff<br/>3    IF             4     nop<br/>4    NOT            5     nop<br/>5    EXISTS         3     nop<br/>3    ID             6     table_name<br/>6    (              7     nop<br/>7    ID             8     column_name<br/>7    UUID           8     column_name<br/>8    BOOLEAN        9     data_type<br/>8    BOOL           9     data_type<br/>8    CHARID         9     data_type<br/>8    VARCHARID      9     data_type<br/>8    TEXT           9     data_type<br/>8    SMALLINT       9     data_type<br/>8    INT            9     data_type<br/>8    INTEGER        9     data_type<br/>8    BIGINT         9     data_type<br/>8    SMALLSERIAL    9     data_type<br/>8    SERIAL         9     data_type<br/>8    BIGSERIAL      9     data_type<br/>8    FLOATID        9     data_type<br/>8    REAL           9     data_type<br/>8    FLOAT8         9     data_type<br/>8    DECIMAL        9     data_type<br/>8    NUMERIC        9     data_type<br/>8    NUMERICID      9     data_type<br/>8    DOUBLE         10    nop<br/>10   PRECISION      9     data_type<br/>8    DATE           9     data_type<br/>8    TIME           9     data_type<br/>8    TIMESTAMPTZ    9     data_type<br/>8    TIMESTAMP      9     data_type<br/>8    INTERVAL       9     data_type<br/>8    JSON           9     data_type<br/>8    JSONB          9     data_type<br/>8    UUID           9     data_type<br/>9    ,              7     nop<br/>9    )              11    nop<br/>9    REFID          9     some_stuff<br/>9    NOT            9     some_stuff<br/>9    ID             9     some_stuff<br/>11   ;              1     end_table<br/>11   ID             11    some_stuff</span></pre><p id="d863" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">除了理解和执行我们的语法，解析器还必须捕获它生成代码所需的所有数据。在真正的编译器中，它可能会构建一个<a class="ae lt" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树</a>来做这件事，然后代码生成器会分析它。在我们的例子中，我们将只构建一个表及其列名和类型的列表，用于我们的生成器。我们的状态机本身只是一个Go map，它接受一个字符串作为输入，并返回下一个要触发的状态和动作(方法)的结构。映射字符串将当前状态和输入令牌连接在一起，形成映射的一个字符串。" CurState，InToken": {NextState，FunctionToCall}</p><p id="da74" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metaapi/metasql/parse.go:</p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="2df7" class="lu lv ji mv b gy ns nt l nu nv">package metasql</span><span id="7f07" class="lu lv ji mv b gy oi nt l nu nv">import (<br/>    "errors"<br/>    "fmt"<br/>    "log"</span><span id="97e2" class="lu lv ji mv b gy oi nt l nu nv">    lex "github.com/timtadh/lexmachine"<br/>)</span><span id="cf63" class="lu lv ji mv b gy oi nt l nu nv">type Column struct {<br/>    Name string<br/>    Type string<br/>}</span><span id="649f" class="lu lv ji mv b gy oi nt l nu nv">type Table struct {<br/>    Name    string<br/>    Query   string<br/>    Columns []Column<br/>}</span><span id="fa8d" class="lu lv ji mv b gy oi nt l nu nv">type StateMachine struct {<br/>    FName    string<br/>    CurState int<br/>    Tables   []Table<br/>}</span><span id="e88f" class="lu lv ji mv b gy oi nt l nu nv">type NextAction struct {<br/>    State int<br/>    Fn    func(*StateMachine, *lex.Token)<br/>}</span><span id="a6df" class="lu lv ji mv b gy oi nt l nu nv">func getColumn(sm *StateMachine) *Column {<br/>    if len(sm.Tables) &gt; 0 {<br/>        table := &amp;(sm.Tables[len(sm.Tables)-1])<br/>        if len(table.Columns) &gt; 0 {<br/>            return &amp;(table.Columns[len(table.Columns)-1])<br/>        } else {<br/>            return nil<br/>        }<br/>    } else {<br/>        return nil<br/>    }</span><span id="d30b" class="lu lv ji mv b gy oi nt l nu nv">}</span><span id="0122" class="lu lv ji mv b gy oi nt l nu nv">func InitState(fname string) *StateMachine {<br/>    sm := new(StateMachine)<br/>    sm.FName = fname<br/>    sm.CurState = 1<br/>    return sm<br/>}</span><span id="360d" class="lu lv ji mv b gy oi nt l nu nv">func error_state(sm *StateMachine, token *lex.Token) {<br/>    //no state found<br/>    log.Fatal("Error in SQL Syntax!")<br/>}</span><span id="78f8" class="lu lv ji mv b gy oi nt l nu nv">func nop(sm *StateMachine, token *lex.Token) {<br/>    //nop<br/>}</span><span id="78a2" class="lu lv ji mv b gy oi nt l nu nv">func create_table(sm *StateMachine, token *lex.Token) {<br/>    sm.Tables = append(sm.Tables, Table{})<br/>}</span><span id="3879" class="lu lv ji mv b gy oi nt l nu nv">func table_name(sm *StateMachine, token *lex.Token) {<br/>    if len(sm.Tables) &gt; 0 {<br/>        sm.Tables[len(sm.Tables)-1].Name = string(token.Lexeme)<br/>    }<br/>}</span><span id="3fea" class="lu lv ji mv b gy oi nt l nu nv">func column_name(sm *StateMachine, token *lex.Token) {<br/>    if len(sm.Tables) &gt; 0 {<br/>        table := &amp;(sm.Tables[len(sm.Tables)-1])<br/>        table.Columns = append(table.Columns, Column{})<br/>        table.Columns[len(table.Columns)-1].Name = string(token.Lexeme)<br/>    }<br/>}</span><span id="b011" class="lu lv ji mv b gy oi nt l nu nv">func data_type(sm *StateMachine, token *lex.Token) {<br/>    column := getColumn(sm)<br/>    column.Type = Tokens[token.Type]<br/>}</span><span id="c27b" class="lu lv ji mv b gy oi nt l nu nv">func some_stuff(sm *StateMachine, token *lex.Token) {<br/>    //nop<br/>}</span><span id="431a" class="lu lv ji mv b gy oi nt l nu nv">func end_table(sm *StateMachine, token *lex.Token) {<br/>    //nop<br/>}</span><span id="50b5" class="lu lv ji mv b gy oi nt l nu nv">func appendQuery(sm *StateMachine, st string) {<br/>    if len(sm.Tables) &gt; 0 {<br/>        (&amp;(sm.Tables[len(sm.Tables)-1])).Query += st + " "<br/>    }<br/>}</span><span id="299f" class="lu lv ji mv b gy oi nt l nu nv">func printQuery(sm *StateMachine) {<br/>    if len(sm.Tables) &gt; 0 {<br/>        fmt.Println("query: ", (&amp;(sm.Tables[len(sm.Tables)-1])).Query, " &lt;&lt;")<br/>    }<br/>}</span><span id="0ec0" class="lu lv ji mv b gy oi nt l nu nv">func ProcessState(sm *StateMachine, token *lex.Token) (err error) {</span><span id="63e8" class="lu lv ji mv b gy oi nt l nu nv">    //State Machine, format is:<br/>    //"CurState, InToken": {NextState, FunctionToCall}</span><span id="b01a" class="lu lv ji mv b gy oi nt l nu nv">    stateMap := map[string]NextAction{<br/>        "Error":         {0, error_state},<br/>        "1,CREATE":      {2, create_table},<br/>        "2,TABLE":       {3, nop},<br/>        "2,ID":          {2, some_stuff},<br/>        "3,IF":          {4, nop},<br/>        "4,NOT":         {5, nop},<br/>        "5,EXISTS":      {3, nop},<br/>        "3,ID":          {6, table_name},<br/>        "6,(":           {7, nop},<br/>        "7,ID":          {8, column_name},<br/>        "7,UUID":        {8, column_name},<br/>        "8,BOOLEAN":     {9, data_type},<br/>        "8,BOOL":        {9, data_type},<br/>        "8,CHARID":      {9, data_type},<br/>        "8,VARCHARID":   {9, data_type},<br/>        "8,TEXT":        {9, data_type},<br/>        "8,SMALLINT":    {9, data_type},<br/>        "8,INT":         {9, data_type},<br/>        "8,INTEGER":     {9, data_type},<br/>        "8,BIGINT":      {9, data_type},<br/>        "8,SMALLSERIAL": {9, data_type},<br/>        "8,SERIAL":      {9, data_type},<br/>        "8,BIGSERIAL":   {9, data_type},<br/>        "8,FLOATID":     {9, data_type},<br/>        "8,REAL":        {9, data_type},<br/>        "8,FLOAT8":      {9, data_type},<br/>        "8,DECIMAL":     {9, data_type},<br/>        "8,NUMERIC":     {9, data_type},<br/>        "8,NUMERICID":   {9, data_type},<br/>        "8,DOUBLE":      {10, nop},<br/>        "10,PRECISION":  {9, data_type},<br/>        "8,DATE":        {9, data_type},<br/>        "8,TIME":        {9, data_type},<br/>        "8,TIMESTAMPTZ": {9, data_type},<br/>        "8,TIMESTAMP":   {9, data_type},<br/>        "8,INTERVAL":    {9, data_type},<br/>        "8,JSON":        {9, data_type},<br/>        "8,JSONB":       {9, data_type},<br/>        "8,UUID":        {9, data_type},<br/>        "9,,":           {7, nop},<br/>        "9,)":           {11, nop},<br/>        "9,REFID":       {9, some_stuff},<br/>        "9,NOT":         {9, some_stuff},<br/>        "9,ID":          {9, some_stuff},<br/>        "11,;":          {1, end_table},<br/>        "11,ID":         {11, some_stuff},<br/>    }</span><span id="662d" class="lu lv ji mv b gy oi nt l nu nv">mapStr := fmt.Sprintf("%d,%s", sm.CurState, Tokens[token.Type])<br/>    nextState := stateMap[mapStr]<br/>    //map zeros all fields of struct if not found<br/>    if nextState.State == 0 {<br/>        nextState = stateMap["Error"]<br/>        printQuery(sm)<br/>        err = errors.New("Syntax Error: " + Tokens[token.Type])<br/>        return<br/>    }<br/>    sm.CurState = nextState.State<br/>    nextState.Fn(sm, token)<br/>    appendQuery(sm, string(token.Lexeme))<br/>    return nil<br/>}</span></pre><h1 id="4c70" class="nx lv ji bd lw ny nz oa lz ob oc od mc ko oe kp mf kr of ks mi ku og kv ml oh bi translated">发电机</h1><p id="48bd" class="pw-post-body-paragraph kx ky ji kz b la mn kj lc ld mo km lf lg mp li lj lk mq lm ln lo mr lq lr ls im bi translated">生成器是我们“编译器”的代码生成部分。它采用我们通过词法分析和解析创建的SQL表的内部表示，并从中为表生成CRUD API。如果一切顺利，产生的代码应该准备好进入另一个项目，编译并运行。</p><p id="2238" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们构建生成器的方法是从一些已知的工作代码开始，这些代码代表我们想要生成的API，我们的目标。我们将把它重命名为一个txt文件，作为模板输入到生成器中，然后一段一段地慢慢转换，直到它完全“模板化”我们将在generate.go中编写相应的接收器方法，并将其传递给模板。运行生成器时，应该重新创建原始目标。这个过程使我们很容易将生成的内容与原始目标进行比较，并在此过程中纠正任何错误。</p><p id="1bdd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在我的例子中，目标API将是来自于<a class="ae lt" href="https://github.com/exyzzy/govueintro" rel="noopener ugc nofollow" target="_blank"> govueintro </a>项目todo.go的Todo CRUD API，我将转换它以使用来自于metaapi的自动生成的todo_generated.go。下面的Crud.txt开始看起来像todo_generated.go(也在下面),当我在generate.go中用receiver方法替换部分时，我迭代地将其转换为crud . txt。crud . txt在这一点上看起来很难看，但相信我，迭代转换过程很容易。Generate.go只是使用go模板将特定的表数据折叠到通用的crud.txt中。</p><p id="4d5c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metaapi/metasql/generate.go:</p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="4ef3" class="lu lv ji mv b gy ns nt l nu nv">package metasql</span><span id="428b" class="lu lv ji mv b gy oi nt l nu nv">import (<br/>    "errors"<br/>    "io/ioutil"<br/>    "os"<br/>    "strconv"<br/>    "strings"<br/>    "text/template"<br/>)</span><span id="f25b" class="lu lv ji mv b gy oi nt l nu nv">//Generate assumes that the primary ID is in the first column (index 0)<br/>func Generate(sm *StateMachine, txtFile string) error {<br/>    if sm.FName == "" {<br/>        return (errors.New("No file name"))<br/>    }<br/>    dot := strings.Index(sm.FName, ".")<br/>    var prefix string<br/>    if dot &gt; 0 {<br/>        prefix = sm.FName[:dot]<br/>    } else {<br/>        prefix = sm.FName<br/>    }<br/>    dat, err := ioutil.ReadFile("./" + txtFile)<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="35e3" class="lu lv ji mv b gy oi nt l nu nv">    tt := template.Must(template.New(prefix).Parse(string(dat)))<br/>    dest := prefix + "_generated.go"<br/>    file, err := os.Create(dest)<br/>    if err != nil {<br/>        return err<br/>    }<br/>    tt.Execute(file, sm)<br/>    file.Close()<br/>    return nil<br/>}</span><span id="af4e" class="lu lv ji mv b gy oi nt l nu nv">//======== string helpers</span><span id="b67a" class="lu lv ji mv b gy oi nt l nu nv">//should use: <a class="ae lt" href="https://github.com/blakeembrey/pluralize" rel="noopener ugc nofollow" target="_blank">https://github.com/blakeembrey/pluralize</a><br/>func singularize(s string) string {<br/>    if strings.HasSuffix(strings.ToLower(s), "s") {<br/>        return strings.TrimSuffix(strings.ToLower(s), "s")<br/>    } else {<br/>        return strings.ToLower(s)<br/>    }<br/>}</span><span id="0f68" class="lu lv ji mv b gy oi nt l nu nv">func capitalize(s string) string {<br/>    return strings.Title(s)<br/>}</span><span id="214d" class="lu lv ji mv b gy oi nt l nu nv">func lowerize(s string) string {<br/>    return strings.ToLower(s)<br/>}</span><span id="f00b" class="lu lv ji mv b gy oi nt l nu nv">//turns submitted_at into SubmittedAt, and otherwise capitalizes<br/>func camelize(s string) string {<br/>    return     strings.ReplaceAll(strings.Title(strings.ReplaceAll(strings.ToLower(s), "_", " ")), " ", "")<br/>}</span><span id="6950" class="lu lv ji mv b gy oi nt l nu nv">func comma(i int, length int) string {<br/>    if i &lt; (length - 1) {<br/>        return ","<br/>    } else {<br/>        return ""<br/>    }<br/>}</span><span id="9dbf" class="lu lv ji mv b gy oi nt l nu nv">//======== template methods</span><span id="2351" class="lu lv ji mv b gy oi nt l nu nv">func (sm *StateMachine) Package() string {<br/>    return os.Getenv("GOPACKAGE")<br/>}</span><span id="0a3b" class="lu lv ji mv b gy oi nt l nu nv">// Writing it to be extended<br/>func (sm *StateMachine) Import() string {</span><span id="6b1d" class="lu lv ji mv b gy oi nt l nu nv">var s string<br/>    var includeTime bool</span><span id="05c7" class="lu lv ji mv b gy oi nt l nu nv">includeTime = false<br/>    for _, table := range sm.Tables {<br/>        for _, column := range table.Columns {<br/>            switch column.Type {<br/>            case "DATE", "TIME", "TIMESTAMP", "TIMESTAMPTZ", "INTERVAL":<br/>                includeTime = true<br/>            default:<br/>            }<br/>        }<br/>    }<br/>    s += "import (\n\t\"database/sql\"\n"<br/>    if includeTime {<br/>        s += "\t\"time\"\n"<br/>    }<br/>    s += ")"<br/>    return s<br/>}</span><span id="7fb4" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) SingName() string {<br/>    return singularize(table.Name)<br/>}</span><span id="8cd1" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) CapName() string {<br/>    return capitalize(lowerize(table.Name))<br/>}</span><span id="fbef" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) CapSingName() string {<br/>    return capitalize(singularize(table.Name))<br/>}</span><span id="f3ea" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) DropTableStatement() string {<br/>    var s string<br/>    s += "(\"DROP TABLE IF EXISTS " + table.Name + "\")"<br/>    return s<br/>}</span><span id="1001" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) CreateTableStatement() string {<br/>    var s string<br/>    s += "(`" + table.Query + "`)"<br/>    return s<br/>}</span><span id="6185" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) StructFields() string {</span><span id="4314" class="lu lv ji mv b gy oi nt l nu nv">var typeMap = map[string]string{<br/>        "BOOLEAN":     "bool",<br/>        "BOOL":        "bool",<br/>        "CHARID":      "string",<br/>        "VARCHARID":   "string",<br/>        "TEXT":        "string",<br/>        "SMALLINT":    "int16",<br/>        "INT":         "int32",<br/>        "INTEGER":     "int32",<br/>        "BIGINT":      "int64",<br/>        "SMALLSERIAL": "int16",<br/>        "SERIAL":      "int32",<br/>        "BIGSERIAL":   "int64",<br/>        "FLOATID":     "float64",<br/>        "REAL":        "float32",<br/>        "FLOAT8":      "float32",<br/>        "DECIMAL":     "float64",<br/>        "NUMERIC":     "float64",<br/>        "NUMERICID":   "float64",<br/>        "PRECISION":   "float64", //DOUBLE PRECISION<br/>        "DATE":        "time.Time",<br/>        "TIME":        "time.Time",<br/>        "TIMESTAMPTZ": "time.Time",<br/>        "TIMESTAMP":   "time.Time",<br/>        "INTERVAL":    "time.Time",<br/>        "JSON":        "[]byte",<br/>        "JSONB":       "[]byte",<br/>        "UUID":        "string",<br/>    }<br/>    var s string</span><span id="01cd" class="lu lv ji mv b gy oi nt l nu nv">    for _, column := range table.Columns {<br/>        s += "\t" + camelize(column.Name)<br/>        s += " " + typeMap[column.Type]<br/>        s += "`xml:\"" + camelize(column.Name) + "\" json:\"" +      lowerize(camelize(column.Name)) + "\"`"<br/>        s += "\n"<br/>    }<br/>    return s<br/>}</span><span id="0ef6" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) Star() string {<br/>    var s string<br/>    for i, column := range table.Columns {<br/>        s += " " + column.Name<br/>        s += comma(i, len(table.Columns))<br/>    }<br/>    return s<br/>}</span><span id="62b3" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) ScanAll() string {</span><span id="b4ac" class="lu lv ji mv b gy oi nt l nu nv">var s string<br/>    s += ".Scan("<br/>    for i, column := range table.Columns {<br/>        s += " &amp;result." + camelize(column.Name)<br/>        s += comma(i, len(table.Columns))<br/>    }<br/>    s += ")"<br/>    return s<br/>}</span><span id="cb77" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) CreateStatement() string {<br/>    var s string<br/>    s += "(\"INSERT INTO " + table.Name + " ("</span><span id="7a14" class="lu lv ji mv b gy oi nt l nu nv">for i, column := range table.Columns {<br/>        if i == 0 {<br/>            continue<br/>        }<br/>        s += " " + column.Name<br/>        s += comma(i, len(table.Columns))<br/>    }<br/>    s += ") VALUES ("<br/>    index := 1<br/>    for i, _ := range table.Columns {<br/>        if i == 0 {<br/>            continue<br/>        }<br/>        s += "$"<br/>        s += strconv.Itoa(index)<br/>        s += comma(i, len(table.Columns))<br/>        index++<br/>    }<br/>    s += ") RETURNING"<br/>    for i, column := range table.Columns {<br/>        s += " " + column.Name<br/>        s += comma(i, len(table.Columns))<br/>    }<br/>    s += "\")"<br/>    return s<br/>}</span><span id="baa2" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) CreateQuery() string {<br/>    var s string<br/>    s += "("<br/>    for i, column := range table.Columns {<br/>        if i == 0 {<br/>            continue<br/>        }<br/>        s += " " + table.SingName() + "." + camelize(column.Name)<br/>        s += comma(i, len(table.Columns))<br/>    }<br/>    s += ")"<br/>    s += table.ScanAll()<br/>    return s<br/>}</span><span id="4fcb" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) RetrieveStatement() string {<br/>    var s string<br/>    s += "(\"SELECT" + table.Star() + " FROM " + table.Name + " WHERE ("</span><span id="8f70" class="lu lv ji mv b gy oi nt l nu nv">    index := 1<br/>    for i, column := range table.Columns {<br/>        if i == 0 {<br/>            s += column.Name + " = $" + strconv.Itoa(index)<br/>            s += ")\", " + table.SingName() + "." + camelize(column.Name) + ")"<br/>        }<br/>        break<br/>    }<br/>    s += table.ScanAll()<br/>    return s<br/>}</span><span id="f496" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) RetrieveAllStatement() string {<br/>    var s string<br/>    s += "(\"SELECT" + table.Star() + " FROM " + table.Name + " ORDER BY "</span><span id="2a42" class="lu lv ji mv b gy oi nt l nu nv">    for i, column := range table.Columns {<br/>        if i == 0 {<br/>            s += column.Name<br/>        }<br/>        break<br/>    }<br/>    s += " DESC\")"<br/>    return s<br/>}</span><span id="45a4" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) UpdateStatement() string {<br/>    var s string<br/>    s += "(\"UPDATE " + table.Name + " SET"</span><span id="299d" class="lu lv ji mv b gy oi nt l nu nv">    index := 2<br/>    for i, column := range table.Columns {<br/>        if i == 0 {<br/>            continue<br/>        }<br/>        s += " " + column.Name + " = $" + strconv.Itoa(index)<br/>        index++<br/>        s += comma(i, len(table.Columns))<br/>    }<br/>    s += " WHERE ("<br/>    index = 1<br/>    for i, column := range table.Columns {<br/>        if i == 0 {<br/>            s += column.Name + " = $" + strconv.Itoa(index)<br/>            s += ") RETURNING"<br/>        }<br/>        break<br/>    }<br/>    for i, column := range table.Columns {<br/>        s += " " + column.Name<br/>        s += comma(i, len(table.Columns))<br/>    }<br/>    s += "\")"<br/>    return s<br/>}</span><span id="1d5b" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) UpdateQuery() string {</span><span id="4a87" class="lu lv ji mv b gy oi nt l nu nv">    var s string<br/>    s += "("<br/>    for i, column := range table.Columns {<br/>        s += " " + table.SingName() + "." + camelize(column.Name)<br/>        s += comma(i, len(table.Columns))<br/>    }<br/>    s += ")"<br/>    s += table.ScanAll()<br/>    return s<br/>}</span><span id="77ec" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) DeleteStatement() string {<br/>    var s string<br/>    s += "(\"DELETE FROM " + table.Name + " WHERE ("</span><span id="1b92" class="lu lv ji mv b gy oi nt l nu nv">    index := 1<br/>    for i, column := range table.Columns {<br/>        if i == 0 {<br/>            s += column.Name + " = $" + strconv.Itoa(index)<br/>        }<br/>        break<br/>    }<br/>    s += ")\")"<br/>    return s<br/>}</span><span id="728e" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) DeleteQuery() string {</span><span id="fc73" class="lu lv ji mv b gy oi nt l nu nv">    var s string<br/>    for i, column := range table.Columns {<br/>        if i == 0 {<br/>            s += "(" + table.SingName() + "." + camelize(column.Name) + ")"<br/>        }<br/>        break<br/>    }<br/>    return s<br/>}</span><span id="56f0" class="lu lv ji mv b gy oi nt l nu nv">func (table Table) DeleteAllStatement() string {<br/>    var s string<br/>    s += "(\"DELETE FROM " + table.Name + "\")"<br/>    return s<br/>}</span></pre><p id="8f7b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metaapi/metasql/crud.txt:</p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="b90b" class="lu lv ji mv b gy ns nt l nu nv">//Auto generated with MetaApi <a class="ae lt" href="https://github.com/exyzzy/metaapi" rel="noopener ugc nofollow" target="_blank">https://github.com/exyzzy/metaapi</a><br/>package {{ .Package }}</span><span id="7142" class="lu lv ji mv b gy oi nt l nu nv">{{ .Import }}</span><span id="de97" class="lu lv ji mv b gy oi nt l nu nv">{{ range $index, $table := .Tables }}<br/>//Create Table<br/>func CreateTable{{ $table.CapName }}(db *sql.DB) (err error) {<br/>    _, err = db.Exec{{ $table.DropTableStatement }}<br/>    if err != nil {<br/>        return<br/>    }<br/>    _, err = db.Exec{{ $table.CreateTableStatement }}<br/>    return<br/>}</span><span id="c240" class="lu lv ji mv b gy oi nt l nu nv">//Struct<br/>type {{ $table.CapSingName }} struct {<br/>{{ $table.StructFields }}<br/>}</span><span id="a94e" class="lu lv ji mv b gy oi nt l nu nv">//Create<br/>func ({{ $table.SingName }} *{{ $table.CapSingName }}) Create{{ $table.CapSingName }}(db *sql.DB) (result {{ $table.CapSingName }}, err error) {<br/>    stmt, err := db.Prepare{{ $table.CreateStatement }}<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer stmt.Close()<br/>    err = stmt.QueryRow{{ $table.CreateQuery }}<br/>    return<br/>}</span><span id="6f13" class="lu lv ji mv b gy oi nt l nu nv">//Retrieve<br/>func ({{ $table.SingName }} *{{ $table.CapSingName }}) Retrieve{{ $table.CapSingName }}(db *sql.DB) (result {{ $table.CapSingName }}, err error) {<br/>    result = {{ $table.CapSingName }}{}<br/>    err = db.QueryRow{{ $table.RetrieveStatement }}<br/>    return<br/>}</span><span id="1d77" class="lu lv ji mv b gy oi nt l nu nv">//RetrieveAll<br/>func ({{ $table.SingName }} *{{ $table.CapSingName }}) RetrieveAll{{ $table.CapName }}(db *sql.DB) ({{ $table.Name }} []{{ $table.CapSingName }}, err error) {<br/>    rows, err := db.Query{{ $table.RetrieveAllStatement }}<br/>    if err != nil {<br/>        return<br/>    }<br/>    for rows.Next() {<br/>        result := {{ $table.CapSingName }}{}<br/>        if err = rows{{ $table.ScanAll }}; err != nil {<br/>            return<br/>        }<br/>        {{ $table.Name }} = append({{ $table.Name }}, result)<br/>    }<br/>    rows.Close()<br/>    return<br/>}</span><span id="9bd8" class="lu lv ji mv b gy oi nt l nu nv">//Update<br/>func ({{ $table.SingName }} *{{ $table.CapSingName }}) Update{{ $table.CapSingName }}(db *sql.DB) (result {{ $table.CapSingName }}, err error) {<br/>    stmt, err := db.Prepare{{ $table.UpdateStatement }}<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer stmt.Close()</span><span id="7b7b" class="lu lv ji mv b gy oi nt l nu nv">err = stmt.QueryRow{{ $table.UpdateQuery }}<br/>    return<br/>}</span><span id="9d06" class="lu lv ji mv b gy oi nt l nu nv">//Delete<br/>func ({{ $table.SingName }} *{{ $table.CapSingName }}) Delete{{ $table.CapSingName }}(db *sql.DB) (err error) {<br/>    stmt, err := db.Prepare{{ $table.DeleteStatement }}<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer stmt.Close()</span><span id="f5ec" class="lu lv ji mv b gy oi nt l nu nv">_, err = stmt.Exec{{ $table.DeleteQuery }}<br/>    return<br/>}</span><span id="3a11" class="lu lv ji mv b gy oi nt l nu nv">//DeleteAll<br/>func DeleteAll{{ $table.CapSingName }}s(db *sql.DB) (err error) {<br/>    stmt, err := db.Prepare{{ $table.DeleteAllStatement}}<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer stmt.Close()</span><span id="0cbc" class="lu lv ji mv b gy oi nt l nu nv">_, err = stmt.Exec()<br/>    return<br/>}<br/>{{ end }}</span></pre><p id="065b" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一个简短的main将所有内容放在一起，并使用go标志来传递要使用的文件名。</p><p id="5240" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metaapi/main.go:</p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="9c38" class="lu lv ji mv b gy ns nt l nu nv">package main</span><span id="9c16" class="lu lv ji mv b gy oi nt l nu nv">import (<br/>    "flag"<br/>    "fmt"<br/>    "io/ioutil"<br/>    "log"<br/>    "strings"</span><span id="5073" class="lu lv ji mv b gy oi nt l nu nv">    "github.com/exyzzy/metaapi/metasql"</span><span id="16e6" class="lu lv ji mv b gy oi nt l nu nv">    lex "github.com/timtadh/lexmachine"<br/>)</span><span id="9329" class="lu lv ji mv b gy oi nt l nu nv">// Turn on debug prints<br/>var DEBUG = false</span><span id="af66" class="lu lv ji mv b gy oi nt l nu nv">func main() {<br/>    sqlPtr := flag.String("sql", "", ".sql input file to parse")<br/>    txtPtr := flag.String("txt", "crud.txt", "go template as .txt file")<br/>    flag.Parse()<br/>    sqlFile := strings.ToLower(*sqlPtr)<br/>    txtFile := strings.ToLower(*txtPtr)</span><span id="1ca5" class="lu lv ji mv b gy oi nt l nu nv">    if (sqlFile == "") || (!strings.HasSuffix(sqlFile, ".sql")) {<br/>        log.Fatal("No .sql File")<br/>    }<br/>    if (txtFile == "") || (!strings.HasSuffix(txtFile, ".txt")) {<br/>        log.Fatal("No .txt File")<br/>    }</span><span id="3a8b" class="lu lv ji mv b gy oi nt l nu nv">    dat, err := ioutil.ReadFile("./" + sqlFile)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }</span><span id="ac24" class="lu lv ji mv b gy oi nt l nu nv">    s, err := metasql.Lexer.Scanner([]byte(dat))<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }</span><span id="1888" class="lu lv ji mv b gy oi nt l nu nv">    sm := metasql.InitState(sqlFile)<br/>    for tok, err, eof := s.Next(); !eof; tok, err, eof = s.Next() {<br/>        if err != nil {<br/>            log.Fatal(err)<br/>        }<br/>        token := tok.(*lex.Token)<br/>        if DEBUG {<br/>            fmt.Printf("%-10v | %-12v | %v:%v-%v:%v\n",<br/>                metasql.Tokens[token.Type],<br/>                string(token.Lexeme),<br/>                token.StartLine,<br/>                token.StartColumn,<br/>                token.EndLine,<br/>                token.EndColumn)<br/>        }<br/>        err = metasql.ProcessState(sm, token)<br/>        if err != nil {<br/>            log.Fatal(err)<br/>        }<br/>    }<br/>    err = metasql.Generate(sm, txtFile)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }<br/>    if DEBUG {<br/>        fmt.Printf("Table Capture:\n%+v\n", sm)<br/>    }<br/>}</span></pre><h1 id="0cba" class="nx lv ji bd lw ny nz oa lz ob oc od mc ko oe kp mf kr of ks mi ku og kv ml oh bi translated">有用吗？</h1><p id="609d" class="pw-post-body-paragraph kx ky ji kz b la mn kj lc ld mo km lf lg mp li lj lk mq lm ln lo mr lq lr ls im bi translated">要将其作为工具运行，您需要:</p><ul class=""><li id="be1e" class="mw mx ji kz b la lb ld le lg my lk mz lo na ls nw nc nd ne bi translated">克隆metaapi项目并安装它</li><li id="511b" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nw nc nd ne bi translated">为新项目创建一个目录</li><li id="af9f" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nw nc nd ne bi translated">将crud模板(crud.txt)、您的sql表定义(todo.sql)和一个启动go generate (todo.go)的可选文件复制到您的新项目中。注意:您可以为您的特定项目更改这些内容。</li><li id="1923" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nw nc nd ne bi translated">运行go generate或手动运行metaapi</li><li id="d996" class="mw mx ji kz b la nf ld ng lg nh lk ni lo nj ls nw nc nd ne bi translated">新的go文件将被创建为*_generated.go(基于sql文件的名称)</li></ul><p id="2587" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对于我的Todo api，我使用了以下代码:</p><p id="5555" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metasql/todo.go:</p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="2d08" class="lu lv ji mv b gy ns nt l nu nv">//go:generate metaapi -sql=todo.sql -txt=crud.txt<br/>package metasql</span><span id="0a20" class="lu lv ji mv b gy oi nt l nu nv">//Now see: todo_generated.go</span></pre><p id="9f83" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">metasql/todo.sql:</p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="e35d" class="lu lv ji mv b gy ns nt l nu nv">create table todos (<br/>  id           integer generated always as identity primary key,<br/>  updated_at   timestamptz,<br/>  done         boolean,<br/>  title        text<br/>);</span></pre><p id="ee09" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们运行它，看看会有什么结果。</p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="39db" class="lu lv ji mv b gy ns nt l nu nv">go get github.com/exyzzy/metaapi<br/>go install $GOPATH/src/github.com/exyzzy/metaapi<br/>mkdir myproj<br/>cd myproj<br/>cp $GOPATH/src/github.com/exyzzy/metaapi/metasql/crud.txt .<br/>cp $GOPATH/src/github.com/exyzzy/metaapi/metasql/todo.sql .<br/>cp $GOPATH/src/github.com/exyzzy/metaapi/metasql/todo.go .<br/>go generate</span></pre><p id="3f2f" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">现在会自动创建todo_generated.go文件:</p><pre class="nk nl nm nn gt no mv np nq aw nr bi"><span id="6081" class="lu lv ji mv b gy ns nt l nu nv">//Auto generated with MetaApi <a class="ae lt" href="https://github.com/exyzzy/metaapi" rel="noopener ugc nofollow" target="_blank">https://github.com/exyzzy/metaapi</a><br/>package metasql</span><span id="385f" class="lu lv ji mv b gy oi nt l nu nv">import (<br/>    "database/sql"<br/>    "time"<br/>)</span><span id="16b6" class="lu lv ji mv b gy oi nt l nu nv">//Create Table<br/>func CreateTableTodos(db *sql.DB) (err error) {<br/>    _, err = db.Exec("DROP TABLE IF EXISTS todos")<br/>    if err != nil {<br/>        return<br/>    }<br/>    _, err = db.Exec(`create table todos ( id integer generated always as identity primary key , updated_at timestamptz , done boolean , title text ) ; `)<br/>    return<br/>}</span><span id="aaf2" class="lu lv ji mv b gy oi nt l nu nv">//Struct<br/>type Todo struct {<br/>    Id int32`xml:"Id" json:"id"`<br/>    UpdatedAt time.Time`xml:"UpdatedAt" json:"updatedat"`<br/>    Done bool`xml:"Done" json:"done"`<br/>    Title string`xml:"Title" json:"title"`</span><span id="5fcc" class="lu lv ji mv b gy oi nt l nu nv">}</span><span id="c84f" class="lu lv ji mv b gy oi nt l nu nv">//Create<br/>func (todo *Todo) CreateTodo(db *sql.DB) (result Todo, err error) {<br/>    stmt, err := db.Prepare("INSERT INTO todos ( updated_at, done, title) VALUES ($1,$2,$3) RETURNING id, updated_at, done, title")<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer stmt.Close()<br/>    err = stmt.QueryRow( todo.UpdatedAt, todo.Done, todo.Title).Scan( &amp;result.Id, &amp;result.UpdatedAt, &amp;result.Done, &amp;result.Title)<br/>    return<br/>}</span><span id="3c63" class="lu lv ji mv b gy oi nt l nu nv">//Retrieve<br/>func (todo *Todo) RetrieveTodo(db *sql.DB) (result Todo, err error) {<br/>    result = Todo{}<br/>    err = db.QueryRow("SELECT id, updated_at, done, title FROM todos WHERE (id = $1)", todo.Id).Scan( &amp;result.Id, &amp;result.UpdatedAt, &amp;result.Done, &amp;result.Title)<br/>    return<br/>}</span><span id="ce33" class="lu lv ji mv b gy oi nt l nu nv">//RetrieveAll<br/>func (todo *Todo) RetrieveAllTodos(db *sql.DB) (todos []Todo, err error) {<br/>    rows, err := db.Query("SELECT id, updated_at, done, title FROM todos ORDER BY id DESC")<br/>    if err != nil {<br/>        return<br/>    }<br/>    for rows.Next() {<br/>        result := Todo{}<br/>        if err = rows.Scan( &amp;result.Id, &amp;result.UpdatedAt, &amp;result.Done, &amp;result.Title); err != nil {<br/>            return<br/>        }<br/>        todos = append(todos, result)<br/>    }<br/>    rows.Close()<br/>    return<br/>}</span><span id="6b3f" class="lu lv ji mv b gy oi nt l nu nv">//Update<br/>func (todo *Todo) UpdateTodo(db *sql.DB) (result Todo, err error) {<br/>    stmt, err := db.Prepare("UPDATE todos SET updated_at = $2, done = $3, title = $4 WHERE (id = $1) RETURNING id, updated_at, done, title")<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer stmt.Close()</span><span id="665d" class="lu lv ji mv b gy oi nt l nu nv">    err = stmt.QueryRow( todo.Id, todo.UpdatedAt, todo.Done, todo.Title).Scan( &amp;result.Id, &amp;result.UpdatedAt, &amp;result.Done, &amp;result.Title)<br/>    return<br/>}</span><span id="7165" class="lu lv ji mv b gy oi nt l nu nv">//Delete<br/>func (todo *Todo) DeleteTodo(db *sql.DB) (err error) {<br/>    stmt, err := db.Prepare("DELETE FROM todos WHERE (id = $1)")<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer stmt.Close()</span><span id="2df3" class="lu lv ji mv b gy oi nt l nu nv">    _, err = stmt.Exec(todo.Id)<br/>    return<br/>}</span><span id="79c2" class="lu lv ji mv b gy oi nt l nu nv">//DeleteAll<br/>func DeleteAllTodos(db *sql.DB) (err error) {<br/>    stmt, err := db.Prepare("DELETE FROM todos")<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer stmt.Close()</span><span id="bfa6" class="lu lv ji mv b gy oi nt l nu nv">    _, err = stmt.Exec()<br/>    return<br/>}</span></pre><p id="60c9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">任务完成。我们现在有了一个工具，可以轻松地为任意SQL表生成基本CRUD API，或者我们可以扩展/定制lexer、解析器、生成器和模板来生成新文件。不喜欢我的API？随意克隆<a class="ae lt" href="https://github.com/exyzzy/metaapi" rel="noopener ugc nofollow" target="_blank"> Github repo </a>，改变模板，制作你自己的CRUD！</p></div></div>    
</body>
</html>